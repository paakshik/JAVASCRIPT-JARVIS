! function (e, t) {
    "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = e || self).tf = e.tf || {})
}(this, function (e) {
    "use strict";
    var t = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};

    function n(e, t) {
        return e(t = {
            exports: {}
        }, t.exports), t.exports
    }
    var r = function (e) {
            return e && e.Math == Math && e
        },
        a = r("object" == typeof globalThis && globalThis) || r("object" == typeof window && window) || r("object" == typeof self && self) || r("object" == typeof t && t) || Function("return this")(),
        i = function (e) {
            try {
                return !!e()
            } catch (e) {
                return !0
            }
        },
        o = !i(function () {
            return 7 != Object.defineProperty({}, 1, {
                get: function () {
                    return 7
                }
            })[1]
        }),
        s = {}.propertyIsEnumerable,
        u = Object.getOwnPropertyDescriptor,
        l = {
            f: u && !s.call({
                1: 2
            }, 1) ? function (e) {
                var t = u(this, e);
                return !!t && t.enumerable
            } : s
        },
        c = function (e, t) {
            return {
                enumerable: !(1 & e),
                configurable: !(2 & e),
                writable: !(4 & e),
                value: t
            }
        },
        p = {}.toString,
        h = function (e) {
            return p.call(e).slice(8, -1)
        },
        f = "".split,
        d = i(function () {
            return !Object("z").propertyIsEnumerable(0)
        }) ? function (e) {
            return "String" == h(e) ? f.call(e, "") : Object(e)
        } : Object,
        m = function (e) {
            if (null == e) throw TypeError("Can't call method on " + e);
            return e
        },
        v = function (e) {
            return d(m(e))
        },
        g = function (e) {
            return "object" == typeof e ? null !== e : "function" == typeof e
        },
        y = function (e, t) {
            if (!g(e)) return e;
            var n, r;
            if (t && "function" == typeof (n = e.toString) && !g(r = n.call(e))) return r;
            if ("function" == typeof (n = e.valueOf) && !g(r = n.call(e))) return r;
            if (!t && "function" == typeof (n = e.toString) && !g(r = n.call(e))) return r;
            throw TypeError("Can't convert object to primitive value")
        },
        b = {}.hasOwnProperty,
        x = function (e, t) {
            return b.call(e, t)
        },
        w = a.document,
        k = g(w) && g(w.createElement),
        N = function (e) {
            return k ? w.createElement(e) : {}
        },
        I = !o && !i(function () {
            return 7 != Object.defineProperty(N("div"), "a", {
                get: function () {
                    return 7
                }
            }).a
        }),
        S = Object.getOwnPropertyDescriptor,
        T = {
            f: o ? S : function (e, t) {
                if (e = v(e), t = y(t, !0), I) try {
                    return S(e, t)
                } catch (e) {}
                if (x(e, t)) return c(!l.f.call(e, t), e[t])
            }
        },
        C = function (e) {
            if (!g(e)) throw TypeError(String(e) + " is not an object");
            return e
        },
        E = Object.defineProperty,
        R = {
            f: o ? E : function (e, t, n) {
                if (C(e), t = y(t, !0), C(n), I) try {
                    return E(e, t, n)
                } catch (e) {}
                if ("get" in n || "set" in n) throw TypeError("Accessors not supported");
                return "value" in n && (e[t] = n.value), e
            }
        },
        A = o ? function (e, t, n) {
            return R.f(e, t, c(1, n))
        } : function (e, t, n) {
            return e[t] = n, e
        },
        F = function (e, t) {
            try {
                A(a, e, t)
            } catch (n) {
                a[e] = t
            }
            return t
        },
        _ = a["__core-js_shared__"] || F("__core-js_shared__", {}),
        D = Function.toString;
    "function" != typeof _.inspectSource && (_.inspectSource = function (e) {
        return D.call(e)
    });
    var O, M, L, z = _.inspectSource,
        P = a.WeakMap,
        B = "function" == typeof P && /native code/.test(z(P)),
        W = n(function (e) {
            (e.exports = function (e, t) {
                return _[e] || (_[e] = void 0 !== t ? t : {})
            })("versions", []).push({
                version: "3.6.5",
                mode: "global",
                copyright: "Â© 2020 Denis Pushkarev (zloirock.ru)"
            })
        }),
        V = 0,
        U = Math.random(),
        G = function (e) {
            return "Symbol(" + String(void 0 === e ? "" : e) + ")_" + (++V + U).toString(36)
        },
        j = W("keys"),
        H = function (e) {
            return j[e] || (j[e] = G(e))
        },
        q = {},
        K = a.WeakMap;
    if (B) {
        var X = new K,
            Y = X.get,
            J = X.has,
            Z = X.set;
        O = function (e, t) {
            return Z.call(X, e, t), t
        }, M = function (e) {
            return Y.call(X, e) || {}
        }, L = function (e) {
            return J.call(X, e)
        }
    } else {
        var Q = H("state");
        q[Q] = !0, O = function (e, t) {
            return A(e, Q, t), t
        }, M = function (e) {
            return x(e, Q) ? e[Q] : {}
        }, L = function (e) {
            return x(e, Q)
        }
    }
    var $, ee = {
            set: O,
            get: M,
            has: L,
            enforce: function (e) {
                return L(e) ? M(e) : O(e, {})
            },
            getterFor: function (e) {
                return function (t) {
                    var n;
                    if (!g(t) || (n = M(t)).type !== e) throw TypeError("Incompatible receiver, " + e + " required");
                    return n
                }
            }
        },
        te = n(function (e) {
            var t = ee.get,
                n = ee.enforce,
                r = String(String).split("String");
            (e.exports = function (e, t, i, o) {
                var s = !!o && !!o.unsafe,
                    u = !!o && !!o.enumerable,
                    l = !!o && !!o.noTargetGet;
                "function" == typeof i && ("string" != typeof t || x(i, "name") || A(i, "name", t), n(i).source = r.join("string" == typeof t ? t : "")), e !== a ? (s ? !l && e[t] && (u = !0) : delete e[t], u ? e[t] = i : A(e, t, i)) : u ? e[t] = i : F(t, i)
            })(Function.prototype, "toString", function () {
                return "function" == typeof this && t(this).source || z(this)
            })
        }),
        ne = a,
        re = function (e) {
            return "function" == typeof e ? e : void 0
        },
        ae = function (e, t) {
            return arguments.length < 2 ? re(ne[e]) || re(a[e]) : ne[e] && ne[e][t] || a[e] && a[e][t]
        },
        ie = Math.ceil,
        oe = Math.floor,
        se = function (e) {
            return isNaN(e = +e) ? 0 : (e > 0 ? oe : ie)(e)
        },
        ue = Math.min,
        le = function (e) {
            return e > 0 ? ue(se(e), 9007199254740991) : 0
        },
        ce = Math.max,
        pe = Math.min,
        he = function (e, t) {
            var n = se(e);
            return n < 0 ? ce(n + t, 0) : pe(n, t)
        },
        fe = function (e) {
            return function (t, n, r) {
                var a, i = v(t),
                    o = le(i.length),
                    s = he(r, o);
                if (e && n != n) {
                    for (; o > s;)
                        if ((a = i[s++]) != a) return !0
                } else
                    for (; o > s; s++)
                        if ((e || s in i) && i[s] === n) return e || s || 0;
                return !e && -1
            }
        },
        de = {
            includes: fe(!0),
            indexOf: fe(!1)
        },
        me = de.indexOf,
        ve = function (e, t) {
            var n, r = v(e),
                a = 0,
                i = [];
            for (n in r) !x(q, n) && x(r, n) && i.push(n);
            for (; t.length > a;) x(r, n = t[a++]) && (~me(i, n) || i.push(n));
            return i
        },
        ge = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"],
        ye = ge.concat("length", "prototype"),
        be = {
            f: Object.getOwnPropertyNames || function (e) {
                return ve(e, ye)
            }
        },
        xe = {
            f: Object.getOwnPropertySymbols
        },
        we = ae("Reflect", "ownKeys") || function (e) {
            var t = be.f(C(e)),
                n = xe.f;
            return n ? t.concat(n(e)) : t
        },
        ke = function (e, t) {
            for (var n = we(t), r = R.f, a = T.f, i = 0; i < n.length; i++) {
                var o = n[i];
                x(e, o) || r(e, o, a(t, o))
            }
        },
        Ne = /#|\.prototype\./,
        Ie = function (e, t) {
            var n = Te[Se(e)];
            return n == Ee || n != Ce && ("function" == typeof t ? i(t) : !!t)
        },
        Se = Ie.normalize = function (e) {
            return String(e).replace(Ne, ".").toLowerCase()
        },
        Te = Ie.data = {},
        Ce = Ie.NATIVE = "N",
        Ee = Ie.POLYFILL = "P",
        Re = Ie,
        Ae = T.f,
        Fe = function (e, t) {
            var n, r, i, o, s, u = e.target,
                l = e.global,
                c = e.stat;
            if (n = l ? a : c ? a[u] || F(u, {}) : (a[u] || {}).prototype)
                for (r in t) {
                    if (o = t[r], i = e.noTargetGet ? (s = Ae(n, r)) && s.value : n[r], !Re(l ? r : u + (c ? "." : "#") + r, e.forced) && void 0 !== i) {
                        if (typeof o == typeof i) continue;
                        ke(o, i)
                    }(e.sham || i && i.sham) && A(o, "sham", !0), te(n, r, o, e)
                }
        },
        _e = !!Object.getOwnPropertySymbols && !i(function () {
            return !String(Symbol())
        }),
        De = _e && !Symbol.sham && "symbol" == typeof Symbol.iterator,
        Oe = Array.isArray || function (e) {
            return "Array" == h(e)
        },
        Me = function (e) {
            return Object(m(e))
        },
        Le = Object.keys || function (e) {
            return ve(e, ge)
        },
        ze = o ? Object.defineProperties : function (e, t) {
            C(e);
            for (var n, r = Le(t), a = r.length, i = 0; a > i;) R.f(e, n = r[i++], t[n]);
            return e
        },
        Pe = ae("document", "documentElement"),
        Be = H("IE_PROTO"),
        We = function () {},
        Ve = function (e) {
            return "<script>" + e + "<\/script>"
        },
        Ue = function () {
            try {
                $ = document.domain && new ActiveXObject("htmlfile")
            } catch (e) {}
            var e, t;
            Ue = $ ? function (e) {
                e.write(Ve("")), e.close();
                var t = e.parentWindow.Object;
                return e = null, t
            }($) : ((t = N("iframe")).style.display = "none", Pe.appendChild(t), t.src = String("javascript:"), (e = t.contentWindow.document).open(), e.write(Ve("document.F=Object")), e.close(), e.F);
            for (var n = ge.length; n--;) delete Ue.prototype[ge[n]];
            return Ue()
        };
    q[Be] = !0;
    var Ge = Object.create || function (e, t) {
            var n;
            return null !== e ? (We.prototype = C(e), n = new We, We.prototype = null, n[Be] = e) : n = Ue(), void 0 === t ? n : ze(n, t)
        },
        je = be.f,
        He = {}.toString,
        qe = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [],
        Ke = {
            f: function (e) {
                return qe && "[object Window]" == He.call(e) ? function (e) {
                    try {
                        return je(e)
                    } catch (e) {
                        return qe.slice()
                    }
                }(e) : je(v(e))
            }
        },
        Xe = W("wks"),
        Ye = a.Symbol,
        Je = De ? Ye : Ye && Ye.withoutSetter || G,
        Ze = function (e) {
            return x(Xe, e) || (_e && x(Ye, e) ? Xe[e] = Ye[e] : Xe[e] = Je("Symbol." + e)), Xe[e]
        },
        Qe = {
            f: Ze
        },
        $e = R.f,
        et = function (e) {
            var t = ne.Symbol || (ne.Symbol = {});
            x(t, e) || $e(t, e, {
                value: Qe.f(e)
            })
        },
        tt = R.f,
        nt = Ze("toStringTag"),
        rt = function (e, t, n) {
            e && !x(e = n ? e : e.prototype, nt) && tt(e, nt, {
                configurable: !0,
                value: t
            })
        },
        at = function (e) {
            if ("function" != typeof e) throw TypeError(String(e) + " is not a function");
            return e
        },
        it = function (e, t, n) {
            if (at(e), void 0 === t) return e;
            switch (n) {
                case 0:
                    return function () {
                        return e.call(t)
                    };
                case 1:
                    return function (n) {
                        return e.call(t, n)
                    };
                case 2:
                    return function (n, r) {
                        return e.call(t, n, r)
                    };
                case 3:
                    return function (n, r, a) {
                        return e.call(t, n, r, a)
                    }
            }
            return function () {
                return e.apply(t, arguments)
            }
        },
        ot = Ze("species"),
        st = function (e, t) {
            var n;
            return Oe(e) && ("function" != typeof (n = e.constructor) || n !== Array && !Oe(n.prototype) ? g(n) && null === (n = n[ot]) && (n = void 0) : n = void 0), new(void 0 === n ? Array : n)(0 === t ? 0 : t)
        },
        ut = [].push,
        lt = function (e) {
            var t = 1 == e,
                n = 2 == e,
                r = 3 == e,
                a = 4 == e,
                i = 6 == e,
                o = 5 == e || i;
            return function (s, u, l, c) {
                for (var p, h, f = Me(s), m = d(f), v = it(u, l, 3), g = le(m.length), y = 0, b = c || st, x = t ? b(s, g) : n ? b(s, 0) : void 0; g > y; y++)
                    if ((o || y in m) && (h = v(p = m[y], y, f), e))
                        if (t) x[y] = h;
                        else if (h) switch (e) {
                    case 3:
                        return !0;
                    case 5:
                        return p;
                    case 6:
                        return y;
                    case 2:
                        ut.call(x, p)
                } else if (a) return !1;
                return i ? -1 : r || a ? a : x
            }
        },
        ct = {
            forEach: lt(0),
            map: lt(1),
            filter: lt(2),
            some: lt(3),
            every: lt(4),
            find: lt(5),
            findIndex: lt(6)
        },
        pt = ct.forEach,
        ht = H("hidden"),
        ft = Ze("toPrimitive"),
        dt = ee.set,
        mt = ee.getterFor("Symbol"),
        vt = Object.prototype,
        gt = a.Symbol,
        yt = ae("JSON", "stringify"),
        bt = T.f,
        xt = R.f,
        wt = Ke.f,
        kt = l.f,
        Nt = W("symbols"),
        It = W("op-symbols"),
        St = W("string-to-symbol-registry"),
        Tt = W("symbol-to-string-registry"),
        Ct = W("wks"),
        Et = a.QObject,
        Rt = !Et || !Et.prototype || !Et.prototype.findChild,
        At = o && i(function () {
            return 7 != Ge(xt({}, "a", {
                get: function () {
                    return xt(this, "a", {
                        value: 7
                    }).a
                }
            })).a
        }) ? function (e, t, n) {
            var r = bt(vt, t);
            r && delete vt[t], xt(e, t, n), r && e !== vt && xt(vt, t, r)
        } : xt,
        Ft = function (e, t) {
            var n = Nt[e] = Ge(gt.prototype);
            return dt(n, {
                type: "Symbol",
                tag: e,
                description: t
            }), o || (n.description = t), n
        },
        _t = De ? function (e) {
            return "symbol" == typeof e
        } : function (e) {
            return Object(e) instanceof gt
        },
        Dt = function (e, t, n) {
            e === vt && Dt(It, t, n), C(e);
            var r = y(t, !0);
            return C(n), x(Nt, r) ? (n.enumerable ? (x(e, ht) && e[ht][r] && (e[ht][r] = !1), n = Ge(n, {
                enumerable: c(0, !1)
            })) : (x(e, ht) || xt(e, ht, c(1, {})), e[ht][r] = !0), At(e, r, n)) : xt(e, r, n)
        },
        Ot = function (e, t) {
            C(e);
            var n = v(t),
                r = Le(n).concat(Pt(n));
            return pt(r, function (t) {
                o && !Mt.call(n, t) || Dt(e, t, n[t])
            }), e
        },
        Mt = function (e) {
            var t = y(e, !0),
                n = kt.call(this, t);
            return !(this === vt && x(Nt, t) && !x(It, t)) && (!(n || !x(this, t) || !x(Nt, t) || x(this, ht) && this[ht][t]) || n)
        },
        Lt = function (e, t) {
            var n = v(e),
                r = y(t, !0);
            if (n !== vt || !x(Nt, r) || x(It, r)) {
                var a = bt(n, r);
                return !a || !x(Nt, r) || x(n, ht) && n[ht][r] || (a.enumerable = !0), a
            }
        },
        zt = function (e) {
            var t = wt(v(e)),
                n = [];
            return pt(t, function (e) {
                x(Nt, e) || x(q, e) || n.push(e)
            }), n
        },
        Pt = function (e) {
            var t = e === vt,
                n = wt(t ? It : v(e)),
                r = [];
            return pt(n, function (e) {
                !x(Nt, e) || t && !x(vt, e) || r.push(Nt[e])
            }), r
        };
    if (_e || (te((gt = function () {
            if (this instanceof gt) throw TypeError("Symbol is not a constructor");
            var e = arguments.length && void 0 !== arguments[0] ? String(arguments[0]) : void 0,
                t = G(e);
            return o && Rt && At(vt, t, {
                configurable: !0,
                set: function e(n) {
                    this === vt && e.call(It, n), x(this, ht) && x(this[ht], t) && (this[ht][t] = !1), At(this, t, c(1, n))
                }
            }), Ft(t, e)
        }).prototype, "toString", function () {
            return mt(this).tag
        }), te(gt, "withoutSetter", function (e) {
            return Ft(G(e), e)
        }), l.f = Mt, R.f = Dt, T.f = Lt, be.f = Ke.f = zt, xe.f = Pt, Qe.f = function (e) {
            return Ft(Ze(e), e)
        }, o && (xt(gt.prototype, "description", {
            configurable: !0,
            get: function () {
                return mt(this).description
            }
        }), te(vt, "propertyIsEnumerable", Mt, {
            unsafe: !0
        }))), Fe({
            global: !0,
            wrap: !0,
            forced: !_e,
            sham: !_e
        }, {
            Symbol: gt
        }), pt(Le(Ct), function (e) {
            et(e)
        }), Fe({
            target: "Symbol",
            stat: !0,
            forced: !_e
        }, {
            for: function (e) {
                var t = String(e);
                if (x(St, t)) return St[t];
                var n = gt(t);
                return St[t] = n, Tt[n] = t, n
            },
            keyFor: function (e) {
                if (!_t(e)) throw TypeError(e + " is not a symbol");
                if (x(Tt, e)) return Tt[e]
            },
            useSetter: function () {
                Rt = !0
            },
            useSimple: function () {
                Rt = !1
            }
        }), Fe({
            target: "Object",
            stat: !0,
            forced: !_e,
            sham: !o
        }, {
            create: function (e, t) {
                return void 0 === t ? Ge(e) : Ot(Ge(e), t)
            },
            defineProperty: Dt,
            defineProperties: Ot,
            getOwnPropertyDescriptor: Lt
        }), Fe({
            target: "Object",
            stat: !0,
            forced: !_e
        }, {
            getOwnPropertyNames: zt,
            getOwnPropertySymbols: Pt
        }), Fe({
            target: "Object",
            stat: !0,
            forced: i(function () {
                xe.f(1)
            })
        }, {
            getOwnPropertySymbols: function (e) {
                return xe.f(Me(e))
            }
        }), yt) {
        var Bt = !_e || i(function () {
            var e = gt();
            return "[null]" != yt([e]) || "{}" != yt({
                a: e
            }) || "{}" != yt(Object(e))
        });
        Fe({
            target: "JSON",
            stat: !0,
            forced: Bt
        }, {
            stringify: function (e, t, n) {
                for (var r, a = [e], i = 1; arguments.length > i;) a.push(arguments[i++]);
                if (r = t, (g(t) || void 0 !== e) && !_t(e)) return Oe(t) || (t = function (e, t) {
                    if ("function" == typeof r && (t = r.call(this, e, t)), !_t(t)) return t
                }), a[1] = t, yt.apply(null, a)
            }
        })
    }
    gt.prototype[ft] || A(gt.prototype, ft, gt.prototype.valueOf), rt(gt, "Symbol"), q[ht] = !0, et("asyncIterator");
    var Wt = R.f,
        Vt = a.Symbol;
    if (o && "function" == typeof Vt && (!("description" in Vt.prototype) || void 0 !== Vt().description)) {
        var Ut = {},
            Gt = function () {
                var e = arguments.length < 1 || void 0 === arguments[0] ? void 0 : String(arguments[0]),
                    t = this instanceof Gt ? new Vt(e) : void 0 === e ? Vt() : Vt(e);
                return "" === e && (Ut[t] = !0), t
            };
        ke(Gt, Vt);
        var jt = Gt.prototype = Vt.prototype;
        jt.constructor = Gt;
        var Ht = jt.toString,
            qt = "Symbol(test)" == String(Vt("test")),
            Kt = /^Symbol\((.*)\)[^)]+$/;
        Wt(jt, "description", {
            configurable: !0,
            get: function () {
                var e = g(this) ? this.valueOf() : this,
                    t = Ht.call(e);
                if (x(Ut, e)) return "";
                var n = qt ? t.slice(7, -1) : t.replace(Kt, "$1");
                return "" === n ? void 0 : n
            }
        }), Fe({
            global: !0,
            forced: !0
        }, {
            Symbol: Gt
        })
    }
    et("hasInstance"), et("isConcatSpreadable"), et("iterator"), et("match"), et("matchAll"), et("replace"), et("search"), et("species"), et("split"), et("toPrimitive"), et("toStringTag"), et("unscopables");
    var Xt = Object.assign,
        Yt = Object.defineProperty,
        Jt = !Xt || i(function () {
            if (o && 1 !== Xt({
                    b: 1
                }, Xt(Yt({}, "a", {
                    enumerable: !0,
                    get: function () {
                        Yt(this, "b", {
                            value: 3,
                            enumerable: !1
                        })
                    }
                }), {
                    b: 2
                })).b) return !0;
            var e = {},
                t = {},
                n = Symbol();
            return e[n] = 7, "abcdefghijklmnopqrst".split("").forEach(function (e) {
                t[e] = e
            }), 7 != Xt({}, e)[n] || "abcdefghijklmnopqrst" != Le(Xt({}, t)).join("")
        }) ? function (e, t) {
            for (var n = Me(e), r = arguments.length, a = 1, i = xe.f, s = l.f; r > a;)
                for (var u, c = d(arguments[a++]), p = i ? Le(c).concat(i(c)) : Le(c), h = p.length, f = 0; h > f;) u = p[f++], o && !s.call(c, u) || (n[u] = c[u]);
            return n
        } : Xt;
    Fe({
        target: "Object",
        stat: !0,
        forced: Object.assign !== Jt
    }, {
        assign: Jt
    }), Fe({
        target: "Object",
        stat: !0,
        sham: !o
    }, {
        create: Ge
    }), Fe({
        target: "Object",
        stat: !0,
        forced: !o,
        sham: !o
    }, {
        defineProperty: R.f
    }), Fe({
        target: "Object",
        stat: !0,
        forced: !o,
        sham: !o
    }, {
        defineProperties: ze
    });
    var Zt = l.f,
        Qt = function (e) {
            return function (t) {
                for (var n, r = v(t), a = Le(r), i = a.length, s = 0, u = []; i > s;) n = a[s++], o && !Zt.call(r, n) || u.push(e ? [n, r[n]] : r[n]);
                return u
            }
        },
        $t = {
            entries: Qt(!0),
            values: Qt(!1)
        },
        en = $t.entries;
    Fe({
        target: "Object",
        stat: !0
    }, {
        entries: function (e) {
            return en(e)
        }
    });
    var tn = !i(function () {
            return Object.isExtensible(Object.preventExtensions({}))
        }),
        nn = n(function (e) {
            var t = R.f,
                n = G("meta"),
                r = 0,
                a = Object.isExtensible || function () {
                    return !0
                },
                i = function (e) {
                    t(e, n, {
                        value: {
                            objectID: "O" + ++r,
                            weakData: {}
                        }
                    })
                },
                o = e.exports = {
                    REQUIRED: !1,
                    fastKey: function (e, t) {
                        if (!g(e)) return "symbol" == typeof e ? e : ("string" == typeof e ? "S" : "P") + e;
                        if (!x(e, n)) {
                            if (!a(e)) return "F";
                            if (!t) return "E";
                            i(e)
                        }
                        return e[n].objectID
                    },
                    getWeakData: function (e, t) {
                        if (!x(e, n)) {
                            if (!a(e)) return !0;
                            if (!t) return !1;
                            i(e)
                        }
                        return e[n].weakData
                    },
                    onFreeze: function (e) {
                        return tn && o.REQUIRED && a(e) && !x(e, n) && i(e), e
                    }
                };
            q[n] = !0
        }),
        rn = (nn.REQUIRED, nn.fastKey, nn.getWeakData, nn.onFreeze, nn.onFreeze),
        an = Object.freeze,
        on = i(function () {
            an(1)
        });
    Fe({
        target: "Object",
        stat: !0,
        forced: on,
        sham: !tn
    }, {
        freeze: function (e) {
            return an && g(e) ? an(rn(e)) : e
        }
    });
    var sn = {},
        un = Ze("iterator"),
        ln = Array.prototype,
        cn = function (e) {
            return void 0 !== e && (sn.Array === e || ln[un] === e)
        },
        pn = {};
    pn[Ze("toStringTag")] = "z";
    var hn = "[object z]" === String(pn),
        fn = Ze("toStringTag"),
        dn = "Arguments" == h(function () {
            return arguments
        }()),
        mn = hn ? h : function (e) {
            var t, n, r;
            return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof (n = function (e, t) {
                try {
                    return e[t]
                } catch (e) {}
            }(t = Object(e), fn)) ? n : dn ? h(t) : "Object" == (r = h(t)) && "function" == typeof t.callee ? "Arguments" : r
        },
        vn = Ze("iterator"),
        gn = function (e) {
            if (null != e) return e[vn] || e["@@iterator"] || sn[mn(e)]
        },
        yn = function (e, t, n, r) {
            try {
                return r ? t(C(n)[0], n[1]) : t(n)
            } catch (t) {
                var a = e.return;
                throw void 0 !== a && C(a.call(e)), t
            }
        },
        bn = n(function (e) {
            var t = function (e, t) {
                this.stopped = e, this.result = t
            };
            (e.exports = function (e, n, r, a, i) {
                var o, s, u, l, c, p, h, f = it(n, r, a ? 2 : 1);
                if (i) o = e;
                else {
                    if ("function" != typeof (s = gn(e))) throw TypeError("Target is not iterable");
                    if (cn(s)) {
                        for (u = 0, l = le(e.length); l > u; u++)
                            if ((c = a ? f(C(h = e[u])[0], h[1]) : f(e[u])) && c instanceof t) return c;
                        return new t(!1)
                    }
                    o = s.call(e)
                }
                for (p = o.next; !(h = p.call(o)).done;)
                    if ("object" == typeof (c = yn(o, f, h.value, a)) && c && c instanceof t) return c;
                return new t(!1)
            }).stop = function (e) {
                return new t(!0, e)
            }
        }),
        xn = function (e, t, n) {
            var r = y(t);
            r in e ? R.f(e, r, c(0, n)) : e[r] = n
        };
    Fe({
        target: "Object",
        stat: !0
    }, {
        fromEntries: function (e) {
            var t = {};
            return bn(e, function (e, n) {
                xn(t, e, n)
            }, void 0, !0), t
        }
    });
    var wn = T.f,
        kn = i(function () {
            wn(1)
        });
    Fe({
        target: "Object",
        stat: !0,
        forced: !o || kn,
        sham: !o
    }, {
        getOwnPropertyDescriptor: function (e, t) {
            return wn(v(e), t)
        }
    }), Fe({
        target: "Object",
        stat: !0,
        sham: !o
    }, {
        getOwnPropertyDescriptors: function (e) {
            for (var t, n, r = v(e), a = T.f, i = we(r), o = {}, s = 0; i.length > s;) void 0 !== (n = a(r, t = i[s++])) && xn(o, t, n);
            return o
        }
    });
    var Nn = Ke.f,
        In = i(function () {
            return !Object.getOwnPropertyNames(1)
        });
    Fe({
        target: "Object",
        stat: !0,
        forced: In
    }, {
        getOwnPropertyNames: Nn
    });
    var Sn = !i(function () {
            function e() {}
            return e.prototype.constructor = null, Object.getPrototypeOf(new e) !== e.prototype
        }),
        Tn = H("IE_PROTO"),
        Cn = Object.prototype,
        En = Sn ? Object.getPrototypeOf : function (e) {
            return e = Me(e), x(e, Tn) ? e[Tn] : "function" == typeof e.constructor && e instanceof e.constructor ? e.constructor.prototype : e instanceof Object ? Cn : null
        },
        Rn = i(function () {
            En(1)
        });
    Fe({
        target: "Object",
        stat: !0,
        forced: Rn,
        sham: !Sn
    }, {
        getPrototypeOf: function (e) {
            return En(Me(e))
        }
    });
    var An = Object.is || function (e, t) {
        return e === t ? 0 !== e || 1 / e == 1 / t : e != e && t != t
    };
    Fe({
        target: "Object",
        stat: !0
    }, {
        is: An
    });
    var Fn = Object.isExtensible,
        _n = i(function () {
            Fn(1)
        });
    Fe({
        target: "Object",
        stat: !0,
        forced: _n
    }, {
        isExtensible: function (e) {
            return !!g(e) && (!Fn || Fn(e))
        }
    });
    var Dn = Object.isFrozen,
        On = i(function () {
            Dn(1)
        });
    Fe({
        target: "Object",
        stat: !0,
        forced: On
    }, {
        isFrozen: function (e) {
            return !g(e) || !!Dn && Dn(e)
        }
    });
    var Mn = Object.isSealed,
        Ln = i(function () {
            Mn(1)
        });
    Fe({
        target: "Object",
        stat: !0,
        forced: Ln
    }, {
        isSealed: function (e) {
            return !g(e) || !!Mn && Mn(e)
        }
    });
    var zn = i(function () {
        Le(1)
    });
    Fe({
        target: "Object",
        stat: !0,
        forced: zn
    }, {
        keys: function (e) {
            return Le(Me(e))
        }
    });
    var Pn = nn.onFreeze,
        Bn = Object.preventExtensions,
        Wn = i(function () {
            Bn(1)
        });
    Fe({
        target: "Object",
        stat: !0,
        forced: Wn,
        sham: !tn
    }, {
        preventExtensions: function (e) {
            return Bn && g(e) ? Bn(Pn(e)) : e
        }
    });
    var Vn = nn.onFreeze,
        Un = Object.seal,
        Gn = i(function () {
            Un(1)
        });
    Fe({
        target: "Object",
        stat: !0,
        forced: Gn,
        sham: !tn
    }, {
        seal: function (e) {
            return Un && g(e) ? Un(Vn(e)) : e
        }
    });
    var jn = function (e) {
            if (!g(e) && null !== e) throw TypeError("Can't set " + String(e) + " as a prototype");
            return e
        },
        Hn = Object.setPrototypeOf || ("__proto__" in {} ? function () {
            var e, t = !1,
                n = {};
            try {
                (e = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(n, []), t = n instanceof Array
            } catch (e) {}
            return function (n, r) {
                return C(n), jn(r), t ? e.call(n, r) : n.__proto__ = r, n
            }
        }() : void 0);
    Fe({
        target: "Object",
        stat: !0
    }, {
        setPrototypeOf: Hn
    });
    var qn = $t.values;
    Fe({
        target: "Object",
        stat: !0
    }, {
        values: function (e) {
            return qn(e)
        }
    });
    var Kn = hn ? {}.toString : function () {
        return "[object " + mn(this) + "]"
    };
    hn || te(Object.prototype, "toString", Kn, {
        unsafe: !0
    });
    var Xn = !i(function () {
        var e = Math.random();
        __defineSetter__.call(null, e, function () {}), delete a[e]
    });
    o && Fe({
        target: "Object",
        proto: !0,
        forced: Xn
    }, {
        __defineGetter__: function (e, t) {
            R.f(Me(this), e, {
                get: at(t),
                enumerable: !0,
                configurable: !0
            })
        }
    }), o && Fe({
        target: "Object",
        proto: !0,
        forced: Xn
    }, {
        __defineSetter__: function (e, t) {
            R.f(Me(this), e, {
                set: at(t),
                enumerable: !0,
                configurable: !0
            })
        }
    });
    var Yn = T.f;
    o && Fe({
        target: "Object",
        proto: !0,
        forced: Xn
    }, {
        __lookupGetter__: function (e) {
            var t, n = Me(this),
                r = y(e, !0);
            do {
                if (t = Yn(n, r)) return t.get
            } while (n = En(n))
        }
    });
    var Jn = T.f;
    o && Fe({
        target: "Object",
        proto: !0,
        forced: Xn
    }, {
        __lookupSetter__: function (e) {
            var t, n = Me(this),
                r = y(e, !0);
            do {
                if (t = Jn(n, r)) return t.set
            } while (n = En(n))
        }
    });
    var Zn = [].slice,
        Qn = {},
        $n = Function.bind || function (e) {
            var t = at(this),
                n = Zn.call(arguments, 1),
                r = function () {
                    var a = n.concat(Zn.call(arguments));
                    return this instanceof r ? function (e, t, n) {
                        if (!(t in Qn)) {
                            for (var r = [], a = 0; a < t; a++) r[a] = "a[" + a + "]";
                            Qn[t] = Function("C,a", "return new C(" + r.join(",") + ")")
                        }
                        return Qn[t](e, n)
                    }(t, a.length, a) : t.apply(e, a)
                };
            return g(t.prototype) && (r.prototype = t.prototype), r
        };
    Fe({
        target: "Function",
        proto: !0
    }, {
        bind: $n
    });
    var er = R.f,
        tr = Function.prototype,
        nr = tr.toString,
        rr = /^\s*function ([^ (]*)/;
    o && !("name" in tr) && er(tr, "name", {
        configurable: !0,
        get: function () {
            try {
                return nr.call(this).match(rr)[1]
            } catch (e) {
                return ""
            }
        }
    });
    var ar = Ze("hasInstance"),
        ir = Function.prototype;
    ar in ir || R.f(ir, ar, {
        value: function (e) {
            if ("function" != typeof this || !g(e)) return !1;
            if (!g(this.prototype)) return e instanceof this;
            for (; e = En(e);)
                if (this.prototype === e) return !0;
            return !1
        }
    }), Fe({
        global: !0
    }, {
        globalThis: a
    });
    var or = function (e) {
            var t, n, r, a, i, o, s = Me(e),
                u = "function" == typeof this ? this : Array,
                l = arguments.length,
                c = l > 1 ? arguments[1] : void 0,
                p = void 0 !== c,
                h = gn(s),
                f = 0;
            if (p && (c = it(c, l > 2 ? arguments[2] : void 0, 2)), null == h || u == Array && cn(h))
                for (n = new u(t = le(s.length)); t > f; f++) o = p ? c(s[f], f) : s[f], xn(n, f, o);
            else
                for (i = (a = h.call(s)).next, n = new u; !(r = i.call(a)).done; f++) o = p ? yn(a, c, [r.value, f], !0) : r.value, xn(n, f, o);
            return n.length = f, n
        },
        sr = Ze("iterator"),
        ur = !1;
    try {
        var lr = 0,
            cr = {
                next: function () {
                    return {
                        done: !!lr++
                    }
                },
                return: function () {
                    ur = !0
                }
            };
        cr[sr] = function () {
            return this
        }, Array.from(cr, function () {
            throw 2
        })
    } catch (e) {}
    var pr = function (e, t) {
            if (!t && !ur) return !1;
            var n = !1;
            try {
                var r = {};
                r[sr] = function () {
                    return {
                        next: function () {
                            return {
                                done: n = !0
                            }
                        }
                    }
                }, e(r)
            } catch (e) {}
            return n
        },
        hr = !pr(function (e) {
            Array.from(e)
        });
    Fe({
        target: "Array",
        stat: !0,
        forced: hr
    }, {
        from: or
    }), Fe({
        target: "Array",
        stat: !0
    }, {
        isArray: Oe
    });
    var fr = i(function () {
        function e() {}
        return !(Array.of.call(e) instanceof e)
    });
    Fe({
        target: "Array",
        stat: !0,
        forced: fr
    }, {
        of: function () {
            for (var e = 0, t = arguments.length, n = new("function" == typeof this ? this : Array)(t); t > e;) xn(n, e, arguments[e++]);
            return n.length = t, n
        }
    });
    var dr, mr, vr = ae("navigator", "userAgent") || "",
        gr = a.process,
        yr = gr && gr.versions,
        br = yr && yr.v8;
    br ? mr = (dr = br.split("."))[0] + dr[1] : vr && (!(dr = vr.match(/Edge\/(\d+)/)) || dr[1] >= 74) && (dr = vr.match(/Chrome\/(\d+)/)) && (mr = dr[1]);
    var xr = mr && +mr,
        wr = Ze("species"),
        kr = function (e) {
            return xr >= 51 || !i(function () {
                var t = [];
                return (t.constructor = {})[wr] = function () {
                    return {
                        foo: 1
                    }
                }, 1 !== t[e](Boolean).foo
            })
        },
        Nr = Ze("isConcatSpreadable"),
        Ir = xr >= 51 || !i(function () {
            var e = [];
            return e[Nr] = !1, e.concat()[0] !== e
        }),
        Sr = kr("concat"),
        Tr = function (e) {
            if (!g(e)) return !1;
            var t = e[Nr];
            return void 0 !== t ? !!t : Oe(e)
        };
    Fe({
        target: "Array",
        proto: !0,
        forced: !Ir || !Sr
    }, {
        concat: function (e) {
            var t, n, r, a, i, o = Me(this),
                s = st(o, 0),
                u = 0;
            for (t = -1, r = arguments.length; t < r; t++)
                if (i = -1 === t ? o : arguments[t], Tr(i)) {
                    if (u + (a = le(i.length)) > 9007199254740991) throw TypeError("Maximum allowed index exceeded");
                    for (n = 0; n < a; n++, u++) n in i && xn(s, u, i[n])
                } else {
                    if (u >= 9007199254740991) throw TypeError("Maximum allowed index exceeded");
                    xn(s, u++, i)
                } return s.length = u, s
        }
    });
    var Cr = Math.min,
        Er = [].copyWithin || function (e, t) {
            var n = Me(this),
                r = le(n.length),
                a = he(e, r),
                i = he(t, r),
                o = arguments.length > 2 ? arguments[2] : void 0,
                s = Cr((void 0 === o ? r : he(o, r)) - i, r - a),
                u = 1;
            for (i < a && a < i + s && (u = -1, i += s - 1, a += s - 1); s-- > 0;) i in n ? n[a] = n[i] : delete n[a], a += u, i += u;
            return n
        },
        Rr = Ze("unscopables"),
        Ar = Array.prototype;
    null == Ar[Rr] && R.f(Ar, Rr, {
        configurable: !0,
        value: Ge(null)
    });
    var Fr = function (e) {
        Ar[Rr][e] = !0
    };
    Fe({
        target: "Array",
        proto: !0
    }, {
        copyWithin: Er
    }), Fr("copyWithin");
    var _r = function (e, t) {
            var n = [][e];
            return !!n && i(function () {
                n.call(null, t || function () {
                    throw 1
                }, 1)
            })
        },
        Dr = Object.defineProperty,
        Or = {},
        Mr = function (e) {
            throw e
        },
        Lr = function (e, t) {
            if (x(Or, e)) return Or[e];
            t || (t = {});
            var n = [][e],
                r = !!x(t, "ACCESSORS") && t.ACCESSORS,
                a = x(t, 0) ? t[0] : Mr,
                s = x(t, 1) ? t[1] : void 0;
            return Or[e] = !!n && !i(function () {
                if (r && !o) return !0;
                var e = {
                    length: -1
                };
                r ? Dr(e, 1, {
                    enumerable: !0,
                    get: Mr
                }) : e[1] = 1, n.call(e, a, s)
            })
        },
        zr = ct.every,
        Pr = _r("every"),
        Br = Lr("every");
    Fe({
        target: "Array",
        proto: !0,
        forced: !Pr || !Br
    }, {
        every: function (e) {
            return zr(this, e, arguments.length > 1 ? arguments[1] : void 0)
        }
    });
    var Wr = function (e) {
        for (var t = Me(this), n = le(t.length), r = arguments.length, a = he(r > 1 ? arguments[1] : void 0, n), i = r > 2 ? arguments[2] : void 0, o = void 0 === i ? n : he(i, n); o > a;) t[a++] = e;
        return t
    };
    Fe({
        target: "Array",
        proto: !0
    }, {
        fill: Wr
    }), Fr("fill");
    var Vr = ct.filter,
        Ur = kr("filter"),
        Gr = Lr("filter");
    Fe({
        target: "Array",
        proto: !0,
        forced: !Ur || !Gr
    }, {
        filter: function (e) {
            return Vr(this, e, arguments.length > 1 ? arguments[1] : void 0)
        }
    });
    var jr = ct.find,
        Hr = !0,
        qr = Lr("find");
    "find" in [] && Array(1).find(function () {
        Hr = !1
    }), Fe({
        target: "Array",
        proto: !0,
        forced: Hr || !qr
    }, {
        find: function (e) {
            return jr(this, e, arguments.length > 1 ? arguments[1] : void 0)
        }
    }), Fr("find");
    var Kr = ct.findIndex,
        Xr = !0,
        Yr = Lr("findIndex");
    "findIndex" in [] && Array(1).findIndex(function () {
        Xr = !1
    }), Fe({
        target: "Array",
        proto: !0,
        forced: Xr || !Yr
    }, {
        findIndex: function (e) {
            return Kr(this, e, arguments.length > 1 ? arguments[1] : void 0)
        }
    }), Fr("findIndex");
    var Jr = function e(t, n, r, a, i, o, s, u) {
        for (var l, c = i, p = 0, h = !!s && it(s, u, 3); p < a;) {
            if (p in r) {
                if (l = h ? h(r[p], p, n) : r[p], o > 0 && Oe(l)) c = e(t, n, l, le(l.length), c, o - 1) - 1;
                else {
                    if (c >= 9007199254740991) throw TypeError("Exceed the acceptable array length");
                    t[c] = l
                }
                c++
            }
            p++
        }
        return c
    };
    Fe({
        target: "Array",
        proto: !0
    }, {
        flat: function () {
            var e = arguments.length ? arguments[0] : void 0,
                t = Me(this),
                n = le(t.length),
                r = st(t, 0);
            return r.length = Jr(r, t, t, n, 0, void 0 === e ? 1 : se(e)), r
        }
    }), Fe({
        target: "Array",
        proto: !0
    }, {
        flatMap: function (e) {
            var t, n = Me(this),
                r = le(n.length);
            return at(e), (t = st(n, 0)).length = Jr(t, n, n, r, 0, 1, e, arguments.length > 1 ? arguments[1] : void 0), t
        }
    });
    var Zr = ct.forEach,
        Qr = _r("forEach"),
        $r = Lr("forEach"),
        ea = Qr && $r ? [].forEach : function (e) {
            return Zr(this, e, arguments.length > 1 ? arguments[1] : void 0)
        };
    Fe({
        target: "Array",
        proto: !0,
        forced: [].forEach != ea
    }, {
        forEach: ea
    });
    var ta = de.includes,
        na = Lr("indexOf", {
            ACCESSORS: !0,
            1: 0
        });
    Fe({
        target: "Array",
        proto: !0,
        forced: !na
    }, {
        includes: function (e) {
            return ta(this, e, arguments.length > 1 ? arguments[1] : void 0)
        }
    }), Fr("includes");
    var ra = de.indexOf,
        aa = [].indexOf,
        ia = !!aa && 1 / [1].indexOf(1, -0) < 0,
        oa = _r("indexOf"),
        sa = Lr("indexOf", {
            ACCESSORS: !0,
            1: 0
        });
    Fe({
        target: "Array",
        proto: !0,
        forced: ia || !oa || !sa
    }, {
        indexOf: function (e) {
            return ia ? aa.apply(this, arguments) || 0 : ra(this, e, arguments.length > 1 ? arguments[1] : void 0)
        }
    });
    var ua = [].join,
        la = d != Object,
        ca = _r("join", ",");
    Fe({
        target: "Array",
        proto: !0,
        forced: la || !ca
    }, {
        join: function (e) {
            return ua.call(v(this), void 0 === e ? "," : e)
        }
    });
    var pa = Math.min,
        ha = [].lastIndexOf,
        fa = !!ha && 1 / [1].lastIndexOf(1, -0) < 0,
        da = _r("lastIndexOf"),
        ma = Lr("indexOf", {
            ACCESSORS: !0,
            1: 0
        }),
        va = !fa && da && ma ? ha : function (e) {
            if (fa) return ha.apply(this, arguments) || 0;
            var t = v(this),
                n = le(t.length),
                r = n - 1;
            for (arguments.length > 1 && (r = pa(r, se(arguments[1]))), r < 0 && (r = n + r); r >= 0; r--)
                if (r in t && t[r] === e) return r || 0;
            return -1
        };
    Fe({
        target: "Array",
        proto: !0,
        forced: va !== [].lastIndexOf
    }, {
        lastIndexOf: va
    });
    var ga = ct.map,
        ya = kr("map"),
        ba = Lr("map");
    Fe({
        target: "Array",
        proto: !0,
        forced: !ya || !ba
    }, {
        map: function (e) {
            return ga(this, e, arguments.length > 1 ? arguments[1] : void 0)
        }
    });
    var xa = function (e) {
            return function (t, n, r, a) {
                at(n);
                var i = Me(t),
                    o = d(i),
                    s = le(i.length),
                    u = e ? s - 1 : 0,
                    l = e ? -1 : 1;
                if (r < 2)
                    for (;;) {
                        if (u in o) {
                            a = o[u], u += l;
                            break
                        }
                        if (u += l, e ? u < 0 : s <= u) throw TypeError("Reduce of empty array with no initial value")
                    }
                for (; e ? u >= 0 : s > u; u += l) u in o && (a = n(a, o[u], u, i));
                return a
            }
        },
        wa = {
            left: xa(!1),
            right: xa(!0)
        },
        ka = wa.left,
        Na = _r("reduce"),
        Ia = Lr("reduce", {
            1: 0
        });
    Fe({
        target: "Array",
        proto: !0,
        forced: !Na || !Ia
    }, {
        reduce: function (e) {
            return ka(this, e, arguments.length, arguments.length > 1 ? arguments[1] : void 0)
        }
    });
    var Sa = wa.right,
        Ta = _r("reduceRight"),
        Ca = Lr("reduce", {
            1: 0
        });
    Fe({
        target: "Array",
        proto: !0,
        forced: !Ta || !Ca
    }, {
        reduceRight: function (e) {
            return Sa(this, e, arguments.length, arguments.length > 1 ? arguments[1] : void 0)
        }
    });
    var Ea = [].reverse,
        Ra = [1, 2];
    Fe({
        target: "Array",
        proto: !0,
        forced: String(Ra) === String(Ra.reverse())
    }, {
        reverse: function () {
            return Oe(this) && (this.length = this.length), Ea.call(this)
        }
    });
    var Aa = kr("slice"),
        Fa = Lr("slice", {
            ACCESSORS: !0,
            0: 0,
            1: 2
        }),
        _a = Ze("species"),
        Da = [].slice,
        Oa = Math.max;
    Fe({
        target: "Array",
        proto: !0,
        forced: !Aa || !Fa
    }, {
        slice: function (e, t) {
            var n, r, a, i = v(this),
                o = le(i.length),
                s = he(e, o),
                u = he(void 0 === t ? o : t, o);
            if (Oe(i) && ("function" != typeof (n = i.constructor) || n !== Array && !Oe(n.prototype) ? g(n) && null === (n = n[_a]) && (n = void 0) : n = void 0, n === Array || void 0 === n)) return Da.call(i, s, u);
            for (r = new(void 0 === n ? Array : n)(Oa(u - s, 0)), a = 0; s < u; s++, a++) s in i && xn(r, a, i[s]);
            return r.length = a, r
        }
    });
    var Ma = ct.some,
        La = _r("some"),
        za = Lr("some");
    Fe({
        target: "Array",
        proto: !0,
        forced: !La || !za
    }, {
        some: function (e) {
            return Ma(this, e, arguments.length > 1 ? arguments[1] : void 0)
        }
    });
    var Pa = [],
        Ba = Pa.sort,
        Wa = i(function () {
            Pa.sort(void 0)
        }),
        Va = i(function () {
            Pa.sort(null)
        }),
        Ua = _r("sort");
    Fe({
        target: "Array",
        proto: !0,
        forced: Wa || !Va || !Ua
    }, {
        sort: function (e) {
            return void 0 === e ? Ba.call(Me(this)) : Ba.call(Me(this), at(e))
        }
    });
    var Ga = kr("splice"),
        ja = Lr("splice", {
            ACCESSORS: !0,
            0: 0,
            1: 2
        }),
        Ha = Math.max,
        qa = Math.min;
    Fe({
        target: "Array",
        proto: !0,
        forced: !Ga || !ja
    }, {
        splice: function (e, t) {
            var n, r, a, i, o, s, u = Me(this),
                l = le(u.length),
                c = he(e, l),
                p = arguments.length;
            if (0 === p ? n = r = 0 : 1 === p ? (n = 0, r = l - c) : (n = p - 2, r = qa(Ha(se(t), 0), l - c)), l + n - r > 9007199254740991) throw TypeError("Maximum allowed length exceeded");
            for (a = st(u, r), i = 0; i < r; i++)(o = c + i) in u && xn(a, i, u[o]);
            if (a.length = r, n < r) {
                for (i = c; i < l - r; i++) s = i + n, (o = i + r) in u ? u[s] = u[o] : delete u[s];
                for (i = l; i > l - r + n; i--) delete u[i - 1]
            } else if (n > r)
                for (i = l - r; i > c; i--) s = i + n - 1, (o = i + r - 1) in u ? u[s] = u[o] : delete u[s];
            for (i = 0; i < n; i++) u[i + c] = arguments[i + 2];
            return u.length = l - r + n, a
        }
    });
    var Ka = Ze("species"),
        Xa = function (e) {
            var t = ae(e),
                n = R.f;
            o && t && !t[Ka] && n(t, Ka, {
                configurable: !0,
                get: function () {
                    return this
                }
            })
        };
    Xa("Array"), Fr("flat"), Fr("flatMap");
    var Ya, Ja, Za, Qa = Ze("iterator"),
        $a = !1;
    [].keys && ("next" in (Za = [].keys()) ? (Ja = En(En(Za))) !== Object.prototype && (Ya = Ja) : $a = !0), null == Ya && (Ya = {}), x(Ya, Qa) || A(Ya, Qa, function () {
        return this
    });
    var ei = {
            IteratorPrototype: Ya,
            BUGGY_SAFARI_ITERATORS: $a
        },
        ti = ei.IteratorPrototype,
        ni = function () {
            return this
        },
        ri = function (e, t, n) {
            var r = t + " Iterator";
            return e.prototype = Ge(ti, {
                next: c(1, n)
            }), rt(e, r, !1), sn[r] = ni, e
        },
        ai = ei.IteratorPrototype,
        ii = ei.BUGGY_SAFARI_ITERATORS,
        oi = Ze("iterator"),
        si = function () {
            return this
        },
        ui = function (e, t, n, r, a, i, o) {
            ri(n, t, r);
            var s, u, l, c = function (e) {
                    if (e === a && m) return m;
                    if (!ii && e in f) return f[e];
                    switch (e) {
                        case "keys":
                        case "values":
                        case "entries":
                            return function () {
                                return new n(this, e)
                            }
                    }
                    return function () {
                        return new n(this)
                    }
                },
                p = t + " Iterator",
                h = !1,
                f = e.prototype,
                d = f[oi] || f["@@iterator"] || a && f[a],
                m = !ii && d || c(a),
                v = "Array" == t && f.entries || d;
            if (v && (s = En(v.call(new e)), ai !== Object.prototype && s.next && (En(s) !== ai && (Hn ? Hn(s, ai) : "function" != typeof s[oi] && A(s, oi, si)), rt(s, p, !0))), "values" == a && d && "values" !== d.name && (h = !0, m = function () {
                    return d.call(this)
                }), f[oi] !== m && A(f, oi, m), sn[t] = m, a)
                if (u = {
                        values: c("values"),
                        keys: i ? m : c("keys"),
                        entries: c("entries")
                    }, o)
                    for (l in u)(ii || h || !(l in f)) && te(f, l, u[l]);
                else Fe({
                    target: t,
                    proto: !0,
                    forced: ii || h
                }, u);
            return u
        },
        li = ee.set,
        ci = ee.getterFor("Array Iterator"),
        pi = ui(Array, "Array", function (e, t) {
            li(this, {
                type: "Array Iterator",
                target: v(e),
                index: 0,
                kind: t
            })
        }, function () {
            var e = ci(this),
                t = e.target,
                n = e.kind,
                r = e.index++;
            return !t || r >= t.length ? (e.target = void 0, {
                value: void 0,
                done: !0
            }) : "keys" == n ? {
                value: r,
                done: !1
            } : "values" == n ? {
                value: t[r],
                done: !1
            } : {
                value: [r, t[r]],
                done: !1
            }
        }, "values");
    sn.Arguments = sn.Array, Fr("keys"), Fr("values"), Fr("entries");
    var hi = String.fromCharCode,
        fi = String.fromCodePoint,
        di = !!fi && 1 != fi.length;
    Fe({
        target: "String",
        stat: !0,
        forced: di
    }, {
        fromCodePoint: function (e) {
            for (var t, n = [], r = arguments.length, a = 0; r > a;) {
                if (t = +arguments[a++], he(t, 1114111) !== t) throw RangeError(t + " is not a valid code point");
                n.push(t < 65536 ? hi(t) : hi(55296 + ((t -= 65536) >> 10), t % 1024 + 56320))
            }
            return n.join("")
        }
    }), Fe({
        target: "String",
        stat: !0
    }, {
        raw: function (e) {
            for (var t = v(e.raw), n = le(t.length), r = arguments.length, a = [], i = 0; n > i;) a.push(String(t[i++])), i < r && a.push(String(arguments[i]));
            return a.join("")
        }
    });
    var mi = function (e) {
            return function (t, n) {
                var r, a, i = String(m(t)),
                    o = se(n),
                    s = i.length;
                return o < 0 || o >= s ? e ? "" : void 0 : (r = i.charCodeAt(o)) < 55296 || r > 56319 || o + 1 === s || (a = i.charCodeAt(o + 1)) < 56320 || a > 57343 ? e ? i.charAt(o) : r : e ? i.slice(o, o + 2) : a - 56320 + (r - 55296 << 10) + 65536
            }
        },
        vi = {
            codeAt: mi(!1),
            charAt: mi(!0)
        },
        gi = vi.codeAt;
    Fe({
        target: "String",
        proto: !0
    }, {
        codePointAt: function (e) {
            return gi(this, e)
        }
    });
    var yi, bi = Ze("match"),
        xi = function (e) {
            var t;
            return g(e) && (void 0 !== (t = e[bi]) ? !!t : "RegExp" == h(e))
        },
        wi = function (e) {
            if (xi(e)) throw TypeError("The method doesn't accept regular expressions");
            return e
        },
        ki = Ze("match"),
        Ni = function (e) {
            var t = /./;
            try {
                "/./" [e](t)
            } catch (n) {
                try {
                    return t[ki] = !1, "/./" [e](t)
                } catch (e) {}
            }
            return !1
        },
        Ii = T.f,
        Si = "".endsWith,
        Ti = Math.min,
        Ci = Ni("endsWith"),
        Ei = !(Ci || (yi = Ii(String.prototype, "endsWith"), !yi || yi.writable));
    Fe({
        target: "String",
        proto: !0,
        forced: !Ei && !Ci
    }, {
        endsWith: function (e) {
            var t = String(m(this));
            wi(e);
            var n = arguments.length > 1 ? arguments[1] : void 0,
                r = le(t.length),
                a = void 0 === n ? r : Ti(le(n), r),
                i = String(e);
            return Si ? Si.call(t, i, a) : t.slice(a - i.length, a) === i
        }
    }), Fe({
        target: "String",
        proto: !0,
        forced: !Ni("includes")
    }, {
        includes: function (e) {
            return !!~String(m(this)).indexOf(wi(e), arguments.length > 1 ? arguments[1] : void 0)
        }
    });
    var Ri = function () {
        var e = C(this),
            t = "";
        return e.global && (t += "g"), e.ignoreCase && (t += "i"), e.multiline && (t += "m"), e.dotAll && (t += "s"), e.unicode && (t += "u"), e.sticky && (t += "y"), t
    };

    function Ai(e, t) {
        return RegExp(e, t)
    }
    var Fi = {
            UNSUPPORTED_Y: i(function () {
                var e = Ai("a", "y");
                return e.lastIndex = 2, null != e.exec("abcd")
            }),
            BROKEN_CARET: i(function () {
                var e = Ai("^r", "gy");
                return e.lastIndex = 2, null != e.exec("str")
            })
        },
        _i = RegExp.prototype.exec,
        Di = String.prototype.replace,
        Oi = _i,
        Mi = function () {
            var e = /a/,
                t = /b*/g;
            return _i.call(e, "a"), _i.call(t, "a"), 0 !== e.lastIndex || 0 !== t.lastIndex
        }(),
        Li = Fi.UNSUPPORTED_Y || Fi.BROKEN_CARET,
        zi = void 0 !== /()??/.exec("")[1];
    (Mi || zi || Li) && (Oi = function (e) {
        var t, n, r, a, i = this,
            o = Li && i.sticky,
            s = Ri.call(i),
            u = i.source,
            l = 0,
            c = e;
        return o && (-1 === (s = s.replace("y", "")).indexOf("g") && (s += "g"), c = String(e).slice(i.lastIndex), i.lastIndex > 0 && (!i.multiline || i.multiline && "\n" !== e[i.lastIndex - 1]) && (u = "(?: " + u + ")", c = " " + c, l++), n = new RegExp("^(?:" + u + ")", s)), zi && (n = new RegExp("^" + u + "$(?!\\s)", s)), Mi && (t = i.lastIndex), r = _i.call(o ? n : i, c), o ? r ? (r.input = r.input.slice(l), r[0] = r[0].slice(l), r.index = i.lastIndex, i.lastIndex += r[0].length) : i.lastIndex = 0 : Mi && r && (i.lastIndex = i.global ? r.index + r[0].length : t), zi && r && r.length > 1 && Di.call(r[0], n, function () {
            for (a = 1; a < arguments.length - 2; a++) void 0 === arguments[a] && (r[a] = void 0)
        }), r
    });
    var Pi = Oi;
    Fe({
        target: "RegExp",
        proto: !0,
        forced: /./.exec !== Pi
    }, {
        exec: Pi
    });
    var Bi = Ze("species"),
        Wi = !i(function () {
            var e = /./;
            return e.exec = function () {
                var e = [];
                return e.groups = {
                    a: "7"
                }, e
            }, "7" !== "".replace(e, "$<a>")
        }),
        Vi = "$0" === "a".replace(/./, "$0"),
        Ui = Ze("replace"),
        Gi = !!/./ [Ui] && "" === /./ [Ui]("a", "$0"),
        ji = !i(function () {
            var e = /(?:)/,
                t = e.exec;
            e.exec = function () {
                return t.apply(this, arguments)
            };
            var n = "ab".split(e);
            return 2 !== n.length || "a" !== n[0] || "b" !== n[1]
        }),
        Hi = function (e, t, n, r) {
            var a = Ze(e),
                o = !i(function () {
                    var t = {};
                    return t[a] = function () {
                        return 7
                    }, 7 != "" [e](t)
                }),
                s = o && !i(function () {
                    var t = !1,
                        n = /a/;
                    return "split" === e && ((n = {}).constructor = {}, n.constructor[Bi] = function () {
                        return n
                    }, n.flags = "", n[a] = /./ [a]), n.exec = function () {
                        return t = !0, null
                    }, n[a](""), !t
                });
            if (!o || !s || "replace" === e && (!Wi || !Vi || Gi) || "split" === e && !ji) {
                var u = /./ [a],
                    l = n(a, "" [e], function (e, t, n, r, a) {
                        return t.exec === Pi ? o && !a ? {
                            done: !0,
                            value: u.call(t, n, r)
                        } : {
                            done: !0,
                            value: e.call(n, t, r)
                        } : {
                            done: !1
                        }
                    }, {
                        REPLACE_KEEPS_$0: Vi,
                        REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: Gi
                    }),
                    c = l[0],
                    p = l[1];
                te(String.prototype, e, c), te(RegExp.prototype, a, 2 == t ? function (e, t) {
                    return p.call(e, this, t)
                } : function (e) {
                    return p.call(e, this)
                })
            }
            r && A(RegExp.prototype[a], "sham", !0)
        },
        qi = vi.charAt,
        Ki = function (e, t, n) {
            return t + (n ? qi(e, t).length : 1)
        },
        Xi = function (e, t) {
            var n = e.exec;
            if ("function" == typeof n) {
                var r = n.call(e, t);
                if ("object" != typeof r) throw TypeError("RegExp exec method returned something other than an Object or null");
                return r
            }
            if ("RegExp" !== h(e)) throw TypeError("RegExp#exec called on incompatible receiver");
            return Pi.call(e, t)
        };
    Hi("match", 1, function (e, t, n) {
        return [function (t) {
            var n = m(this),
                r = null == t ? void 0 : t[e];
            return void 0 !== r ? r.call(t, n) : new RegExp(t)[e](String(n))
        }, function (e) {
            var r = n(t, e, this);
            if (r.done) return r.value;
            var a = C(e),
                i = String(this);
            if (!a.global) return Xi(a, i);
            var o = a.unicode;
            a.lastIndex = 0;
            for (var s, u = [], l = 0; null !== (s = Xi(a, i));) {
                var c = String(s[0]);
                u[l] = c, "" === c && (a.lastIndex = Ki(i, le(a.lastIndex), o)), l++
            }
            return 0 === l ? null : u
        }]
    });
    var Yi = Ze("species"),
        Ji = function (e, t) {
            var n, r = C(e).constructor;
            return void 0 === r || null == (n = C(r)[Yi]) ? t : at(n)
        },
        Zi = Ze("matchAll"),
        Qi = ee.set,
        $i = ee.getterFor("RegExp String Iterator"),
        eo = RegExp.prototype,
        to = eo.exec,
        no = "".matchAll,
        ro = !!no && !i(function () {
            "a".matchAll(/./)
        }),
        ao = ri(function (e, t, n, r) {
            Qi(this, {
                type: "RegExp String Iterator",
                regexp: e,
                string: t,
                global: n,
                unicode: r,
                done: !1
            })
        }, "RegExp String", function () {
            var e = $i(this);
            if (e.done) return {
                value: void 0,
                done: !0
            };
            var t = e.regexp,
                n = e.string,
                r = function (e, t) {
                    var n, r = e.exec;
                    if ("function" == typeof r) {
                        if ("object" != typeof (n = r.call(e, t))) throw TypeError("Incorrect exec result");
                        return n
                    }
                    return to.call(e, t)
                }(t, n);
            return null === r ? {
                value: void 0,
                done: e.done = !0
            } : e.global ? ("" == String(r[0]) && (t.lastIndex = Ki(n, le(t.lastIndex), e.unicode)), {
                value: r,
                done: !1
            }) : (e.done = !0, {
                value: r,
                done: !1
            })
        });
    Fe({
        target: "String",
        proto: !0,
        forced: ro
    }, {
        matchAll: function (e) {
            var t, n, r = m(this);
            if (null != e) {
                if (xi(e) && !~String(m("flags" in eo ? e.flags : Ri.call(e))).indexOf("g")) throw TypeError("`.matchAll` does not allow non-global regexes");
                if (ro) return no.apply(r, arguments);
                if (null != (n = e[Zi])) return at(n).call(e, r)
            } else if (ro) return no.apply(r, arguments);
            return t = String(r), new RegExp(e, "g")[Zi](t)
        }
    }), Zi in eo || A(eo, Zi, function (e) {
        var t, n, r, a, i, o, s = C(this),
            u = String(e);
        return t = Ji(s, RegExp), void 0 === (n = s.flags) && s instanceof RegExp && !("flags" in eo) && (n = Ri.call(s)), r = void 0 === n ? "" : String(n), a = new t(t === RegExp ? s.source : s, r), i = !!~r.indexOf("g"), o = !!~r.indexOf("u"), a.lastIndex = le(s.lastIndex), new ao(a, u, i, o)
    });
    var io = "".repeat || function (e) {
            var t = String(m(this)),
                n = "",
                r = se(e);
            if (r < 0 || r == 1 / 0) throw RangeError("Wrong number of repetitions");
            for (; r > 0;
                (r >>>= 1) && (t += t)) 1 & r && (n += t);
            return n
        },
        oo = Math.ceil,
        so = function (e) {
            return function (t, n, r) {
                var a, i, o = String(m(t)),
                    s = o.length,
                    u = void 0 === r ? " " : String(r),
                    l = le(n);
                return l <= s || "" == u ? o : (a = l - s, (i = io.call(u, oo(a / u.length))).length > a && (i = i.slice(0, a)), e ? o + i : i + o)
            }
        },
        uo = {
            start: so(!1),
            end: so(!0)
        },
        lo = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(vr),
        co = uo.end;
    Fe({
        target: "String",
        proto: !0,
        forced: lo
    }, {
        padEnd: function (e) {
            return co(this, e, arguments.length > 1 ? arguments[1] : void 0)
        }
    });
    var po = uo.start;
    Fe({
        target: "String",
        proto: !0,
        forced: lo
    }, {
        padStart: function (e) {
            return po(this, e, arguments.length > 1 ? arguments[1] : void 0)
        }
    }), Fe({
        target: "String",
        proto: !0
    }, {
        repeat: io
    });
    var ho = Math.max,
        fo = Math.min,
        mo = Math.floor,
        vo = /\$([$&'`]|\d\d?|<[^>]*>)/g,
        go = /\$([$&'`]|\d\d?)/g;
    Hi("replace", 2, function (e, t, n, r) {
        var a = r.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE,
            i = r.REPLACE_KEEPS_$0,
            o = a ? "$" : "$0";
        return [function (n, r) {
            var a = m(this),
                i = null == n ? void 0 : n[e];
            return void 0 !== i ? i.call(n, a, r) : t.call(String(a), n, r)
        }, function (e, r) {
            if (!a && i || "string" == typeof r && -1 === r.indexOf(o)) {
                var u = n(t, e, this, r);
                if (u.done) return u.value
            }
            var l = C(e),
                c = String(this),
                p = "function" == typeof r;
            p || (r = String(r));
            var h = l.global;
            if (h) {
                var f = l.unicode;
                l.lastIndex = 0
            }
            for (var d = [];;) {
                var m = Xi(l, c);
                if (null === m) break;
                if (d.push(m), !h) break;
                "" === String(m[0]) && (l.lastIndex = Ki(c, le(l.lastIndex), f))
            }
            for (var v, g = "", y = 0, b = 0; b < d.length; b++) {
                m = d[b];
                for (var x = String(m[0]), w = ho(fo(se(m.index), c.length), 0), k = [], N = 1; N < m.length; N++) k.push(void 0 === (v = m[N]) ? v : String(v));
                var I = m.groups;
                if (p) {
                    var S = [x].concat(k, w, c);
                    void 0 !== I && S.push(I);
                    var T = String(r.apply(void 0, S))
                } else T = s(x, c, w, k, I, r);
                w >= y && (g += c.slice(y, w) + T, y = w + x.length)
            }
            return g + c.slice(y)
        }];

        function s(e, n, r, a, i, o) {
            var s = r + e.length,
                u = a.length,
                l = go;
            return void 0 !== i && (i = Me(i), l = vo), t.call(o, l, function (t, o) {
                var l;
                switch (o.charAt(0)) {
                    case "$":
                        return "$";
                    case "&":
                        return e;
                    case "`":
                        return n.slice(0, r);
                    case "'":
                        return n.slice(s);
                    case "<":
                        l = i[o.slice(1, -1)];
                        break;
                    default:
                        var c = +o;
                        if (0 === c) return t;
                        if (c > u) {
                            var p = mo(c / 10);
                            return 0 === p ? t : p <= u ? void 0 === a[p - 1] ? o.charAt(1) : a[p - 1] + o.charAt(1) : t
                        }
                        l = a[c - 1]
                }
                return void 0 === l ? "" : l
            })
        }
    }), Hi("search", 1, function (e, t, n) {
        return [function (t) {
            var n = m(this),
                r = null == t ? void 0 : t[e];
            return void 0 !== r ? r.call(t, n) : new RegExp(t)[e](String(n))
        }, function (e) {
            var r = n(t, e, this);
            if (r.done) return r.value;
            var a = C(e),
                i = String(this),
                o = a.lastIndex;
            An(o, 0) || (a.lastIndex = 0);
            var s = Xi(a, i);
            return An(a.lastIndex, o) || (a.lastIndex = o), null === s ? -1 : s.index
        }]
    });
    var yo = [].push,
        bo = Math.min,
        xo = !i(function () {
            return !RegExp(4294967295, "y")
        });
    Hi("split", 2, function (e, t, n) {
        var r;
        return r = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function (e, n) {
            var r = String(m(this)),
                a = void 0 === n ? 4294967295 : n >>> 0;
            if (0 === a) return [];
            if (void 0 === e) return [r];
            if (!xi(e)) return t.call(r, e, a);
            for (var i, o, s, u = [], l = (e.ignoreCase ? "i" : "") + (e.multiline ? "m" : "") + (e.unicode ? "u" : "") + (e.sticky ? "y" : ""), c = 0, p = new RegExp(e.source, l + "g");
                (i = Pi.call(p, r)) && !((o = p.lastIndex) > c && (u.push(r.slice(c, i.index)), i.length > 1 && i.index < r.length && yo.apply(u, i.slice(1)), s = i[0].length, c = o, u.length >= a));) p.lastIndex === i.index && p.lastIndex++;
            return c === r.length ? !s && p.test("") || u.push("") : u.push(r.slice(c)), u.length > a ? u.slice(0, a) : u
        } : "0".split(void 0, 0).length ? function (e, n) {
            return void 0 === e && 0 === n ? [] : t.call(this, e, n)
        } : t, [function (t, n) {
            var a = m(this),
                i = null == t ? void 0 : t[e];
            return void 0 !== i ? i.call(t, a, n) : r.call(String(a), t, n)
        }, function (e, a) {
            var i = n(r, e, this, a, r !== t);
            if (i.done) return i.value;
            var o = C(e),
                s = String(this),
                u = Ji(o, RegExp),
                l = o.unicode,
                c = (o.ignoreCase ? "i" : "") + (o.multiline ? "m" : "") + (o.unicode ? "u" : "") + (xo ? "y" : "g"),
                p = new u(xo ? o : "^(?:" + o.source + ")", c),
                h = void 0 === a ? 4294967295 : a >>> 0;
            if (0 === h) return [];
            if (0 === s.length) return null === Xi(p, s) ? [s] : [];
            for (var f = 0, d = 0, m = []; d < s.length;) {
                p.lastIndex = xo ? d : 0;
                var v, g = Xi(p, xo ? s : s.slice(d));
                if (null === g || (v = bo(le(p.lastIndex + (xo ? 0 : d)), s.length)) === f) d = Ki(s, d, l);
                else {
                    if (m.push(s.slice(f, d)), m.length === h) return m;
                    for (var y = 1; y <= g.length - 1; y++)
                        if (m.push(g[y]), m.length === h) return m;
                    d = f = v
                }
            }
            return m.push(s.slice(f)), m
        }]
    }, !xo);
    var wo = T.f,
        ko = "".startsWith,
        No = Math.min,
        Io = Ni("startsWith"),
        So = !Io && !! function () {
            var e = wo(String.prototype, "startsWith");
            return e && !e.writable
        }();
    Fe({
        target: "String",
        proto: !0,
        forced: !So && !Io
    }, {
        startsWith: function (e) {
            var t = String(m(this));
            wi(e);
            var n = le(No(arguments.length > 1 ? arguments[1] : void 0, t.length)),
                r = String(e);
            return ko ? ko.call(t, r, n) : t.slice(n, n + r.length) === r
        }
    });
    var To = "\t\n\v\f\r  áââââââââââââ¯âã\u2028\u2029\ufeff",
        Co = "[" + To + "]",
        Eo = RegExp("^" + Co + Co + "*"),
        Ro = RegExp(Co + Co + "*$"),
        Ao = function (e) {
            return function (t) {
                var n = String(m(t));
                return 1 & e && (n = n.replace(Eo, "")), 2 & e && (n = n.replace(Ro, "")), n
            }
        },
        Fo = {
            start: Ao(1),
            end: Ao(2),
            trim: Ao(3)
        },
        _o = function (e) {
            return i(function () {
                return !!To[e]() || "âÂá " != "âÂá " [e]() || To[e].name !== e
            })
        },
        Do = Fo.trim;
    Fe({
        target: "String",
        proto: !0,
        forced: _o("trim")
    }, {
        trim: function () {
            return Do(this)
        }
    });
    var Oo = Fo.start,
        Mo = _o("trimStart"),
        Lo = Mo ? function () {
            return Oo(this)
        } : "".trimStart;
    Fe({
        target: "String",
        proto: !0,
        forced: Mo
    }, {
        trimStart: Lo,
        trimLeft: Lo
    });
    var zo = Fo.end,
        Po = _o("trimEnd"),
        Bo = Po ? function () {
            return zo(this)
        } : "".trimEnd;
    Fe({
        target: "String",
        proto: !0,
        forced: Po
    }, {
        trimEnd: Bo,
        trimRight: Bo
    });
    var Wo = vi.charAt,
        Vo = ee.set,
        Uo = ee.getterFor("String Iterator");
    ui(String, "String", function (e) {
        Vo(this, {
            type: "String Iterator",
            string: String(e),
            index: 0
        })
    }, function () {
        var e, t = Uo(this),
            n = t.string,
            r = t.index;
        return r >= n.length ? {
            value: void 0,
            done: !0
        } : (e = Wo(n, r), t.index += e.length, {
            value: e,
            done: !1
        })
    });
    var Go = /"/g,
        jo = function (e, t, n, r) {
            var a = String(m(e)),
                i = "<" + t;
            return "" !== n && (i += " " + n + '="' + String(r).replace(Go, "&quot;") + '"'), i + ">" + a + "</" + t + ">"
        },
        Ho = function (e) {
            return i(function () {
                var t = "" [e]('"');
                return t !== t.toLowerCase() || t.split('"').length > 3
            })
        };
    Fe({
        target: "String",
        proto: !0,
        forced: Ho("anchor")
    }, {
        anchor: function (e) {
            return jo(this, "a", "name", e)
        }
    }), Fe({
        target: "String",
        proto: !0,
        forced: Ho("big")
    }, {
        big: function () {
            return jo(this, "big", "", "")
        }
    }), Fe({
        target: "String",
        proto: !0,
        forced: Ho("blink")
    }, {
        blink: function () {
            return jo(this, "blink", "", "")
        }
    }), Fe({
        target: "String",
        proto: !0,
        forced: Ho("bold")
    }, {
        bold: function () {
            return jo(this, "b", "", "")
        }
    }), Fe({
        target: "String",
        proto: !0,
        forced: Ho("fixed")
    }, {
        fixed: function () {
            return jo(this, "tt", "", "")
        }
    }), Fe({
        target: "String",
        proto: !0,
        forced: Ho("fontcolor")
    }, {
        fontcolor: function (e) {
            return jo(this, "font", "color", e)
        }
    }), Fe({
        target: "String",
        proto: !0,
        forced: Ho("fontsize")
    }, {
        fontsize: function (e) {
            return jo(this, "font", "size", e)
        }
    }), Fe({
        target: "String",
        proto: !0,
        forced: Ho("italics")
    }, {
        italics: function () {
            return jo(this, "i", "", "")
        }
    }), Fe({
        target: "String",
        proto: !0,
        forced: Ho("link")
    }, {
        link: function (e) {
            return jo(this, "a", "href", e)
        }
    }), Fe({
        target: "String",
        proto: !0,
        forced: Ho("small")
    }, {
        small: function () {
            return jo(this, "small", "", "")
        }
    }), Fe({
        target: "String",
        proto: !0,
        forced: Ho("strike")
    }, {
        strike: function () {
            return jo(this, "strike", "", "")
        }
    }), Fe({
        target: "String",
        proto: !0,
        forced: Ho("sub")
    }, {
        sub: function () {
            return jo(this, "sub", "", "")
        }
    }), Fe({
        target: "String",
        proto: !0,
        forced: Ho("sup")
    }, {
        sup: function () {
            return jo(this, "sup", "", "")
        }
    });
    var qo = function (e, t, n) {
            var r, a;
            return Hn && "function" == typeof (r = t.constructor) && r !== n && g(a = r.prototype) && a !== n.prototype && Hn(e, a), e
        },
        Ko = R.f,
        Xo = be.f,
        Yo = ee.set,
        Jo = Ze("match"),
        Zo = a.RegExp,
        Qo = Zo.prototype,
        $o = /a/g,
        es = /a/g,
        ts = new Zo($o) !== $o,
        ns = Fi.UNSUPPORTED_Y;
    if (o && Re("RegExp", !ts || ns || i(function () {
            return es[Jo] = !1, Zo($o) != $o || Zo(es) == es || "/a/i" != Zo($o, "i")
        }))) {
        for (var rs = function (e, t) {
                var n, r = this instanceof rs,
                    a = xi(e),
                    i = void 0 === t;
                if (!r && a && e.constructor === rs && i) return e;
                ts ? a && !i && (e = e.source) : e instanceof rs && (i && (t = Ri.call(e)), e = e.source), ns && (n = !!t && t.indexOf("y") > -1) && (t = t.replace(/y/g, ""));
                var o = qo(ts ? new Zo(e, t) : Zo(e, t), r ? this : Qo, rs);
                return ns && n && Yo(o, {
                    sticky: n
                }), o
            }, as = function (e) {
                e in rs || Ko(rs, e, {
                    configurable: !0,
                    get: function () {
                        return Zo[e]
                    },
                    set: function (t) {
                        Zo[e] = t
                    }
                })
            }, is = Xo(Zo), os = 0; is.length > os;) as(is[os++]);
        Qo.constructor = rs, rs.prototype = Qo, te(a, "RegExp", rs)
    }
    Xa("RegExp"), o && ("g" != /./g.flags || Fi.UNSUPPORTED_Y) && R.f(RegExp.prototype, "flags", {
        configurable: !0,
        get: Ri
    });
    var ss = Fi.UNSUPPORTED_Y,
        us = R.f,
        ls = ee.get,
        cs = RegExp.prototype;
    o && ss && us(RegExp.prototype, "sticky", {
        configurable: !0,
        get: function () {
            if (this !== cs) {
                if (this instanceof RegExp) return !!ls(this).sticky;
                throw TypeError("Incompatible receiver, RegExp required")
            }
        }
    });
    var ps = function () {
            var e = !1,
                t = /[ac]/;
            return t.exec = function () {
                return e = !0, /./.exec.apply(this, arguments)
            }, !0 === t.test("abc") && e
        }(),
        hs = /./.test;
    Fe({
        target: "RegExp",
        proto: !0,
        forced: !ps
    }, {
        test: function (e) {
            if ("function" != typeof this.exec) return hs.call(this, e);
            var t = this.exec(e);
            if (null !== t && !g(t)) throw new Error("RegExp exec method returned something other than an Object or null");
            return !!t
        }
    });
    var fs = RegExp.prototype,
        ds = fs.toString,
        ms = i(function () {
            return "/a/b" != ds.call({
                source: "a",
                flags: "b"
            })
        }),
        vs = "toString" != ds.name;
    (ms || vs) && te(RegExp.prototype, "toString", function () {
        var e = C(this),
            t = String(e.source),
            n = e.flags;
        return "/" + t + "/" + String(void 0 === n && e instanceof RegExp && !("flags" in fs) ? Ri.call(e) : n)
    }, {
        unsafe: !0
    });
    var gs = Fo.trim,
        ys = a.parseInt,
        bs = /^[+-]?0[Xx]/,
        xs = 8 !== ys(To + "08") || 22 !== ys(To + "0x16") ? function (e, t) {
            var n = gs(String(e));
            return ys(n, t >>> 0 || (bs.test(n) ? 16 : 10))
        } : ys;
    Fe({
        global: !0,
        forced: parseInt != xs
    }, {
        parseInt: xs
    });
    var ws = Fo.trim,
        ks = a.parseFloat,
        Ns = 1 / ks(To + "-0") != -1 / 0 ? function (e) {
            var t = ws(String(e)),
                n = ks(t);
            return 0 === n && "-" == t.charAt(0) ? -0 : n
        } : ks;
    Fe({
        global: !0,
        forced: parseFloat != Ns
    }, {
        parseFloat: Ns
    });
    var Is = be.f,
        Ss = T.f,
        Ts = R.f,
        Cs = Fo.trim,
        Es = a.Number,
        Rs = Es.prototype,
        As = "Number" == h(Ge(Rs)),
        Fs = function (e) {
            var t, n, r, a, i, o, s, u, l = y(e, !1);
            if ("string" == typeof l && l.length > 2)
                if (43 === (t = (l = Cs(l)).charCodeAt(0)) || 45 === t) {
                    if (88 === (n = l.charCodeAt(2)) || 120 === n) return NaN
                } else if (48 === t) {
                switch (l.charCodeAt(1)) {
                    case 66:
                    case 98:
                        r = 2, a = 49;
                        break;
                    case 79:
                    case 111:
                        r = 8, a = 55;
                        break;
                    default:
                        return +l
                }
                for (o = (i = l.slice(2)).length, s = 0; s < o; s++)
                    if ((u = i.charCodeAt(s)) < 48 || u > a) return NaN;
                return parseInt(i, r)
            }
            return +l
        };
    if (Re("Number", !Es(" 0o1") || !Es("0b1") || Es("+0x1"))) {
        for (var _s, Ds = function (e) {
                var t = arguments.length < 1 ? 0 : e,
                    n = this;
                return n instanceof Ds && (As ? i(function () {
                    Rs.valueOf.call(n)
                }) : "Number" != h(n)) ? qo(new Es(Fs(t)), n, Ds) : Fs(t)
            }, Os = o ? Is(Es) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","), Ms = 0; Os.length > Ms; Ms++) x(Es, _s = Os[Ms]) && !x(Ds, _s) && Ts(Ds, _s, Ss(Es, _s));
        Ds.prototype = Rs, Rs.constructor = Ds, te(a, "Number", Ds)
    }
    Fe({
        target: "Number",
        stat: !0
    }, {
        EPSILON: Math.pow(2, -52)
    });
    var Ls = a.isFinite,
        zs = Number.isFinite || function (e) {
            return "number" == typeof e && Ls(e)
        };
    Fe({
        target: "Number",
        stat: !0
    }, {
        isFinite: zs
    });
    var Ps = Math.floor,
        Bs = function (e) {
            return !g(e) && isFinite(e) && Ps(e) === e
        };
    Fe({
        target: "Number",
        stat: !0
    }, {
        isInteger: Bs
    }), Fe({
        target: "Number",
        stat: !0
    }, {
        isNaN: function (e) {
            return e != e
        }
    });
    var Ws = Math.abs;
    Fe({
        target: "Number",
        stat: !0
    }, {
        isSafeInteger: function (e) {
            return Bs(e) && Ws(e) <= 9007199254740991
        }
    }), Fe({
        target: "Number",
        stat: !0
    }, {
        MAX_SAFE_INTEGER: 9007199254740991
    }), Fe({
        target: "Number",
        stat: !0
    }, {
        MIN_SAFE_INTEGER: -9007199254740991
    }), Fe({
        target: "Number",
        stat: !0,
        forced: Number.parseFloat != Ns
    }, {
        parseFloat: Ns
    }), Fe({
        target: "Number",
        stat: !0,
        forced: Number.parseInt != xs
    }, {
        parseInt: xs
    });
    var Vs = function (e) {
            if ("number" != typeof e && "Number" != h(e)) throw TypeError("Incorrect invocation");
            return +e
        },
        Us = 1..toFixed,
        Gs = Math.floor,
        js = function e(t, n, r) {
            return 0 === n ? r : n % 2 == 1 ? e(t, n - 1, r * t) : e(t * t, n / 2, r)
        },
        Hs = Us && ("0.000" !== 8e-5.toFixed(3) || "1" !== .9.toFixed(0) || "1.25" !== 1.255.toFixed(2) || "1000000000000000128" !== (0xde0b6b3a7640080).toFixed(0)) || !i(function () {
            Us.call({})
        });
    Fe({
        target: "Number",
        proto: !0,
        forced: Hs
    }, {
        toFixed: function (e) {
            var t, n, r, a, i = Vs(this),
                o = se(e),
                s = [0, 0, 0, 0, 0, 0],
                u = "",
                l = "0",
                c = function (e, t) {
                    for (var n = -1, r = t; ++n < 6;) r += e * s[n], s[n] = r % 1e7, r = Gs(r / 1e7)
                },
                p = function (e) {
                    for (var t = 6, n = 0; --t >= 0;) n += s[t], s[t] = Gs(n / e), n = n % e * 1e7
                },
                h = function () {
                    for (var e = 6, t = ""; --e >= 0;)
                        if ("" !== t || 0 === e || 0 !== s[e]) {
                            var n = String(s[e]);
                            t = "" === t ? n : t + io.call("0", 7 - n.length) + n
                        } return t
                };
            if (o < 0 || o > 20) throw RangeError("Incorrect fraction digits");
            if (i != i) return "NaN";
            if (i <= -1e21 || i >= 1e21) return String(i);
            if (i < 0 && (u = "-", i = -i), i > 1e-21)
                if (n = (t = function (e) {
                        for (var t = 0, n = i * js(2, 69, 1); n >= 4096;) t += 12, n /= 4096;
                        for (; n >= 2;) t += 1, n /= 2;
                        return t
                    }() - 69) < 0 ? i * js(2, -t, 1) : i / js(2, t, 1), n *= 4503599627370496, (t = 52 - t) > 0) {
                    for (c(0, n), r = o; r >= 7;) c(1e7, 0), r -= 7;
                    for (c(js(10, r, 1), 0), r = t - 1; r >= 23;) p(1 << 23), r -= 23;
                    p(1 << r), c(1, 1), p(2), l = h()
                } else c(0, n), c(1 << -t, 0), l = h() + io.call("0", o);
            return o > 0 ? u + ((a = l.length) <= o ? "0." + io.call("0", o - a) + l : l.slice(0, a - o) + "." + l.slice(a - o)) : u + l
        }
    });
    var qs = 1..toPrecision,
        Ks = i(function () {
            return "1" !== qs.call(1, void 0)
        }) || !i(function () {
            qs.call({})
        });
    Fe({
        target: "Number",
        proto: !0,
        forced: Ks
    }, {
        toPrecision: function (e) {
            return void 0 === e ? qs.call(Vs(this)) : qs.call(Vs(this), e)
        }
    });
    var Xs = Math.log,
        Ys = Math.log1p || function (e) {
            return (e = +e) > -1e-8 && e < 1e-8 ? e - e * e / 2 : Xs(1 + e)
        },
        Js = Math.acosh,
        Zs = Math.log,
        Qs = Math.sqrt,
        $s = Math.LN2,
        eu = !Js || 710 != Math.floor(Js(Number.MAX_VALUE)) || Js(1 / 0) != 1 / 0;
    Fe({
        target: "Math",
        stat: !0,
        forced: eu
    }, {
        acosh: function (e) {
            return (e = +e) < 1 ? NaN : e > 94906265.62425156 ? Zs(e) + $s : Ys(e - 1 + Qs(e - 1) * Qs(e + 1))
        }
    });
    var tu = Math.asinh,
        nu = Math.log,
        ru = Math.sqrt;
    Fe({
        target: "Math",
        stat: !0,
        forced: !(tu && 1 / tu(0) > 0)
    }, {
        asinh: function e(t) {
            return isFinite(t = +t) && 0 != t ? t < 0 ? -e(-t) : nu(t + ru(t * t + 1)) : t
        }
    });
    var au = Math.atanh,
        iu = Math.log;
    Fe({
        target: "Math",
        stat: !0,
        forced: !(au && 1 / au(-0) < 0)
    }, {
        atanh: function (e) {
            return 0 == (e = +e) ? e : iu((1 + e) / (1 - e)) / 2
        }
    });
    var ou = Math.sign || function (e) {
            return 0 == (e = +e) || e != e ? e : e < 0 ? -1 : 1
        },
        su = Math.abs,
        uu = Math.pow;
    Fe({
        target: "Math",
        stat: !0
    }, {
        cbrt: function (e) {
            return ou(e = +e) * uu(su(e), 1 / 3)
        }
    });
    var lu = Math.floor,
        cu = Math.log,
        pu = Math.LOG2E;
    Fe({
        target: "Math",
        stat: !0
    }, {
        clz32: function (e) {
            return (e >>>= 0) ? 31 - lu(cu(e + .5) * pu) : 32
        }
    });
    var hu = Math.expm1,
        fu = Math.exp,
        du = !hu || hu(10) > 22025.465794806718 || hu(10) < 22025.465794806718 || -2e-17 != hu(-2e-17) ? function (e) {
            return 0 == (e = +e) ? e : e > -1e-6 && e < 1e-6 ? e + e * e / 2 : fu(e) - 1
        } : hu,
        mu = Math.cosh,
        vu = Math.abs,
        gu = Math.E;
    Fe({
        target: "Math",
        stat: !0,
        forced: !mu || mu(710) === 1 / 0
    }, {
        cosh: function (e) {
            var t = du(vu(e) - 1) + 1;
            return (t + 1 / (t * gu * gu)) * (gu / 2)
        }
    }), Fe({
        target: "Math",
        stat: !0,
        forced: du != Math.expm1
    }, {
        expm1: du
    });
    var yu = Math.abs,
        bu = Math.pow,
        xu = bu(2, -52),
        wu = bu(2, -23),
        ku = bu(2, 127) * (2 - wu),
        Nu = bu(2, -126),
        Iu = Math.fround || function (e) {
            var t, n, r = yu(e),
                a = ou(e);
            return r < Nu ? a * (r / Nu / wu + 1 / xu - 1 / xu) * Nu * wu : (n = (t = (1 + wu / xu) * r) - (t - r)) > ku || n != n ? a * (1 / 0) : a * n
        };
    Fe({
        target: "Math",
        stat: !0
    }, {
        fround: Iu
    });
    var Su = Math.hypot,
        Tu = Math.abs,
        Cu = Math.sqrt,
        Eu = !!Su && Su(1 / 0, NaN) !== 1 / 0;
    Fe({
        target: "Math",
        stat: !0,
        forced: Eu
    }, {
        hypot: function (e, t) {
            for (var n, r, a = 0, i = 0, o = arguments.length, s = 0; i < o;) s < (n = Tu(arguments[i++])) ? (a = a * (r = s / n) * r + 1, s = n) : a += n > 0 ? (r = n / s) * r : n;
            return s === 1 / 0 ? 1 / 0 : s * Cu(a)
        }
    });
    var Ru = Math.imul,
        Au = i(function () {
            return -5 != Ru(4294967295, 5) || 2 != Ru.length
        });
    Fe({
        target: "Math",
        stat: !0,
        forced: Au
    }, {
        imul: function (e, t) {
            var n = +e,
                r = +t,
                a = 65535 & n,
                i = 65535 & r;
            return 0 | a * i + ((65535 & n >>> 16) * i + a * (65535 & r >>> 16) << 16 >>> 0)
        }
    });
    var Fu = Math.log,
        _u = Math.LOG10E;
    Fe({
        target: "Math",
        stat: !0
    }, {
        log10: function (e) {
            return Fu(e) * _u
        }
    }), Fe({
        target: "Math",
        stat: !0
    }, {
        log1p: Ys
    });
    var Du = Math.log,
        Ou = Math.LN2;
    Fe({
        target: "Math",
        stat: !0
    }, {
        log2: function (e) {
            return Du(e) / Ou
        }
    }), Fe({
        target: "Math",
        stat: !0
    }, {
        sign: ou
    });
    var Mu = Math.abs,
        Lu = Math.exp,
        zu = Math.E,
        Pu = i(function () {
            return -2e-17 != Math.sinh(-2e-17)
        });
    Fe({
        target: "Math",
        stat: !0,
        forced: Pu
    }, {
        sinh: function (e) {
            return Mu(e = +e) < 1 ? (du(e) - du(-e)) / 2 : (Lu(e - 1) - Lu(-e - 1)) * (zu / 2)
        }
    });
    var Bu = Math.exp;
    Fe({
        target: "Math",
        stat: !0
    }, {
        tanh: function (e) {
            var t = du(e = +e),
                n = du(-e);
            return t == 1 / 0 ? 1 : n == 1 / 0 ? -1 : (t - n) / (Bu(e) + Bu(-e))
        }
    }), rt(Math, "Math", !0);
    var Wu = Math.ceil,
        Vu = Math.floor;
    Fe({
        target: "Math",
        stat: !0
    }, {
        trunc: function (e) {
            return (e > 0 ? Vu : Wu)(e)
        }
    }), Fe({
        target: "Date",
        stat: !0
    }, {
        now: function () {
            return (new Date).getTime()
        }
    });
    var Uu = i(function () {
        return null !== new Date(NaN).toJSON() || 1 !== Date.prototype.toJSON.call({
            toISOString: function () {
                return 1
            }
        })
    });
    Fe({
        target: "Date",
        proto: !0,
        forced: Uu
    }, {
        toJSON: function (e) {
            var t = Me(this),
                n = y(t);
            return "number" != typeof n || isFinite(n) ? t.toISOString() : null
        }
    });
    var Gu = uo.start,
        ju = Math.abs,
        Hu = Date.prototype,
        qu = Hu.getTime,
        Ku = Hu.toISOString,
        Xu = i(function () {
            return "0385-07-25T07:06:39.999Z" != Ku.call(new Date(-50000000000001))
        }) || !i(function () {
            Ku.call(new Date(NaN))
        }) ? function () {
            if (!isFinite(qu.call(this))) throw RangeError("Invalid time value");
            var e = this.getUTCFullYear(),
                t = this.getUTCMilliseconds(),
                n = e < 0 ? "-" : e > 9999 ? "+" : "";
            return n + Gu(ju(e), n ? 6 : 4, 0) + "-" + Gu(this.getUTCMonth() + 1, 2, 0) + "-" + Gu(this.getUTCDate(), 2, 0) + "T" + Gu(this.getUTCHours(), 2, 0) + ":" + Gu(this.getUTCMinutes(), 2, 0) + ":" + Gu(this.getUTCSeconds(), 2, 0) + "." + Gu(t, 3, 0) + "Z"
        } : Ku;
    Fe({
        target: "Date",
        proto: !0,
        forced: Date.prototype.toISOString !== Xu
    }, {
        toISOString: Xu
    });
    var Yu = Date.prototype,
        Ju = Yu.toString,
        Zu = Yu.getTime;
    new Date(NaN) + "" != "Invalid Date" && te(Yu, "toString", function () {
        var e = Zu.call(this);
        return e == e ? Ju.call(this) : "Invalid Date"
    });
    var Qu = Ze("toPrimitive"),
        $u = Date.prototype;
    Qu in $u || A($u, Qu, function (e) {
        if ("string" !== e && "number" !== e && "default" !== e) throw TypeError("Incorrect hint");
        return y(C(this), "number" !== e)
    });
    var el = ae("JSON", "stringify"),
        tl = /[\uD800-\uDFFF]/g,
        nl = /^[\uD800-\uDBFF]$/,
        rl = /^[\uDC00-\uDFFF]$/,
        al = function (e, t, n) {
            var r = n.charAt(t - 1),
                a = n.charAt(t + 1);
            return nl.test(e) && !rl.test(a) || rl.test(e) && !nl.test(r) ? "\\u" + e.charCodeAt(0).toString(16) : e
        },
        il = i(function () {
            return '"\\udf06\\ud834"' !== el("\udf06\ud834") || '"\\udead"' !== el("\udead")
        });
    el && Fe({
        target: "JSON",
        stat: !0,
        forced: il
    }, {
        stringify: function (e, t, n) {
            var r = el.apply(null, arguments);
            return "string" == typeof r ? r.replace(tl, al) : r
        }
    }), rt(a.JSON, "JSON", !0);
    var ol, sl, ul, ll = a.Promise,
        cl = function (e, t, n) {
            for (var r in t) te(e, r, t[r], n);
            return e
        },
        pl = function (e, t, n) {
            if (!(e instanceof t)) throw TypeError("Incorrect " + (n ? n + " " : "") + "invocation");
            return e
        },
        hl = /(iphone|ipod|ipad).*applewebkit/i.test(vr),
        fl = a.location,
        dl = a.setImmediate,
        ml = a.clearImmediate,
        vl = a.process,
        gl = a.MessageChannel,
        yl = a.Dispatch,
        bl = 0,
        xl = {},
        wl = function (e) {
            if (xl.hasOwnProperty(e)) {
                var t = xl[e];
                delete xl[e], t()
            }
        },
        kl = function (e) {
            return function () {
                wl(e)
            }
        },
        Nl = function (e) {
            wl(e.data)
        },
        Il = function (e) {
            a.postMessage(e + "", fl.protocol + "//" + fl.host)
        };
    dl && ml || (dl = function (e) {
        for (var t = [], n = 1; arguments.length > n;) t.push(arguments[n++]);
        return xl[++bl] = function () {
            ("function" == typeof e ? e : Function(e)).apply(void 0, t)
        }, ol(bl), bl
    }, ml = function (e) {
        delete xl[e]
    }, "process" == h(vl) ? ol = function (e) {
        vl.nextTick(kl(e))
    } : yl && yl.now ? ol = function (e) {
        yl.now(kl(e))
    } : gl && !hl ? (ul = (sl = new gl).port2, sl.port1.onmessage = Nl, ol = it(ul.postMessage, ul, 1)) : !a.addEventListener || "function" != typeof postMessage || a.importScripts || i(Il) || "file:" === fl.protocol ? ol = "onreadystatechange" in N("script") ? function (e) {
        Pe.appendChild(N("script")).onreadystatechange = function () {
            Pe.removeChild(this), wl(e)
        }
    } : function (e) {
        setTimeout(kl(e), 0)
    } : (ol = Il, a.addEventListener("message", Nl, !1)));
    var Sl, Tl, Cl, El, Rl, Al, Fl, _l, Dl = {
            set: dl,
            clear: ml
        },
        Ol = T.f,
        Ml = Dl.set,
        Ll = a.MutationObserver || a.WebKitMutationObserver,
        zl = a.process,
        Pl = a.Promise,
        Bl = "process" == h(zl),
        Wl = Ol(a, "queueMicrotask"),
        Vl = Wl && Wl.value;
    Vl || (Sl = function () {
        var e, t;
        for (Bl && (e = zl.domain) && e.exit(); Tl;) {
            t = Tl.fn, Tl = Tl.next;
            try {
                t()
            } catch (e) {
                throw Tl ? El() : Cl = void 0, e
            }
        }
        Cl = void 0, e && e.enter()
    }, Bl ? El = function () {
        zl.nextTick(Sl)
    } : Ll && !hl ? (Rl = !0, Al = document.createTextNode(""), new Ll(Sl).observe(Al, {
        characterData: !0
    }), El = function () {
        Al.data = Rl = !Rl
    }) : Pl && Pl.resolve ? (Fl = Pl.resolve(void 0), _l = Fl.then, El = function () {
        _l.call(Fl, Sl)
    }) : El = function () {
        Ml.call(a, Sl)
    });
    var Ul, Gl, jl, Hl, ql = Vl || function (e) {
            var t = {
                fn: e,
                next: void 0
            };
            Cl && (Cl.next = t), Tl || (Tl = t, El()), Cl = t
        },
        Kl = function (e) {
            var t, n;
            this.promise = new e(function (e, r) {
                if (void 0 !== t || void 0 !== n) throw TypeError("Bad Promise constructor");
                t = e, n = r
            }), this.resolve = at(t), this.reject = at(n)
        },
        Xl = {
            f: function (e) {
                return new Kl(e)
            }
        },
        Yl = function (e, t) {
            if (C(e), g(t) && t.constructor === e) return t;
            var n = Xl.f(e);
            return (0, n.resolve)(t), n.promise
        },
        Jl = function (e) {
            try {
                return {
                    error: !1,
                    value: e()
                }
            } catch (e) {
                return {
                    error: !0,
                    value: e
                }
            }
        },
        Zl = Dl.set,
        Ql = Ze("species"),
        $l = "Promise",
        ec = ee.get,
        tc = ee.set,
        nc = ee.getterFor($l),
        rc = ll,
        ac = a.TypeError,
        ic = a.document,
        oc = a.process,
        sc = ae("fetch"),
        uc = Xl.f,
        lc = uc,
        cc = "process" == h(oc),
        pc = !!(ic && ic.createEvent && a.dispatchEvent),
        hc = Re($l, function () {
            if (z(rc) === String(rc)) {
                if (66 === xr) return !0;
                if (!cc && "function" != typeof PromiseRejectionEvent) return !0
            }
            if (xr >= 51 && /native code/.test(rc)) return !1;
            var e = rc.resolve(1),
                t = function (e) {
                    e(function () {}, function () {})
                };
            return (e.constructor = {})[Ql] = t, !(e.then(function () {}) instanceof t)
        }),
        fc = hc || !pr(function (e) {
            rc.all(e).catch(function () {})
        }),
        dc = function (e) {
            var t;
            return !(!g(e) || "function" != typeof (t = e.then)) && t
        },
        mc = function (e, t, n) {
            if (!t.notified) {
                t.notified = !0;
                var r = t.reactions;
                ql(function () {
                    for (var a = t.value, i = 1 == t.state, o = 0; r.length > o;) {
                        var s, u, l, c = r[o++],
                            p = i ? c.ok : c.fail,
                            h = c.resolve,
                            f = c.reject,
                            d = c.domain;
                        try {
                            p ? (i || (2 === t.rejection && bc(e, t), t.rejection = 1), !0 === p ? s = a : (d && d.enter(), s = p(a), d && (d.exit(), l = !0)), s === c.promise ? f(ac("Promise-chain cycle")) : (u = dc(s)) ? u.call(s, h, f) : h(s)) : f(a)
                        } catch (e) {
                            d && !l && d.exit(), f(e)
                        }
                    }
                    t.reactions = [], t.notified = !1, n && !t.rejection && gc(e, t)
                })
            }
        },
        vc = function (e, t, n) {
            var r, i;
            pc ? ((r = ic.createEvent("Event")).promise = t, r.reason = n, r.initEvent(e, !1, !0), a.dispatchEvent(r)) : r = {
                promise: t,
                reason: n
            }, (i = a["on" + e]) ? i(r) : "unhandledrejection" === e && function (e, t) {
                var n = a.console;
                n && n.error && (1 === arguments.length ? n.error(e) : n.error(e, t))
            }("Unhandled promise rejection", n)
        },
        gc = function (e, t) {
            Zl.call(a, function () {
                var n, r = t.value;
                if (yc(t) && (n = Jl(function () {
                        cc ? oc.emit("unhandledRejection", r, e) : vc("unhandledrejection", e, r)
                    }), t.rejection = cc || yc(t) ? 2 : 1, n.error)) throw n.value
            })
        },
        yc = function (e) {
            return 1 !== e.rejection && !e.parent
        },
        bc = function (e, t) {
            Zl.call(a, function () {
                cc ? oc.emit("rejectionHandled", e) : vc("rejectionhandled", e, t.value)
            })
        },
        xc = function (e, t, n, r) {
            return function (a) {
                e(t, n, a, r)
            }
        },
        wc = function (e, t, n, r) {
            t.done || (t.done = !0, r && (t = r), t.value = n, t.state = 2, mc(e, t, !0))
        },
        kc = function e(t, n, r, a) {
            if (!n.done) {
                n.done = !0, a && (n = a);
                try {
                    if (t === r) throw ac("Promise can't be resolved itself");
                    var i = dc(r);
                    i ? ql(function () {
                        var a = {
                            done: !1
                        };
                        try {
                            i.call(r, xc(e, t, a, n), xc(wc, t, a, n))
                        } catch (e) {
                            wc(t, a, e, n)
                        }
                    }) : (n.value = r, n.state = 1, mc(t, n, !1))
                } catch (e) {
                    wc(t, {
                        done: !1
                    }, e, n)
                }
            }
        };
    hc && (rc = function (e) {
        pl(this, rc, $l), at(e), Ul.call(this);
        var t = ec(this);
        try {
            e(xc(kc, this, t), xc(wc, this, t))
        } catch (e) {
            wc(this, t, e)
        }
    }, (Ul = function (e) {
        tc(this, {
            type: $l,
            done: !1,
            notified: !1,
            parent: !1,
            reactions: [],
            rejection: !1,
            state: 0,
            value: void 0
        })
    }).prototype = cl(rc.prototype, {
        then: function (e, t) {
            var n = nc(this),
                r = uc(Ji(this, rc));
            return r.ok = "function" != typeof e || e, r.fail = "function" == typeof t && t, r.domain = cc ? oc.domain : void 0, n.parent = !0, n.reactions.push(r), 0 != n.state && mc(this, n, !1), r.promise
        },
        catch: function (e) {
            return this.then(void 0, e)
        }
    }), Gl = function () {
        var e = new Ul,
            t = ec(e);
        this.promise = e, this.resolve = xc(kc, e, t), this.reject = xc(wc, e, t)
    }, Xl.f = uc = function (e) {
        return e === rc || e === jl ? new Gl(e) : lc(e)
    }, "function" == typeof ll && (Hl = ll.prototype.then, te(ll.prototype, "then", function (e, t) {
        var n = this;
        return new rc(function (e, t) {
            Hl.call(n, e, t)
        }).then(e, t)
    }, {
        unsafe: !0
    }), "function" == typeof sc && Fe({
        global: !0,
        enumerable: !0,
        forced: !0
    }, {
        fetch: function (e) {
            return Yl(rc, sc.apply(a, arguments))
        }
    }))), Fe({
        global: !0,
        wrap: !0,
        forced: hc
    }, {
        Promise: rc
    }), rt(rc, $l, !1), Xa($l), jl = ae($l), Fe({
        target: $l,
        stat: !0,
        forced: hc
    }, {
        reject: function (e) {
            var t = uc(this);
            return t.reject.call(void 0, e), t.promise
        }
    }), Fe({
        target: $l,
        stat: !0,
        forced: hc
    }, {
        resolve: function (e) {
            return Yl(this, e)
        }
    }), Fe({
        target: $l,
        stat: !0,
        forced: fc
    }, {
        all: function (e) {
            var t = this,
                n = uc(t),
                r = n.resolve,
                a = n.reject,
                i = Jl(function () {
                    var n = at(t.resolve),
                        i = [],
                        o = 0,
                        s = 1;
                    bn(e, function (e) {
                        var u = o++,
                            l = !1;
                        i.push(void 0), s++, n.call(t, e).then(function (e) {
                            l || (l = !0, i[u] = e, --s || r(i))
                        }, a)
                    }), --s || r(i)
                });
            return i.error && a(i.value), n.promise
        },
        race: function (e) {
            var t = this,
                n = uc(t),
                r = n.reject,
                a = Jl(function () {
                    var a = at(t.resolve);
                    bn(e, function (e) {
                        a.call(t, e).then(n.resolve, r)
                    })
                });
            return a.error && r(a.value), n.promise
        }
    }), Fe({
        target: "Promise",
        stat: !0
    }, {
        allSettled: function (e) {
            var t = this,
                n = Xl.f(t),
                r = n.resolve,
                a = n.reject,
                i = Jl(function () {
                    var n = at(t.resolve),
                        a = [],
                        i = 0,
                        o = 1;
                    bn(e, function (e) {
                        var s = i++,
                            u = !1;
                        a.push(void 0), o++, n.call(t, e).then(function (e) {
                            u || (u = !0, a[s] = {
                                status: "fulfilled",
                                value: e
                            }, --o || r(a))
                        }, function (e) {
                            u || (u = !0, a[s] = {
                                status: "rejected",
                                reason: e
                            }, --o || r(a))
                        })
                    }), --o || r(a)
                });
            return i.error && a(i.value), n.promise
        }
    });
    var Nc = !!ll && i(function () {
        ll.prototype.finally.call({
            then: function () {}
        }, function () {})
    });
    Fe({
        target: "Promise",
        proto: !0,
        real: !0,
        forced: Nc
    }, {
        finally: function (e) {
            var t = Ji(this, ae("Promise")),
                n = "function" == typeof e;
            return this.then(n ? function (n) {
                return Yl(t, e()).then(function () {
                    return n
                })
            } : e, n ? function (n) {
                return Yl(t, e()).then(function () {
                    throw n
                })
            } : e)
        }
    }), "function" != typeof ll || ll.prototype.finally || te(ll.prototype, "finally", ae("Promise").prototype.finally);
    var Ic = function (e, t, n) {
            var r = -1 !== e.indexOf("Map"),
                o = -1 !== e.indexOf("Weak"),
                s = r ? "set" : "add",
                u = a[e],
                l = u && u.prototype,
                c = u,
                p = {},
                h = function (e) {
                    var t = l[e];
                    te(l, e, "add" == e ? function (e) {
                        return t.call(this, 0 === e ? 0 : e), this
                    } : "delete" == e ? function (e) {
                        return !(o && !g(e)) && t.call(this, 0 === e ? 0 : e)
                    } : "get" == e ? function (e) {
                        return o && !g(e) ? void 0 : t.call(this, 0 === e ? 0 : e)
                    } : "has" == e ? function (e) {
                        return !(o && !g(e)) && t.call(this, 0 === e ? 0 : e)
                    } : function (e, n) {
                        return t.call(this, 0 === e ? 0 : e, n), this
                    })
                };
            if (Re(e, "function" != typeof u || !(o || l.forEach && !i(function () {
                    (new u).entries().next()
                })))) c = n.getConstructor(t, e, r, s), nn.REQUIRED = !0;
            else if (Re(e, !0)) {
                var f = new c,
                    d = f[s](o ? {} : -0, 1) != f,
                    m = i(function () {
                        f.has(1)
                    }),
                    v = pr(function (e) {
                        new u(e)
                    }),
                    y = !o && i(function () {
                        for (var e = new u, t = 5; t--;) e[s](t, t);
                        return !e.has(-0)
                    });
                v || ((c = t(function (t, n) {
                    pl(t, c, e);
                    var a = qo(new u, t, c);
                    return null != n && bn(n, a[s], a, r), a
                })).prototype = l, l.constructor = c), (m || y) && (h("delete"), h("has"), r && h("get")), (y || d) && h(s), o && l.clear && delete l.clear
            }
            return p[e] = c, Fe({
                global: !0,
                forced: c != u
            }, p), rt(c, e), o || n.setStrong(c, e, r), c
        },
        Sc = R.f,
        Tc = nn.fastKey,
        Cc = ee.set,
        Ec = ee.getterFor,
        Rc = {
            getConstructor: function (e, t, n, r) {
                var a = e(function (e, i) {
                        pl(e, a, t), Cc(e, {
                            type: t,
                            index: Ge(null),
                            first: void 0,
                            last: void 0,
                            size: 0
                        }), o || (e.size = 0), null != i && bn(i, e[r], e, n)
                    }),
                    i = Ec(t),
                    s = function (e, t, n) {
                        var r, a, s = i(e),
                            l = u(e, t);
                        return l ? l.value = n : (s.last = l = {
                            index: a = Tc(t, !0),
                            key: t,
                            value: n,
                            previous: r = s.last,
                            next: void 0,
                            removed: !1
                        }, s.first || (s.first = l), r && (r.next = l), o ? s.size++ : e.size++, "F" !== a && (s.index[a] = l)), e
                    },
                    u = function (e, t) {
                        var n, r = i(e),
                            a = Tc(t);
                        if ("F" !== a) return r.index[a];
                        for (n = r.first; n; n = n.next)
                            if (n.key == t) return n
                    };
                return cl(a.prototype, {
                    clear: function () {
                        for (var e = i(this), t = e.index, n = e.first; n;) n.removed = !0, n.previous && (n.previous = n.previous.next = void 0), delete t[n.index], n = n.next;
                        e.first = e.last = void 0, o ? e.size = 0 : this.size = 0
                    },
                    delete: function (e) {
                        var t = i(this),
                            n = u(this, e);
                        if (n) {
                            var r = n.next,
                                a = n.previous;
                            delete t.index[n.index], n.removed = !0, a && (a.next = r), r && (r.previous = a), t.first == n && (t.first = r), t.last == n && (t.last = a), o ? t.size-- : this.size--
                        }
                        return !!n
                    },
                    forEach: function (e) {
                        for (var t, n = i(this), r = it(e, arguments.length > 1 ? arguments[1] : void 0, 3); t = t ? t.next : n.first;)
                            for (r(t.value, t.key, this); t && t.removed;) t = t.previous
                    },
                    has: function (e) {
                        return !!u(this, e)
                    }
                }), cl(a.prototype, n ? {
                    get: function (e) {
                        var t = u(this, e);
                        return t && t.value
                    },
                    set: function (e, t) {
                        return s(this, 0 === e ? 0 : e, t)
                    }
                } : {
                    add: function (e) {
                        return s(this, e = 0 === e ? 0 : e, e)
                    }
                }), o && Sc(a.prototype, "size", {
                    get: function () {
                        return i(this).size
                    }
                }), a
            },
            setStrong: function (e, t, n) {
                var r = t + " Iterator",
                    a = Ec(t),
                    i = Ec(r);
                ui(e, t, function (e, t) {
                    Cc(this, {
                        type: r,
                        target: e,
                        state: a(e),
                        kind: t,
                        last: void 0
                    })
                }, function () {
                    for (var e = i(this), t = e.kind, n = e.last; n && n.removed;) n = n.previous;
                    return e.target && (e.last = n = n ? n.next : e.state.first) ? "keys" == t ? {
                        value: n.key,
                        done: !1
                    } : "values" == t ? {
                        value: n.value,
                        done: !1
                    } : {
                        value: [n.key, n.value],
                        done: !1
                    } : (e.target = void 0, {
                        value: void 0,
                        done: !0
                    })
                }, n ? "entries" : "values", !n, !0), Xa(t)
            }
        },
        Ac = (Ic("Map", function (e) {
            return function () {
                return e(this, arguments.length ? arguments[0] : void 0)
            }
        }, Rc), Ic("Set", function (e) {
            return function () {
                return e(this, arguments.length ? arguments[0] : void 0)
            }
        }, Rc), nn.getWeakData),
        Fc = ee.set,
        _c = ee.getterFor,
        Dc = ct.find,
        Oc = ct.findIndex,
        Mc = 0,
        Lc = function (e) {
            return e.frozen || (e.frozen = new zc)
        },
        zc = function () {
            this.entries = []
        },
        Pc = function (e, t) {
            return Dc(e.entries, function (e) {
                return e[0] === t
            })
        };
    zc.prototype = {
        get: function (e) {
            var t = Pc(this, e);
            if (t) return t[1]
        },
        has: function (e) {
            return !!Pc(this, e)
        },
        set: function (e, t) {
            var n = Pc(this, e);
            n ? n[1] = t : this.entries.push([e, t])
        },
        delete: function (e) {
            var t = Oc(this.entries, function (t) {
                return t[0] === e
            });
            return ~t && this.entries.splice(t, 1), !!~t
        }
    };
    var Bc = {
        getConstructor: function (e, t, n, r) {
            var a = e(function (e, i) {
                    pl(e, a, t), Fc(e, {
                        type: t,
                        id: Mc++,
                        frozen: void 0
                    }), null != i && bn(i, e[r], e, n)
                }),
                i = _c(t),
                o = function (e, t, n) {
                    var r = i(e),
                        a = Ac(C(t), !0);
                    return !0 === a ? Lc(r).set(t, n) : a[r.id] = n, e
                };
            return cl(a.prototype, {
                delete: function (e) {
                    var t = i(this);
                    if (!g(e)) return !1;
                    var n = Ac(e);
                    return !0 === n ? Lc(t).delete(e) : n && x(n, t.id) && delete n[t.id]
                },
                has: function (e) {
                    var t = i(this);
                    if (!g(e)) return !1;
                    var n = Ac(e);
                    return !0 === n ? Lc(t).has(e) : n && x(n, t.id)
                }
            }), cl(a.prototype, n ? {
                get: function (e) {
                    var t = i(this);
                    if (g(e)) {
                        var n = Ac(e);
                        return !0 === n ? Lc(t).get(e) : n ? n[t.id] : void 0
                    }
                },
                set: function (e, t) {
                    return o(this, e, t)
                }
            } : {
                add: function (e) {
                    return o(this, e, !0)
                }
            }), a
        }
    };
    n(function (e) {
        var t, n = ee.enforce,
            r = !a.ActiveXObject && "ActiveXObject" in a,
            i = Object.isExtensible,
            o = function (e) {
                return function () {
                    return e(this, arguments.length ? arguments[0] : void 0)
                }
            },
            s = e.exports = Ic("WeakMap", o, Bc);
        if (B && r) {
            t = Bc.getConstructor(o, "WeakMap", !0), nn.REQUIRED = !0;
            var u = s.prototype,
                l = u.delete,
                c = u.has,
                p = u.get,
                h = u.set;
            cl(u, {
                delete: function (e) {
                    if (g(e) && !i(e)) {
                        var r = n(this);
                        return r.frozen || (r.frozen = new t), l.call(this, e) || r.frozen.delete(e)
                    }
                    return l.call(this, e)
                },
                has: function (e) {
                    if (g(e) && !i(e)) {
                        var r = n(this);
                        return r.frozen || (r.frozen = new t), c.call(this, e) || r.frozen.has(e)
                    }
                    return c.call(this, e)
                },
                get: function (e) {
                    if (g(e) && !i(e)) {
                        var r = n(this);
                        return r.frozen || (r.frozen = new t), c.call(this, e) ? p.call(this, e) : r.frozen.get(e)
                    }
                    return p.call(this, e)
                },
                set: function (e, r) {
                    if (g(e) && !i(e)) {
                        var a = n(this);
                        a.frozen || (a.frozen = new t), c.call(this, e) ? h.call(this, e, r) : a.frozen.set(e, r)
                    } else h.call(this, e, r);
                    return this
                }
            })
        }
    }), Ic("WeakSet", function (e) {
        return function () {
            return e(this, arguments.length ? arguments[0] : void 0)
        }
    }, Bc);
    var Wc = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView,
        Vc = function (e) {
            if (void 0 === e) return 0;
            var t = se(e),
                n = le(t);
            if (t !== n) throw RangeError("Wrong length or index");
            return n
        },
        Uc = Math.abs,
        Gc = Math.pow,
        jc = Math.floor,
        Hc = Math.log,
        qc = Math.LN2,
        Kc = be.f,
        Xc = R.f,
        Yc = ee.get,
        Jc = ee.set,
        Zc = a.ArrayBuffer,
        Qc = Zc,
        $c = a.DataView,
        ep = $c && $c.prototype,
        tp = Object.prototype,
        np = a.RangeError,
        rp = function (e, t, n) {
            var r, a, i, o = new Array(n),
                s = 8 * n - t - 1,
                u = (1 << s) - 1,
                l = u >> 1,
                c = 23 === t ? Gc(2, -24) - Gc(2, -77) : 0,
                p = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0,
                h = 0;
            for ((e = Uc(e)) != e || e === 1 / 0 ? (a = e != e ? 1 : 0, r = u) : (r = jc(Hc(e) / qc), e * (i = Gc(2, -r)) < 1 && (r--, i *= 2), (e += r + l >= 1 ? c / i : c * Gc(2, 1 - l)) * i >= 2 && (r++, i /= 2), r + l >= u ? (a = 0, r = u) : r + l >= 1 ? (a = (e * i - 1) * Gc(2, t), r += l) : (a = e * Gc(2, l - 1) * Gc(2, t), r = 0)); t >= 8; o[h++] = 255 & a, a /= 256, t -= 8);
            for (r = r << t | a, s += t; s > 0; o[h++] = 255 & r, r /= 256, s -= 8);
            return o[--h] |= 128 * p, o
        },
        ap = function (e, t) {
            var n, r = e.length,
                a = 8 * r - t - 1,
                i = (1 << a) - 1,
                o = i >> 1,
                s = a - 7,
                u = r - 1,
                l = e[u--],
                c = 127 & l;
            for (l >>= 7; s > 0; c = 256 * c + e[u], u--, s -= 8);
            for (n = c & (1 << -s) - 1, c >>= -s, s += t; s > 0; n = 256 * n + e[u], u--, s -= 8);
            if (0 === c) c = 1 - o;
            else {
                if (c === i) return n ? NaN : l ? -1 / 0 : 1 / 0;
                n += Gc(2, t), c -= o
            }
            return (l ? -1 : 1) * n * Gc(2, c - t)
        },
        ip = function (e) {
            return [255 & e]
        },
        op = function (e) {
            return [255 & e, e >> 8 & 255]
        },
        sp = function (e) {
            return [255 & e, e >> 8 & 255, e >> 16 & 255, e >> 24 & 255]
        },
        up = function (e) {
            return e[3] << 24 | e[2] << 16 | e[1] << 8 | e[0]
        },
        lp = function (e) {
            return rp(e, 23, 4)
        },
        cp = function (e) {
            return rp(e, 52, 8)
        },
        pp = function (e, t) {
            Xc(e.prototype, t, {
                get: function () {
                    return Yc(this)[t]
                }
            })
        },
        hp = function (e, t, n, r) {
            var a = Vc(n),
                i = Yc(e);
            if (a + t > i.byteLength) throw np("Wrong index");
            var o = Yc(i.buffer).bytes,
                s = a + i.byteOffset,
                u = o.slice(s, s + t);
            return r ? u : u.reverse()
        },
        fp = function (e, t, n, r, a, i) {
            var o = Vc(n),
                s = Yc(e);
            if (o + t > s.byteLength) throw np("Wrong index");
            for (var u = Yc(s.buffer).bytes, l = o + s.byteOffset, c = r(+a), p = 0; p < t; p++) u[l + p] = c[i ? p : t - p - 1]
        };
    if (Wc) {
        if (!i(function () {
                Zc(1)
            }) || !i(function () {
                new Zc(-1)
            }) || i(function () {
                return new Zc, new Zc(1.5), new Zc(NaN), "ArrayBuffer" != Zc.name
            })) {
            for (var dp, mp = (Qc = function (e) {
                    return pl(this, Qc), new Zc(Vc(e))
                }).prototype = Zc.prototype, vp = Kc(Zc), gp = 0; vp.length > gp;)(dp = vp[gp++]) in Qc || A(Qc, dp, Zc[dp]);
            mp.constructor = Qc
        }
        Hn && En(ep) !== tp && Hn(ep, tp);
        var yp = new $c(new Qc(2)),
            bp = ep.setInt8;
        yp.setInt8(0, 2147483648), yp.setInt8(1, 2147483649), !yp.getInt8(0) && yp.getInt8(1) || cl(ep, {
            setInt8: function (e, t) {
                bp.call(this, e, t << 24 >> 24)
            },
            setUint8: function (e, t) {
                bp.call(this, e, t << 24 >> 24)
            }
        }, {
            unsafe: !0
        })
    } else Qc = function (e) {
        pl(this, Qc, "ArrayBuffer");
        var t = Vc(e);
        Jc(this, {
            bytes: Wr.call(new Array(t), 0),
            byteLength: t
        }), o || (this.byteLength = t)
    }, $c = function (e, t, n) {
        pl(this, $c, "DataView"), pl(e, Qc, "DataView");
        var r = Yc(e).byteLength,
            a = se(t);
        if (a < 0 || a > r) throw np("Wrong offset");
        if (a + (n = void 0 === n ? r - a : le(n)) > r) throw np("Wrong length");
        Jc(this, {
            buffer: e,
            byteLength: n,
            byteOffset: a
        }), o || (this.buffer = e, this.byteLength = n, this.byteOffset = a)
    }, o && (pp(Qc, "byteLength"), pp($c, "buffer"), pp($c, "byteLength"), pp($c, "byteOffset")), cl($c.prototype, {
        getInt8: function (e) {
            return hp(this, 1, e)[0] << 24 >> 24
        },
        getUint8: function (e) {
            return hp(this, 1, e)[0]
        },
        getInt16: function (e) {
            var t = hp(this, 2, e, arguments.length > 1 ? arguments[1] : void 0);
            return (t[1] << 8 | t[0]) << 16 >> 16
        },
        getUint16: function (e) {
            var t = hp(this, 2, e, arguments.length > 1 ? arguments[1] : void 0);
            return t[1] << 8 | t[0]
        },
        getInt32: function (e) {
            return up(hp(this, 4, e, arguments.length > 1 ? arguments[1] : void 0))
        },
        getUint32: function (e) {
            return up(hp(this, 4, e, arguments.length > 1 ? arguments[1] : void 0)) >>> 0
        },
        getFloat32: function (e) {
            return ap(hp(this, 4, e, arguments.length > 1 ? arguments[1] : void 0), 23)
        },
        getFloat64: function (e) {
            return ap(hp(this, 8, e, arguments.length > 1 ? arguments[1] : void 0), 52)
        },
        setInt8: function (e, t) {
            fp(this, 1, e, ip, t)
        },
        setUint8: function (e, t) {
            fp(this, 1, e, ip, t)
        },
        setInt16: function (e, t) {
            fp(this, 2, e, op, t, arguments.length > 2 ? arguments[2] : void 0)
        },
        setUint16: function (e, t) {
            fp(this, 2, e, op, t, arguments.length > 2 ? arguments[2] : void 0)
        },
        setInt32: function (e, t) {
            fp(this, 4, e, sp, t, arguments.length > 2 ? arguments[2] : void 0)
        },
        setUint32: function (e, t) {
            fp(this, 4, e, sp, t, arguments.length > 2 ? arguments[2] : void 0)
        },
        setFloat32: function (e, t) {
            fp(this, 4, e, lp, t, arguments.length > 2 ? arguments[2] : void 0)
        },
        setFloat64: function (e, t) {
            fp(this, 8, e, cp, t, arguments.length > 2 ? arguments[2] : void 0)
        }
    });
    rt(Qc, "ArrayBuffer"), rt($c, "DataView");
    var xp = {
            ArrayBuffer: Qc,
            DataView: $c
        },
        wp = xp.ArrayBuffer,
        kp = a.ArrayBuffer;
    Fe({
        global: !0,
        forced: kp !== wp
    }, {
        ArrayBuffer: wp
    }), Xa("ArrayBuffer");
    var Np, Ip = R.f,
        Sp = a.Int8Array,
        Tp = Sp && Sp.prototype,
        Cp = a.Uint8ClampedArray,
        Ep = Cp && Cp.prototype,
        Rp = Sp && En(Sp),
        Ap = Tp && En(Tp),
        Fp = Object.prototype,
        _p = Fp.isPrototypeOf,
        Dp = Ze("toStringTag"),
        Op = G("TYPED_ARRAY_TAG"),
        Mp = Wc && !!Hn && "Opera" !== mn(a.opera),
        Lp = !1,
        zp = {
            Int8Array: 1,
            Uint8Array: 1,
            Uint8ClampedArray: 1,
            Int16Array: 2,
            Uint16Array: 2,
            Int32Array: 4,
            Uint32Array: 4,
            Float32Array: 4,
            Float64Array: 8
        },
        Pp = function (e) {
            return g(e) && x(zp, mn(e))
        };
    for (Np in zp) a[Np] || (Mp = !1);
    if ((!Mp || "function" != typeof Rp || Rp === Function.prototype) && (Rp = function () {
            throw TypeError("Incorrect invocation")
        }, Mp))
        for (Np in zp) a[Np] && Hn(a[Np], Rp);
    if ((!Mp || !Ap || Ap === Fp) && (Ap = Rp.prototype, Mp))
        for (Np in zp) a[Np] && Hn(a[Np].prototype, Ap);
    if (Mp && En(Ep) !== Ap && Hn(Ep, Ap), o && !x(Ap, Dp))
        for (Np in Lp = !0, Ip(Ap, Dp, {
                get: function () {
                    return g(this) ? this[Op] : void 0
                }
            }), zp) a[Np] && A(a[Np], Op, Np);
    var Bp = {
        NATIVE_ARRAY_BUFFER_VIEWS: Mp,
        TYPED_ARRAY_TAG: Lp && Op,
        aTypedArray: function (e) {
            if (Pp(e)) return e;
            throw TypeError("Target is not a typed array")
        },
        aTypedArrayConstructor: function (e) {
            if (Hn) {
                if (_p.call(Rp, e)) return e
            } else
                for (var t in zp)
                    if (x(zp, Np)) {
                        var n = a[t];
                        if (n && (e === n || _p.call(n, e))) return e
                    } throw TypeError("Target is not a typed array constructor")
        },
        exportTypedArrayMethod: function (e, t, n) {
            if (o) {
                if (n)
                    for (var r in zp) {
                        var i = a[r];
                        i && x(i.prototype, e) && delete i.prototype[e]
                    }
                Ap[e] && !n || te(Ap, e, n ? t : Mp && Tp[e] || t)
            }
        },
        exportTypedArrayStaticMethod: function (e, t, n) {
            var r, i;
            if (o) {
                if (Hn) {
                    if (n)
                        for (r in zp)(i = a[r]) && x(i, e) && delete i[e];
                    if (Rp[e] && !n) return;
                    try {
                        return te(Rp, e, n ? t : Mp && Sp[e] || t)
                    } catch (e) {}
                }
                for (r in zp) !(i = a[r]) || i[e] && !n || te(i, e, t)
            }
        },
        isView: function (e) {
            var t = mn(e);
            return "DataView" === t || x(zp, t)
        },
        isTypedArray: Pp,
        TypedArray: Rp,
        TypedArrayPrototype: Ap
    };
    Fe({
        target: "ArrayBuffer",
        stat: !0,
        forced: !Bp.NATIVE_ARRAY_BUFFER_VIEWS
    }, {
        isView: Bp.isView
    });
    var Wp = xp.ArrayBuffer,
        Vp = xp.DataView,
        Up = Wp.prototype.slice,
        Gp = i(function () {
            return !new Wp(2).slice(1, void 0).byteLength
        });
    Fe({
        target: "ArrayBuffer",
        proto: !0,
        unsafe: !0,
        forced: Gp
    }, {
        slice: function (e, t) {
            if (void 0 !== Up && void 0 === t) return Up.call(C(this), e);
            for (var n = C(this).byteLength, r = he(e, n), a = he(void 0 === t ? n : t, n), i = new(Ji(this, Wp))(le(a - r)), o = new Vp(this), s = new Vp(i), u = 0; r < a;) s.setUint8(u++, o.getUint8(r++));
            return i
        }
    }), Fe({
        global: !0,
        forced: !Wc
    }, {
        DataView: xp.DataView
    });
    var jp = Bp.NATIVE_ARRAY_BUFFER_VIEWS,
        Hp = a.ArrayBuffer,
        qp = a.Int8Array,
        Kp = !jp || !i(function () {
            qp(1)
        }) || !i(function () {
            new qp(-1)
        }) || !pr(function (e) {
            new qp, new qp(null), new qp(1.5), new qp(e)
        }, !0) || i(function () {
            return 1 !== new qp(new Hp(2), 1, void 0).length
        }),
        Xp = function (e, t) {
            var n = function (e) {
                var t = se(e);
                if (t < 0) throw RangeError("The argument can't be less than 0");
                return t
            }(e);
            if (n % t) throw RangeError("Wrong offset");
            return n
        },
        Yp = Bp.aTypedArrayConstructor,
        Jp = function (e) {
            var t, n, r, a, i, o, s = Me(e),
                u = arguments.length,
                l = u > 1 ? arguments[1] : void 0,
                c = void 0 !== l,
                p = gn(s);
            if (null != p && !cn(p))
                for (o = (i = p.call(s)).next, s = []; !(a = o.call(i)).done;) s.push(a.value);
            for (c && u > 2 && (l = it(l, arguments[2], 2)), n = le(s.length), r = new(Yp(this))(n), t = 0; n > t; t++) r[t] = c ? l(s[t], t) : s[t];
            return r
        },
        Zp = n(function (e) {
            var t = be.f,
                n = ct.forEach,
                r = ee.get,
                i = ee.set,
                s = R.f,
                u = T.f,
                l = Math.round,
                p = a.RangeError,
                h = xp.ArrayBuffer,
                f = xp.DataView,
                d = Bp.NATIVE_ARRAY_BUFFER_VIEWS,
                m = Bp.TYPED_ARRAY_TAG,
                v = Bp.TypedArray,
                b = Bp.TypedArrayPrototype,
                w = Bp.aTypedArrayConstructor,
                k = Bp.isTypedArray,
                N = function (e, t) {
                    for (var n = 0, r = t.length, a = new(w(e))(r); r > n;) a[n] = t[n++];
                    return a
                },
                I = function (e, t) {
                    s(e, t, {
                        get: function () {
                            return r(this)[t]
                        }
                    })
                },
                S = function (e) {
                    var t;
                    return e instanceof h || "ArrayBuffer" == (t = mn(e)) || "SharedArrayBuffer" == t
                },
                C = function (e, t) {
                    return k(e) && "symbol" != typeof t && t in e && String(+t) == String(t)
                },
                E = function (e, t) {
                    return C(e, t = y(t, !0)) ? c(2, e[t]) : u(e, t)
                },
                F = function (e, t, n) {
                    return !(C(e, t = y(t, !0)) && g(n) && x(n, "value")) || x(n, "get") || x(n, "set") || n.configurable || x(n, "writable") && !n.writable || x(n, "enumerable") && !n.enumerable ? s(e, t, n) : (e[t] = n.value, e)
                };
            o ? (d || (T.f = E, R.f = F, I(b, "buffer"), I(b, "byteOffset"), I(b, "byteLength"), I(b, "length")), Fe({
                target: "Object",
                stat: !0,
                forced: !d
            }, {
                getOwnPropertyDescriptor: E,
                defineProperty: F
            }), e.exports = function (e, o, u) {
                var c = e.match(/\d+$/)[0] / 8,
                    y = e + (u ? "Clamped" : "") + "Array",
                    x = "get" + e,
                    w = "set" + e,
                    I = a[y],
                    T = I,
                    C = T && T.prototype,
                    E = {},
                    R = function (e, t) {
                        s(e, t, {
                            get: function () {
                                return function (e, t) {
                                    var n = r(e);
                                    return n.view[x](t * c + n.byteOffset, !0)
                                }(this, t)
                            },
                            set: function (e) {
                                return function (e, t, n) {
                                    var a = r(e);
                                    u && (n = (n = l(n)) < 0 ? 0 : n > 255 ? 255 : 255 & n), a.view[w](t * c + a.byteOffset, n, !0)
                                }(this, t, e)
                            },
                            enumerable: !0
                        })
                    };
                d ? Kp && (T = o(function (e, t, n, r) {
                    return pl(e, T, y), qo(g(t) ? S(t) ? void 0 !== r ? new I(t, Xp(n, c), r) : void 0 !== n ? new I(t, Xp(n, c)) : new I(t) : k(t) ? N(T, t) : Jp.call(T, t) : new I(Vc(t)), e, T)
                }), Hn && Hn(T, v), n(t(I), function (e) {
                    e in T || A(T, e, I[e])
                }), T.prototype = C) : (T = o(function (e, t, n, r) {
                    pl(e, T, y);
                    var a, o, s, u = 0,
                        l = 0;
                    if (g(t)) {
                        if (!S(t)) return k(t) ? N(T, t) : Jp.call(T, t);
                        a = t, l = Xp(n, c);
                        var d = t.byteLength;
                        if (void 0 === r) {
                            if (d % c) throw p("Wrong length");
                            if ((o = d - l) < 0) throw p("Wrong length")
                        } else if ((o = le(r) * c) + l > d) throw p("Wrong length");
                        s = o / c
                    } else s = Vc(t), a = new h(o = s * c);
                    for (i(e, {
                            buffer: a,
                            byteOffset: l,
                            byteLength: o,
                            length: s,
                            view: new f(a)
                        }); u < s;) R(e, u++)
                }), Hn && Hn(T, v), C = T.prototype = Ge(b)), C.constructor !== T && A(C, "constructor", T), m && A(C, m, y), E[y] = T, Fe({
                    global: !0,
                    forced: T != I,
                    sham: !d
                }, E), "BYTES_PER_ELEMENT" in T || A(T, "BYTES_PER_ELEMENT", c), "BYTES_PER_ELEMENT" in C || A(C, "BYTES_PER_ELEMENT", c), Xa(y)
            }) : e.exports = function () {}
        });
    Zp("Int8", function (e) {
        return function (t, n, r) {
            return e(this, t, n, r)
        }
    }), Zp("Uint8", function (e) {
        return function (t, n, r) {
            return e(this, t, n, r)
        }
    }), Zp("Uint8", function (e) {
        return function (t, n, r) {
            return e(this, t, n, r)
        }
    }, !0), Zp("Int16", function (e) {
        return function (t, n, r) {
            return e(this, t, n, r)
        }
    }), Zp("Uint16", function (e) {
        return function (t, n, r) {
            return e(this, t, n, r)
        }
    }), Zp("Int32", function (e) {
        return function (t, n, r) {
            return e(this, t, n, r)
        }
    }), Zp("Uint32", function (e) {
        return function (t, n, r) {
            return e(this, t, n, r)
        }
    }), Zp("Float32", function (e) {
        return function (t, n, r) {
            return e(this, t, n, r)
        }
    }), Zp("Float64", function (e) {
        return function (t, n, r) {
            return e(this, t, n, r)
        }
    }), (0, Bp.exportTypedArrayStaticMethod)("from", Jp, Kp);
    var Qp = Bp.aTypedArrayConstructor;
    (0, Bp.exportTypedArrayStaticMethod)("of", function () {
        for (var e = 0, t = arguments.length, n = new(Qp(this))(t); t > e;) n[e] = arguments[e++];
        return n
    }, Kp);
    var $p = Bp.aTypedArray;
    (0, Bp.exportTypedArrayMethod)("copyWithin", function (e, t) {
        return Er.call($p(this), e, t, arguments.length > 2 ? arguments[2] : void 0)
    });
    var eh = ct.every,
        th = Bp.aTypedArray;
    (0, Bp.exportTypedArrayMethod)("every", function (e) {
        return eh(th(this), e, arguments.length > 1 ? arguments[1] : void 0)
    });
    var nh = Bp.aTypedArray;
    (0, Bp.exportTypedArrayMethod)("fill", function (e) {
        return Wr.apply(nh(this), arguments)
    });
    var rh = ct.filter,
        ah = Bp.aTypedArray,
        ih = Bp.aTypedArrayConstructor;
    (0, Bp.exportTypedArrayMethod)("filter", function (e) {
        for (var t = rh(ah(this), e, arguments.length > 1 ? arguments[1] : void 0), n = Ji(this, this.constructor), r = 0, a = t.length, i = new(ih(n))(a); a > r;) i[r] = t[r++];
        return i
    });
    var oh = ct.find,
        sh = Bp.aTypedArray;
    (0, Bp.exportTypedArrayMethod)("find", function (e) {
        return oh(sh(this), e, arguments.length > 1 ? arguments[1] : void 0)
    });
    var uh = ct.findIndex,
        lh = Bp.aTypedArray;
    (0, Bp.exportTypedArrayMethod)("findIndex", function (e) {
        return uh(lh(this), e, arguments.length > 1 ? arguments[1] : void 0)
    });
    var ch = ct.forEach,
        ph = Bp.aTypedArray;
    (0, Bp.exportTypedArrayMethod)("forEach", function (e) {
        ch(ph(this), e, arguments.length > 1 ? arguments[1] : void 0)
    });
    var hh = de.includes,
        fh = Bp.aTypedArray;
    (0, Bp.exportTypedArrayMethod)("includes", function (e) {
        return hh(fh(this), e, arguments.length > 1 ? arguments[1] : void 0)
    });
    var dh = de.indexOf,
        mh = Bp.aTypedArray;
    (0, Bp.exportTypedArrayMethod)("indexOf", function (e) {
        return dh(mh(this), e, arguments.length > 1 ? arguments[1] : void 0)
    });
    var vh = Ze("iterator"),
        gh = a.Uint8Array,
        yh = pi.values,
        bh = pi.keys,
        xh = pi.entries,
        wh = Bp.aTypedArray,
        kh = Bp.exportTypedArrayMethod,
        Nh = gh && gh.prototype[vh],
        Ih = !!Nh && ("values" == Nh.name || null == Nh.name),
        Sh = function () {
            return yh.call(wh(this))
        };
    kh("entries", function () {
        return xh.call(wh(this))
    }), kh("keys", function () {
        return bh.call(wh(this))
    }), kh("values", Sh, !Ih), kh(vh, Sh, !Ih);
    var Th = Bp.aTypedArray,
        Ch = [].join;
    (0, Bp.exportTypedArrayMethod)("join", function (e) {
        return Ch.apply(Th(this), arguments)
    });
    var Eh = Bp.aTypedArray;
    (0, Bp.exportTypedArrayMethod)("lastIndexOf", function (e) {
        return va.apply(Eh(this), arguments)
    });
    var Rh = ct.map,
        Ah = Bp.aTypedArray,
        Fh = Bp.aTypedArrayConstructor;
    (0, Bp.exportTypedArrayMethod)("map", function (e) {
        return Rh(Ah(this), e, arguments.length > 1 ? arguments[1] : void 0, function (e, t) {
            return new(Fh(Ji(e, e.constructor)))(t)
        })
    });
    var _h = wa.left,
        Dh = Bp.aTypedArray;
    (0, Bp.exportTypedArrayMethod)("reduce", function (e) {
        return _h(Dh(this), e, arguments.length, arguments.length > 1 ? arguments[1] : void 0)
    });
    var Oh = wa.right,
        Mh = Bp.aTypedArray;
    (0, Bp.exportTypedArrayMethod)("reduceRight", function (e) {
        return Oh(Mh(this), e, arguments.length, arguments.length > 1 ? arguments[1] : void 0)
    });
    var Lh = Bp.aTypedArray,
        zh = Bp.exportTypedArrayMethod,
        Ph = Math.floor;
    zh("reverse", function () {
        for (var e, t = Lh(this).length, n = Ph(t / 2), r = 0; r < n;) e = this[r], this[r++] = this[--t], this[t] = e;
        return this
    });
    var Bh = Bp.aTypedArray;
    (0, Bp.exportTypedArrayMethod)("set", function (e) {
        Bh(this);
        var t = Xp(arguments.length > 1 ? arguments[1] : void 0, 1),
            n = this.length,
            r = Me(e),
            a = le(r.length),
            i = 0;
        if (a + t > n) throw RangeError("Wrong length");
        for (; i < a;) this[t + i] = r[i++]
    }, i(function () {
        new Int8Array(1).set({})
    }));
    var Wh = Bp.aTypedArray,
        Vh = Bp.aTypedArrayConstructor,
        Uh = [].slice;
    (0, Bp.exportTypedArrayMethod)("slice", function (e, t) {
        for (var n = Uh.call(Wh(this), e, t), r = Ji(this, this.constructor), a = 0, i = n.length, o = new(Vh(r))(i); i > a;) o[a] = n[a++];
        return o
    }, i(function () {
        new Int8Array(1).slice()
    }));
    var Gh = ct.some,
        jh = Bp.aTypedArray;
    (0, Bp.exportTypedArrayMethod)("some", function (e) {
        return Gh(jh(this), e, arguments.length > 1 ? arguments[1] : void 0)
    });
    var Hh = Bp.aTypedArray,
        qh = [].sort;
    (0, Bp.exportTypedArrayMethod)("sort", function (e) {
        return qh.call(Hh(this), e)
    });
    var Kh = Bp.aTypedArray;
    (0, Bp.exportTypedArrayMethod)("subarray", function (e, t) {
        var n = Kh(this),
            r = n.length,
            a = he(e, r);
        return new(Ji(n, n.constructor))(n.buffer, n.byteOffset + a * n.BYTES_PER_ELEMENT, le((void 0 === t ? r : he(t, r)) - a))
    });
    var Xh = a.Int8Array,
        Yh = Bp.aTypedArray,
        Jh = Bp.exportTypedArrayMethod,
        Zh = [].toLocaleString,
        Qh = [].slice,
        $h = !!Xh && i(function () {
            Zh.call(new Xh(1))
        });
    Jh("toLocaleString", function () {
        return Zh.apply($h ? Qh.call(Yh(this)) : Yh(this), arguments)
    }, i(function () {
        return [1, 2].toLocaleString() != new Xh([1, 2]).toLocaleString()
    }) || !i(function () {
        Xh.prototype.toLocaleString.call([1, 2])
    }));
    var ef = Bp.exportTypedArrayMethod,
        tf = a.Uint8Array,
        nf = tf && tf.prototype || {},
        rf = [].toString,
        af = [].join;
    i(function () {
        rf.call({})
    }) && (rf = function () {
        return af.call(this)
    });
    var of = nf.toString != rf;
    ef("toString", rf, of );
    var sf = ae("Reflect", "apply"),
        uf = Function.apply,
        lf = !i(function () {
            sf(function () {})
        });
    Fe({
        target: "Reflect",
        stat: !0,
        forced: lf
    }, {
        apply: function (e, t, n) {
            return at(e), C(n), sf ? sf(e, t, n) : uf.call(e, t, n)
        }
    });
    var cf = ae("Reflect", "construct"),
        pf = i(function () {
            function e() {}
            return !(cf(function () {}, [], e) instanceof e)
        }),
        hf = !i(function () {
            cf(function () {})
        }),
        ff = pf || hf;
    Fe({
        target: "Reflect",
        stat: !0,
        forced: ff,
        sham: ff
    }, {
        construct: function (e, t) {
            at(e), C(t);
            var n = arguments.length < 3 ? e : at(arguments[2]);
            if (hf && !pf) return cf(e, t, n);
            if (e == n) {
                switch (t.length) {
                    case 0:
                        return new e;
                    case 1:
                        return new e(t[0]);
                    case 2:
                        return new e(t[0], t[1]);
                    case 3:
                        return new e(t[0], t[1], t[2]);
                    case 4:
                        return new e(t[0], t[1], t[2], t[3])
                }
                var r = [null];
                return r.push.apply(r, t), new($n.apply(e, r))
            }
            var a = n.prototype,
                i = Ge(g(a) ? a : Object.prototype),
                o = Function.apply.call(e, i, t);
            return g(o) ? o : i
        }
    });
    var df = i(function () {
        Reflect.defineProperty(R.f({}, 1, {
            value: 1
        }), 1, {
            value: 2
        })
    });
    Fe({
        target: "Reflect",
        stat: !0,
        forced: df,
        sham: !o
    }, {
        defineProperty: function (e, t, n) {
            C(e);
            var r = y(t, !0);
            C(n);
            try {
                return R.f(e, r, n), !0
            } catch (e) {
                return !1
            }
        }
    });
    var mf = T.f;
    Fe({
        target: "Reflect",
        stat: !0
    }, {
        deleteProperty: function (e, t) {
            var n = mf(C(e), t);
            return !(n && !n.configurable) && delete e[t]
        }
    }), Fe({
        target: "Reflect",
        stat: !0
    }, {
        get: function e(t, n) {
            var r, a, i = arguments.length < 3 ? t : arguments[2];
            return C(t) === i ? t[n] : (r = T.f(t, n)) ? x(r, "value") ? r.value : void 0 === r.get ? void 0 : r.get.call(i) : g(a = En(t)) ? e(a, n, i) : void 0
        }
    }), Fe({
        target: "Reflect",
        stat: !0,
        sham: !o
    }, {
        getOwnPropertyDescriptor: function (e, t) {
            return T.f(C(e), t)
        }
    }), Fe({
        target: "Reflect",
        stat: !0,
        sham: !Sn
    }, {
        getPrototypeOf: function (e) {
            return En(C(e))
        }
    }), Fe({
        target: "Reflect",
        stat: !0
    }, {
        has: function (e, t) {
            return t in e
        }
    });
    var vf = Object.isExtensible;
    Fe({
        target: "Reflect",
        stat: !0
    }, {
        isExtensible: function (e) {
            return C(e), !vf || vf(e)
        }
    }), Fe({
        target: "Reflect",
        stat: !0
    }, {
        ownKeys: we
    }), Fe({
        target: "Reflect",
        stat: !0,
        sham: !tn
    }, {
        preventExtensions: function (e) {
            C(e);
            try {
                var t = ae("Object", "preventExtensions");
                return t && t(e), !0
            } catch (e) {
                return !1
            }
        }
    });
    var gf = i(function () {
        var e = R.f({}, "a", {
            configurable: !0
        });
        return !1 !== Reflect.set(En(e), "a", 1, e)
    });
    Fe({
        target: "Reflect",
        stat: !0,
        forced: gf
    }, {
        set: function e(t, n, r) {
            var a, i, o = arguments.length < 4 ? t : arguments[3],
                s = T.f(C(t), n);
            if (!s) {
                if (g(i = En(t))) return e(i, n, r, o);
                s = c(0)
            }
            if (x(s, "value")) {
                if (!1 === s.writable || !g(o)) return !1;
                if (a = T.f(o, n)) {
                    if (a.get || a.set || !1 === a.writable) return !1;
                    a.value = r, R.f(o, n, a)
                } else R.f(o, n, c(0, r));
                return !0
            }
            return void 0 !== s.set && (s.set.call(o, r), !0)
        }
    }), Hn && Fe({
        target: "Reflect",
        stat: !0
    }, {
        setPrototypeOf: function (e, t) {
            C(e), jn(t);
            try {
                return Hn(e, t), !0
            } catch (e) {
                return !1
            }
        }
    });
    var yf = {
        CSSRuleList: 0,
        CSSStyleDeclaration: 0,
        CSSValueList: 0,
        ClientRectList: 0,
        DOMRectList: 0,
        DOMStringList: 0,
        DOMTokenList: 1,
        DataTransferItemList: 0,
        FileList: 0,
        HTMLAllCollection: 0,
        HTMLCollection: 0,
        HTMLFormElement: 0,
        HTMLSelectElement: 0,
        MediaList: 0,
        MimeTypeArray: 0,
        NamedNodeMap: 0,
        NodeList: 1,
        PaintRequestList: 0,
        Plugin: 0,
        PluginArray: 0,
        SVGLengthList: 0,
        SVGNumberList: 0,
        SVGPathSegList: 0,
        SVGPointList: 0,
        SVGStringList: 0,
        SVGTransformList: 0,
        SourceBufferList: 0,
        StyleSheetList: 0,
        TextTrackCueList: 0,
        TextTrackList: 0,
        TouchList: 0
    };
    for (var bf in yf) {
        var xf = a[bf],
            wf = xf && xf.prototype;
        if (wf && wf.forEach !== ea) try {
            A(wf, "forEach", ea)
        } catch (e) {
            wf.forEach = ea
        }
    }
    var kf = Ze("iterator"),
        Nf = Ze("toStringTag"),
        If = pi.values;
    for (var Sf in yf) {
        var Tf = a[Sf],
            Cf = Tf && Tf.prototype;
        if (Cf) {
            if (Cf[kf] !== If) try {
                A(Cf, kf, If)
            } catch (e) {
                Cf[kf] = If
            }
            if (Cf[Nf] || A(Cf, Nf, Sf), yf[Sf])
                for (var Ef in pi)
                    if (Cf[Ef] !== pi[Ef]) try {
                        A(Cf, Ef, pi[Ef])
                    } catch (e) {
                        Cf[Ef] = pi[Ef]
                    }
        }
    }
    var Rf = !a.setImmediate || !a.clearImmediate;
    Fe({
        global: !0,
        bind: !0,
        enumerable: !0,
        forced: Rf
    }, {
        setImmediate: Dl.set,
        clearImmediate: Dl.clear
    });
    var Af = a.process,
        Ff = "process" == h(Af);
    Fe({
        global: !0,
        enumerable: !0,
        noTargetGet: !0
    }, {
        queueMicrotask: function (e) {
            var t = Ff && Af.domain;
            ql(t ? t.bind(e) : e)
        }
    });
    var _f = [].slice,
        Df = /MSIE .\./.test(vr),
        Of = function (e) {
            return function (t, n) {
                var r = arguments.length > 2,
                    a = r ? _f.call(arguments, 2) : void 0;
                return e(r ? function () {
                    ("function" == typeof t ? t : Function(t)).apply(this, a)
                } : t, n)
            }
        };
    Fe({
        global: !0,
        bind: !0,
        forced: Df
    }, {
        setTimeout: Of(a.setTimeout),
        setInterval: Of(a.setInterval)
    });
    var Mf = Ze("iterator"),
        Lf = !i(function () {
            var e = new URL("b?a=1&b=2&c=3", "http://a"),
                t = e.searchParams,
                n = "";
            return e.pathname = "c%20d", t.forEach(function (e, r) {
                t.delete("b"), n += r + e
            }), !t.sort || "http://a/c%20d?a=1&c=3" !== e.href || "3" !== t.get("c") || "a=1" !== String(new URLSearchParams("?a=1")) || !t[Mf] || "a" !== new URL("https://a@b").username || "b" !== new URLSearchParams(new URLSearchParams("a=b")).get("a") || "xn--e1aybc" !== new URL("http://ÑÐµÑÑ").host || "#%D0%B1" !== new URL("http://a#Ð±").hash || "a1c3" !== n || "x" !== new URL("http://x", void 0).host
        }),
        zf = /[^\0-\u007E]/,
        Pf = /[.\u3002\uFF0E\uFF61]/g,
        Bf = "Overflow: input needs wider integers to process",
        Wf = Math.floor,
        Vf = String.fromCharCode,
        Uf = function (e) {
            return e + 22 + 75 * (e < 26)
        },
        Gf = function (e, t, n) {
            var r = 0;
            for (e = n ? Wf(e / 700) : e >> 1, e += Wf(e / t); e > 455; r += 36) e = Wf(e / 35);
            return Wf(r + 36 * e / (e + 38))
        },
        jf = function (e) {
            var t, n, r = [],
                a = (e = function (e) {
                    for (var t = [], n = 0, r = e.length; n < r;) {
                        var a = e.charCodeAt(n++);
                        if (a >= 55296 && a <= 56319 && n < r) {
                            var i = e.charCodeAt(n++);
                            56320 == (64512 & i) ? t.push(((1023 & a) << 10) + (1023 & i) + 65536) : (t.push(a), n--)
                        } else t.push(a)
                    }
                    return t
                }(e)).length,
                i = 128,
                o = 0,
                s = 72;
            for (t = 0; t < e.length; t++)(n = e[t]) < 128 && r.push(Vf(n));
            var u = r.length,
                l = u;
            for (u && r.push("-"); l < a;) {
                var c = 2147483647;
                for (t = 0; t < e.length; t++)(n = e[t]) >= i && n < c && (c = n);
                var p = l + 1;
                if (c - i > Wf((2147483647 - o) / p)) throw RangeError(Bf);
                for (o += (c - i) * p, i = c, t = 0; t < e.length; t++) {
                    if ((n = e[t]) < i && ++o > 2147483647) throw RangeError(Bf);
                    if (n == i) {
                        for (var h = o, f = 36;; f += 36) {
                            var d = f <= s ? 1 : f >= s + 26 ? 26 : f - s;
                            if (h < d) break;
                            var m = h - d,
                                v = 36 - d;
                            r.push(Vf(Uf(d + m % v))), h = Wf(m / v)
                        }
                        r.push(Vf(Uf(h))), s = Gf(o, p, l == u), o = 0, ++l
                    }
                }++o, ++i
            }
            return r.join("")
        },
        Hf = function (e) {
            var t = gn(e);
            if ("function" != typeof t) throw TypeError(String(e) + " is not iterable");
            return C(t.call(e))
        },
        qf = ae("fetch"),
        Kf = ae("Headers"),
        Xf = Ze("iterator"),
        Yf = ee.set,
        Jf = ee.getterFor("URLSearchParams"),
        Zf = ee.getterFor("URLSearchParamsIterator"),
        Qf = /\+/g,
        $f = Array(4),
        ed = function (e) {
            return $f[e - 1] || ($f[e - 1] = RegExp("((?:%[\\da-f]{2}){" + e + "})", "gi"))
        },
        td = function (e) {
            try {
                return decodeURIComponent(e)
            } catch (t) {
                return e
            }
        },
        nd = function (e) {
            var t = e.replace(Qf, " "),
                n = 4;
            try {
                return decodeURIComponent(t)
            } catch (e) {
                for (; n;) t = t.replace(ed(n--), td);
                return t
            }
        },
        rd = /[!'()~]|%20/g,
        ad = {
            "!": "%21",
            "'": "%27",
            "(": "%28",
            ")": "%29",
            "~": "%7E",
            "%20": "+"
        },
        id = function (e) {
            return ad[e]
        },
        od = function (e) {
            return encodeURIComponent(e).replace(rd, id)
        },
        sd = function (e, t) {
            if (t)
                for (var n, r, a = t.split("&"), i = 0; i < a.length;)(n = a[i++]).length && (r = n.split("="), e.push({
                    key: nd(r.shift()),
                    value: nd(r.join("="))
                }))
        },
        ud = function (e) {
            this.entries.length = 0, sd(this.entries, e)
        },
        ld = function (e, t) {
            if (e < t) throw TypeError("Not enough arguments")
        },
        cd = ri(function (e, t) {
            Yf(this, {
                type: "URLSearchParamsIterator",
                iterator: Hf(Jf(e).entries),
                kind: t
            })
        }, "Iterator", function () {
            var e = Zf(this),
                t = e.kind,
                n = e.iterator.next(),
                r = n.value;
            return n.done || (n.value = "keys" === t ? r.key : "values" === t ? r.value : [r.key, r.value]), n
        }),
        pd = function () {
            pl(this, pd, "URLSearchParams");
            var e, t, n, r, a, i, o, s, u, l = arguments.length > 0 ? arguments[0] : void 0,
                c = [];
            if (Yf(this, {
                    type: "URLSearchParams",
                    entries: c,
                    updateURL: function () {},
                    updateSearchParams: ud
                }), void 0 !== l)
                if (g(l))
                    if ("function" == typeof (e = gn(l)))
                        for (n = (t = e.call(l)).next; !(r = n.call(t)).done;) {
                            if ((o = (i = (a = Hf(C(r.value))).next).call(a)).done || (s = i.call(a)).done || !i.call(a).done) throw TypeError("Expected sequence with length 2");
                            c.push({
                                key: o.value + "",
                                value: s.value + ""
                            })
                        } else
                            for (u in l) x(l, u) && c.push({
                                key: u,
                                value: l[u] + ""
                            });
                    else sd(c, "string" == typeof l ? "?" === l.charAt(0) ? l.slice(1) : l : l + "")
        },
        hd = pd.prototype;
    cl(hd, {
        append: function (e, t) {
            ld(arguments.length, 2);
            var n = Jf(this);
            n.entries.push({
                key: e + "",
                value: t + ""
            }), n.updateURL()
        },
        delete: function (e) {
            ld(arguments.length, 1);
            for (var t = Jf(this), n = t.entries, r = e + "", a = 0; a < n.length;) n[a].key === r ? n.splice(a, 1) : a++;
            t.updateURL()
        },
        get: function (e) {
            ld(arguments.length, 1);
            for (var t = Jf(this).entries, n = e + "", r = 0; r < t.length; r++)
                if (t[r].key === n) return t[r].value;
            return null
        },
        getAll: function (e) {
            ld(arguments.length, 1);
            for (var t = Jf(this).entries, n = e + "", r = [], a = 0; a < t.length; a++) t[a].key === n && r.push(t[a].value);
            return r
        },
        has: function (e) {
            ld(arguments.length, 1);
            for (var t = Jf(this).entries, n = e + "", r = 0; r < t.length;)
                if (t[r++].key === n) return !0;
            return !1
        },
        set: function (e, t) {
            ld(arguments.length, 1);
            for (var n, r = Jf(this), a = r.entries, i = !1, o = e + "", s = t + "", u = 0; u < a.length; u++)(n = a[u]).key === o && (i ? a.splice(u--, 1) : (i = !0, n.value = s));
            i || a.push({
                key: o,
                value: s
            }), r.updateURL()
        },
        sort: function () {
            var e, t, n, r = Jf(this),
                a = r.entries,
                i = a.slice();
            for (a.length = 0, n = 0; n < i.length; n++) {
                for (e = i[n], t = 0; t < n; t++)
                    if (a[t].key > e.key) {
                        a.splice(t, 0, e);
                        break
                    } t === n && a.push(e)
            }
            r.updateURL()
        },
        forEach: function (e) {
            for (var t, n = Jf(this).entries, r = it(e, arguments.length > 1 ? arguments[1] : void 0, 3), a = 0; a < n.length;) r((t = n[a++]).value, t.key, this)
        },
        keys: function () {
            return new cd(this, "keys")
        },
        values: function () {
            return new cd(this, "values")
        },
        entries: function () {
            return new cd(this, "entries")
        }
    }, {
        enumerable: !0
    }), te(hd, Xf, hd.entries), te(hd, "toString", function () {
        for (var e, t = Jf(this).entries, n = [], r = 0; r < t.length;) e = t[r++], n.push(od(e.key) + "=" + od(e.value));
        return n.join("&")
    }, {
        enumerable: !0
    }), rt(pd, "URLSearchParams"), Fe({
        global: !0,
        forced: !Lf
    }, {
        URLSearchParams: pd
    }), Lf || "function" != typeof qf || "function" != typeof Kf || Fe({
        global: !0,
        enumerable: !0,
        forced: !0
    }, {
        fetch: function (e) {
            var t, n, r, a = [e];
            return arguments.length > 1 && (t = arguments[1], g(t) && (n = t.body, "URLSearchParams" === mn(n) && ((r = t.headers ? new Kf(t.headers) : new Kf).has("content-type") || r.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"), t = Ge(t, {
                body: c(0, String(n)),
                headers: c(0, r)
            }))), a.push(t)), qf.apply(this, a)
        }
    });
    var fd, dd = {
            URLSearchParams: pd,
            getState: Jf
        },
        md = vi.codeAt,
        vd = a.URL,
        gd = dd.URLSearchParams,
        yd = dd.getState,
        bd = ee.set,
        xd = ee.getterFor("URL"),
        wd = Math.floor,
        kd = Math.pow,
        Nd = /[A-Za-z]/,
        Id = /[\d+-.A-Za-z]/,
        Sd = /\d/,
        Td = /^(0x|0X)/,
        Cd = /^[0-7]+$/,
        Ed = /^\d+$/,
        Rd = /^[\dA-Fa-f]+$/,
        Ad = /[\u0000\u0009\u000A\u000D #%\/:?@[\\]]/,
        Fd = /[\u0000\u0009\u000A\u000D #\/:?@[\\]]/,
        _d = /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g,
        Dd = /[\u0009\u000A\u000D]/g,
        Od = function (e, t) {
            var n, r, a;
            if ("[" == t.charAt(0)) {
                if ("]" != t.charAt(t.length - 1)) return "Invalid host";
                if (!(n = Ld(t.slice(1, -1)))) return "Invalid host";
                e.host = n
            } else if (jd(e)) {
                if (t = function (e) {
                        var t, n, r = [],
                            a = e.toLowerCase().replace(Pf, ".").split(".");
                        for (t = 0; t < a.length; t++) n = a[t], r.push(zf.test(n) ? "xn--" + jf(n) : n);
                        return r.join(".")
                    }(t), Ad.test(t)) return "Invalid host";
                if (null === (n = Md(t))) return "Invalid host";
                e.host = n
            } else {
                if (Fd.test(t)) return "Invalid host";
                for (n = "", r = or(t), a = 0; a < r.length; a++) n += Ud(r[a], Pd);
                e.host = n
            }
        },
        Md = function (e) {
            var t, n, r, a, i, o, s, u = e.split(".");
            if (u.length && "" == u[u.length - 1] && u.pop(), (t = u.length) > 4) return e;
            for (n = [], r = 0; r < t; r++) {
                if ("" == (a = u[r])) return e;
                if (i = 10, a.length > 1 && "0" == a.charAt(0) && (i = Td.test(a) ? 16 : 8, a = a.slice(8 == i ? 1 : 2)), "" === a) o = 0;
                else {
                    if (!(10 == i ? Ed : 8 == i ? Cd : Rd).test(a)) return e;
                    o = parseInt(a, i)
                }
                n.push(o)
            }
            for (r = 0; r < t; r++)
                if (o = n[r], r == t - 1) {
                    if (o >= kd(256, 5 - t)) return null
                } else if (o > 255) return null;
            for (s = n.pop(), r = 0; r < n.length; r++) s += n[r] * kd(256, 3 - r);
            return s
        },
        Ld = function (e) {
            var t, n, r, a, i, o, s, u = [0, 0, 0, 0, 0, 0, 0, 0],
                l = 0,
                c = null,
                p = 0,
                h = function () {
                    return e.charAt(p)
                };
            if (":" == h()) {
                if (":" != e.charAt(1)) return;
                p += 2, c = ++l
            }
            for (; h();) {
                if (8 == l) return;
                if (":" != h()) {
                    for (t = n = 0; n < 4 && Rd.test(h());) t = 16 * t + parseInt(h(), 16), p++, n++;
                    if ("." == h()) {
                        if (0 == n) return;
                        if (p -= n, l > 6) return;
                        for (r = 0; h();) {
                            if (a = null, r > 0) {
                                if (!("." == h() && r < 4)) return;
                                p++
                            }
                            if (!Sd.test(h())) return;
                            for (; Sd.test(h());) {
                                if (i = parseInt(h(), 10), null === a) a = i;
                                else {
                                    if (0 == a) return;
                                    a = 10 * a + i
                                }
                                if (a > 255) return;
                                p++
                            }
                            u[l] = 256 * u[l] + a, 2 != ++r && 4 != r || l++
                        }
                        if (4 != r) return;
                        break
                    }
                    if (":" == h()) {
                        if (p++, !h()) return
                    } else if (h()) return;
                    u[l++] = t
                } else {
                    if (null !== c) return;
                    p++, c = ++l
                }
            }
            if (null !== c)
                for (o = l - c, l = 7; 0 != l && o > 0;) s = u[l], u[l--] = u[c + o - 1], u[c + --o] = s;
            else if (8 != l) return;
            return u
        },
        zd = function (e) {
            var t, n, r, a;
            if ("number" == typeof e) {
                for (t = [], n = 0; n < 4; n++) t.unshift(e % 256), e = wd(e / 256);
                return t.join(".")
            }
            if ("object" == typeof e) {
                for (t = "", r = function (e) {
                        for (var t = null, n = 1, r = null, a = 0, i = 0; i < 8; i++) 0 !== e[i] ? (a > n && (t = r, n = a), r = null, a = 0) : (null === r && (r = i), ++a);
                        return a > n && (t = r, n = a), t
                    }(e), n = 0; n < 8; n++) a && 0 === e[n] || (a && (a = !1), r === n ? (t += n ? ":" : "::", a = !0) : (t += e[n].toString(16), n < 7 && (t += ":")));
                return "[" + t + "]"
            }
            return e
        },
        Pd = {},
        Bd = Jt({}, Pd, {
            " ": 1,
            '"': 1,
            "<": 1,
            ">": 1,
            "`": 1
        }),
        Wd = Jt({}, Bd, {
            "#": 1,
            "?": 1,
            "{": 1,
            "}": 1
        }),
        Vd = Jt({}, Wd, {
            "/": 1,
            ":": 1,
            ";": 1,
            "=": 1,
            "@": 1,
            "[": 1,
            "\\": 1,
            "]": 1,
            "^": 1,
            "|": 1
        }),
        Ud = function (e, t) {
            var n = md(e, 0);
            return n > 32 && n < 127 && !x(t, e) ? e : encodeURIComponent(e)
        },
        Gd = {
            ftp: 21,
            file: null,
            http: 80,
            https: 443,
            ws: 80,
            wss: 443
        },
        jd = function (e) {
            return x(Gd, e.scheme)
        },
        Hd = function (e) {
            return "" != e.username || "" != e.password
        },
        qd = function (e) {
            return !e.host || e.cannotBeABaseURL || "file" == e.scheme
        },
        Kd = function (e, t) {
            var n;
            return 2 == e.length && Nd.test(e.charAt(0)) && (":" == (n = e.charAt(1)) || !t && "|" == n)
        },
        Xd = function (e) {
            var t;
            return e.length > 1 && Kd(e.slice(0, 2)) && (2 == e.length || "/" === (t = e.charAt(2)) || "\\" === t || "?" === t || "#" === t)
        },
        Yd = function (e) {
            var t = e.path,
                n = t.length;
            !n || "file" == e.scheme && 1 == n && Kd(t[0], !0) || t.pop()
        },
        Jd = function (e) {
            return "." === e || "%2e" === e.toLowerCase()
        },
        Zd = {},
        Qd = {},
        $d = {},
        em = {},
        tm = {},
        nm = {},
        rm = {},
        am = {},
        im = {},
        om = {},
        sm = {},
        um = {},
        lm = {},
        cm = {},
        pm = {},
        hm = {},
        fm = {},
        dm = {},
        mm = {},
        vm = {},
        gm = {},
        ym = function (e, t, n, r) {
            var a, i, o, s, u, l = n || Zd,
                c = 0,
                p = "",
                h = !1,
                f = !1,
                d = !1;
            for (n || (e.scheme = "", e.username = "", e.password = "", e.host = null, e.port = null, e.path = [], e.query = null, e.fragment = null, e.cannotBeABaseURL = !1, t = t.replace(_d, "")), t = t.replace(Dd, ""), a = or(t); c <= a.length;) {
                switch (i = a[c], l) {
                    case Zd:
                        if (!i || !Nd.test(i)) {
                            if (n) return "Invalid scheme";
                            l = $d;
                            continue
                        }
                        p += i.toLowerCase(), l = Qd;
                        break;
                    case Qd:
                        if (i && (Id.test(i) || "+" == i || "-" == i || "." == i)) p += i.toLowerCase();
                        else {
                            if (":" != i) {
                                if (n) return "Invalid scheme";
                                p = "", l = $d, c = 0;
                                continue
                            }
                            if (n && (jd(e) != x(Gd, p) || "file" == p && (Hd(e) || null !== e.port) || "file" == e.scheme && !e.host)) return;
                            if (e.scheme = p, n) return void(jd(e) && Gd[e.scheme] == e.port && (e.port = null));
                            p = "", "file" == e.scheme ? l = cm : jd(e) && r && r.scheme == e.scheme ? l = em : jd(e) ? l = am : "/" == a[c + 1] ? (l = tm, c++) : (e.cannotBeABaseURL = !0, e.path.push(""), l = mm)
                        }
                        break;
                    case $d:
                        if (!r || r.cannotBeABaseURL && "#" != i) return "Invalid scheme";
                        if (r.cannotBeABaseURL && "#" == i) {
                            e.scheme = r.scheme, e.path = r.path.slice(), e.query = r.query, e.fragment = "", e.cannotBeABaseURL = !0, l = gm;
                            break
                        }
                        l = "file" == r.scheme ? cm : nm;
                        continue;
                    case em:
                        if ("/" != i || "/" != a[c + 1]) {
                            l = nm;
                            continue
                        }
                        l = im, c++;
                        break;
                    case tm:
                        if ("/" == i) {
                            l = om;
                            break
                        }
                        l = dm;
                        continue;
                    case nm:
                        if (e.scheme = r.scheme, i == fd) e.username = r.username, e.password = r.password, e.host = r.host, e.port = r.port, e.path = r.path.slice(), e.query = r.query;
                        else if ("/" == i || "\\" == i && jd(e)) l = rm;
                        else if ("?" == i) e.username = r.username, e.password = r.password, e.host = r.host, e.port = r.port, e.path = r.path.slice(), e.query = "", l = vm;
                        else {
                            if ("#" != i) {
                                e.username = r.username, e.password = r.password, e.host = r.host, e.port = r.port, e.path = r.path.slice(), e.path.pop(), l = dm;
                                continue
                            }
                            e.username = r.username, e.password = r.password, e.host = r.host, e.port = r.port, e.path = r.path.slice(), e.query = r.query, e.fragment = "", l = gm
                        }
                        break;
                    case rm:
                        if (!jd(e) || "/" != i && "\\" != i) {
                            if ("/" != i) {
                                e.username = r.username, e.password = r.password, e.host = r.host, e.port = r.port, l = dm;
                                continue
                            }
                            l = om
                        } else l = im;
                        break;
                    case am:
                        if (l = im, "/" != i || "/" != p.charAt(c + 1)) continue;
                        c++;
                        break;
                    case im:
                        if ("/" != i && "\\" != i) {
                            l = om;
                            continue
                        }
                        break;
                    case om:
                        if ("@" == i) {
                            h && (p = "%40" + p), h = !0, o = or(p);
                            for (var m = 0; m < o.length; m++) {
                                var v = o[m];
                                if (":" != v || d) {
                                    var g = Ud(v, Vd);
                                    d ? e.password += g : e.username += g
                                } else d = !0
                            }
                            p = ""
                        } else if (i == fd || "/" == i || "?" == i || "#" == i || "\\" == i && jd(e)) {
                            if (h && "" == p) return "Invalid authority";
                            c -= or(p).length + 1, p = "", l = sm
                        } else p += i;
                        break;
                    case sm:
                    case um:
                        if (n && "file" == e.scheme) {
                            l = hm;
                            continue
                        }
                        if (":" != i || f) {
                            if (i == fd || "/" == i || "?" == i || "#" == i || "\\" == i && jd(e)) {
                                if (jd(e) && "" == p) return "Invalid host";
                                if (n && "" == p && (Hd(e) || null !== e.port)) return;
                                if (s = Od(e, p)) return s;
                                if (p = "", l = fm, n) return;
                                continue
                            }
                            "[" == i ? f = !0 : "]" == i && (f = !1), p += i
                        } else {
                            if ("" == p) return "Invalid host";
                            if (s = Od(e, p)) return s;
                            if (p = "", l = lm, n == um) return
                        }
                        break;
                    case lm:
                        if (!Sd.test(i)) {
                            if (i == fd || "/" == i || "?" == i || "#" == i || "\\" == i && jd(e) || n) {
                                if ("" != p) {
                                    var y = parseInt(p, 10);
                                    if (y > 65535) return "Invalid port";
                                    e.port = jd(e) && y === Gd[e.scheme] ? null : y, p = ""
                                }
                                if (n) return;
                                l = fm;
                                continue
                            }
                            return "Invalid port"
                        }
                        p += i;
                        break;
                    case cm:
                        if (e.scheme = "file", "/" == i || "\\" == i) l = pm;
                        else {
                            if (!r || "file" != r.scheme) {
                                l = dm;
                                continue
                            }
                            if (i == fd) e.host = r.host, e.path = r.path.slice(), e.query = r.query;
                            else if ("?" == i) e.host = r.host, e.path = r.path.slice(), e.query = "", l = vm;
                            else {
                                if ("#" != i) {
                                    Xd(a.slice(c).join("")) || (e.host = r.host, e.path = r.path.slice(), Yd(e)), l = dm;
                                    continue
                                }
                                e.host = r.host, e.path = r.path.slice(), e.query = r.query, e.fragment = "", l = gm
                            }
                        }
                        break;
                    case pm:
                        if ("/" == i || "\\" == i) {
                            l = hm;
                            break
                        }
                        r && "file" == r.scheme && !Xd(a.slice(c).join("")) && (Kd(r.path[0], !0) ? e.path.push(r.path[0]) : e.host = r.host), l = dm;
                        continue;
                    case hm:
                        if (i == fd || "/" == i || "\\" == i || "?" == i || "#" == i) {
                            if (!n && Kd(p)) l = dm;
                            else if ("" == p) {
                                if (e.host = "", n) return;
                                l = fm
                            } else {
                                if (s = Od(e, p)) return s;
                                if ("localhost" == e.host && (e.host = ""), n) return;
                                p = "", l = fm
                            }
                            continue
                        }
                        p += i;
                        break;
                    case fm:
                        if (jd(e)) {
                            if (l = dm, "/" != i && "\\" != i) continue
                        } else if (n || "?" != i)
                            if (n || "#" != i) {
                                if (i != fd && (l = dm, "/" != i)) continue
                            } else e.fragment = "", l = gm;
                        else e.query = "", l = vm;
                        break;
                    case dm:
                        if (i == fd || "/" == i || "\\" == i && jd(e) || !n && ("?" == i || "#" == i)) {
                            if (".." === (u = (u = p).toLowerCase()) || "%2e." === u || ".%2e" === u || "%2e%2e" === u ? (Yd(e), "/" == i || "\\" == i && jd(e) || e.path.push("")) : Jd(p) ? "/" == i || "\\" == i && jd(e) || e.path.push("") : ("file" == e.scheme && !e.path.length && Kd(p) && (e.host && (e.host = ""), p = p.charAt(0) + ":"), e.path.push(p)), p = "", "file" == e.scheme && (i == fd || "?" == i || "#" == i))
                                for (; e.path.length > 1 && "" === e.path[0];) e.path.shift();
                            "?" == i ? (e.query = "", l = vm) : "#" == i && (e.fragment = "", l = gm)
                        } else p += Ud(i, Wd);
                        break;
                    case mm:
                        "?" == i ? (e.query = "", l = vm) : "#" == i ? (e.fragment = "", l = gm) : i != fd && (e.path[0] += Ud(i, Pd));
                        break;
                    case vm:
                        n || "#" != i ? i != fd && ("'" == i && jd(e) ? e.query += "%27" : e.query += "#" == i ? "%23" : Ud(i, Pd)) : (e.fragment = "", l = gm);
                        break;
                    case gm:
                        i != fd && (e.fragment += Ud(i, Bd))
                }
                c++
            }
        },
        bm = function (e) {
            var t, n, r = pl(this, bm, "URL"),
                a = arguments.length > 1 ? arguments[1] : void 0,
                i = String(e),
                s = bd(r, {
                    type: "URL"
                });
            if (void 0 !== a)
                if (a instanceof bm) t = xd(a);
                else if (n = ym(t = {}, String(a))) throw TypeError(n);
            if (n = ym(s, i, null, t)) throw TypeError(n);
            var u = s.searchParams = new gd,
                l = yd(u);
            l.updateSearchParams(s.query), l.updateURL = function () {
                s.query = String(u) || null
            }, o || (r.href = wm.call(r), r.origin = km.call(r), r.protocol = Nm.call(r), r.username = Im.call(r), r.password = Sm.call(r), r.host = Tm.call(r), r.hostname = Cm.call(r), r.port = Em.call(r), r.pathname = Rm.call(r), r.search = Am.call(r), r.searchParams = Fm.call(r), r.hash = _m.call(r))
        },
        xm = bm.prototype,
        wm = function () {
            var e = xd(this),
                t = e.scheme,
                n = e.username,
                r = e.password,
                a = e.host,
                i = e.port,
                o = e.path,
                s = e.query,
                u = e.fragment,
                l = t + ":";
            return null !== a ? (l += "//", Hd(e) && (l += n + (r ? ":" + r : "") + "@"), l += zd(a), null !== i && (l += ":" + i)) : "file" == t && (l += "//"), l += e.cannotBeABaseURL ? o[0] : o.length ? "/" + o.join("/") : "", null !== s && (l += "?" + s), null !== u && (l += "#" + u), l
        },
        km = function () {
            var e = xd(this),
                t = e.scheme,
                n = e.port;
            if ("blob" == t) try {
                return new URL(t.path[0]).origin
            } catch (e) {
                return "null"
            }
            return "file" != t && jd(e) ? t + "://" + zd(e.host) + (null !== n ? ":" + n : "") : "null"
        },
        Nm = function () {
            return xd(this).scheme + ":"
        },
        Im = function () {
            return xd(this).username
        },
        Sm = function () {
            return xd(this).password
        },
        Tm = function () {
            var e = xd(this),
                t = e.host,
                n = e.port;
            return null === t ? "" : null === n ? zd(t) : zd(t) + ":" + n
        },
        Cm = function () {
            var e = xd(this).host;
            return null === e ? "" : zd(e)
        },
        Em = function () {
            var e = xd(this).port;
            return null === e ? "" : String(e)
        },
        Rm = function () {
            var e = xd(this),
                t = e.path;
            return e.cannotBeABaseURL ? t[0] : t.length ? "/" + t.join("/") : ""
        },
        Am = function () {
            var e = xd(this).query;
            return e ? "?" + e : ""
        },
        Fm = function () {
            return xd(this).searchParams
        },
        _m = function () {
            var e = xd(this).fragment;
            return e ? "#" + e : ""
        },
        Dm = function (e, t) {
            return {
                get: e,
                set: t,
                configurable: !0,
                enumerable: !0
            }
        };
    if (o && ze(xm, {
            href: Dm(wm, function (e) {
                var t = xd(this),
                    n = String(e),
                    r = ym(t, n);
                if (r) throw TypeError(r);
                yd(t.searchParams).updateSearchParams(t.query)
            }),
            origin: Dm(km),
            protocol: Dm(Nm, function (e) {
                var t = xd(this);
                ym(t, String(e) + ":", Zd)
            }),
            username: Dm(Im, function (e) {
                var t = xd(this),
                    n = or(String(e));
                if (!qd(t)) {
                    t.username = "";
                    for (var r = 0; r < n.length; r++) t.username += Ud(n[r], Vd)
                }
            }),
            password: Dm(Sm, function (e) {
                var t = xd(this),
                    n = or(String(e));
                if (!qd(t)) {
                    t.password = "";
                    for (var r = 0; r < n.length; r++) t.password += Ud(n[r], Vd)
                }
            }),
            host: Dm(Tm, function (e) {
                var t = xd(this);
                t.cannotBeABaseURL || ym(t, String(e), sm)
            }),
            hostname: Dm(Cm, function (e) {
                var t = xd(this);
                t.cannotBeABaseURL || ym(t, String(e), um)
            }),
            port: Dm(Em, function (e) {
                var t = xd(this);
                qd(t) || ("" == (e = String(e)) ? t.port = null : ym(t, e, lm))
            }),
            pathname: Dm(Rm, function (e) {
                var t = xd(this);
                t.cannotBeABaseURL || (t.path = [], ym(t, e + "", fm))
            }),
            search: Dm(Am, function (e) {
                var t = xd(this);
                "" == (e = String(e)) ? t.query = null: ("?" == e.charAt(0) && (e = e.slice(1)), t.query = "", ym(t, e, vm)), yd(t.searchParams).updateSearchParams(t.query)
            }),
            searchParams: Dm(Fm),
            hash: Dm(_m, function (e) {
                var t = xd(this);
                "" != (e = String(e)) ? ("#" == e.charAt(0) && (e = e.slice(1)), t.fragment = "", ym(t, e, gm)) : t.fragment = null
            })
        }), te(xm, "toJSON", function () {
            return wm.call(this)
        }, {
            enumerable: !0
        }), te(xm, "toString", function () {
            return wm.call(this)
        }, {
            enumerable: !0
        }), vd) {
        var Om = vd.createObjectURL,
            Mm = vd.revokeObjectURL;
        Om && te(bm, "createObjectURL", function (e) {
            return Om.apply(vd, arguments)
        }), Mm && te(bm, "revokeObjectURL", function (e) {
            return Mm.apply(vd, arguments)
        })
    }

    function Lm(e) {
        var t, n;

        function r(t, n) {
            try {
                var i = e[t](n),
                    o = i.value,
                    s = o instanceof
                function (e) {
                    this.wrapped = e
                };
                Promise.resolve(s ? o.wrapped : o).then(function (e) {
                    s ? r("return" === t ? "return" : "next", e) : a(i.done ? "return" : "normal", e)
                }, function (e) {
                    r("throw", e)
                })
            } catch (e) {
                a("throw", e)
            }
        }

        function a(e, a) {
            switch (e) {
                case "return":
                    t.resolve({
                        value: a,
                        done: !0
                    });
                    break;
                case "throw":
                    t.reject(a);
                    break;
                default:
                    t.resolve({
                        value: a,
                        done: !1
                    })
            }(t = t.next) ? r(t.key, t.arg): n = null
        }
        this._invoke = function (e, a) {
            return new Promise(function (i, o) {
                var s = {
                    key: e,
                    arg: a,
                    resolve: i,
                    reject: o,
                    next: null
                };
                n ? n = n.next = s : (t = n = s, r(e, a))
            })
        }, "function" != typeof e.return && (this.return = void 0)
    }

    function zm(e, t, n, r, a, i, o) {
        try {
            var s = e[i](o),
                u = s.value
        } catch (e) {
            return void n(e)
        }
        s.done ? t(u) : Promise.resolve(u).then(r, a)
    }

    function Pm(e) {
        return function () {
            var t = this,
                n = arguments;
            return new Promise(function (r, a) {
                var i = e.apply(t, n);

                function o(e) {
                    zm(i, r, a, o, s, "next", e)
                }

                function s(e) {
                    zm(i, r, a, o, s, "throw", e)
                }
                o(void 0)
            })
        }
    }

    function Bm(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function Wm(e, t, n) {
        return t && Bm(e.prototype, t), n && Bm(e, n), e
    }

    function Vm(e, t) {
        e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t
    }

    function Um(e) {
        return (Um = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function Gm(e, t) {
        return (Gm = Object.setPrototypeOf || function (e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }

    function jm(e, t, n) {
        return (jm = function () {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0
            } catch (e) {
                return !1
            }
        }() ? Reflect.construct : function (e, t, n) {
            var r = [null];
            r.push.apply(r, t);
            var a = new(Function.bind.apply(e, r));
            return n && Gm(a, n.prototype), a
        }).apply(null, arguments)
    }

    function Hm(e) {
        var t = "function" == typeof Map ? new Map : void 0;
        return (Hm = function (e) {
            if (null === e || (n = e, -1 === Function.toString.call(n).indexOf("[native code]"))) return e;
            var n;
            if ("function" != typeof e) throw new TypeError("Super expression must either be null or a function");
            if (void 0 !== t) {
                if (t.has(e)) return t.get(e);
                t.set(e, r)
            }

            function r() {
                return jm(e, arguments, Um(this).constructor)
            }
            return r.prototype = Object.create(e.prototype, {
                constructor: {
                    value: r,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), Gm(r, e)
        })(e)
    }

    function qm(e) {
        if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e
    }

    function Km(e, t) {
        (null == t || t > e.length) && (t = e.length);
        for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
        return r
    }

    function Xm(e) {
        var t = 0;
        if ("undefined" == typeof Symbol || null == e[Symbol.iterator]) {
            if (Array.isArray(e) || (e = function (e, t) {
                    if (e) {
                        if ("string" == typeof e) return Km(e, t);
                        var n = Object.prototype.toString.call(e).slice(8, -1);
                        return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(n) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Km(e, t) : void 0
                    }
                }(e))) return function () {
                return t >= e.length ? {
                    done: !0
                } : {
                    done: !1,
                    value: e[t++]
                }
            };
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }
        return (t = e[Symbol.iterator]()).next.bind(t)
    }
    rt(bm, "URL"), Fe({
        global: !0,
        forced: !Lf,
        sham: !o
    }, {
        URL: bm
    }), Fe({
        target: "URL",
        proto: !0,
        enumerable: !0
    }, {
        toJSON: function () {
            return URL.prototype.toString.call(this)
        }
    }), n(function (e) {
        var t = function (e) {
            var t = Object.prototype,
                n = t.hasOwnProperty,
                r = "function" == typeof Symbol ? Symbol : {},
                a = r.iterator || "@@iterator",
                i = r.asyncIterator || "@@asyncIterator",
                o = r.toStringTag || "@@toStringTag";

            function s(e, t, n, r) {
                var a = t && t.prototype instanceof c ? t : c,
                    i = Object.create(a.prototype),
                    o = new k(r || []);
                return i._invoke = function (e, t, n) {
                    var r = "suspendedStart";
                    return function (a, i) {
                        if ("executing" === r) throw new Error("Generator is already running");
                        if ("completed" === r) {
                            if ("throw" === a) throw i;
                            return {
                                value: void 0,
                                done: !0
                            }
                        }
                        for (n.method = a, n.arg = i;;) {
                            var o = n.delegate;
                            if (o) {
                                var s = b(o, n);
                                if (s) {
                                    if (s === l) continue;
                                    return s
                                }
                            }
                            if ("next" === n.method) n.sent = n._sent = n.arg;
                            else if ("throw" === n.method) {
                                if ("suspendedStart" === r) throw r = "completed", n.arg;
                                n.dispatchException(n.arg)
                            } else "return" === n.method && n.abrupt("return", n.arg);
                            r = "executing";
                            var c = u(e, t, n);
                            if ("normal" === c.type) {
                                if (r = n.done ? "completed" : "suspendedYield", c.arg === l) continue;
                                return {
                                    value: c.arg,
                                    done: n.done
                                }
                            }
                            "throw" === c.type && (r = "completed", n.method = "throw", n.arg = c.arg)
                        }
                    }
                }(e, n, o), i
            }

            function u(e, t, n) {
                try {
                    return {
                        type: "normal",
                        arg: e.call(t, n)
                    }
                } catch (e) {
                    return {
                        type: "throw",
                        arg: e
                    }
                }
            }
            e.wrap = s;
            var l = {};

            function c() {}

            function p() {}

            function h() {}
            var f = {};
            f[a] = function () {
                return this
            };
            var d = Object.getPrototypeOf,
                m = d && d(d(N([])));
            m && m !== t && n.call(m, a) && (f = m);
            var v = h.prototype = c.prototype = Object.create(f);

            function g(e) {
                ["next", "throw", "return"].forEach(function (t) {
                    e[t] = function (e) {
                        return this._invoke(t, e)
                    }
                })
            }

            function y(e, t) {
                var r;
                this._invoke = function (a, i) {
                    function o() {
                        return new t(function (r, o) {
                            ! function r(a, i, o, s) {
                                var l = u(e[a], e, i);
                                if ("throw" !== l.type) {
                                    var c = l.arg,
                                        p = c.value;
                                    return p && "object" == typeof p && n.call(p, "__await") ? t.resolve(p.__await).then(function (e) {
                                        r("next", e, o, s)
                                    }, function (e) {
                                        r("throw", e, o, s)
                                    }) : t.resolve(p).then(function (e) {
                                        c.value = e, o(c)
                                    }, function (e) {
                                        return r("throw", e, o, s)
                                    })
                                }
                                s(l.arg)
                            }(a, i, r, o)
                        })
                    }
                    return r = r ? r.then(o, o) : o()
                }
            }

            function b(e, t) {
                var n = e.iterator[t.method];
                if (void 0 === n) {
                    if (t.delegate = null, "throw" === t.method) {
                        if (e.iterator.return && (t.method = "return", t.arg = void 0, b(e, t), "throw" === t.method)) return l;
                        t.method = "throw", t.arg = new TypeError("The iterator does not provide a 'throw' method")
                    }
                    return l
                }
                var r = u(n, e.iterator, t.arg);
                if ("throw" === r.type) return t.method = "throw", t.arg = r.arg, t.delegate = null, l;
                var a = r.arg;
                return a ? a.done ? (t[e.resultName] = a.value, t.next = e.nextLoc, "return" !== t.method && (t.method = "next", t.arg = void 0), t.delegate = null, l) : a : (t.method = "throw", t.arg = new TypeError("iterator result is not an object"), t.delegate = null, l)
            }

            function x(e) {
                var t = {
                    tryLoc: e[0]
                };
                1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t)
            }

            function w(e) {
                var t = e.completion || {};
                t.type = "normal", delete t.arg, e.completion = t
            }

            function k(e) {
                this.tryEntries = [{
                    tryLoc: "root"
                }], e.forEach(x, this), this.reset(!0)
            }

            function N(e) {
                if (e) {
                    var t = e[a];
                    if (t) return t.call(e);
                    if ("function" == typeof e.next) return e;
                    if (!isNaN(e.length)) {
                        var r = -1,
                            i = function t() {
                                for (; ++r < e.length;)
                                    if (n.call(e, r)) return t.value = e[r], t.done = !1, t;
                                return t.value = void 0, t.done = !0, t
                            };
                        return i.next = i
                    }
                }
                return {
                    next: I
                }
            }

            function I() {
                return {
                    value: void 0,
                    done: !0
                }
            }
            return p.prototype = v.constructor = h, h.constructor = p, h[o] = p.displayName = "GeneratorFunction", e.isGeneratorFunction = function (e) {
                var t = "function" == typeof e && e.constructor;
                return !!t && (t === p || "GeneratorFunction" === (t.displayName || t.name))
            }, e.mark = function (e) {
                return Object.setPrototypeOf ? Object.setPrototypeOf(e, h) : (e.__proto__ = h, o in e || (e[o] = "GeneratorFunction")), e.prototype = Object.create(v), e
            }, e.awrap = function (e) {
                return {
                    __await: e
                }
            }, g(y.prototype), y.prototype[i] = function () {
                return this
            }, e.AsyncIterator = y, e.async = function (t, n, r, a, i) {
                void 0 === i && (i = Promise);
                var o = new y(s(t, n, r, a), i);
                return e.isGeneratorFunction(n) ? o : o.next().then(function (e) {
                    return e.done ? e.value : o.next()
                })
            }, g(v), v[o] = "Generator", v[a] = function () {
                return this
            }, v.toString = function () {
                return "[object Generator]"
            }, e.keys = function (e) {
                var t = [];
                for (var n in e) t.push(n);
                return t.reverse(),
                    function n() {
                        for (; t.length;) {
                            var r = t.pop();
                            if (r in e) return n.value = r, n.done = !1, n
                        }
                        return n.done = !0, n
                    }
            }, e.values = N, k.prototype = {
                constructor: k,
                reset: function (e) {
                    if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(w), !e)
                        for (var t in this) "t" === t.charAt(0) && n.call(this, t) && !isNaN(+t.slice(1)) && (this[t] = void 0)
                },
                stop: function () {
                    this.done = !0;
                    var e = this.tryEntries[0].completion;
                    if ("throw" === e.type) throw e.arg;
                    return this.rval
                },
                dispatchException: function (e) {
                    if (this.done) throw e;
                    var t = this;

                    function r(n, r) {
                        return o.type = "throw", o.arg = e, t.next = n, r && (t.method = "next", t.arg = void 0), !!r
                    }
                    for (var a = this.tryEntries.length - 1; a >= 0; --a) {
                        var i = this.tryEntries[a],
                            o = i.completion;
                        if ("root" === i.tryLoc) return r("end");
                        if (i.tryLoc <= this.prev) {
                            var s = n.call(i, "catchLoc"),
                                u = n.call(i, "finallyLoc");
                            if (s && u) {
                                if (this.prev < i.catchLoc) return r(i.catchLoc, !0);
                                if (this.prev < i.finallyLoc) return r(i.finallyLoc)
                            } else if (s) {
                                if (this.prev < i.catchLoc) return r(i.catchLoc, !0)
                            } else {
                                if (!u) throw new Error("try statement without catch or finally");
                                if (this.prev < i.finallyLoc) return r(i.finallyLoc)
                            }
                        }
                    }
                },
                abrupt: function (e, t) {
                    for (var r = this.tryEntries.length - 1; r >= 0; --r) {
                        var a = this.tryEntries[r];
                        if (a.tryLoc <= this.prev && n.call(a, "finallyLoc") && this.prev < a.finallyLoc) {
                            var i = a;
                            break
                        }
                    }
                    i && ("break" === e || "continue" === e) && i.tryLoc <= t && t <= i.finallyLoc && (i = null);
                    var o = i ? i.completion : {};
                    return o.type = e, o.arg = t, i ? (this.method = "next", this.next = i.finallyLoc, l) : this.complete(o)
                },
                complete: function (e, t) {
                    if ("throw" === e.type) throw e.arg;
                    return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), l
                },
                finish: function (e) {
                    for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                        var n = this.tryEntries[t];
                        if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), w(n), l
                    }
                },
                catch: function (e) {
                    for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                        var n = this.tryEntries[t];
                        if (n.tryLoc === e) {
                            var r = n.completion;
                            if ("throw" === r.type) {
                                var a = r.arg;
                                w(n)
                            }
                            return a
                        }
                    }
                    throw new Error("illegal catch attempt")
                },
                delegateYield: function (e, t, n) {
                    return this.delegate = {
                        iterator: N(e),
                        resultName: t,
                        nextLoc: n
                    }, "next" === this.method && (this.arg = void 0), l
                }
            }, e
        }(e.exports);
        try {
            regeneratorRuntime = t
        } catch (e) {
            Function("r", "regeneratorRuntime = r")(t)
        }
    }), "function" == typeof Symbol && Symbol.asyncIterator && (Lm.prototype[Symbol.asyncIterator] = function () {
        return this
    }), Lm.prototype.next = function (e) {
        return this._invoke("next", e)
    }, Lm.prototype.throw = function (e) {
        return this._invoke("throw", e)
    }, Lm.prototype.return = function (e) {
        return this._invoke("return", e)
    };
    var Ym = function () {
            function e(e, t) {
                this.backend = e, this.dataMover = t, this.data = new WeakMap, this.dataIdsCount = 0
            }
            var t = e.prototype;
            return t.get = function (e) {
                return this.data.has(e) || this.dataMover.moveData(this.backend, e), this.data.get(e)
            }, t.set = function (e, t) {
                this.dataIdsCount++, this.data.set(e, t)
            }, t.has = function (e) {
                return this.data.has(e)
            }, t.delete = function (e) {
                return this.dataIdsCount--, this.data.delete(e)
            }, t.numDataIds = function () {
                return this.dataIdsCount
            }, e
        }(),
        Jm = function () {
            function e() {}
            var t = e.prototype;
            return t.refCount = function (e) {
                return Zm("refCount")
            }, t.incRef = function (e) {
                return Zm("incRef")
            }, t.timerAvailable = function () {
                return !0
            }, t.time = function (e) {
                return Zm("time")
            }, t.read = function (e) {
                return Zm("read")
            }, t.readSync = function (e) {
                return Zm("readSync")
            }, t.numDataIds = function () {
                return Zm("numDataIds")
            }, t.disposeData = function (e, t) {
                return Zm("disposeData")
            }, t.write = function (e, t, n) {
                return Zm("write")
            }, t.move = function (e, t, n, r, a) {
                return Zm("move")
            }, t.memory = function () {
                return Zm("memory")
            }, t.floatPrecision = function () {
                return Zm("floatPrecision")
            }, t.epsilon = function () {
                return 32 === this.floatPrecision() ? 1e-7 : 1e-4
            }, t.dispose = function () {
                return Zm("dispose")
            }, e
        }();

    function Zm(e) {
        throw new Error("'" + e + "' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen")
    }

    function Qm(e) {
        for (var t = e.length, n = 0, r = 0; t > 0;) r = Math.random() * t | 0, n = e[--t], e[t] = e[r], e[r] = n
    }

    function $m(e, t, n) {
        return Math.max(e, Math.min(t, n))
    }

    function ev(e) {
        return e % 2 == 0 ? e : e + 1
    }

    function tv(e) {
        for (var t = 0, n = 0; n < e.length; n++) t += e[n];
        return t
    }

    function nv(e, t) {
        if (!e) throw new Error("string" == typeof t ? t : t())
    }

    function rv(e, t, n) {
        void 0 === n && (n = ""), nv(sv(e, t), function () {
            return n + " Shapes " + e + " and " + t + " must match"
        })
    }

    function av(e) {
        nv(null != e, function () {
            return "The input to the tensor constructor must be a non-null value."
        })
    }

    function iv(e, t, n) {
        if (void 0 === t && (t = []), void 0 === n && (n = !1), null == t && (t = []), Array.isArray(e) || xv(e) && !n)
            for (var r = 0; r < e.length; ++r) iv(e[r], t, n);
        else t.push(e);
        return t
    }

    function ov(e) {
        if (0 === e.length) return 1;
        for (var t = e[0], n = 1; n < e.length; n++) t *= e[n];
        return t
    }

    function sv(e, t) {
        if (e === t) return !0;
        if (null == e || null == t) return !1;
        if (e.length !== t.length) return !1;
        for (var n = 0; n < e.length; n++)
            if (e[n] !== t[n]) return !1;
        return !0
    }

    function uv(e) {
        return e % 1 == 0
    }

    function lv(e) {
        var t = Math.ceil(Math.sqrt(e));
        return [t, Math.ceil(e / t)]
    }

    function cv(e, t) {
        return t <= e.length ? e : e + " ".repeat(t - e.length)
    }

    function pv(e, t, n) {
        return void 0 === t && (t = function (e) {
            return 0
        }), new Promise(function (r, a) {
            var i = 0;
            ! function o() {
                if (e()) r();
                else {
                    var s = t(++i);
                    null != n && i >= n ? a() : setTimeout(o, s)
                }
            }()
        })
    }

    function hv(e, t) {
        for (var n = 1, r = -1, a = 0; a < e.length; ++a)
            if (e[a] >= 0) n *= e[a];
            else if (-1 === e[a]) {
            if (-1 !== r) throw Error("Shapes can only have 1 implicit size. Found -1 at dim " + r + " and dim " + a);
            r = a
        } else if (e[a] < 0) throw Error("Shapes can not be < 0. Found " + e[a] + " at dim " + a);
        if (-1 === r) {
            if (t > 0 && t !== n) throw Error("Size(" + t + ") must match the product of shape " + e);
            return e
        }
        if (0 === n) throw Error("Cannot infer the missing size in [" + e + "] when there are 0 elements");
        if (t % n != 0) throw Error("The implicit shape can't be a fractional number. Got " + t + " / " + n);
        var i = e.slice();
        return i[r] = t / n, i
    }

    function fv(e, t) {
        var n = t.length;
        return nv((e = null == e ? t.map(function (e, t) {
            return t
        }) : [].concat(e)).every(function (e) {
            return e >= -n && e < n
        }), function () {
            return "All values in axis param must be in range [-" + n + ", " + n + ") but got axis " + e
        }), nv(e.every(function (e) {
            return uv(e)
        }), function () {
            return "All values in axis param must be integers but got axis " + e
        }), e.map(function (e) {
            return e < 0 ? n + e : e
        })
    }

    function dv(e, t) {
        for (var n = [], r = [], a = null != t && Array.isArray(t) && 0 === t.length, i = null == t || a ? null : fv(t, e).sort(), o = 0, s = 0; s < e.length; ++s) {
            if (null != i) {
                if (i[o] === s && 1 !== e[s]) throw new Error("Can't squeeze axis " + s + " since its dim '" + e[s] + "' is not 1");
                (null == i[o] || i[o] > s) && 1 === e[s] && (n.push(e[s]), r.push(s)), i[o] <= s && o++
            }
            1 !== e[s] && (n.push(e[s]), r.push(s))
        }
        return {
            newShape: n,
            keptDims: r
        }
    }

    function mv(e, t) {
        var n = null;
        if (null == e || "float32" === e) n = new Float32Array(t);
        else if ("int32" === e) n = new Int32Array(t);
        else {
            if ("bool" !== e) throw new Error("Unknown data type " + e);
            n = new Uint8Array(t)
        }
        return n
    }

    function vv(e, t) {
        var n = null;
        if (null == e || "float32" === e) n = new Float32Array(t);
        else if ("int32" === e) n = new Int32Array(t);
        else if ("bool" === e) n = new Uint8Array(t);
        else {
            if ("string" !== e) throw new Error("Unknown data type " + e);
            n = new Array(t)
        }
        return n
    }

    function gv(e, t) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            if (isNaN(r) || !isFinite(r)) throw Error("A tensor of type " + t + " being uploaded contains " + r + ".")
        }
    }

    function yv(e) {
        return "bool" === e || "complex64" === e || "float32" === e || "int32" === e || "string" === e
    }

    function bv(e, t) {
        return !("complex64" === t || "float32" === t && "complex64" !== e || "int32" === t && "float32" !== e && "complex64" !== e || "bool" === t && "bool" === e)
    }

    function xv(e) {
        return e instanceof Float32Array || e instanceof Int32Array || e instanceof Uint8Array
    }

    function wv(e) {
        if ("float32" === e || "int32" === e) return 4;
        if ("complex64" === e) return 8;
        if ("bool" === e) return 1;
        throw new Error("Unknown dtype " + e)
    }

    function kv(e) {
        if (null == e) return 0;
        var t = 0;
        return e.forEach(function (e) {
            return t += e.length
        }), t
    }

    function Nv(e) {
        return "string" == typeof e || e instanceof String
    }

    function Iv(e) {
        return "boolean" == typeof e
    }

    function Sv(e) {
        return "number" == typeof e
    }

    function Tv(e) {
        return Array.isArray(e) ? Tv(e[0]) : e instanceof Float32Array ? "float32" : e instanceof Int32Array || e instanceof Uint8Array ? "int32" : Sv(e) ? "float32" : Nv(e) ? "string" : Iv(e) ? "bool" : "float32"
    }

    function Cv(e) {
        return !!(e && e.constructor && e.call && e.apply)
    }

    function Ev(e, t) {
        for (var n = t; n < e; ++n)
            if (e % n == 0) return n;
        return e
    }

    function Rv(e) {
        var t = e.length;
        if (t < 2) return [];
        var n = new Array(t - 1);
        n[t - 2] = e[t - 1];
        for (var r = t - 3; r >= 0; --r) n[r] = n[r + 1] * e[r + 1];
        return n
    }

    function Av(e, t) {
        if (0 === e.length) return t[0];
        var n = e.reduce(function (e, t) {
            return e * t
        });
        if (0 === n) return [];
        if (n !== t.length) throw new Error("[" + e + "] does not match the input size " + t.length + ".");
        return function e(t, n, r) {
            var a = new Array;
            if (1 === n.length)
                for (var i = n[0], o = 0; o < i; o++) a[o] = r[t + o];
            else
                for (var s = n[0], u = n.slice(1), l = u.reduce(function (e, t) {
                        return e * t
                    }), c = 0; c < s; c++) a[c] = e(t + c * l, u, r);
            return a
        }(0, e, t)
    }

    function Fv(e, t) {
        for (var n = _v(e, t), r = 0; r < n.length; r++) n[r] = 1;
        return n
    }

    function _v(e, t) {
        if (null == t || "float32" === t || "complex64" === t) return new Float32Array(e);
        if ("int32" === t) return new Int32Array(e);
        if ("bool" === t) return new Uint8Array(e);
        throw new Error("Unknown data type " + t)
    }

    function Dv(e, t) {
        var n = e.reduce(function (e, t) {
            return e * t
        }, 1);
        if (null == t || "float32" === t) return Av(e, new Float32Array(n));
        if ("int32" === t) return Av(e, new Int32Array(n));
        if ("bool" === t) return Av(e, new Uint8Array(n));
        throw new Error("Unknown data type " + t)
    }

    function Ov(e) {
        e.forEach(function (t) {
            nv(Number.isInteger(t) && t >= 0, function () {
                return "Tensor must have a shape comprised of positive integers but got shape [" + e + "]."
            })
        })
    }

    function Mv(e, t, n) {
        if (0 === t) return 0;
        if (1 === t) return e[0];
        for (var r = e[e.length - 1], a = 0; a < e.length - 1; ++a) r += n[a] * e[a];
        return r
    }

    function Lv(e, t, n) {
        if (0 === t) return [];
        if (1 === t) return [e];
        for (var r = new Array(t), a = 0; a < r.length - 1; ++a) r[a] = Math.floor(e / n[a]), e -= r[a] * n[a];
        return r[r.length - 1] = e, r
    }

    function zv(e) {
        return e && e.then && "function" == typeof e.then
    }
    var Pv, Bv = function () {
        function e(e) {
            this.global = e, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.populateURLFlags()
        }
        var t = e.prototype;
        return t.setPlatform = function (e, t) {
            null != this.platform && console.warn("Platform " + this.platformName + " has already been set. Overwriting the platform with " + t + "."), this.platformName = e, this.platform = t
        }, t.registerFlag = function (e, t, n) {
            if (this.flagRegistry[e] = {
                    evaluationFn: t,
                    setHook: n
                }, null != this.urlFlags[e]) {
                var r = this.urlFlags[e];
                console.warn("Setting feature override from URL " + e + ": " + r + "."), this.set(e, r)
            }
        }, t.getAsync = function () {
            var e = Pm(regeneratorRuntime.mark(function e(t) {
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (!(t in this.flags)) {
                                e.next = 2;
                                break
                            }
                            return e.abrupt("return", this.flags[t]);
                        case 2:
                            return e.next = 4, this.evaluateFlag(t);
                        case 4:
                            return this.flags[t] = e.sent, e.abrupt("return", this.flags[t]);
                        case 6:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function (t) {
                return e.apply(this, arguments)
            }
        }(), t.get = function (e) {
            if (e in this.flags) return this.flags[e];
            var t = this.evaluateFlag(e);
            if (zv(t)) throw new Error("Flag " + e + " cannot be synchronously evaluated. Please use getAsync() instead.");
            return this.flags[e] = t, this.flags[e]
        }, t.getNumber = function (e) {
            return this.get(e)
        }, t.getBool = function (e) {
            return this.get(e)
        }, t.getFlags = function () {
            return this.flags
        }, t.set = function (e, t) {
            if (null == this.flagRegistry[e]) throw new Error("Cannot set flag " + e + " as it has not been registered.");
            this.flags[e] = t, null != this.flagRegistry[e].setHook && this.flagRegistry[e].setHook(t)
        }, t.evaluateFlag = function (e) {
            if (null == this.flagRegistry[e]) throw new Error("Cannot evaluate flag '" + e + "': no evaluation function found.");
            return this.flagRegistry[e].evaluationFn()
        }, t.setFlags = function (e) {
            this.flags = Object.assign({}, e)
        }, t.reset = function () {
            this.flags = {}, this.urlFlags = {}, this.populateURLFlags()
        }, t.populateURLFlags = function () {
            var e = this;
            if (void 0 !== this.global && void 0 !== this.global.location && void 0 !== this.global.location.search) {
                var t, n, r = (t = this.global.location.search, n = {}, t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function (e) {
                    for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), a = 1; a < t; a++) r[a - 1] = arguments[a];
                    return function (e, t, n) {
                        e[decodeURIComponent(t)] = decodeURIComponent(n || "")
                    }(n, r[0], r[1]), r.join("=")
                }), n);
                "tfjsflags" in r && r.tfjsflags.split(",").forEach(function (t) {
                    var n = t.split(":"),
                        r = n[0],
                        a = n[1];
                    e.urlFlags[r] = function (e, t) {
                        if ("true" === (t = t.toLowerCase()) || "false" === t) return "true" === t;
                        if ("" + +t === t) return +t;
                        throw new Error("Could not parse value flag value " + t + " for flag " + e + ".")
                    }(r, a)
                })
            }
        }, Wm(e, [{
            key: "features",
            get: function () {
                return this.flags
            }
        }]), e
    }();

    function Wv() {
        return e.ENV
    }

    function Vv() {
        if (null == Pv) {
            var e;
            if ("undefined" != typeof window) e = window;
            else if ("undefined" != typeof global) e = global;
            else if ("undefined" != typeof process) e = process;
            else {
                if ("undefined" == typeof self) throw new Error("Could not find a global object");
                e = self
            }
            Pv = e
        }
        return Pv
    }

    function Uv(e, t) {
        var n, r = (null == (n = Vv())._tfGlobals && (n._tfGlobals = new Map), n._tfGlobals);
        if (r.has(e)) return r.get(e);
        var a = t();
        return r.set(e, a), r.get(e)
    }
    e.ENV = null;
    var Gv = "Add",
        jv = "Cos",
        Hv = "Elu",
        qv = "Erf",
        Kv = "Exp",
        Xv = "Log",
        Yv = "Mod",
        Jv = "Pow",
        Zv = "Sin",
        Qv = "Sub",
        $v = "Tan",
        eg = Uv("kernelRegistry", function () {
            return new Map
        }),
        tg = Uv("gradRegistry", function () {
            return new Map
        });

    function ng(e, t) {
        var n = sg(e, t);
        return eg.get(n)
    }

    function rg(e) {
        return tg.get(e)
    }

    function ag(e) {
        for (var t = eg.entries(), n = [];;) {
            var r = t.next(),
                a = r.done,
                i = r.value;
            if (a) break;
            var o = i[0],
                s = i[1];
            o.split("_")[0] === e && n.push(s)
        }
        return n
    }

    function ig(e) {
        var t = e.kernelName,
            n = e.backendName,
            r = sg(t, n);
        eg.has(r) && console.warn("The kernel '" + t + "' for backend '" + n + "' is already registered"), eg.set(r, e)
    }

    function og(e) {
        var t = e.kernelName;
        tg.has(t) && Wv().getBool("DEBUG") && console.warn("Overriding the gradient for '" + t + "'"), tg.set(t, e)
    }

    function sg(e, t) {
        return t + "_" + e
    }

    function ug(e, t) {
        return "string" === t ? hg(e) : lg([e], t)
    }

    function lg(e, t) {
        if ("string" === t) throw new Error("Cannot convert a string[] to a TypedArray");
        if (Array.isArray(e) && (e = iv(e)), Wv().getBool("DEBUG") && gv(e, t), function (e, t) {
                return e instanceof Float32Array && "float32" === t || e instanceof Int32Array && "int32" === t || e instanceof Uint8Array && "bool" === t
            }(e, t)) return e;
        if (null == t || "float32" === t || "complex64" === t) return new Float32Array(e);
        if ("int32" === t) return new Int32Array(e);
        if ("bool" === t) {
            for (var n = new Uint8Array(e.length), r = 0; r < n.length; ++r) 0 !== Math.round(e[r]) && (n[r] = 1);
            return n
        }
        throw new Error("Unknown data type " + t)
    }

    function cg() {
        return Wv().platform.now()
    }

    function pg(e, t) {
        return Wv().platform.fetch(e, t)
    }

    function hg(e, t) {
        return void 0 === t && (t = "utf-8"), t = t || "utf-8", Wv().platform.encode(e, t)
    }

    function fg(e, t) {
        return void 0 === t && (t = "utf-8"), t = t || "utf-8", Wv().platform.decode(e, t)
    }
    var dg = {
            __proto__: null,
            createScalarValue: ug,
            toTypedArray: lg,
            now: cg,
            fetch: pg,
            encodeString: hg,
            decodeString: fg,
            shuffle: Qm,
            shuffleCombo: function (e, t) {
                if (e.length !== t.length) throw new Error("Array sizes must match to be shuffled together First array length was " + e.length + "Second array length was " + t.length);
                for (var n, r, a = e.length, i = 0; a > 0;) i = Math.random() * a | 0, n = e[--a], r = t[a], e[a] = e[i], t[a] = t[i], e[i] = n, t[i] = r
            },
            clamp: $m,
            nearestLargerEven: ev,
            sum: tv,
            randUniform: function (e, t) {
                var n = Math.random();
                return t * n + (1 - n) * e
            },
            distSquared: function (e, t) {
                for (var n = 0, r = 0; r < e.length; r++) {
                    var a = Number(e[r]) - Number(t[r]);
                    n += a * a
                }
                return n
            },
            assert: nv,
            assertShapesMatch: rv,
            assertNonNull: av,
            flatten: iv,
            sizeFromShape: ov,
            isScalarShape: function (e) {
                return 0 === e.length
            },
            arraysEqual: sv,
            isInt: uv,
            tanh: function (e) {
                if (null != Math.tanh) return Math.tanh(e);
                if (e === 1 / 0) return 1;
                if (e === -1 / 0) return -1;
                var t = Math.exp(2 * e);
                return (t - 1) / (t + 1)
            },
            sizeToSquarishShape: lv,
            createShuffledIndices: function (e) {
                for (var t = new Uint32Array(e), n = 0; n < e; ++n) t[n] = n;
                return Qm(t), t
            },
            rightPad: cv,
            repeatedTry: pv,
            inferFromImplicitShape: hv,
            parseAxisParam: fv,
            squeezeShape: dv,
            getTypedArrayFromDType: mv,
            getArrayFromDType: vv,
            checkConversionForErrors: gv,
            isValidDtype: yv,
            hasEncodingLoss: bv,
            isTypedArray: xv,
            bytesPerElement: wv,
            bytesFromStringArray: kv,
            isString: Nv,
            isBoolean: Iv,
            isNumber: Sv,
            inferDtype: Tv,
            isFunction: Cv,
            nearestDivisor: Ev,
            computeStrides: Rv,
            toNestedArray: Av,
            makeOnesTypedArray: Fv,
            makeZerosTypedArray: _v,
            makeZerosNestedTypedArray: Dv,
            assertNonNegativeIntegerDimensions: Ov,
            locToIndex: Mv,
            indexToLoc: Lv,
            isPromise: zv
        },
        mg = function () {
            function e(e, t) {
                this.backendTimer = e, this.logger = t, null == t && (this.logger = new vg)
            }
            var t = e.prototype;
            return t.profileKernel = function (e, t, n) {
                var r, a, i = function () {
                        r = n()
                    },
                    o = cg();
                if (this.backendTimer.timerAvailable()) a = this.backendTimer.time(i);
                else {
                    i();
                    for (var s, u = Xm(r); !(s = u()).done;) s.value.dataSync();
                    a = Promise.resolve({
                        kernelMs: cg() - o
                    })
                }
                if (Wv().getBool("CHECK_COMPUTATION_FOR_ERRORS"))
                    for (var l = function (t) {
                            var n = r[t];
                            n.data().then(function (t) {
                                ! function (e, t, n) {
                                    if ("float32" !== t) return !1;
                                    for (var r = 0; r < e.length; r++) {
                                        var a = e[r];
                                        if (isNaN(a) || !isFinite(a)) return console.warn("Found " + a + " in the result of '" + n + "'"), !0
                                    }
                                }(t, n.dtype, e)
                            })
                        }, c = 0; c < r.length; c++) l(c);
                return {
                    kernelName: e,
                    outputs: r,
                    inputs: t,
                    timeMs: a.then(function (e) {
                        return e.kernelMs
                    }),
                    extraInfo: a.then(function (e) {
                        return null != e.getExtraProfileInfo ? e.getExtraProfileInfo() : ""
                    })
                }
            }, t.logKernelProfile = function (e) {
                var t = this,
                    n = e.kernelName,
                    r = e.outputs,
                    a = e.timeMs,
                    i = e.inputs,
                    o = e.extraInfo;
                r.forEach(function (e) {
                    Promise.all([e.data(), a, o]).then(function (r) {
                        t.logger.logKernelProfile(n, e, r[0], r[1], i, r[2])
                    })
                })
            }, e
        }(),
        vg = function () {
            function e() {}
            return e.prototype.logKernelProfile = function (e, t, n, r, a, i) {
                var o = "number" == typeof r ? cv(r + "ms", 9) : r.error,
                    s = cv(e, 25),
                    u = t.rank,
                    l = t.size,
                    c = cv(t.shape.toString(), 14),
                    p = "";
                for (var h in a) {
                    var f = a[h];
                    if (null != f) {
                        var d = f.shape || t.shape,
                            m = d.length;
                        p += h + ": " + m + "D " + (m > 0 ? d : "") + " "
                    }
                }
                console.log("%c" + s + "\t%c" + o + "\t%c" + u + "D " + c + "\t%c" + l + "\t%c" + p + "\t%c" + i, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue")
            }, e
        }();

    function gg(e, t, n) {
        return cv(Array.isArray(e) ? parseFloat(e[0].toFixed(7)) + " + " + parseFloat(e[1].toFixed(7)) + "j" : Nv(e) ? "'" + e + "'" : "bool" === n ? yg(e) : parseFloat(e.toFixed(7)).toString(), t)
    }

    function yg(e) {
        return 0 === e ? "false" : "true"
    }

    function bg(e) {
        for (var t = [], n = 0; n < e.length; n += 2) t.push([e[n], e[n + 1]]);
        return t
    }
    var xg = function () {
            function e(e, t, n) {
                var r = this;
                if (this.dtype = t, this.shape = e.slice(), this.size = ov(e), null != n) {
                    var a = n.length;
                    nv(a === this.size, function () {
                        return "Length of values '" + a + "' does not match the size inferred by the shape '" + r.size + "'."
                    })
                }
                if ("complex64" === t) throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
                this.values = n || vv(t, this.size), this.strides = Rv(e)
            }
            var t = e.prototype;
            return t.set = function (e) {
                for (var t = this, n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++) r[a - 1] = arguments[a];
                0 === r.length && (r = [0]), nv(r.length === this.rank, function () {
                    return "The number of provided coordinates (" + r.length + ") must match the rank (" + t.rank + ")"
                });
                var i = this.locToIndex(r);
                this.values[i] = e
            }, t.get = function () {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                0 === t.length && (t = [0]);
                for (var r = 0, a = 0, i = t; a < i.length; a++) {
                    var o = i[a];
                    if (o < 0 || o >= this.shape[r]) {
                        var s = "Requested out of range element at " + t + ".   Buffer shape=" + this.shape;
                        throw new Error(s)
                    }
                    r++
                }
                for (var u = t[t.length - 1], l = 0; l < t.length - 1; ++l) u += this.strides[l] * t[l];
                return this.values[u]
            }, t.locToIndex = function (e) {
                if (0 === this.rank) return 0;
                if (1 === this.rank) return e[0];
                for (var t = e[e.length - 1], n = 0; n < e.length - 1; ++n) t += this.strides[n] * e[n];
                return t
            }, t.indexToLoc = function (e) {
                if (0 === this.rank) return [];
                if (1 === this.rank) return [e];
                for (var t = new Array(this.shape.length), n = 0; n < t.length - 1; ++n) t[n] = Math.floor(e / this.strides[n]), e -= t[n] * this.strides[n];
                return t[t.length - 1] = e, t
            }, t.toTensor = function () {
                return wg().makeTensor(this.values, this.shape, this.dtype)
            }, Wm(e, [{
                key: "rank",
                get: function () {
                    return this.shape.length
                }
            }]), e
        }(),
        wg = null,
        kg = null,
        Ng = function () {
            function e(e, t, n, r) {
                this.kept = !1, this.isDisposedInternal = !1, this.shape = e.slice(), this.dtype = t || "float32", this.size = ov(e), this.strides = Rv(e), this.dataId = n, this.id = r, this.rankType = this.rank < 5 ? this.rank.toString() : "higher"
            }
            var t = e.prototype;
            return t.buffer = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.data();
                            case 2:
                                return t = e.sent, e.abrupt("return", kg.buffer(this.shape, this.dtype, t));
                            case 4:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t.bufferSync = function () {
                return kg.buffer(this.shape, this.dtype, this.dataSync())
            }, t.array = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.data();
                            case 2:
                                return t = e.sent, e.abrupt("return", Av(this.shape, t));
                            case 4:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t.arraySync = function () {
                return Av(this.shape, this.dataSync())
            }, t.data = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t, n;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (this.throwIfDisposed(), t = wg().read(this.dataId), "string" !== this.dtype) {
                                    e.next = 13;
                                    break
                                }
                                return e.next = 5, t;
                            case 5:
                                return n = e.sent, e.prev = 6, e.abrupt("return", n.map(function (e) {
                                    return fg(e)
                                }));
                            case 10:
                                throw e.prev = 10, e.t0 = e.catch(6), new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
                            case 13:
                                return e.abrupt("return", t);
                            case 14:
                            case "end":
                                return e.stop()
                        }
                    }, e, this, [
                        [6, 10]
                    ])
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t.dataSync = function () {
                this.throwIfDisposed();
                var e = wg().readSync(this.dataId);
                if ("string" === this.dtype) try {
                    return e.map(function (e) {
                        return fg(e)
                    })
                } catch (e) {
                    throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")
                }
                return e
            }, t.bytes = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return this.throwIfDisposed(), e.next = 3, wg().read(this.dataId);
                            case 3:
                                if (t = e.sent, "string" !== this.dtype) {
                                    e.next = 8;
                                    break
                                }
                                return e.abrupt("return", t);
                            case 8:
                                return e.abrupt("return", new Uint8Array(t.buffer));
                            case 9:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t.dispose = function () {
                this.isDisposed || (wg().disposeTensor(this), this.isDisposedInternal = !0)
            }, t.throwIfDisposed = function () {
                if (this.isDisposed) throw new Error("Tensor is disposed.")
            }, t.print = function (e) {
                return void 0 === e && (e = !1), kg.print(this, e)
            }, t.clone = function () {
                return this.throwIfDisposed(), kg.clone(this)
            }, t.toString = function (e) {
                return void 0 === e && (e = !1),
                    function (e, t, n, r) {
                        var a = Rv(t),
                            i = function (e, t, n, r) {
                                var a = ov(t),
                                    i = r[r.length - 1],
                                    o = new Array(i).fill(0),
                                    s = t.length,
                                    u = "complex64" === n ? bg(e) : e;
                                if (s > 1)
                                    for (var l = 0; l < a / i; l++)
                                        for (var c = l * i, p = 0; p < i; p++) o[p] = Math.max(o[p], gg(u[c + p], 0, n).length);
                                return o
                            }(e, t, n, a),
                            o = t.length,
                            s = function e(t, n, r, a, i, o) {
                                void 0 === o && (o = !0);
                                var s = "complex64" === r ? 2 : 1,
                                    u = n[0],
                                    l = n.length;
                                if (0 === l) return "complex64" === r ? [gg(bg(t)[0], 0, r)] : "bool" === r ? [yg(t[0])] : [t[0].toString()];
                                if (1 === l) {
                                    if (u > 20) {
                                        var c = 3 * s,
                                            p = Array.from(t.slice(0, c)),
                                            h = Array.from(t.slice((u - 3) * s, u * s));
                                        return "complex64" === r && (p = bg(p), h = bg(h)), ["[" + p.map(function (e, t) {
                                            return gg(e, i[t], r)
                                        }).join(", ") + ", ..., " + h.map(function (e, t) {
                                            return gg(e, i[u - 3 + t], r)
                                        }).join(", ") + "]"]
                                    }
                                    return ["[" + ("complex64" === r ? bg(t) : Array.from(t)).map(function (e, t) {
                                        return gg(e, i[t], r)
                                    }).join(", ") + "]"]
                                }
                                var f = n.slice(1),
                                    d = a.slice(1),
                                    m = a[0] * s,
                                    v = [];
                                if (u > 20) {
                                    for (var g = 0; g < 3; g++) {
                                        var y = g * m,
                                            b = y + m;
                                        v.push.apply(v, e(t.slice(y, b), f, r, d, i, !1))
                                    }
                                    v.push("...");
                                    for (var x = u - 3; x < u; x++) {
                                        var w = x * m,
                                            k = w + m;
                                        v.push.apply(v, e(t.slice(w, k), f, r, d, i, x === u - 1))
                                    }
                                } else
                                    for (var N = 0; N < u; N++) {
                                        var I = N * m,
                                            S = I + m;
                                        v.push.apply(v, e(t.slice(I, S), f, r, d, i, N === u - 1))
                                    }
                                var T = 2 === l ? "," : "";
                                v[0] = "[" + v[0] + T;
                                for (var C = 1; C < v.length - 1; C++) v[C] = " " + v[C] + T;
                                for (var E = ",\n", R = 2; R < l; R++) E += "\n";
                                return v[v.length - 1] = " " + v[v.length - 1] + "]" + (o ? "" : E), v
                            }(e, t, n, a, i),
                            u = ["Tensor"];
                        return r && (u.push("  dtype: " + n), u.push("  rank: " + o), u.push("  shape: [" + t + "]"), u.push("  values:")), u.push(s.map(function (e) {
                            return "    " + e
                        }).join("\n")), u.join("\n")
                    }(this.dataSync(), this.shape, this.dtype, e)
            }, t.cast = function (e) {
                return this.throwIfDisposed(), kg.cast(this, e)
            }, t.variable = function (e, t, n) {
                return void 0 === e && (e = !0), this.throwIfDisposed(), wg().makeVariable(this, e, t, n)
            }, Wm(e, [{
                key: "rank",
                get: function () {
                    return this.shape.length
                }
            }, {
                key: "isDisposed",
                get: function () {
                    return this.isDisposedInternal
                }
            }]), e
        }();

    function Ig() {
        return Uv("Tensor", function () {
            return Ng
        })
    }
    Object.defineProperty(Ng, Symbol.hasInstance, {
        value: function (e) {
            return !!e && null != e.data && null != e.dataSync && null != e.throwIfDisposed
        }
    }), Ig();
    var Sg, Tg, Cg, Eg, Rg, Ag = function (e) {
        function t(t, n, r, a) {
            var i;
            return (i = e.call(this, t.shape, t.dtype, t.dataId, a) || this).trainable = n, i.name = r, i
        }
        Vm(t, e);
        var n = t.prototype;
        return n.assign = function (e) {
            if (e.dtype !== this.dtype) throw new Error("dtype of the new value (" + e.dtype + ") and previous value (" + this.dtype + ") must match");
            if (!sv(e.shape, this.shape)) throw new Error("shape of the new value (" + e.shape + ") and previous value (" + this.shape + ") must match");
            wg().disposeTensor(this), this.dataId = e.dataId, wg().incRef(this, null)
        }, n.dispose = function () {
            wg().disposeVariable(this), this.isDisposedInternal = !0
        }, t
    }(Ng);
    Object.defineProperty(Ag, Symbol.hasInstance, {
            value: function (e) {
                return e instanceof Ng && null != e.assign && e.assign instanceof Function
            }
        }), (Sg = e.Rank || (e.Rank = {})).R0 = "R0", Sg.R1 = "R1", Sg.R2 = "R2", Sg.R3 = "R3", Sg.R4 = "R4", Sg.R5 = "R5", Sg.R6 = "R6",
        function (e) {
            e.float32 = "float32", e.int32 = "int32", e.bool = "int32", e.complex64 = "complex64"
        }(Tg || (Tg = {})),
        function (e) {
            e.float32 = "float32", e.int32 = "int32", e.bool = "bool", e.complex64 = "complex64"
        }(Cg || (Cg = {})),
        function (e) {
            e.float32 = "float32", e.int32 = "float32", e.bool = "float32", e.complex64 = "complex64"
        }(Eg || (Eg = {})),
        function (e) {
            e.float32 = "complex64", e.int32 = "complex64", e.bool = "complex64", e.complex64 = "complex64"
        }(Rg || (Rg = {}));
    var Fg = {
        float32: Eg,
        int32: Tg,
        bool: Cg,
        complex64: Rg
    };

    function _g(e, t) {
        if ("string" === e || "string" === t) {
            if ("string" === e && "string" === t) return "string";
            throw new Error("Can not upcast " + e + " with " + t)
        }
        return Fg[e][t]
    }

    function Dg(e) {
        return _g(e, "int32")
    }

    function Og(e, t) {
        if (e.dtype === t.dtype) return [e, t];
        var n = _g(e.dtype, t.dtype);
        return [e.cast(n), t.cast(n)]
    }

    function Mg(e, t) {
        nv(e.dtype === t.dtype, function () {
            return "The dtypes of the first(" + e.dtype + ") and second(" + t.dtype + ") input must match"
        })
    }

    function Lg(e, t) {
        return t.some(function (t) {
            return t.id === e.id
        })
    }

    function zg(e) {
        var t = [];
        return function e(t, n, r) {
            if (null != t)
                if (t instanceof Ng) n.push(t);
                else if (a = t, Array.isArray(a) || "object" == typeof a) {
                var a, i = t;
                for (var o in i) {
                    var s = i[o];
                    r.has(s) || (r.add(s), e(s, n, r))
                }
            }
        }(e, t, new Set), t
    }
    var Pg = {
        __proto__: null,
        makeTypesMatch: Og,
        assertTypesMatch: Mg,
        isTensorInList: Lg,
        getTensorsInContainer: zg
    };

    function Bg(e) {
        return null != e.kernelName
    }
    var Wg = function () {
            function e() {
                this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = new WeakMap, this.profiling = !1, this.activeProfile = {
                    newBytes: 0,
                    newTensors: 0,
                    peakBytes: 0,
                    kernels: [],
                    result: null,
                    get kernelNames() {
                        return Array.from(new Set(this.kernels.map(function (e) {
                            return e.name
                        })))
                    }
                }
            }
            return e.prototype.dispose = function () {
                for (var e in this.registeredVariables) this.registeredVariables[e].dispose()
            }, e
        }(),
        Vg = function () {
            function e(e) {
                this.ENV = e, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new Wg
            }
            var t = e.prototype;
            return t.ready = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t, n, r;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (null == this.pendingBackendInit) {
                                    e.next = 2;
                                    break
                                }
                                return e.abrupt("return", this.pendingBackendInit.then(function () {}));
                            case 2:
                                if (null == this.backendInstance) {
                                    e.next = 4;
                                    break
                                }
                                return e.abrupt("return");
                            case 4:
                                t = this.getSortedBackends(), n = 0;
                            case 6:
                                if (!(n < t.length)) {
                                    e.next = 18;
                                    break
                                }
                                return r = t[n], e.next = 10, this.initializeBackend(r).success;
                            case 10:
                                if (!e.sent) {
                                    e.next = 15;
                                    break
                                }
                                return e.next = 14, this.setBackend(r);
                            case 14:
                                return e.abrupt("return");
                            case 15:
                                n++, e.next = 6;
                                break;
                            case 18:
                                throw new Error("Could not initialize any backends, all backend initializations failed.");
                            case 19:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t.backendNames = function () {
                return Object.keys(this.registryFactory)
            }, t.findBackend = function (e) {
                if (!(e in this.registry)) {
                    if (!(e in this.registryFactory)) return null;
                    if (this.initializeBackend(e).asyncInit) return null
                }
                return this.registry[e]
            }, t.findBackendFactory = function (e) {
                return e in this.registryFactory ? this.registryFactory[e].factory : null
            }, t.registerBackend = function (e, t, n) {
                return void 0 === n && (n = 1), e in this.registryFactory ? (console.warn(e + " backend was already registered. Reusing existing backend factory."), !1) : (this.registryFactory[e] = {
                    factory: t,
                    priority: n
                }, !0)
            }, t.setBackend = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    var n, r;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (null != this.registryFactory[t]) {
                                    e.next = 2;
                                    break
                                }
                                throw new Error("Backend name '" + t + "' not found in registry");
                            case 2:
                                if (this.backendName = t, null != this.registry[t]) {
                                    e.next = 16;
                                    break
                                }
                                if (this.backendInstance = null, n = this.initializeBackend(t), r = n.success, !n.asyncInit) {
                                    e.next = 12;
                                    break
                                }
                                return e.next = 9, r;
                            case 9:
                                e.t0 = e.sent, e.next = 13;
                                break;
                            case 12:
                                e.t0 = r;
                            case 13:
                                if (e.t0) {
                                    e.next = 16;
                                    break
                                }
                                return e.abrupt("return", !1);
                            case 16:
                                return this.backendInstance = this.registry[t], this.setupRegisteredKernels(), this.profiler = new mg(this.backendInstance), e.abrupt("return", !0);
                            case 20:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), t.setupRegisteredKernels = function () {
                var e = this;
                ag(this.backendName).forEach(function (t) {
                    null != t.setupFunc && t.setupFunc(e.backendInstance)
                })
            }, t.disposeRegisteredKernels = function (e) {
                var t = this;
                ag(e).forEach(function (n) {
                    null != n.disposeFunc && n.disposeFunc(t.registry[e])
                })
            }, t.initializeBackend = function (e) {
                var t = this,
                    n = this.registryFactory[e];
                if (null == n) throw new Error("Cannot initialize backend " + e + ", no registration found.");
                try {
                    var r = n.factory();
                    if (!r || r instanceof Jm || "function" != typeof r.then) return this.registry[e] = r, {
                        success: !0,
                        asyncInit: !1
                    };
                    var a = ++this.pendingBackendInitId,
                        i = r.then(function (n) {
                            return !(a < t.pendingBackendInitId || (t.registry[e] = n, t.pendingBackendInit = null, 0))
                        }).catch(function (n) {
                            return a < t.pendingBackendInitId || (t.pendingBackendInit = null, console.warn("Initialization of backend " + e + " failed"), console.warn(n.stack || n.message)), !1
                        });
                    return this.pendingBackendInit = i, {
                        success: i,
                        asyncInit: !0
                    }
                } catch (t) {
                    return console.warn("Initialization of backend " + e + " failed"), console.warn(t.stack || t.message), {
                        success: !1,
                        asyncInit: !1
                    }
                }
            }, t.removeBackend = function (e) {
                if (!(e in this.registryFactory)) throw new Error(e + " backend not found in registry");
                this.backendName === e && null != this.pendingBackendInit && this.pendingBackendInitId++, e in this.registry && (this.disposeRegisteredKernels(e), this.registry[e].dispose(), delete this.registry[e]), delete this.registryFactory[e], this.backendName === e && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null)
            }, t.getSortedBackends = function () {
                var e = this;
                if (0 === Object.keys(this.registryFactory).length) throw new Error("No backend found in registry.");
                return Object.keys(this.registryFactory).sort(function (t, n) {
                    return e.registryFactory[n].priority - e.registryFactory[t].priority
                })
            }, t.initializeBackendsAndReturnBest = function () {
                for (var e = this.getSortedBackends(), t = 0; t < e.length; t++) {
                    var n = e[t],
                        r = this.initializeBackend(n),
                        a = r.success,
                        i = r.asyncInit;
                    if (i || a) return {
                        name: n,
                        asyncInit: i
                    }
                }
                throw new Error("Could not initialize any backends, all backend initializations failed.")
            }, t.moveData = function (e, t) {
                var n = this.state.tensorInfo.get(t),
                    r = n.backend,
                    a = this.readSync(t),
                    i = r.refCount(t);
                r.disposeData(t, !0), n.backend = e, e.move(t, a, n.shape, n.dtype, i), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++
            }, t.tidy = function (e, t) {
                var n, r = this,
                    a = null;
                if (null == t) {
                    if ("function" != typeof e) throw new Error("Please provide a function to tidy()");
                    t = e
                } else {
                    if ("string" != typeof e && !(e instanceof String)) throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
                    if ("function" != typeof t) throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
                    a = e
                }
                return this.scopedRun(function () {
                    return r.startScope(a)
                }, function () {
                    return r.endScope(n)
                }, function () {
                    return (n = t()) instanceof Promise && console.error("Cannot return a Promise inside of tidy."), n
                })
            }, t.scopedRun = function (e, t, n) {
                e();
                try {
                    var r = n();
                    return t(), r
                } catch (e) {
                    throw t(), e
                }
            }, t.nextTensorId = function () {
                return e.nextTensorId++
            }, t.nextVariableId = function () {
                return e.nextVariableId++
            }, t.clone = function (e) {
                var t = Gg.runKernel("Identity", {
                        x: e
                    }),
                    n = {
                        x: e
                    };
                return this.addTapeNode(this.state.activeScope.name, n, [t], function (e) {
                    return {
                        x: function () {
                            var t = {
                                x: e
                            };
                            return Gg.runKernel("Cast", t, {
                                dtype: "float32"
                            })
                        }
                    }
                }, [], {}), t
            }, t.runKernel = function (e, t, n) {
                if (null == ng(e, this.backendName)) throw new Error("Kernel '" + e + "' not registered for backend '" + this.backendName + "'");
                return this.runKernelFunc({
                    kernelName: e,
                    inputs: t,
                    attrs: n
                })
            }, t.shouldCheckForMemLeaks = function () {
                return this.ENV.getBool("IS_TEST")
            }, t.checkKernelForMemLeak = function (e, t, n) {
                var r = this.backend.numDataIds(),
                    a = 0;
                n.forEach(function (e) {
                    a += "complex64" === e.dtype ? 3 : 1
                });
                var i = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1],
                    o = r - t - a - i;
                if (o > 0) throw new Error("Backend '" + this.backendName + "' has an internal memory leak (" + o + " data ids) after running '" + e + "'")
            }, t.runKernelFunc = function (e) {
                var t, n, r, a = this,
                    i = [],
                    o = this.isTapeOn(),
                    s = this.state.numBytes,
                    u = this.state.numTensors;
                this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0), null == this.backendName && this.backend;
                var l = Bg(e) ? e.kernelName : null != this.state.activeScope ? this.state.activeScope.name : "";
                if (Bg(e)) {
                    var c = e.kernelName,
                        p = e.inputs,
                        h = e.attrs;
                    null == this.backendName && this.backend;
                    var f = ng(c, this.backendName);
                    nv(null != f, function () {
                        return "Cannot find registered kernel '" + c + "' for backend '" + a.backendName + "'"
                    }), n = function () {
                        var e = a.backend.numDataIds();
                        r = f.kernelFunc({
                            inputs: p,
                            attrs: h,
                            backend: a.backend
                        });
                        var t = Array.isArray(r) ? r : [r];
                        a.shouldCheckForMemLeaks() && a.checkKernelForMemLeak(c, e, t);
                        var n = t.map(function (e) {
                            if (null != e.rank) return e;
                            var t = e.dataId,
                                n = e.shape,
                                r = e.dtype;
                            return a.makeTensorFromDataId(t, n, r)
                        });
                        if (o) {
                            var s = a.getTensorsForGradient(c, p, n);
                            i = a.saveTensorsForBackwardMode(s)
                        }
                        return n
                    }
                } else {
                    var d = e.forwardFunc,
                        m = function (e) {
                            o && (i = e.map(function (e) {
                                return a.keep(a.clone(e))
                            }))
                        };
                    n = function () {
                        var e = a.backend.numDataIds();
                        r = a.tidy(function () {
                            return d(a.backend, m)
                        });
                        var t = Array.isArray(r) ? r : [r];
                        return a.shouldCheckForMemLeaks() && a.checkKernelForMemLeak(l, e, t), t
                    }
                }
                var v, g = e.inputs,
                    y = e.attrs,
                    b = Bg(e) ? null : e.backwardsFunc;
                return this.scopedRun(function () {
                    return a.state.kernelDepth++
                }, function () {
                    return a.state.kernelDepth--
                }, function () {
                    a.ENV.getBool("DEBUG") || a.state.profiling ? (v = a.profiler.profileKernel(l, g, function () {
                        return n()
                    }), a.ENV.getBool("DEBUG") && a.profiler.logKernelProfile(v), t = v.outputs) : t = n()
                }), o && this.addTapeNode(l, g, t, b, i, y), this.state.profiling && this.state.activeProfile.kernels.push({
                    name: l,
                    bytesAdded: this.state.numBytes - s,
                    totalBytesSnapshot: this.state.numBytes,
                    tensorsAdded: this.state.numTensors - u,
                    totalTensorsSnapshot: this.state.numTensors,
                    inputShapes: Object.keys(g).map(function (e) {
                        return null != g[e] ? g[e].shape : null
                    }),
                    outputShapes: t.map(function (e) {
                        return e.shape
                    }),
                    kernelTimeMs: v.timeMs,
                    extraInfo: v.extraInfo
                }), Array.isArray(r) ? t : t[0]
            }, t.saveTensorsForBackwardMode = function (e) {
                var t = this;
                return e.map(function (e) {
                    return t.keep(t.clone(e))
                })
            }, t.getTensorsForGradient = function (e, t, n) {
                var r = rg(e);
                if (null != r) {
                    var a, i = r.inputsToSave || [],
                        o = r.outputsToSave || [];
                    r.saveAllInputs ? (nv(Array.isArray(t), function () {
                        return "saveAllInputs is true, expected inputs to be an array."
                    }), a = Object.keys(t).map(function (e) {
                        return t[e]
                    })) : a = i.map(function (e) {
                        return t[e]
                    });
                    var s = n.filter(function (e, t) {
                        return o[t]
                    });
                    return a.concat(s)
                }
                return []
            }, t.makeTensor = function (e, t, n, r) {
                if (null == e) throw new Error("Values passed to engine.makeTensor() are null");
                n = n || "float32", r = r || this.backend;
                var a = e;
                "string" === n && Nv(e[0]) && (a = e.map(function (e) {
                    return hg(e)
                }));
                var i = r.write(a, t, n),
                    o = new Ng(t, n, i, this.nextTensorId());
                if (this.trackTensor(o, r), "string" === n) {
                    var s = this.state.tensorInfo.get(i),
                        u = kv(a);
                    this.state.numBytes += u - s.bytes, s.bytes = u
                }
                return o
            }, t.makeTensorFromDataId = function (e, t, n, r) {
                var a = new Ng(t, n = n || "float32", e, this.nextTensorId());
                return this.trackTensor(a, r), a
            }, t.makeVariable = function (e, t, n, r) {
                void 0 === t && (t = !0), n = n || this.nextVariableId().toString(), null != r && r !== e.dtype && (e = e.cast(r));
                var a = new Ag(e, t, n, this.nextTensorId());
                if (null != this.state.registeredVariables[a.name]) throw new Error("Variable with name " + a.name + " was already registered");
                return this.state.registeredVariables[a.name] = a, this.incRef(a, this.backend), a
            }, t.trackTensor = function (e, t) {
                this.state.numTensors++, "string" === e.dtype && this.state.numStringTensors++;
                var n = 0;
                "complex64" !== e.dtype && "string" !== e.dtype && (n = e.size * wv(e.dtype)), this.state.numBytes += n, this.state.tensorInfo.has(e.dataId) || (this.state.numDataBuffers++, this.state.tensorInfo.set(e.dataId, {
                    backend: t || this.backend,
                    dtype: e.dtype,
                    shape: e.shape,
                    bytes: n
                })), e instanceof Ag || this.track(e)
            }, t.incRef = function (e, t) {
                this.trackTensor(e, t), this.backend.incRef(e.dataId)
            }, t.removeDataId = function (e, t) {
                this.state.tensorInfo.has(e) && this.state.tensorInfo.get(e).backend === t && (this.state.tensorInfo.delete(e), this.state.numDataBuffers--)
            }, t.disposeTensor = function (e) {
                if (this.state.tensorInfo.has(e.dataId)) {
                    var t = this.state.tensorInfo.get(e.dataId);
                    if (this.state.numTensors--, "string" === e.dtype && (this.state.numStringTensors--, this.state.numBytes -= t.bytes), "complex64" !== e.dtype && "string" !== e.dtype) {
                        var n = e.size * wv(e.dtype);
                        this.state.numBytes -= n
                    }
                    t.backend.disposeData(e.dataId) && this.removeDataId(e.dataId, t.backend)
                }
            }, t.disposeVariables = function () {
                for (var e in this.state.registeredVariables) {
                    var t = this.state.registeredVariables[e];
                    this.disposeVariable(t)
                }
            }, t.disposeVariable = function (e) {
                this.disposeTensor(e), null != this.state.registeredVariables[e.name] && delete this.state.registeredVariables[e.name]
            }, t.memory = function () {
                var e = this.backend.memory();
                return e.numTensors = this.state.numTensors, e.numDataBuffers = this.state.numDataBuffers, e.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (e.unreliable = !0, null == e.reasons && (e.reasons = []), e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), e
            }, t.profile = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    var n, r, a, i, o;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return this.state.profiling = !0, n = this.state.numBytes, r = this.state.numTensors, this.state.activeProfile.kernels = [], e.next = 6, t();
                            case 6:
                                this.state.activeProfile.result = e.sent, this.state.profiling = !1, this.state.activeProfile.peakBytes = Math.max.apply(Math, this.state.activeProfile.kernels.map(function (e) {
                                    return e.totalBytesSnapshot
                                })), this.state.activeProfile.newBytes = this.state.numBytes - n, this.state.activeProfile.newTensors = this.state.numTensors - r, a = Xm(this.state.activeProfile.kernels);
                            case 12:
                                if ((i = a()).done) {
                                    e.next = 22;
                                    break
                                }
                                return o = i.value, e.next = 16, o.kernelTimeMs;
                            case 16:
                                return o.kernelTimeMs = e.sent, e.next = 19, o.extraInfo;
                            case 19:
                                o.extraInfo = e.sent;
                            case 20:
                                e.next = 12;
                                break;
                            case 22:
                                return e.abrupt("return", this.state.activeProfile);
                            case 23:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), t.isTapeOn = function () {
                return this.state.gradientDepth > 0 && 0 === this.state.kernelDepth
            }, t.addTapeNode = function (e, t, n, r, a, i) {
                var o = this,
                    s = {
                        id: this.state.nextTapeNodeId++,
                        kernelName: e,
                        inputs: t,
                        outputs: n,
                        saved: a
                    },
                    u = rg(e);
                null != u && (r = u.gradFunc), null != r && (s.gradient = function (e) {
                    return e = e.map(function (e, t) {
                        if (null == e) {
                            var r = n[t],
                                a = _v(r.size, r.dtype);
                            return o.makeTensor(a, r.shape, r.dtype)
                        }
                        return e
                    }), r(e.length > 1 ? e : e[0], a, i)
                }), this.state.activeTape.push(s)
            }, t.keep = function (e) {
                return e.kept = !0, e
            }, t.startTape = function () {
                0 === this.state.gradientDepth && (this.state.activeTape = []), this.state.gradientDepth++
            }, t.endTape = function () {
                this.state.gradientDepth--
            }, t.startScope = function (e) {
                var t = {
                    track: [],
                    name: "unnamed scope",
                    id: this.state.nextScopeId++
                };
                e && (t.name = e), this.state.scopeStack.push(t), this.state.activeScope = t
            }, t.endScope = function (e) {
                for (var t = this, n = zg(e), r = new Set(n.map(function (e) {
                        return e.id
                    })), a = 0; a < this.state.activeScope.track.length; a++) {
                    var i = this.state.activeScope.track[a];
                    i.kept || r.has(i.id) || i.dispose()
                }
                var o = this.state.scopeStack.pop();
                this.state.activeScope = 0 === this.state.scopeStack.length ? null : this.state.scopeStack[this.state.scopeStack.length - 1], n.forEach(function (e) {
                    e.kept || e.scopeId !== o.id || t.track(e)
                })
            }, t.gradients = function (e, t, n, r) {
                var a = this;
                if (void 0 === r && (r = !1), nv(t.length > 0, function () {
                        return "gradients() received an empty list of xs."
                    }), null != n && "float32" !== n.dtype) throw new Error("dy must have 'float32' dtype, but has '" + n.dtype + "'");
                var i = this.scopedRun(function () {
                    return a.startTape()
                }, function () {
                    return a.endTape()
                }, function () {
                    return a.tidy("forward", e)
                });
                nv(i instanceof Ng, function () {
                    return "The result y returned by f() must be a tensor."
                });
                var o = function (e, t, n) {
                    for (var r = {}, a = {}, i = 0; i < t.length; i++) r[t[i].id] = !0;
                    for (var o = 0; o < e.length; o++) {
                        var s = e[o],
                            u = s.inputs;
                        for (var l in u) {
                            for (var c = u[l], p = !1, h = 0; h < t.length; h++)
                                if (r[c.id]) {
                                    s.outputs.forEach(function (e) {
                                        return r[e.id] = !0
                                    }), p = !0, a[s.id] = !0;
                                    break
                                } if (p) break
                        }
                    }
                    var f = {};
                    f[n.id] = !0;
                    for (var d = {}, m = e.length - 1; m >= 0; m--)
                        for (var v = e[m], g = v.inputs, y = 0; y < v.outputs.length; y++)
                            if (f[v.outputs[y].id]) {
                                for (var b in g) f[g[b].id] = !0, d[v.id] = !0;
                                break
                            } for (var x = [], w = 0; w < e.length; w++) {
                        var k = e[w];
                        if (a[k.id] && d[k.id]) {
                            var N = {};
                            for (var I in k.inputs) {
                                var S = k.inputs[I];
                                r[S.id] && (N[I] = S)
                            }
                            var T = Object.assign({}, k);
                            T.inputs = N, T.outputs = k.outputs, x.push(T)
                        }
                    }
                    return x
                }(this.state.activeTape, t, i);
                if (!r && 0 === o.length && t.length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
                return this.tidy("backward", function () {
                    var e, r, s = {};
                    s[i.id] = null == n ? (r = Fv(ov(e = i.shape), "float32"), Gg.makeTensor(r, e, "float32")) : n,
                        function (e, t, n, r) {
                            for (var a = function (a) {
                                    var i = t[a],
                                        o = [];
                                    if (i.outputs.forEach(function (t) {
                                            var n = e[t.id];
                                            null != n ? o.push(n) : o.push(null)
                                        }), null == i.gradient) throw new Error("Cannot compute gradient: gradient function not found for " + i.kernelName + ".");
                                    var s = i.gradient(o),
                                        u = function (t) {
                                            if (!(t in s)) throw new Error("Cannot backprop through input " + t + ". Available gradients found: " + Object.keys(s) + ".");
                                            var a = n(function () {
                                                return s[t]()
                                            });
                                            if ("float32" !== a.dtype) throw new Error("Error in gradient for op " + i.kernelName + ". The gradient of input " + t + " must have 'float32' dtype, but has '" + a.dtype + "'");
                                            var o = i.inputs[t];
                                            if (!sv(a.shape, o.shape)) throw new Error("Error in gradient for op " + i.kernelName + ". The gradient of input '" + t + "' has shape '" + a.shape + "', which does not match the shape of the input '" + o.shape + "'");
                                            if (null == e[o.id]) e[o.id] = a;
                                            else {
                                                var u = e[o.id];
                                                e[o.id] = r(u, a), u.dispose()
                                            }
                                        };
                                    for (var l in i.inputs) u(l)
                                }, i = t.length - 1; i >= 0; i--) a(i)
                        }(s, o, function (e) {
                            return a.tidy(e)
                        }, jg);
                    var u = t.map(function (e) {
                        return s[e.id]
                    });
                    return 0 === a.state.gradientDepth && (a.state.activeTape.forEach(function (e) {
                        for (var t, n = Xm(e.saved); !(t = n()).done;) t.value.dispose()
                    }), a.state.activeTape = null), {
                        value: i,
                        grads: u
                    }
                })
            }, t.customGrad = function (e) {
                var t = this;
                return nv(Cv(e), function () {
                        return "The f passed in customGrad(f) must be a function."
                    }),
                    function () {
                        for (var n = arguments.length, r = new Array(n), a = 0; a < n; a++) r[a] = arguments[a];
                        var i;
                        nv(r.every(function (e) {
                            return e instanceof Ng
                        }), function () {
                            return "The args passed in customGrad(f)(x1, x2,...) must all be tensors"
                        });
                        var o = {};
                        r.forEach(function (e, t) {
                            o[t] = e
                        });
                        return t.runKernelFunc({
                            forwardFunc: function (t, n) {
                                return nv((i = e.apply(void 0, [].concat(r, [n]))).value instanceof Ng, function () {
                                    return "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"
                                }), nv(Cv(i.gradFunc), function () {
                                    return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."
                                }), i.value
                            },
                            backwardsFunc: function (e, t) {
                                var n = i.gradFunc(e, t),
                                    a = Array.isArray(n) ? n : [n];
                                nv(a.length === r.length, function () {
                                    return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."
                                }), nv(a.every(function (e) {
                                    return e instanceof Ng
                                }), function () {
                                    return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."
                                });
                                var o = {};
                                return a.forEach(function (e, t) {
                                    o[t] = function () {
                                        return e
                                    }
                                }), o
                            },
                            inputs: o
                        })
                    }
            }, t.readSync = function (e) {
                return this.state.tensorInfo.get(e).backend.readSync(e)
            }, t.read = function (e) {
                return this.state.tensorInfo.get(e).backend.read(e)
            }, t.time = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    var n, r;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return n = cg(), e.next = 3, this.backend.time(t);
                            case 3:
                                return (r = e.sent).wallMs = cg() - n, e.abrupt("return", r);
                            case 6:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), t.track = function (e) {
                return null != this.state.activeScope && (e.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(e)), e
            }, t.reset = function () {
                for (var e in this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new Wg, this.registry) this.disposeRegisteredKernels(e), this.registry[e].dispose(), delete this.registry[e];
                this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null
            }, Wm(e, [{
                key: "backend",
                get: function () {
                    if (null != this.pendingBackendInit) throw new Error("Backend '" + this.backendName + "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");
                    if (null == this.backendInstance) {
                        var e = this.initializeBackendsAndReturnBest(),
                            t = e.name;
                        if (e.asyncInit) throw new Error("The highest priority backend '" + t + "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");
                        this.setBackend(t)
                    }
                    return this.backendInstance
                }
            }, {
                key: "registeredVariables",
                get: function () {
                    return this.state.registeredVariables
                }
            }]), e
        }();

    function Ug() {
        var t = Vv();
        if (null == t._tfengine) {
            var n = new Bv(t);
            t._tfengine = new Vg(n)
        }
        return function (t) {
            e.ENV = t
        }(t._tfengine.ENV), wg = function () {
            return t._tfengine
        }, t._tfengine
    }
    Vg.nextTensorId = 0, Vg.nextVariableId = 0;
    var Gg = Ug();

    function jg(e, t) {
        var n = {
            a: e,
            b: t
        };
        return Gg.runKernel(Gv, n)
    }

    function Hg() {
        if ("undefined" != typeof navigator && null != navigator) {
            var e = navigator.userAgent || navigator.vendor || window.opera;
            return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0, 4))
        }
        return !1
    }

    function qg() {
        return "undefined" != typeof window && null != window.document || "undefined" != typeof WorkerGlobalScope
    }
    var Kg = {
            __proto__: null,
            isMobile: Hg,
            isBrowser: qg
        },
        Xg = Wv();

    function Yg(e, t) {
        var n = e;
        if (xv(e)) return "string" === t ? [] : [e.length];
        if (!Array.isArray(e)) return [];
        for (var r = []; Array.isArray(n) || xv(n) && "string" !== t;) r.push(n.length), n = n[0];
        return Array.isArray(e) && Wv().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && function e(t, n, r) {
            if (r = r || [], Array.isArray(t) || xv(t)) {
                nv(n.length > 0, function () {
                    return "Element arr[" + r.join("][") + "] should be a primitive, but is an array of " + t.length + " elements"
                }), nv(t.length === n[0], function () {
                    return "Element arr[" + r.join("][") + "] should have " + n[0] + " elements, but has " + t.length + " elements"
                });
                for (var a = n.slice(1), i = 0; i < t.length; ++i) e(t[i], a, r.concat(i))
            } else nv(0 === n.length, function () {
                return "Element arr[" + r.join("][") + "] is a primitive, but should be an array/TypedArray of " + n[0] + " elements"
            })
        }(e, r, []), r
    }

    function Jg(e, t, n, r) {
        if ("string_or_numeric" !== e) {
            if (null == e) throw new Error("Expected dtype cannot be null.");
            if ("numeric" !== e && e !== t || "numeric" === e && "string" === t) throw new Error("Argument '" + n + "' passed to '" + r + "' must be " + e + " tensor, but got " + t + " tensor")
        }
    }

    function Zg(e, t, n, r) {
        if (void 0 === r && (r = "numeric"), e instanceof Ng) return Jg(r, e.dtype, t, n), e;
        var a = Tv(e);
        if ("string" !== a && ["bool", "int32", "float32"].indexOf(r) >= 0 && (a = r), Jg(r, a, t, n), null == e || !xv(e) && !Array.isArray(e) && "number" != typeof e && "boolean" != typeof e && "string" != typeof e) {
            var i = null == e ? "null" : e.constructor.name;
            throw new Error("Argument '" + t + "' passed to '" + n + "' must be a Tensor or TensorLike, but got '" + i + "'")
        }
        var o = Yg(e, a);
        xv(e) || Array.isArray(e) || (e = [e]);
        var s = "string" !== a ? lg(e, a) : iv(e, [], !0);
        return Gg.makeTensor(s, o, a)
    }

    function Qg(e, t, n, r) {
        if (void 0 === r && (r = "numeric"), !Array.isArray(e)) throw new Error("Argument " + t + " passed to " + n + " must be a `Tensor[]` or `TensorLike[]`");
        return e.map(function (e, a) {
            return Zg(e, t + "[" + a + "]", n, r)
        })
    }

    function $g(e) {
        var t = Object.keys(e);
        if (1 !== t.length) throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with " + t.length + " keys.");
        var n = t[0],
            r = e[n];
        n.endsWith("_") && (n = n.substring(0, n.length - 1)), n += "__op";
        var a = function () {
            Gg.startScope(n);
            try {
                var e = r.apply(void 0, arguments);
                return zv(e) && console.error("Cannot return a Promise inside of tidy."), Gg.endScope(e), e
            } catch (e) {
                throw Gg.endScope(null), e
            }
        };
        return Object.defineProperty(a, "name", {
            value: n,
            configurable: !0
        }), a
    }
    Xg.registerFlag("DEBUG", function () {
        return !1
    }, function (e) {
        e && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")
    }), Xg.registerFlag("IS_BROWSER", function () {
        return qg()
    }), Xg.registerFlag("IS_NODE", function () {
        return "undefined" != typeof process && void 0 !== process.versions && void 0 !== process.versions.node
    }), Xg.registerFlag("IS_CHROME", function () {
        return "undefined" != typeof navigator && null != navigator && null != navigator.userAgent && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor)
    }), Xg.registerFlag("PROD", function () {
        return !1
    }), Xg.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", function () {
        return Xg.getBool("DEBUG")
    }), Xg.registerFlag("DEPRECATION_WARNINGS_ENABLED", function () {
        return !0
    }), Xg.registerFlag("IS_TEST", function () {
        return !1
    }), Xg.registerFlag("CHECK_COMPUTATION_FOR_ERRORS", function () {
        return !0
    }), Xg.registerFlag("WRAP_TO_IMAGEBITMAP", function () {
        return !1
    });
    var ey = $g({
        complex_: function (e, t) {
            var n = Zg(e, "real", "complex"),
                r = Zg(t, "imag", "complex");
            rv(n.shape, r.shape, "real and imag shapes, " + n.shape + " and " + r.shape + ", must match in call to tf.complex().");
            var a = {
                real: n,
                imag: r
            };
            return Gg.runKernel("Complex", a)
        }
    });

    function ty(e, t, n, r) {
        if (null == r && (r = Tv(e)), "complex64" === r) throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
        if (!xv(e) && !Array.isArray(e) && "number" != typeof e && "boolean" != typeof e && "string" != typeof e) throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
        if (null != t) {
            Ov(t);
            var a = ov(t),
                i = ov(n);
            nv(a === i, function () {
                return "Based on the provided shape, [" + t + "], the tensor should have " + a + " values but has " + i
            });
            for (var o = 0; o < n.length; ++o) {
                var s = n[o],
                    u = o !== n.length - 1 || s !== ov(t.slice(o));
                nv(n[o] === t[o] || !u, function () {
                    return "Error creating a new Tensor. Inferred shape (" + n + ") does not match the provided shape (" + t + "). "
                })
            }
        }
        return xv(e) || Array.isArray(e) || (e = [e]), t = t || n, e = "string" !== r ? lg(e, r) : iv(e, [], !0), Gg.makeTensor(e, t, r)
    }

    function ny(e, t, n) {
        return ty(e, t, Yg(e, n), n)
    }
    var ry = {
        float32: 4,
        float16: 2,
        int32: 4,
        uint16: 2,
        uint8: 1,
        bool: 1,
        complex64: 8
    };

    function ay(e, t) {
        return function () {
            return Pm(regeneratorRuntime.mark(function e(t, n) {
                var r, a, i, o, s, u;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            for (r = [], a = [], i = Array.isArray(t) ? t.map(function (e) {
                                    return e.name
                                }) : Object.keys(t), o = function (e) {
                                    var o = i[e],
                                        s = Array.isArray(t) ? t[e].tensor : t[o];
                                    if ("float32" !== s.dtype && "int32" !== s.dtype && "bool" !== s.dtype && "string" !== s.dtype && "complex64" !== s.dtype) throw new Error("Unsupported dtype in weight '" + o + "': " + s.dtype);
                                    var u = {
                                        name: o,
                                        shape: s.shape,
                                        dtype: s.dtype
                                    };
                                    if ("string" === s.dtype) {
                                        var l = new Promise(function () {
                                            var e = Pm(regeneratorRuntime.mark(function e(t) {
                                                var n, r, a, i, o, u, l;
                                                return regeneratorRuntime.wrap(function (e) {
                                                    for (;;) switch (e.prev = e.next) {
                                                        case 0:
                                                            return e.next = 2, s.bytes();
                                                        case 2:
                                                            for (n = e.sent, r = n.reduce(function (e, t) {
                                                                    return e + t.length
                                                                }, 0) + 4 * n.length, a = new Uint8Array(r), i = 0, o = 0; o < n.length; o++) u = n[o], l = new Uint8Array(new Uint32Array([u.length]).buffer), a.set(l, i), i += 4, a.set(u, i), i += u.length;
                                                            t(a);
                                                        case 8:
                                                        case "end":
                                                            return e.stop()
                                                    }
                                                }, e)
                                            }));
                                            return function (t) {
                                                return e.apply(this, arguments)
                                            }
                                        }());
                                        a.push(l)
                                    } else a.push(s.data());
                                    null != n && (u.group = n), r.push(u)
                                }, s = 0; s < i.length; ++s) o(s);
                            return e.next = 7, Promise.all(a);
                        case 7:
                            return u = e.sent, e.abrupt("return", {
                                data: oy(u),
                                specs: r
                            });
                        case 9:
                        case "end":
                            return e.stop()
                    }
                }, e)
            })).apply(this, arguments)
        }.apply(this, arguments)
    }

    function iy(e, t) {
        for (var n, r, a = {}, i = 0, o = Xm(t); !(r = o()).done;) {
            var s = r.value,
                u = s.name,
                l = s.dtype,
                c = s.shape,
                p = ov(c),
                h = void 0;
            if ("quantization" in s) {
                var f = s.quantization;
                if ("uint8" === f.dtype || "uint16" === f.dtype) {
                    if (!("min" in f && "scale" in f)) throw new Error("Weight " + s.name + " with quantization " + f.dtype + " doesn't have corresponding metadata min and scale.")
                } else {
                    if ("float16" !== f.dtype) throw new Error("Weight " + s.name + " has unknown quantization dtype " + f.dtype + ". Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.");
                    if ("float32" !== l) throw new Error("Weight " + s.name + " is quantized with " + f.dtype + " which only supports weights of type float32 not " + l + ".")
                }
                var d = ry[f.dtype],
                    m = e.slice(i, i + p * d),
                    v = "uint8" === f.dtype ? new Uint8Array(m) : new Uint16Array(m);
                if ("float32" === l)
                    if ("uint8" === f.dtype || "uint16" === f.dtype) {
                        h = new Float32Array(v.length);
                        for (var g = 0; g < v.length; g++) {
                            var y = v[g];
                            h[g] = y * f.scale + f.min
                        }
                    } else {
                        if ("float16" !== f.dtype) throw new Error("Unsupported quantization type " + f.dtype + " for weight type float32.");
                        void 0 === n && (n = dy()), h = n(v)
                    }
                else {
                    if ("int32" !== l) throw new Error("Unsupported dtype in weight '" + u + "': " + l);
                    if ("uint8" !== f.dtype && "uint16" !== f.dtype) throw new Error("Unsupported quantization type " + f.dtype + " for weight type int32.");
                    h = new Int32Array(v.length);
                    for (var b = 0; b < v.length; b++) {
                        var x = v[b];
                        h[b] = Math.round(x * f.scale + f.min)
                    }
                }
                i += p * d
            } else if ("string" === l) {
                var w = ov(s.shape);
                h = [];
                for (var k = 0; k < w; k++) {
                    var N = new Uint32Array(e.slice(i, i + 4))[0];
                    i += 4;
                    var I = new Uint8Array(e.slice(i, i + N));
                    h.push(I), i += N
                }
            } else {
                var S = ry[l],
                    T = e.slice(i, i + p * S);
                if ("float32" === l) h = new Float32Array(T);
                else if ("int32" === l) h = new Int32Array(T);
                else if ("bool" === l) h = new Uint8Array(T);
                else {
                    if ("complex64" !== l) throw new Error("Unsupported dtype in weight '" + u + "': " + l);
                    h = new Float32Array(T);
                    for (var C = new Float32Array(h.length / 2), E = new Float32Array(h.length / 2), R = 0; R < C.length; R++) C[R] = h[2 * R], E[R] = h[2 * R + 1];
                    var A = ny(C, c, "float32"),
                        F = ny(E, c, "float32");
                    a[u] = ey(A, F), A.dispose(), F.dispose()
                }
                i += p * S
            }
            "complex64" !== l && (a[u] = ny(h, c, l))
        }
        return a
    }

    function oy(e) {
        if (null === e) throw new Error("Invalid input value: " + JSON.stringify(e));
        var t = 0,
            n = [];
        e.forEach(function (e) {
            if (t += e.byteLength, n.push(e.byteLength === e.buffer.byteLength ? e : new e.constructor(e)), !(e instanceof Float32Array || e instanceof Int32Array || e instanceof Uint8Array)) throw new Error("Unsupported TypedArray subtype: " + e.constructor.name)
        });
        var r = new Uint8Array(t),
            a = 0;
        return n.forEach(function (e) {
            r.set(new Uint8Array(e.buffer), a), a += e.byteLength
        }), r.buffer
    }
    var sy = "undefined" != typeof Buffer && ("undefined" == typeof Blob || "undefined" == typeof atob || "undefined" == typeof btoa);

    function uy(e) {
        return sy ? Buffer.byteLength(e) : new Blob([e]).size
    }

    function ly(e) {
        if (sy) return Buffer.from(e).toString("base64");
        for (var t = new Uint8Array(e), n = "", r = 0, a = t.length; r < a; r++) n += String.fromCharCode(t[r]);
        return btoa(n)
    }

    function cy(e) {
        if (sy) {
            var t = Buffer.from(e, "base64");
            return t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength)
        }
        for (var n = atob(e), r = new Uint8Array(n.length), a = 0; a < n.length; ++a) r.set([n.charCodeAt(a)], a);
        return r.buffer
    }

    function py(e) {
        if (1 === e.length) return e[0];
        var t = 0;
        e.forEach(function (e) {
            t += e.byteLength
        });
        var n = new Uint8Array(t),
            r = 0;
        return e.forEach(function (e) {
            n.set(new Uint8Array(e), r), r += e.byteLength
        }), n.buffer
    }

    function hy(e) {
        for (e = e.trim(); e.endsWith("/");) e = e.slice(0, e.length - 1);
        var t = e.split("/");
        return t[t.length - 1]
    }

    function fy(e) {
        if (e.modelTopology instanceof ArrayBuffer) throw new Error("Expected JSON model topology, received ArrayBuffer.");
        return {
            dateSaved: new Date,
            modelTopologyType: "JSON",
            modelTopologyBytes: null == e.modelTopology ? 0 : uy(JSON.stringify(e.modelTopology)),
            weightSpecsBytes: null == e.weightSpecs ? 0 : uy(JSON.stringify(e.weightSpecs)),
            weightDataBytes: null == e.weightData ? 0 : e.weightData.byteLength
        }
    }

    function dy() {
        var e = function () {
                var e = function (e) {
                        for (var t = e << 13, n = 0; 0 == (8388608 & t);) n -= 8388608, t <<= 1;
                        return (t &= -8388609) | n + 947912704
                    },
                    t = new Uint32Array(2048);
                t[0] = 0;
                for (var n = 1; n < 1024; n++) t[n] = e(n);
                for (var r = 1024; r < 2048; r++) t[r] = 939524096 + (r - 1024 << 13);
                return t
            }(),
            t = function () {
                var e = new Uint32Array(64);
                e[0] = 0, e[31] = 1199570944, e[32] = 2147483648, e[63] = 3347054592;
                for (var t = 1; t < 31; t++) e[t] = t << 23;
                for (var n = 33; n < 63; n++) e[n] = 2147483648 + (n - 32 << 23);
                return e
            }(),
            n = function () {
                for (var e = new Uint32Array(64), t = 0; t < 64; t++) e[t] = 1024;
                return e[0] = e[32] = 0, e
            }();
        return function (r) {
            for (var a = new ArrayBuffer(4 * r.length), i = new Uint32Array(a), o = 0; o < r.length; o++) {
                var s = r[o],
                    u = e[n[s >> 10] + (1023 & s)] + t[s >> 10];
                i[o] = u
            }
            return new Float32Array(a)
        }
    }
    var my = function () {
            function e() {
                this.saveRouters = [], this.loadRouters = []
            }
            return e.getInstance = function () {
                return null == e.instance && (e.instance = new e), e.instance
            }, e.registerSaveRouter = function (t) {
                e.getInstance().saveRouters.push(t)
            }, e.registerLoadRouter = function (t) {
                e.getInstance().loadRouters.push(t)
            }, e.getSaveHandlers = function (t) {
                return e.getHandlers(t, "save")
            }, e.getLoadHandlers = function (t, n) {
                return e.getHandlers(t, "load", n)
            }, e.getHandlers = function (t, n, r) {
                var a = [];
                return ("load" === n ? e.getInstance().loadRouters : e.getInstance().saveRouters).forEach(function (e) {
                    var n = e(t, r);
                    null !== n && a.push(n)
                }), a
            }, e
        }(),
        vy = function (e) {
            return my.getSaveHandlers(e)
        },
        gy = function (e, t) {
            return my.getLoadHandlers(e, t)
        };

    function yy() {
        if (!Wv().getBool("IS_BROWSER")) throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
        var e = "undefined" == typeof window ? self : window,
            t = e.indexedDB || e.mozIndexedDB || e.webkitIndexedDB || e.msIndexedDB || e.shimIndexedDB;
        if (null == t) throw new Error("The current browser does not appear to support IndexedDB.");
        return t
    }

    function by(e) {
        var t = e.result;
        t.createObjectStore("models_store", {
            keyPath: "modelPath"
        }), t.createObjectStore("model_info_store", {
            keyPath: "modelPath"
        })
    }
    var xy = function () {
        function e(e) {
            if (this.indexedDB = yy(), null == e || !e) throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
            this.modelPath = e
        }
        var t = e.prototype;
        return t.save = function () {
            var e = Pm(regeneratorRuntime.mark(function e(t) {
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (!(t.modelTopology instanceof ArrayBuffer)) {
                                e.next = 2;
                                break
                            }
                            throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
                        case 2:
                            return e.abrupt("return", this.databaseAction(this.modelPath, t));
                        case 3:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function (t) {
                return e.apply(this, arguments)
            }
        }(), t.load = function () {
            var e = Pm(regeneratorRuntime.mark(function e() {
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return e.abrupt("return", this.databaseAction(this.modelPath));
                        case 1:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function () {
                return e.apply(this, arguments)
            }
        }(), t.databaseAction = function (e, t) {
            var n = this;
            return new Promise(function (e, r) {
                var a = n.indexedDB.open("tensorflowjs", 1);
                a.onupgradeneeded = function () {
                    return by(a)
                }, a.onsuccess = function () {
                    var i = a.result;
                    if (null == t) {
                        var o = i.transaction("models_store", "readonly"),
                            s = o.objectStore("models_store").get(n.modelPath);
                        s.onsuccess = function () {
                            if (null == s.result) return i.close(), r(new Error("Cannot find model with path '" + n.modelPath + "' in IndexedDB."));
                            e(s.result.modelArtifacts)
                        }, s.onerror = function (e) {
                            return i.close(), r(s.error)
                        }, o.oncomplete = function () {
                            return i.close()
                        }
                    } else {
                        var u, l = fy(t),
                            c = i.transaction("model_info_store", "readwrite"),
                            p = c.objectStore("model_info_store"),
                            h = p.put({
                                modelPath: n.modelPath,
                                modelArtifactsInfo: l
                            });
                        h.onsuccess = function () {
                            var a = (u = i.transaction("models_store", "readwrite")).objectStore("models_store").put({
                                modelPath: n.modelPath,
                                modelArtifacts: t,
                                modelArtifactsInfo: l
                            });
                            a.onsuccess = function () {
                                return e({
                                    modelArtifactsInfo: l
                                })
                            }, a.onerror = function (e) {
                                var t = (p = c.objectStore("model_info_store")).delete(n.modelPath);
                                t.onsuccess = function () {
                                    return i.close(), r(a.error)
                                }, t.onerror = function (e) {
                                    return i.close(), r(a.error)
                                }
                            }
                        }, h.onerror = function (e) {
                            return i.close(), r(h.error)
                        }, c.oncomplete = function () {
                            null == u ? i.close() : u.oncomplete = function () {
                                return i.close()
                            }
                        }
                    }
                }, a.onerror = function (e) {
                    return r(a.error)
                }
            })
        }, e
    }();
    xy.URL_SCHEME = "indexeddb://";
    var wy = function (e) {
        return Wv().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(xy.URL_SCHEME) ? (t = e.slice(xy.URL_SCHEME.length), new xy(t)) : null;
        var t
    };

    function ky(e) {
        return e.startsWith(xy.URL_SCHEME) ? e.slice(xy.URL_SCHEME.length) : e
    }
    my.registerSaveRouter(wy), my.registerLoadRouter(wy);
    var Ny = function () {
            function e() {
                this.indexedDB = yy()
            }
            var t = e.prototype;
            return t.listModels = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t = this;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.abrupt("return", new Promise(function (e, n) {
                                    var r = t.indexedDB.open("tensorflowjs", 1);
                                    r.onupgradeneeded = function () {
                                        return by(r)
                                    }, r.onsuccess = function () {
                                        var t = r.result,
                                            a = t.transaction("model_info_store", "readonly"),
                                            i = a.objectStore("model_info_store").getAll();
                                        i.onsuccess = function () {
                                            for (var t, n = {}, r = Xm(i.result); !(t = r()).done;) {
                                                var a = t.value;
                                                n[a.modelPath] = a.modelArtifactsInfo
                                            }
                                            e(n)
                                        }, i.onerror = function (e) {
                                            return t.close(), n(i.error)
                                        }, a.oncomplete = function () {
                                            return t.close()
                                        }
                                    }, r.onerror = function (e) {
                                        return n(r.error)
                                    }
                                }));
                            case 1:
                            case "end":
                                return e.stop()
                        }
                    }, e)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t.removeModel = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    var n = this;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return t = ky(t), e.abrupt("return", new Promise(function (e, r) {
                                    var a = n.indexedDB.open("tensorflowjs", 1);
                                    a.onupgradeneeded = function () {
                                        return by(a)
                                    }, a.onsuccess = function () {
                                        var n, i = a.result,
                                            o = i.transaction("model_info_store", "readwrite"),
                                            s = o.objectStore("model_info_store"),
                                            u = s.get(t);
                                        u.onsuccess = function () {
                                            if (null == u.result) return i.close(), r(new Error("Cannot find model with path '" + t + "' in IndexedDB."));
                                            var a = s.delete(t),
                                                o = function () {
                                                    var a = (n = i.transaction("models_store", "readwrite")).objectStore("models_store").delete(t);
                                                    a.onsuccess = function () {
                                                        return e(u.result.modelArtifactsInfo)
                                                    }, a.onerror = function (e) {
                                                        return r(u.error)
                                                    }
                                                };
                                            a.onsuccess = o, a.onerror = function (e) {
                                                return o(), i.close(), r(u.error)
                                            }
                                        }, u.onerror = function (e) {
                                            return i.close(), r(u.error)
                                        }, o.oncomplete = function () {
                                            null == n ? i.close() : n.oncomplete = function () {
                                                return i.close()
                                            }
                                        }
                                    }, a.onerror = function (e) {
                                        return r(a.error)
                                    }
                                }));
                            case 2:
                            case "end":
                                return e.stop()
                        }
                    }, e)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), e
        }(),
        Iy = "tensorflowjs_models",
        Sy = "info",
        Ty = "model_topology",
        Cy = "weight_specs",
        Ey = "weight_data",
        Ry = "model_metadata";

    function Ay(e) {
        return {
            info: [Iy, e, Sy].join("/"),
            topology: [Iy, e, Ty].join("/"),
            weightSpecs: [Iy, e, Cy].join("/"),
            weightData: [Iy, e, Ey].join("/"),
            modelMetadata: [Iy, e, Ry].join("/")
        }
    }

    function Fy(e) {
        var t = e.split("/");
        if (t.length < 3) throw new Error("Invalid key format: " + e);
        return t.slice(1, t.length - 1).join("/")
    }

    function _y(e) {
        return e.startsWith(Dy.URL_SCHEME) ? e.slice(Dy.URL_SCHEME.length) : e
    }
    var Dy = function () {
        function e(e) {
            if (!Wv().getBool("IS_BROWSER") || "undefined" == typeof window || void 0 === window.localStorage) throw new Error("The current environment does not support local storage.");
            if (this.LS = window.localStorage, null == e || !e) throw new Error("For local storage, modelPath must not be null, undefined or empty.");
            this.modelPath = e, this.keys = Ay(this.modelPath)
        }
        var t = e.prototype;
        return t.save = function () {
            var e = Pm(regeneratorRuntime.mark(function e(t) {
                var n, r, a, i;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (!(t.modelTopology instanceof ArrayBuffer)) {
                                e.next = 4;
                                break
                            }
                            throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
                        case 4:
                            return n = JSON.stringify(t.modelTopology), r = JSON.stringify(t.weightSpecs), a = fy(t), e.prev = 7, this.LS.setItem(this.keys.info, JSON.stringify(a)), this.LS.setItem(this.keys.topology, n), this.LS.setItem(this.keys.weightSpecs, r), this.LS.setItem(this.keys.weightData, ly(t.weightData)), i = {
                                format: t.format,
                                generatedBy: t.generatedBy,
                                convertedBy: t.convertedBy
                            }, null != t.signature && (i.signature = t.signature), null != t.userDefinedMetadata && (i.userDefinedMetadata = t.userDefinedMetadata), null != t.modelInitializer && (i.modelInitializer = t.modelInitializer), this.LS.setItem(this.keys.modelMetadata, JSON.stringify(i)), e.abrupt("return", {
                                modelArtifactsInfo: a
                            });
                        case 20:
                            throw e.prev = 20, e.t0 = e.catch(7), this.LS.removeItem(this.keys.info), this.LS.removeItem(this.keys.topology), this.LS.removeItem(this.keys.weightSpecs), this.LS.removeItem(this.keys.weightData), this.LS.removeItem(this.keys.modelMetadata), new Error("Failed to save model '" + this.modelPath + "' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=" + a.modelTopologyBytes + ", weightSpecsBytes=" + a.weightSpecsBytes + ", weightDataBytes=" + a.weightDataBytes + ".");
                        case 28:
                        case "end":
                            return e.stop()
                    }
                }, e, this, [
                    [7, 20]
                ])
            }));
            return function (t) {
                return e.apply(this, arguments)
            }
        }(), t.load = function () {
            var e = Pm(regeneratorRuntime.mark(function e() {
                var t, n, r, a, i, o, s;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (null != (t = JSON.parse(this.LS.getItem(this.keys.info)))) {
                                e.next = 3;
                                break
                            }
                            throw new Error("In local storage, there is no model with name '" + this.modelPath + "'");
                        case 3:
                            if ("JSON" === t.modelTopologyType) {
                                e.next = 5;
                                break
                            }
                            throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
                        case 5:
                            if (n = {}, null != (r = JSON.parse(this.LS.getItem(this.keys.topology)))) {
                                e.next = 9;
                                break
                            }
                            throw new Error("In local storage, the topology of model '" + this.modelPath + "' is missing.");
                        case 9:
                            if (n.modelTopology = r, null != (a = JSON.parse(this.LS.getItem(this.keys.weightSpecs)))) {
                                e.next = 13;
                                break
                            }
                            throw new Error("In local storage, the weight specs of model '" + this.modelPath + "' are missing.");
                        case 13:
                            if (n.weightSpecs = a, null != (i = this.LS.getItem(this.keys.modelMetadata)) && (o = JSON.parse(i), n.format = o.format, n.generatedBy = o.generatedBy, n.convertedBy = o.convertedBy, null != o.signature && (n.signature = o.signature), null != o.userDefinedMetadata && (n.userDefinedMetadata = o.userDefinedMetadata), null != o.modelInitializer && (n.modelInitializer = o.modelInitializer)), null != (s = this.LS.getItem(this.keys.weightData))) {
                                e.next = 19;
                                break
                            }
                            throw new Error("In local storage, the binary weight values of model '" + this.modelPath + "' are missing.");
                        case 19:
                            return n.weightData = cy(s), e.abrupt("return", n);
                        case 21:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function () {
                return e.apply(this, arguments)
            }
        }(), e
    }();
    Dy.URL_SCHEME = "localstorage://";
    var Oy = function (e) {
        return Wv().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(Dy.URL_SCHEME) ? (t = e.slice(Dy.URL_SCHEME.length), new Dy(t)) : null;
        var t
    };
    my.registerSaveRouter(Oy), my.registerLoadRouter(Oy);
    var My = function () {
            function e() {
                nv(Wv().getBool("IS_BROWSER"), function () {
                    return "Current environment is not a web browser"
                }), nv("undefined" == typeof window || void 0 !== window.localStorage, function () {
                    return "Current browser does not appear to support localStorage"
                }), this.LS = window.localStorage
            }
            var t = e.prototype;
            return t.listModels = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t, n, r, a, i, o;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                for (t = {}, n = Iy + "/", r = "/" + Sy, a = 0; a < this.LS.length; ++a)(i = this.LS.key(a)).startsWith(n) && i.endsWith(r) && (o = Fy(i), t[o] = JSON.parse(this.LS.getItem(i)));
                                return e.abrupt("return", t);
                            case 5:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t.removeModel = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    var n, r;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (t = _y(t), n = Ay(t), null != this.LS.getItem(n.info)) {
                                    e.next = 4;
                                    break
                                }
                                throw new Error("Cannot find model at path '" + t + "'");
                            case 4:
                                return r = JSON.parse(this.LS.getItem(n.info)), this.LS.removeItem(n.info), this.LS.removeItem(n.topology), this.LS.removeItem(n.weightSpecs), this.LS.removeItem(n.weightData), e.abrupt("return", r);
                            case 10:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), e
        }(),
        Ly = function () {
            function e() {
                this.managers = {}
            }
            return e.getInstance = function () {
                return null == e.instance && (e.instance = new e), e.instance
            }, e.registerManager = function (t, n) {
                nv(null != t, function () {
                    return "scheme must not be undefined or null."
                }), t.endsWith("://") && (t = t.slice(0, t.indexOf("://"))), nv(t.length > 0, function () {
                    return "scheme must not be an empty string."
                });
                var r = e.getInstance();
                nv(null == r.managers[t], function () {
                    return "A model store manager is already registered for scheme '" + t + "'."
                }), r.managers[t] = n
            }, e.getManager = function (e) {
                var t = this.getInstance().managers[e];
                if (null == t) throw new Error("Cannot find model manager for scheme '" + e + "'");
                return t
            }, e.getSchemes = function () {
                return Object.keys(this.getInstance().managers)
            }, e
        }();

    function zy(e) {
        if (-1 === e.indexOf("://")) throw new Error("The url string provided does not contain a scheme. Supported schemes are: " + Ly.getSchemes().join(","));
        return {
            scheme: e.split("://")[0],
            path: e.split("://")[1]
        }
    }

    function Py(e, t, n) {
        return function () {
            return Pm(regeneratorRuntime.mark(function e(t, n, r) {
                var a, i, o, s, u, l, c, p, h;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return void 0 === r && (r = !1), nv(t !== n, function () {
                                return "Old path and new path are the same: '" + t + "'"
                            }), nv((a = my.getLoadHandlers(t)).length > 0, function () {
                                return "Copying failed because no load handler is found for source URL " + t + "."
                            }), nv(a.length < 2, function () {
                                return "Copying failed because more than one (" + a.length + ") load handlers for source URL " + t + "."
                            }), i = a[0], nv((o = my.getSaveHandlers(n)).length > 0, function () {
                                return "Copying failed because no save handler is found for destination URL " + n + "."
                            }), nv(o.length < 2, function () {
                                return "Copying failed because more than one (" + a.length + ") save handlers for destination URL " + n + "."
                            }), s = o[0], u = zy(t).scheme, l = zy(t).path, c = u === zy(t).scheme, e.next = 15, i.load();
                        case 15:
                            if (p = e.sent, !r || !c) {
                                e.next = 19;
                                break
                            }
                            return e.next = 19, Ly.getManager(u).removeModel(l);
                        case 19:
                            return e.next = 21, s.save(p);
                        case 21:
                            if (h = e.sent, !r || c) {
                                e.next = 25;
                                break
                            }
                            return e.next = 25, Ly.getManager(u).removeModel(l);
                        case 25:
                            return e.abrupt("return", h.modelArtifactsInfo);
                        case 26:
                        case "end":
                            return e.stop()
                    }
                }, e)
            })).apply(this, arguments)
        }.apply(this, arguments)
    }

    function By() {
        return (By = Pm(regeneratorRuntime.mark(function e() {
            var t, n, r, a, i, o, s;
            return regeneratorRuntime.wrap(function (e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        t = Ly.getSchemes(), n = {}, r = Xm(t);
                    case 3:
                        if ((a = r()).done) {
                            e.next = 11;
                            break
                        }
                        return i = a.value, e.next = 7, Ly.getManager(i).listModels();
                    case 7:
                        for (s in o = e.sent) n[i + "://" + s] = o[s];
                    case 9:
                        e.next = 3;
                        break;
                    case 11:
                        return e.abrupt("return", n);
                    case 12:
                    case "end":
                        return e.stop()
                }
            }, e)
        }))).apply(this, arguments)
    }

    function Wy() {
        return (Wy = Pm(regeneratorRuntime.mark(function e(t) {
            var n, r;
            return regeneratorRuntime.wrap(function (e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return n = zy(t), r = Ly.getManager(n.scheme), e.abrupt("return", r.removeModel(n.path));
                    case 3:
                    case "end":
                        return e.stop()
                }
            }, e)
        }))).apply(this, arguments)
    }

    function Vy() {
        return (Vy = Pm(regeneratorRuntime.mark(function e(t, n) {
            return regeneratorRuntime.wrap(function (e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return e.abrupt("return", Py(t, n, !1));
                    case 2:
                    case "end":
                        return e.stop()
                }
            }, e)
        }))).apply(this, arguments)
    }

    function Uy() {
        return (Uy = Pm(regeneratorRuntime.mark(function e(t, n) {
            return regeneratorRuntime.wrap(function (e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return e.abrupt("return", Py(t, n, !0));
                    case 2:
                    case "end":
                        return e.stop()
                }
            }, e)
        }))).apply(this, arguments)
    }
    var Gy = function () {
        function e() {}
        var t = e.prototype;
        return t.fetch = function (e) {
            function t(t, n) {
                return e.apply(this, arguments)
            }
            return t.toString = function () {
                return e.toString()
            }, t
        }(function (e, t) {
            return fetch(e, t)
        }), t.now = function () {
            return performance.now()
        }, t.encode = function (e, t) {
            if ("utf-8" !== t && "utf8" !== t) throw new Error("Browser's encoder only supports utf-8, but got " + t);
            return null == this.textEncoder && (this.textEncoder = new TextEncoder), this.textEncoder.encode(e)
        }, t.decode = function (e, t) {
            return new TextDecoder(t).decode(e)
        }, e
    }();
    if (Wv().get("IS_BROWSER")) {
        Wv().setPlatform("browser", new Gy);
        try {
            Ly.registerManager(Dy.URL_SCHEME, new My)
        } catch (e) {}
        try {
            Ly.registerManager(xy.URL_SCHEME, new Ny)
        } catch (e) {}
    }
    var jy, Hy = function () {
        function e() {
            this.util = require("util"), this.textEncoder = new this.util.TextEncoder
        }
        var t = e.prototype;
        return t.fetch = function (e, t) {
            return null != Wv().global.fetch ? Wv().global.fetch(e, t) : (null == jy && (jy = require("node-fetch")), jy(e, t))
        }, t.now = function () {
            var e = process.hrtime();
            return 1e3 * e[0] + e[1] / 1e6
        }, t.encode = function (e, t) {
            if ("utf-8" !== t && "utf8" !== t) throw new Error("Node built-in encoder only supports utf-8, but got " + t);
            return this.textEncoder.encode(e)
        }, t.decode = function (e, t) {
            return 0 === e.length ? "" : new this.util.TextDecoder(t).decode(e)
        }, e
    }();

    function qy(e, t, n) {
        return void 0 === t && (t = "float32"), t = t || "float32", Ov(e), new xg(e, t, n)
    }
    Wv().get("IS_NODE") && Wv().setPlatform("node", new Hy);
    var Ky = $g({
            cast_: function (e, t) {
                var n = Zg(e, "x", "cast");
                if (!yv(t)) throw new Error("Failed to cast to unknown dtype " + t);
                if ("string" === t && "string" !== n.dtype || "string" !== t && "string" === n.dtype) throw new Error("Only strings can be casted to strings");
                var r = {
                        x: n
                    },
                    a = {
                        dtype: t
                    };
                return Gg.runKernel("Cast", r, a)
            }
        }),
        Xy = $g({
            clone_: function (e) {
                var t = {
                    x: Zg(e, "x", "clone", "string_or_numeric")
                };
                return Gg.runKernel("Identity", t)
            }
        });

    function Yy(e, t) {
        void 0 === t && (t = !1), console.log(e.toString(t))
    }

    function Jy(e) {
        return new Promise(function (e) {
            return setTimeout(e)
        }).then(e)
    }
    Ug(), kg = {
        buffer: qy,
        cast: Ky,
        clone: Xy,
        print: Yy
    };
    var Zy = function () {
        function e(t) {
            if (!Wv().getBool("IS_BROWSER")) throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
            t.startsWith(e.URL_SCHEME) && (t = t.slice(e.URL_SCHEME.length)), null != t && 0 !== t.length || (t = "model"), this.modelTopologyFileName = t + ".json", this.weightDataFileName = t + ".weights.bin"
        }
        return e.prototype.save = function () {
            var e = Pm(regeneratorRuntime.mark(function e(t) {
                var n, r, a, i, o, s;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if ("undefined" != typeof document) {
                                e.next = 2;
                                break
                            }
                            throw new Error("Browser downloads are not supported in this environment since `document` is not present");
                        case 2:
                            if (n = window.URL.createObjectURL(new Blob([t.weightData], {
                                    type: "application/octet-stream"
                                })), !(t.modelTopology instanceof ArrayBuffer)) {
                                e.next = 7;
                                break
                            }
                            throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
                        case 7:
                            return r = [{
                                paths: ["./" + this.weightDataFileName],
                                weights: t.weightSpecs
                            }], a = {
                                modelTopology: t.modelTopology,
                                format: t.format,
                                generatedBy: t.generatedBy,
                                convertedBy: t.convertedBy,
                                weightsManifest: r
                            }, null != t.signature && (a.signature = t.signature), null != t.userDefinedMetadata && (a.userDefinedMetadata = t.userDefinedMetadata), null != t.modelInitializer && (a.modelInitializer = t.modelInitializer), i = window.URL.createObjectURL(new Blob([JSON.stringify(a)], {
                                type: "application/json"
                            })), (o = null == this.jsonAnchor ? document.createElement("a") : this.jsonAnchor).download = this.modelTopologyFileName, o.href = i, e.next = 18, Jy(function () {
                                return o.dispatchEvent(new MouseEvent("click"))
                            });
                        case 18:
                            if (null == t.weightData) {
                                e.next = 24;
                                break
                            }
                            return (s = null == this.weightDataAnchor ? document.createElement("a") : this.weightDataAnchor).download = this.weightDataFileName, s.href = n, e.next = 24, Jy(function () {
                                return s.dispatchEvent(new MouseEvent("click"))
                            });
                        case 24:
                            return e.abrupt("return", {
                                modelArtifactsInfo: fy(t)
                            });
                        case 25:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function (t) {
                return e.apply(this, arguments)
            }
        }(), e
    }();
    Zy.URL_SCHEME = "downloads://";
    var Qy = function () {
        function e(e) {
            if (null == e || e.length < 1) throw new Error("When calling browserFiles, at least 1 file is required, but received " + e);
            this.files = e
        }
        var t = e.prototype;
        return t.load = function () {
            var e = Pm(regeneratorRuntime.mark(function e() {
                var t, n, r = this;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return t = this.files[0], n = this.files.slice(1), e.abrupt("return", new Promise(function (e, a) {
                                var i = new FileReader;
                                i.onload = function (i) {
                                    var o = JSON.parse(i.target.result),
                                        s = o.modelTopology;
                                    if (null != s) {
                                        0 === n.length && e({
                                            modelTopology: s
                                        });
                                        var u = o.weightsManifest;
                                        if (null != u) {
                                            var l;
                                            try {
                                                l = r.checkManifestAndWeightFiles(u, n)
                                            } catch (e) {
                                                return void a(e)
                                            }
                                            var c = [],
                                                p = [],
                                                h = [];
                                            u.forEach(function (e) {
                                                e.paths.forEach(function (e) {
                                                    p.push(e), h.push(null)
                                                }), c.push.apply(c, e.weights)
                                            }), u.forEach(function (t) {
                                                t.paths.forEach(function (t) {
                                                    var n = new FileReader;
                                                    n.onload = function (n) {
                                                        var r = n.target.result,
                                                            a = p.indexOf(t);
                                                        if (h[a] = r, -1 === h.indexOf(null)) {
                                                            var i = {
                                                                modelTopology: s,
                                                                weightSpecs: c,
                                                                weightData: py(h),
                                                                format: o.format,
                                                                generatedBy: o.generatedBy,
                                                                convertedBy: o.convertedBy
                                                            };
                                                            null != o.signature && (i.signature = o.signature), null != o.userDefinedMetadata && (i.userDefinedMetadata = o.userDefinedMetadata), null != o.modelInitializer && (i.modelInitializer = o.modelInitializer), e(i)
                                                        }
                                                    }, n.onerror = function (e) {
                                                        return a("Failed to weights data from file of path '" + t + "'.")
                                                    }, n.readAsArrayBuffer(l[t])
                                                })
                                            })
                                        } else a(new Error("weightManifest field is missing from file " + t.name))
                                    } else a(new Error("modelTopology field is missing from file " + t.name))
                                }, i.onerror = function (e) {
                                    return a("Failed to read model topology and weights manifest JSON from file '" + t.name + "'. BrowserFiles supports loading Keras-style tf.Model artifacts only.")
                                }, i.readAsText(t)
                            }));
                        case 3:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function () {
                return e.apply(this, arguments)
            }
        }(), t.checkManifestAndWeightFiles = function (e, t) {
            for (var n, r = [], a = t.map(function (e) {
                    return hy(e.name)
                }), i = {}, o = Xm(e); !(n = o()).done;) n.value.paths.forEach(function (e) {
                var n = hy(e);
                if (-1 !== r.indexOf(n)) throw new Error("Duplicate file basename found in weights manifest: '" + n + "'");
                if (r.push(n), -1 === a.indexOf(n)) throw new Error("Weight file with basename '" + n + "' is not provided.");
                i[e] = t[a.indexOf(n)]
            });
            if (r.length !== t.length) throw new Error("Mismatch in the number of files in weights manifest (" + r.length + ") and the number of weight files provided (" + t.length + ").");
            return i
        }, e
    }();

    function $y(e, t, n, r) {
        ! function (e) {
            nv(null != e && Array.isArray(e) && e.length > 0, function () {
                return "promises must be a none empty array"
            })
        }(e),
        function (e, t) {
            nv(e >= 0 && e <= 1, function () {
                return "Progress fraction must be in range [0, 1], but got startFraction " + e
            }), nv(t >= 0 && t <= 1, function () {
                return "Progress fraction must be in range [0, 1], but got endFraction " + t
            }), nv(t >= e, function () {
                return "startFraction must be no more than endFraction, but got startFraction " + e + " and endFraction " + t
            })
        }(n = null == n ? 0 : n, r = null == r ? 1 : r);
        var a = 0;
        return Promise.all(e.map(function (i) {
            return i.then(function (i) {
                var o = n + ++a / e.length * (r - n);
                return t(o), i
            }), i
        }))
    }

    function eb(e, t) {
        return function () {
            return Pm(regeneratorRuntime.mark(function e(t, n) {
                var r, a, i, o, s, u, l, c, p;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (null == n && (n = {}), r = null == n.fetchFunc ? Wv().platform.fetch : n.fetchFunc, a = t.map(function (e) {
                                    return r(e, n.requestInit, {
                                        isBinary: !0
                                    })
                                }), i = 0, o = .5, null != n.onProgress) {
                                e.next = 11;
                                break
                            }
                            return e.next = 8, Promise.all(a);
                        case 8:
                            e.t0 = e.sent, e.next = 14;
                            break;
                        case 11:
                            return e.next = 13, $y(a, n.onProgress, i, o);
                        case 13:
                            e.t0 = e.sent;
                        case 14:
                            if (s = e.t0, u = s.map(function (e) {
                                    return e.arrayBuffer()
                                }), l = .5, c = 1, null != n.onProgress) {
                                e.next = 24;
                                break
                            }
                            return e.next = 21, Promise.all(u);
                        case 21:
                            e.t1 = e.sent, e.next = 27;
                            break;
                        case 24:
                            return e.next = 26, $y(u, n.onProgress, l, c);
                        case 26:
                            e.t1 = e.sent;
                        case 27:
                            return p = e.t1, e.abrupt("return", p);
                        case 29:
                        case "end":
                            return e.stop()
                    }
                }, e)
            })).apply(this, arguments)
        }.apply(this, arguments)
    }

    function tb(e, t, n, r) {
        return function () {
            return Pm(regeneratorRuntime.mark(function e(t, n, r, a) {
                var i;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return void 0 === n && (n = ""), i = nb(function (e) {
                                return eb(e, {
                                    requestInit: a
                                })
                            }), e.abrupt("return", i(t, n, r));
                        case 4:
                        case "end":
                            return e.stop()
                    }
                }, e)
            })).apply(this, arguments)
        }.apply(this, arguments)
    }

    function nb(e) {
        return t = Pm(regeneratorRuntime.mark(function t(n, r, a) {
                var i, o, s, u, l, c, p, h, f, d;
                return regeneratorRuntime.wrap(function (t) {
                    for (;;) switch (t.prev = t.next) {
                        case 0:
                            if (void 0 === r && (r = ""), i = n.map(function () {
                                    return !1
                                }), o = {}, s = null != a ? a.map(function () {
                                    return !1
                                }) : [], u = [], n.forEach(function (e, t) {
                                    var n = 0;
                                    e.weights.forEach(function (e) {
                                        var r = "quantization" in e ? e.quantization.dtype : e.dtype,
                                            l = ry[r] * ov(e.shape),
                                            c = function () {
                                                i[t] = !0, null == o[t] && (o[t] = []), o[t].push({
                                                    manifestEntry: e,
                                                    groupOffset: n,
                                                    sizeBytes: l
                                                })
                                            };
                                        null != a ? a.forEach(function (t, n) {
                                            t === e.name && (c(), s[n] = !0)
                                        }) : c(), u.push(e.name), n += l
                                    })
                                }), s.every(function (e) {
                                    return e
                                })) {
                                t.next = 9;
                                break
                            }
                            throw l = a.filter(function (e, t) {
                                return !s[t]
                            }), new Error("Could not find weights in manifest with names: " + l.join(", ") + ". \nManifest JSON has weights with names: " + u.join(", ") + ".");
                        case 9:
                            return c = i.reduce(function (e, t, n) {
                                return t && e.push(n), e
                            }, []), p = [], c.forEach(function (e) {
                                n[e].paths.forEach(function (e) {
                                    var t = r + (r.endsWith("/") ? "" : "/") + e;
                                    p.push(t)
                                })
                            }), t.next = 14, e(p);
                        case 14:
                            return h = t.sent, f = {}, d = 0, c.forEach(function (e) {
                                for (var t = n[e].paths.length, r = 0, a = 0; a < t; a++) r += h[d + a].byteLength;
                                for (var i = new ArrayBuffer(r), s = new Uint8Array(i), u = 0, l = 0; l < t; l++) {
                                    var c = new Uint8Array(h[d + l]);
                                    s.set(c, u), u += c.byteLength
                                }
                                o[e].forEach(function (e) {
                                    var t = iy(i.slice(e.groupOffset, e.groupOffset + e.sizeBytes), [e.manifestEntry]);
                                    for (var n in t) f[n] = t[n]
                                }), d += t
                            }), t.abrupt("return", f);
                        case 19:
                        case "end":
                            return t.stop()
                    }
                }, t)
            })),
            function (e, n, r) {
                return t.apply(this, arguments)
            };
        var t
    }
    my.registerSaveRouter(function (e) {
        return Wv().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(Zy.URL_SCHEME) ? function (e) {
            return void 0 === e && (e = "model"), new Zy(e)
        }(e.slice(Zy.URL_SCHEME.length)) : null
    });
    var rb = function () {
        function e(e, t) {
            if (this.DEFAULT_METHOD = "POST", null == t && (t = {}), this.weightPathPrefix = t.weightPathPrefix, this.onProgress = t.onProgress, this.weightUrlConverter = t.weightUrlConverter, null != t.fetchFunc ? (nv("function" == typeof t.fetchFunc, function () {
                    return "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"
                }), this.fetch = t.fetchFunc) : this.fetch = Wv().platform.fetch, nv(null != e && e.length > 0, function () {
                    return "URL path for http must not be null, undefined or empty."
                }), Array.isArray(e) && nv(2 === e.length, function () {
                    return "URL paths for http must have a length of 2, (actual length is " + e.length + ")."
                }), this.path = e, null != t.requestInit && null != t.requestInit.body) throw new Error("requestInit is expected to have no pre-existing body, but has one.");
            this.requestInit = t.requestInit || {}
        }
        var t = e.prototype;
        return t.save = function () {
            var e = Pm(regeneratorRuntime.mark(function e(t) {
                var n, r, a, i;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (!(t.modelTopology instanceof ArrayBuffer)) {
                                e.next = 2;
                                break
                            }
                            throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
                        case 2:
                            return (n = Object.assign({
                                method: this.DEFAULT_METHOD
                            }, this.requestInit)).body = new FormData, r = [{
                                paths: ["./model.weights.bin"],
                                weights: t.weightSpecs
                            }], a = {
                                modelTopology: t.modelTopology,
                                format: t.format,
                                generatedBy: t.generatedBy,
                                convertedBy: t.convertedBy,
                                weightsManifest: r
                            }, null != t.signature && (a.signature = t.signature), null != t.userDefinedMetadata && (a.userDefinedMetadata = t.userDefinedMetadata), null != t.modelInitializer && (a.modelInitializer = t.modelInitializer), n.body.append("model.json", new Blob([JSON.stringify(a)], {
                                type: "application/json"
                            }), "model.json"), null != t.weightData && n.body.append("model.weights.bin", new Blob([t.weightData], {
                                type: "application/octet-stream"
                            }), "model.weights.bin"), e.next = 13, this.fetch(this.path, n);
                        case 13:
                            if (!(i = e.sent).ok) {
                                e.next = 18;
                                break
                            }
                            return e.abrupt("return", {
                                modelArtifactsInfo: fy(t),
                                responses: [i]
                            });
                        case 18:
                            throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status " + i.status + ".");
                        case 19:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function (t) {
                return e.apply(this, arguments)
            }
        }(), t.load = function () {
            var e = Pm(regeneratorRuntime.mark(function e() {
                var t, n, r, a, i, o, s, u, l, c, p, h, f, d, m;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return e.next = 2, this.fetch(this.path, this.requestInit);
                        case 2:
                            if ((t = e.sent).ok) {
                                e.next = 5;
                                break
                            }
                            throw new Error("Request to " + this.path + " failed with status code " + t.status + ". Please verify this URL points to the model JSON of the model to load.");
                        case 5:
                            return e.prev = 5, e.next = 8, t.json();
                        case 8:
                            n = e.sent, e.next = 16;
                            break;
                        case 11:
                            throw e.prev = 11, e.t0 = e.catch(5), r = "Failed to parse model JSON of response from " + this.path + ".", this.path.endsWith(".pb") ? r += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : r += " Please make sure the server is serving valid JSON for this request.", new Error(r);
                        case 16:
                            if (a = n.modelTopology, i = n.weightsManifest, o = n.generatedBy, s = n.convertedBy, u = n.format, l = n.signature, c = n.userDefinedMetadata, null != a || null != i) {
                                e.next = 25;
                                break
                            }
                            throw new Error("The JSON from HTTP path " + this.path + " contains neither model topology or manifest for weights.");
                        case 25:
                            if (null == i) {
                                e.next = 31;
                                break
                            }
                            return e.next = 28, this.loadWeights(i);
                        case 28:
                            f = e.sent, p = f[0], h = f[1];
                        case 31:
                            return d = {
                                modelTopology: a,
                                weightSpecs: p,
                                weightData: h,
                                generatedBy: o,
                                convertedBy: s,
                                format: u
                            }, null != l && (d.signature = l), null != c && (d.userDefinedMetadata = c), (m = n.modelInitializer) && (d.modelInitializer = m), e.abrupt("return", d);
                        case 37:
                        case "end":
                            return e.stop()
                    }
                }, e, this, [
                    [5, 11]
                ])
            }));
            return function () {
                return e.apply(this, arguments)
            }
        }(), t.loadWeights = function () {
            var e = Pm(regeneratorRuntime.mark(function e(t) {
                var n, r, a, i, o, s, u, l, c, p, h, f, d, m, v, g, y, b;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            for (n = Array.isArray(this.path) ? this.path[1] : this.path, r = ab(n), a = r[0], i = r[1], o = this.weightPathPrefix || a, s = [], u = Xm(t); !(l = u()).done;) c = l.value, s.push.apply(s, c.weights);
                            for (p = [], h = [], f = Xm(t); !(d = f()).done;)
                                for (m = d.value, v = Xm(m.paths); !(g = v()).done;) y = g.value, null != this.weightUrlConverter ? h.push(this.weightUrlConverter(y)) : p.push(o + y + i);
                            if (!this.weightUrlConverter) {
                                e.next = 15;
                                break
                            }
                            return e.t0 = p.push, e.t1 = p, e.next = 13, Promise.all(h);
                        case 13:
                            e.t2 = e.sent, e.t0.apply.call(e.t0, e.t1, e.t2);
                        case 15:
                            return e.next = 17, eb(p, {
                                requestInit: this.requestInit,
                                fetchFunc: this.fetch,
                                onProgress: this.onProgress
                            });
                        case 17:
                            return b = e.sent, e.abrupt("return", [s, py(b)]);
                        case 19:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function (t) {
                return e.apply(this, arguments)
            }
        }(), e
    }();

    function ab(e) {
        var t = e.lastIndexOf("/"),
            n = e.lastIndexOf("?");
        return [e.substring(0, t) + "/", n > t ? e.substring(n) : ""]
    }

    function ib(e) {
        return null != e.match(rb.URL_SCHEME_REGEX)
    }
    rb.URL_SCHEME_REGEX = /^https?:\/\//;
    var ob = function (e, t) {
        return ("undefined" != typeof fetch || null != t && null != t.fetchFunc) && (Array.isArray(e) ? e.every(function (e) {
            return ib(e)
        }) : ib(e)) ? sb(e, t) : null
    };

    function sb(e, t) {
        return new rb(e, t)
    }

    function ub(e, t) {
        return sb(e, t)
    }
    my.registerSaveRouter(ob), my.registerLoadRouter(ob);
    var lb, cb = function () {
            function e(e) {
                this.modelArtifacts = e
            }
            return e.prototype.load = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.abrupt("return", this.modelArtifacts);
                            case 1:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), e
        }(),
        pb = function () {
            function e(e) {
                this.saveHandler = e
            }
            return e.prototype.save = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.abrupt("return", this.saveHandler(t));
                            case 1:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), e
        }(),
        hb = {
            __proto__: null,
            browserFiles: function (e) {
                return new Qy(e)
            },
            browserHTTPRequest: ub,
            concatenateArrayBuffers: py,
            decodeWeights: iy,
            encodeWeights: ay,
            fromMemory: function (e, t, n, r) {
                return 1 === arguments.length ? null != e.modelTopology || null != e.weightSpecs ? new cb(e) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new cb({
                    modelTopology: e
                })) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new cb({
                    modelTopology: e,
                    weightSpecs: t,
                    weightData: n,
                    trainingConfig: r
                }))
            },
            getLoadHandlers: gy,
            getModelArtifactsInfoForJSON: fy,
            getSaveHandlers: vy,
            http: sb,
            isHTTPScheme: ib,
            loadWeights: tb,
            registerLoadRouter: function (e) {
                return my.registerLoadRouter(e)
            },
            registerSaveRouter: function (e) {
                return my.registerSaveRouter(e)
            },
            weightsLoaderFactory: nb,
            withSaveHandler: function (e) {
                return new pb(e)
            },
            copyModel: function (e, t) {
                return Vy.apply(this, arguments)
            },
            listModels: function () {
                return By.apply(this, arguments)
            },
            moveModel: function (e, t) {
                return Uy.apply(this, arguments)
            },
            removeModel: function (e) {
                return Wy.apply(this, arguments)
            }
        },
        fb = $g({
            matMul_: function (e, t, n, r) {
                void 0 === n && (n = !1), void 0 === r && (r = !1);
                var a = Zg(e, "a", "matMul"),
                    i = Zg(t, "b", "matMul"),
                    o = Og(a, i),
                    s = {
                        a: a = o[0],
                        b: i = o[1]
                    },
                    u = {
                        transposeA: n,
                        transposeB: r
                    };
                return Gg.runKernel("BatchMatMul", s, u)
            }
        }),
        db = $g({
            oneHot_: function (e, t, n, r) {
                if (void 0 === n && (n = 1), void 0 === r && (r = 0), t < 2) throw new Error("Error in oneHot: depth must be >=2, but it is " + t);
                var a = {
                        indices: Zg(e, "indices", "oneHot", "int32")
                    },
                    i = {
                        depth: t,
                        onValue: n,
                        offValue: r
                    };
                return Gg.runKernel("OneHot", a, i)
            }
        }),
        mb = $g({
            transpose_: function (e, t) {
                var n = Zg(e, "x", "transpose");
                if (null == t && (t = n.shape.map(function (e, t) {
                        return t
                    }).reverse()), nv(n.rank === t.length, function () {
                        return "Error in transpose: rank of input " + n.rank + " must match length of perm " + t + "."
                    }), t.forEach(function (e) {
                        nv(e >= 0 && e < n.rank, function () {
                            return "All entries in 'perm' must be between 0 and " + (n.rank - 1) + " but got " + t
                        })
                    }), n.rank <= 1) return n.clone();
                var r = {
                        x: n
                    },
                    a = {
                        perm: t
                    };
                return Gg.runKernel("Transpose", r, a)
            }
        }),
        vb = {
            __proto__: null,
            confusionMatrix: $g({
                confusionMatrix_: function (e, t, n) {
                    var r = Zg(e, "labels", "confusionMatrix"),
                        a = Zg(t, "predictions", "confusionMatrix");
                    nv(null == n || n > 0 && Number.isInteger(n), function () {
                        return "If provided, numClasses must be a positive integer, but got " + n
                    }), nv(1 === r.rank, function () {
                        return "Expected the rank of labels to be 1, but got " + r.rank
                    }), nv(1 === a.rank, function () {
                        return "Expected the rank of predictions to be 1, but got " + a.rank
                    }), nv(r.shape[0] === a.shape[0], function () {
                        return "Mismatch in the number of examples: " + r.shape[0] + " vs. " + a.shape[0] + ". Labels and predictions should have the same number of elements."
                    }), nv(n > 0 && Number.isInteger(n), function () {
                        return "numClasses is required to be a positive integer, but got " + n
                    });
                    var i = db(Ky(r, "int32"), n),
                        o = db(Ky(a, "int32"), n),
                        s = mb(i),
                        u = fb(s, o);
                    return Ky(u, "int32")
                }
            })
        };

    function gb(e, t, n) {
        if (av(e), null != t && 3 !== t.length) throw new Error("tensor3d() requires shape to have three numbers");
        var r = Yg(e, n);
        if (3 !== r.length && 1 !== r.length) throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
        if (1 === r.length && null == t) throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
        return ty(e, t, r, n)
    }

    function yb(e, t) {
        if (void 0 === t && (t = 3), t > 4) throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
        if (null == e) throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
        var n = !1,
            r = !1,
            a = !1,
            i = !1,
            o = !1,
            s = !1;
        if (e.data instanceof Uint8Array) n = !0;
        else if ("undefined" != typeof ImageData && e instanceof ImageData) r = !0;
        else if ("undefined" != typeof HTMLVideoElement && e instanceof HTMLVideoElement) a = !0;
        else if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement) i = !0;
        else if (null != e.getContext) o = !0;
        else {
            if (!("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)) throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was " + e.constructor.name);
            s = !0
        }
        if (a && a && e.readyState < 2) throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");
        if (null != ng("FromPixels", Gg.backendName)) {
            var u = {
                    pixels: e
                },
                l = {
                    numChannels: t
                };
            return Gg.runKernel("FromPixels", u, l)
        }
        var c, p, h = a ? [e.videoWidth, e.videoHeight] : [e.width, e.height],
            f = h[0],
            d = h[1];
        if (o ? c = e.getContext("2d").getImageData(0, 0, f, d).data : r || n ? c = e.data : (i || a || s) && (null == lb && (lb = document.createElement("canvas").getContext("2d")), lb.canvas.width = f, lb.canvas.height = d, lb.drawImage(e, 0, 0, f, d), c = lb.getImageData(0, 0, f, d).data), 4 === t) p = new Int32Array(c);
        else {
            var m = f * d;
            p = new Int32Array(m * t);
            for (var v = 0; v < m; v++)
                for (var g = 0; g < t; ++g) p[v * t + g] = c[4 * v + g]
        }
        return gb(p, [d, f, t], "int32")
    }

    function bb(e) {
        return "undefined" != typeof window && "undefined" != typeof ImageBitmap && window.hasOwnProperty("createImageBitmap") && !(e instanceof ImageBitmap) && function (e) {
            return null != e && 0 !== e.width && 0 !== e.height
        }(e) && ! function (e) {
            return null != e && e.data instanceof Uint8Array
        }(e)
    }

    function xb() {
        return (xb = Pm(regeneratorRuntime.mark(function e(t, n) {
            var r, a;
            return regeneratorRuntime.wrap(function (e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        if (void 0 === n && (n = 3), r = null, !Wv().getBool("WRAP_TO_IMAGEBITMAP") || !bb(t)) {
                            e.next = 15;
                            break
                        }
                        return e.prev = 3, e.next = 6, createImageBitmap(t, {
                            premultiplyAlpha: "none"
                        });
                    case 6:
                        a = e.sent, e.next = 12;
                        break;
                    case 9:
                        e.prev = 9, e.t0 = e.catch(3), a = null;
                    case 12:
                        r = null != a && a.width === t.width && a.height === t.height ? a : t, e.next = 16;
                        break;
                    case 15:
                        r = t;
                    case 16:
                        return e.abrupt("return", yb(r, n));
                    case 17:
                    case "end":
                        return e.stop()
                }
            }, e, null, [
                [3, 9]
            ])
        }))).apply(this, arguments)
    }

    function wb() {
        return (wb = Pm(regeneratorRuntime.mark(function e(t, n) {
            var r, a, i, o, s, u, l, c, p, h, f, d, m, v, g, y;
            return regeneratorRuntime.wrap(function (e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        if (r = Zg(t, "img", "toPixels"), t instanceof Ng || (r = Ky(a = r, "int32"), a.dispose()), 2 === r.rank || 3 === r.rank) {
                            e.next = 4;
                            break
                        }
                        throw new Error("toPixels only supports rank 2 or 3 tensors, got rank " + r.rank + ".");
                    case 4:
                        if (i = r.shape.slice(0, 2), o = i[0], s = i[1], !((u = 2 === r.rank ? 1 : r.shape[2]) > 4 || 2 === u)) {
                            e.next = 8;
                            break
                        }
                        throw new Error("toPixels only supports depth of size 1, 3 or 4 but got " + u);
                    case 8:
                        if ("float32" === r.dtype || "int32" === r.dtype) {
                            e.next = 10;
                            break
                        }
                        throw new Error("Unsupported type for toPixels: " + r.dtype + ". Please use float32 or int32 tensors.");
                    case 10:
                        return e.next = 12, r.data();
                    case 12:
                        l = e.sent, c = "float32" === r.dtype ? 255 : 1, p = new Uint8ClampedArray(s * o * 4), h = 0;
                    case 16:
                        if (!(h < o * s)) {
                            e.next = 41;
                            break
                        }
                        f = [0, 0, 0, 255], d = 0;
                    case 19:
                        if (!(d < u)) {
                            e.next = 33;
                            break
                        }
                        if (m = l[h * u + d], "float32" !== r.dtype) {
                            e.next = 26;
                            break
                        }
                        if (!(m < 0 || m > 1)) {
                            e.next = 24;
                            break
                        }
                        throw new Error("Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered " + m + ".");
                    case 24:
                        e.next = 29;
                        break;
                    case 26:
                        if ("int32" !== r.dtype) {
                            e.next = 29;
                            break
                        }
                        if (!(m < 0 || m > 255)) {
                            e.next = 29;
                            break
                        }
                        throw new Error("Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered " + m + ".");
                    case 29:
                        1 === u ? (f[0] = m * c, f[1] = m * c, f[2] = m * c) : f[d] = m * c;
                    case 30:
                        d++, e.next = 19;
                        break;
                    case 33:
                        p[0 + (v = 4 * h)] = Math.round(f[0]), p[v + 1] = Math.round(f[1]), p[v + 2] = Math.round(f[2]), p[v + 3] = Math.round(f[3]);
                    case 38:
                        ++h, e.next = 16;
                        break;
                    case 41:
                        return null != n && (n.width = s, n.height = o, g = n.getContext("2d"), y = new ImageData(p, s, o), g.putImageData(y, 0, 0)), r !== t && r.dispose(), e.abrupt("return", p);
                    case 44:
                    case "end":
                        return e.stop()
                }
            }, e)
        }))).apply(this, arguments)
    }
    var kb = $g({
            fromPixels_: yb
        }),
        Nb = {
            __proto__: null,
            fromPixelsAsync: function (e, t) {
                return xb.apply(this, arguments)
            },
            toPixels: function (e, t) {
                return wb.apply(this, arguments)
            },
            fromPixels: kb
        };

    function Ib(e, t) {
        var n = e.shape.length,
            r = t.shape.length;
        if (n < 1) throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was " + n + ".");
        if (r < 1) throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was " + r + ".");
        if ("int32" !== t.dtype) throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was " + t.dtype + ".");
        if (t.shape[r - 1] > n) throw new Error("index innermost dimension length must be <= tensor rank; saw: " + t.shape[r - 1] + " vs. " + n);
        if (0 === ov(e.shape)) throw new Error("Requested more than 0 entries, but input is empty. Input shape: " + e.shape + ".");
        for (var a = t.shape, i = a[a.length - 1], o = 1, s = 0; s < a.length - 1; ++s) o *= a[s];
        var u = e.shape,
            l = a.slice();
        l.pop();
        for (var c = 1, p = i; p < n; ++p) c *= u[p], l.push(u[p]);
        var h = [].concat(Rv(e.shape).map(function (e) {
            return e / c
        }), [1]).slice(0, i);
        return [l, o, c, h]
    }
    var Sb = {
        __proto__: null,
        prepareAndValidate: Ib
    };

    function Tb(e, t, n) {
        var r = t.rank > 1 ? t.shape[t.rank - 1] : 1,
            a = t.rank > 1 ? t.rank - 1 : 1,
            i = "Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: " + n.shape + ", indices.shape: " + t.shape + ", shape: " + e + ", sliceDim: " + r + ", and batchDim: " + a + ".";
        if (n.rank < a) throw new Error(i + " update.rank < " + a + ". ");
        if (e.length < r + (n.rank - a)) throw new Error(i + " Output shape length < " + (r + (n.rank - a)));
        if (n.rank !== a + e.length - r) throw new Error(i + " update.rank != " + (a + e.length - r));
        for (var o = 0; o < a; ++o)
            if (n.shape[o] !== t.shape[o]) throw new Error(i + " updates.shape[" + o + "] (" + n.shape[o] + ") != indices.shape[" + o + "] (" + t.shape[o] + ").");
        for (var s = 0; s < n.rank - a; ++s)
            if (n.shape[s + a] !== e[s + r]) throw new Error(i + " updates.shape[" + (s + a) + "] (" + n.shape[s + a] + ") != shape[" + (s + a) + "] (" + e[s + a] + ")")
    }

    function Cb(e, t, n) {
        if (t.rank < 1) throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was " + t.rank + ".");
        if (e.rank < 1) throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was " + e.rank + ".");
        if ("int32" !== t.dtype) throw new Error("The dtype of 'indices' should be int32, but got dtype: " + t.dtype);
        if (n.length < 1) throw new Error("Output rank must be greater or equal to 1, but got shape: " + n);
        if (0 === n.length) {
            if (0 === t.size) throw new Error("Indices specified for empty output. indices shape: " + t.shape);
            if (0 === e.size) throw new Error("Updates specified for empty output. updates shape: " + e.shape)
        }
        Tb(n, t, e)
    }

    function Eb(e, t, n) {
        for (var r = t.shape.length, a = r > 1 ? t.shape[r - 1] : 1, i = n.length, o = 1, s = a; s < i; ++s) o *= n[s];
        var u = a < 1 ? 1 : a;
        return {
            sliceRank: a,
            numUpdates: ov(t.shape) / u,
            sliceSize: o,
            strides: [].concat(Rv(n.slice(0, a)), [1]),
            outputSize: ov(n)
        }
    }
    var Rb = {
        __proto__: null,
        validateUpdateShape: Tb,
        validateInput: Cb,
        calculateShapes: Eb
    };

    function Ab(e, t, n) {
        var r = e.shape.length;
        nv(r === t.length, function () {
            return "Error in slice" + r + "D: Length of begin " + t + " must match the rank of the array (" + r + ")."
        }), nv(r === n.length, function () {
            return "Error in slice" + r + "D: Length of size " + n + " must match the rank of the array (" + r + ")."
        });
        for (var a = function (a) {
                nv(t[a] + n[a] <= e.shape[a], function () {
                    return "Error in slice" + r + "D: begin[" + a + "] + size[" + a + "] (" + (t[a] + n[a]) + ") would overflow input.shape[" + a + "] (" + e.shape[a] + ")"
                })
            }, i = 0; i < r; ++i) a(i)
    }

    function Fb(e) {
        for (var t = [], n = 0; e > 0;) 1 & e && t.push(n), e /= 2, n++;
        return t
    }

    function _b(e, t, n) {
        for (var r = [], a = 0; a < e.length; a++) r[a] = Math.ceil((t[a] - e[a]) / n[a]);
        return r
    }

    function Db(e, t, n, r) {
        for (var a = [].concat(e), i = a.length; i < r.length; i++) a.push(1);
        for (var o = 0; o < n; o++) 0 === o ? a[t] = 1 : (a.splice(t, 0, 1), a.pop());
        return a
    }

    function Ob(e, t, n) {
        return n <= e ? n : n - (t - 1)
    }

    function Mb(e, t) {
        for (var n = [], r = 0; r < e; r++) n.push(t + r);
        return n
    }

    function Lb(e, t, n, r, a, i, o, s, u) {
        var l = e.length,
            c = new Array(l),
            p = new Array(l),
            h = new Array(l);
        if (t.length && n > 0) {
            var f = t[0],
                d = n + 1;
            c = zb(o, f, d, r, e), p = Pb(s, f, d, a, e), h = Db(i, f, d, e)
        } else
            for (var m = 0; m < l; m++) c[m] = Wb(o, r, i, e, m, u), p[m] = Vb(s, a, i, e, m, u), h[m] = Bb(i, m, u);
        return {
            begin: c,
            end: p,
            strides: h
        }
    }

    function zb(e, t, n, r, a) {
        for (var i = [].concat(a), o = Mb(n, t), s = 0; s < i.length; s++)
            if (o.indexOf(s) > -1) i[s] = 0;
            else {
                var u = Ob(t, n, s),
                    l = r[u];
                e & 1 << u && (l = 0), i[s] = l
            } return i
    }

    function Pb(e, t, n, r, a) {
        for (var i = [].concat(a), o = Mb(n, t), s = 0; s < i.length; s++)
            if (o.indexOf(s) > -1) i[s] = Number.MAX_SAFE_INTEGER;
            else {
                var u = Ob(t, n, s),
                    l = r[u];
                e & 1 << u && (l = Number.MAX_SAFE_INTEGER), i[s] = l
            } for (var c = 0; c < i.length; c++) {
            var p = a[c];
            i[c] < 0 && (i[c] += p), i[c] = $m(0, i[c], a[c])
        }
        return i
    }

    function Bb(e, t, n) {
        var r = e[t];
        return (n & 1 << t || null == r) && (r = 1), r
    }

    function Wb(e, t, n, r, a, i) {
        var o = t[a],
            s = n[a] || 1;
        (e & 1 << a || i & 1 << a || null == o) && (o = s > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);
        var u = r[a];
        return o < 0 && (o += u), $m(0, o, u - 1)
    }

    function Vb(e, t, n, r, a, i) {
        var o = t[a],
            s = n[a] || 1;
        (e & 1 << a || i & 1 << a || null == o) && (o = s > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);
        var u = r[a];
        return o < 0 && (o += u), s > 0 ? $m(0, o, u) : $m(-1, o, u - 1)
    }

    function Ub(e, t, n) {
        for (var r = n.length, a = 0; a < n.length; a++)
            if (n[a] > 1) {
                r = a;
                break
            } for (var i = r + 1; i < n.length; i++)
            if (t[i] > 0 || n[i] !== e[i]) return !1;
        return !0
    }

    function Gb(e, t) {
        for (var n = e.length > 0 ? e[e.length - 1] : 1, r = 0; r < e.length - 1; r++) n += e[r] * t[r];
        return n
    }

    function jb(e, t, n) {
        var r, a, i = e.shape.length;
        return (r = "number" == typeof t ? [t].concat(new Array(i - 1).fill(0)) : t.length < i ? t.concat(new Array(i - t.length).fill(0)) : t.slice()).forEach(function (e) {
            nv(-1 !== e, function () {
                return "slice() does not support negative begin indexing."
            })
        }), a = (a = null == n ? new Array(i).fill(-1) : "number" == typeof n ? [n].concat(new Array(i - 1).fill(-1)) : n.length < i ? n.concat(new Array(i - n.length).fill(-1)) : n).map(function (t, n) {
            return t >= 0 ? t : (nv(-1 === t, function () {
                return "Negative size values should be exactly -1 but got " + t + " for the slice() size at index " + n + "."
            }), e.shape[n] - r[n])
        }), [r, a]
    }

    function Hb(e, t, n, r, a, i, o, s, u) {
        var l = t.slice(),
            c = n.slice(),
            p = r;
        null == r && (p = new Array(l.length));
        var h = Fb(o);
        if (h.length > 1) throw new Error("Multiple ellipses in slice is not allowed.");
        if (0 !== o && 0 !== s) throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");
        if (0 !== o && 0 !== u) throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");
        var f = e.length - l.length,
            d = Fb(s),
            m = e.slice();
        d.forEach(function (e) {
            l[e] = 0, c[e] = 1, m.splice(e, 0, 1)
        });
        var v = Lb(m, h, f, l, c, p, a, i, o),
            g = v.begin,
            y = v.end,
            b = v.strides;
        l = g, c = y, p = b;
        var x = Fb(u);
        x.forEach(function (e) {
            c[e] = l[e] + 1, p[e] = 1
        });
        var w = _b(l, c, p),
            k = w.filter(function (e, t) {
                return -1 === x.indexOf(t)
            });
        return {
            nonStrided: p.every(function (e) {
                return 1 === e
            }),
            $begin: l,
            $end: c,
            $strides: p,
            size: w,
            newShape: m,
            outShape: k
        }
    }
    var qb = {
            __proto__: null,
            assertParamsValid: Ab,
            maskToAxes: Fb,
            computeOutShape: _b,
            stridesWithElidedDims: Db,
            getNormalizedAxes: Lb,
            startIndicesWithElidedDims: zb,
            stopIndicesWithElidedDims: Pb,
            stridesForAxis: Bb,
            startForAxis: Wb,
            stopForAxis: Vb,
            isSliceContinous: Ub,
            computeFlatOffset: Gb,
            parseSliceParams: jb,
            sliceInfo: Hb
        },
        Kb = function () {
            function e() {}
            return e.prototype.getClassName = function () {
                return this.constructor.className
            }, e.fromConfig = function (e, t) {
                return new e(t)
            }, e
        }(),
        Xb = function () {
            function e() {
                this.classNameMap = {}
            }
            return e.getMap = function () {
                return null == e.instance && (e.instance = new e), e.instance
            }, e.register = function (t) {
                e.getMap().classNameMap[t.className] = [t, t.fromConfig]
            }, e
        }();

    function Yb(e) {
        nv(null != e.className, function () {
            return "Class being registered does not have the static className property defined."
        }), nv("string" == typeof e.className, function () {
            return "className is required to be a string, but got type " + typeof e.className
        }), nv(e.className.length > 0, function () {
            return "Class being registered has an empty-string as its className, which is disallowed."
        }), Xb.register(e)
    }
    var Jb = {
        __proto__: null,
        Serializable: Kb,
        SerializationMap: Xb,
        registerClass: Yb
    };

    function Zb() {
        return 32 === Gg.backend.floatPrecision() ? .001 : .1
    }

    function Qb(e, t, n) {
        var r = !0;
        if ((xv(e) || xv(t)) && (r = !1), xv(e) && xv(t) && (r = !0), r) {
            var a = e.constructor.name,
                i = t.constructor.name;
            if (a !== i) throw new Error("Arrays are of different type. Actual: " + a + ". Expected: " + i)
        }
        if (Array.isArray(e) && Array.isArray(t)) {
            var o = Yg(e),
                s = Yg(t);
            if (!sv(o, s)) throw new Error("Arrays have different shapes. Actual: [" + o + "]. Expected: [" + s + "]")
        }
        var u = xv(e) ? e : iv(e),
            l = xv(t) ? t : iv(t);
        if (u.length !== l.length) throw new Error("Arrays have different lengths actual: " + u.length + " vs expected: " + l.length + ".\nActual:   " + u + ".\nExpected: " + l + ".");
        for (var c = 0; c < l.length; ++c) {
            var p = u[c],
                h = l[c];
            if (!n(p, h)) throw new Error("Arrays differ: actual[" + c + "] = " + p + ", expected[" + c + "] = " + h + ".\nActual:   " + u + ".\nExpected: " + l + ".")
        }
    }

    function $b(e, t, n) {
        return !isFinite(e) && !isFinite(t) || !(isNaN(e) || isNaN(t) || Math.abs(e - t) > n)
    }
    var ex = {
        __proto__: null,
        TEST_EPSILON_FLOAT16: .1,
        expectArraysClose: function (e, t, n) {
            return null == n && (n = Zb()), Qb(e, t, function (e, t) {
                return $b(e, t, n)
            })
        },
        testEpsilon: Zb,
        expectPromiseToFail: function (e, t) {
            e().then(function () {
                return t.fail()
            }, function () {
                return t()
            })
        },
        expectArraysEqual: function (e, t) {
            var n = "string" == typeof t || "number" == typeof t || "boolean" == typeof t ? [t] : t;
            return Nv(e) || Nv(e[0]) || Nv(t) || Nv(t[0]) ? Qb(e, n, function (e, t) {
                return e == t
            }) : Qb(e, t, function (e, t) {
                return $b(e, t, 0)
            })
        },
        expectNumbersClose: function (e, t, n) {
            if (null == n && (n = Zb()), !$b(e, t, n)) throw new Error("Numbers differ: actual === " + e + ", expected === " + t)
        },
        expectValuesInRange: function (e, t, n) {
            for (var r = 0; r < e.length; r++)
                if (e[r] < t || e[r] > n) throw new Error("Value out of range:" + e[r] + " low: " + t + ", high: " + n)
        },
        expectArrayBuffersEqual: function (e, t) {
            expect(new Float32Array(e)).toEqual(new Float32Array(t))
        },
        encodeStrings: function e(t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                Array.isArray(r) ? e(r) : t[n] = hg(r)
            }
            return t
        }
    };

    function tx() {
        return Gg
    }

    function nx() {
        return Gg.memory()
    }

    function rx(e, t) {
        return Gg.tidy(e, t)
    }

    function ax(e) {
        zg(e).forEach(function (e) {
            return e.dispose()
        })
    }

    function ix(e) {
        return Gg.keep(e)
    }

    function ox(e, t, n) {
        return void 0 === n && (n = 1), Gg.registerBackend(e, t, n)
    }

    function sx() {
        return Gg.backend
    }
    var ux = $g({
            add_: function (e, t) {
                var n = Zg(e, "a", "add"),
                    r = Zg(t, "b", "add"),
                    a = Og(n, r),
                    i = {
                        a: n = a[0],
                        b: r = a[1]
                    };
                return Gg.runKernel(Gv, i)
            }
        }),
        lx = $g({
            floorDiv_: function (e, t) {
                var n = Zg(e, "a", "floorDiv"),
                    r = Zg(t, "b", "floorDiv"),
                    a = Og(n, r),
                    i = {
                        a: n = a[0],
                        b: r = a[1]
                    };
                return Gg.runKernel("FloorDiv", i)
            }
        }),
        cx = $g({
            div_: function (e, t) {
                var n = Zg(e, "a", "div"),
                    r = Zg(t, "b", "div"),
                    a = Og(n, r);
                if (n = a[0], r = a[1], "int32" === n.dtype && "int32" === r.dtype) return lx(n, r);
                var i = {
                    a: n,
                    b: r
                };
                return Gg.runKernel("RealDiv", i, {})
            }
        }),
        px = $g({
            mul_: function (e, t) {
                var n = Zg(e, "a", "mul"),
                    r = Zg(t, "b", "mul"),
                    a = Og(n, r),
                    i = {
                        a: n = a[0],
                        b: r = a[1]
                    };
                return Gg.runKernel("Multiply", i)
            }
        }),
        hx = $g({
            abs_: function (e) {
                var t = Zg(e, "x", "abs");
                if ("complex64" === t.dtype) {
                    var n = {
                        x: t
                    };
                    return Gg.runKernel("ComplexAbs", n)
                }
                var r = {
                    x: t
                };
                return Gg.runKernel("Abs", r)
            }
        }),
        fx = $g({
            acos_: function (e) {
                var t = {
                    x: Zg(e, "x", "acos")
                };
                return Gg.runKernel("Acos", t)
            }
        }),
        dx = $g({
            acosh_: function (e) {
                var t = {
                    x: Zg(e, "x", "acosh")
                };
                return Gg.runKernel("Acosh", t)
            }
        }),
        mx = $g({
            addN_: function (e) {
                nv(Array.isArray(e), function () {
                    return "The argument passed to tf.addN() must be a list of tensors"
                }), nv(e.length >= 1, function () {
                    return "Must pass at least one tensor to tf.addN(), but got " + e.length
                });
                var t = e.map(function (e, t) {
                        return Zg(e, "tensors" + t, "addN")
                    }),
                    n = t[0];
                t.forEach(function (e) {
                    if (e.dtype !== n.dtype) throw new Error("All tensors passed to tf.addN() must have the same dtype")
                }), t.forEach(function (e) {
                    if (!sv(e.shape, n.shape)) throw new Error("All tensors passed to tf.addN() must have the same shape")
                });
                var r = t;
                return Gg.runKernel("AddN", r)
            }
        }),
        vx = $g({
            all_: function (e, t, n) {
                void 0 === t && (t = null), void 0 === n && (n = !1);
                var r = {
                        x: Zg(e, "x", "all", "bool")
                    },
                    a = {
                        axis: t,
                        keepDims: n
                    };
                return Gg.runKernel("All", r, a)
            }
        }),
        gx = $g({
            any_: function (e, t, n) {
                void 0 === t && (t = null), void 0 === n && (n = !1);
                var r = {
                        x: Zg(e, "x", "any", "bool")
                    },
                    a = {
                        axis: t,
                        keepDims: n
                    };
                return Gg.runKernel("Any", r, a)
            }
        }),
        yx = $g({
            argMax_: function (e, t) {
                void 0 === t && (t = 0);
                var n = {
                        x: Zg(e, "x", "argMax")
                    },
                    r = {
                        axis: t
                    };
                return Gg.runKernel("ArgMax", n, r)
            }
        }),
        bx = $g({
            argMin_: function (e, t) {
                void 0 === t && (t = 0);
                var n = {
                        x: Zg(e, "x", "argMin")
                    },
                    r = {
                        axis: t
                    };
                return Gg.runKernel("ArgMin", n, r)
            }
        }),
        xx = $g({
            asin_: function (e) {
                var t = {
                    x: Zg(e, "x", "asin")
                };
                return Gg.runKernel("Asin", t)
            }
        }),
        wx = $g({
            asinh_: function (e) {
                var t = {
                    x: Zg(e, "x", "asinh")
                };
                return Gg.runKernel("Asinh", t)
            }
        }),
        kx = $g({
            atan_: function (e) {
                var t = {
                    x: Zg(e, "x", "atan")
                };
                return Gg.runKernel("Atan", t)
            }
        }),
        Nx = $g({
            atan2_: function (e, t) {
                var n = Zg(e, "a", "atan2"),
                    r = Zg(t, "b", "atan2"),
                    a = Og(n, r),
                    i = {
                        a: n = a[0],
                        b: r = a[1]
                    };
                return Gg.runKernel("Atan2", i)
            }
        }),
        Ix = $g({
            atanh_: function (e) {
                var t = {
                    x: Zg(e, "x", "atanh")
                };
                return Gg.runKernel("Atanh", t)
            }
        });

    function Sx(e, t, n, r, a, i) {
        void 0 === a && (a = "NHWC");
        var o = e[3];
        return Ex(e, [].concat(t, [o]), n, i, r, null, null, zx(a))
    }

    function Tx(e, t, n, r, a, i, o) {
        void 0 === o && (o = "channelsLast");
        var s, u = Fx(t),
            l = u[0],
            c = u[1];
        if ("channelsLast" === o) s = [l, c, e[3], e[3]];
        else {
            if ("channelsFirst" !== o) throw new Error("Unknown dataFormat " + o);
            s = [l, c, e[1], e[1]]
        }
        return Ex(e, s, n, r, a, i, !1, o)
    }

    function Cx(e, t, n, r, a, i, o) {
        void 0 === o && (o = "NDHWC");
        var s, u, l = _x(t),
            c = l[0],
            p = l[1],
            h = l[2];
        if ("NDHWC" === o) u = "channelsLast", s = [c, p, h, e[4], e[4]];
        else {
            if ("NCDHW" !== o) throw new Error("Unknown dataFormat " + o);
            u = "channelsFirst", s = [c, p, h, e[1], e[1]]
        }
        return Rx(e, s, n, r, a, !1, u, i)
    }

    function Ex(e, t, n, r, a, i, o, s) {
        void 0 === o && (o = !1), void 0 === s && (s = "channelsLast");
        var u = -1,
            l = -1,
            c = -1,
            p = -1;
        if ("channelsLast" === s) u = e[0], l = e[1], c = e[2], p = e[3];
        else {
            if ("channelsFirst" !== s) throw new Error("Unknown dataFormat " + s);
            u = e[0], p = e[1], l = e[2], c = e[3]
        }
        var h, f = t[0],
            d = t[1],
            m = t[3],
            v = Fx(n),
            g = v[0],
            y = v[1],
            b = Fx(r),
            x = b[0],
            w = b[1],
            k = Dx(f, x),
            N = Dx(d, w),
            I = function (e, t, n, r, a, i, o, s, u) {
                var l, c, p;
                if ("number" == typeof e) {
                    l = {
                        top: e,
                        bottom: e,
                        left: e,
                        right: e,
                        type: 0 === e ? "VALID" : "NUMBER"
                    };
                    var h = function (e, t, n, r, a) {
                        null == r && (r = Ax(e, t, n));
                        var i = e[1];
                        return [Ox((e[0] - t + 2 * r) / n + 1, a), Ox((i - t + 2 * r) / n + 1, a)]
                    }([t, n], i, r, e, s);
                    c = h[0], p = h[1]
                } else if ("same" === e) {
                    c = Math.ceil(t / r), p = Math.ceil(n / a);
                    var f = Math.max(0, (c - 1) * r + i - t),
                        d = Math.max(0, (p - 1) * a + o - n),
                        m = Math.floor(f / 2),
                        v = f - m,
                        g = Math.floor(d / 2);
                    l = {
                        top: m,
                        bottom: v,
                        left: g,
                        right: d - g,
                        type: "SAME"
                    }
                } else if ("valid" === e) l = {
                    top: 0,
                    bottom: 0,
                    left: 0,
                    right: 0,
                    type: "VALID"
                }, c = Math.ceil((t - i + 1) / r), p = Math.ceil((n - o + 1) / a);
                else {
                    if ("object" != typeof e) throw Error("Unknown padding parameter: " + e);
                    var y = "channelsLast" === u ? e[1][0] : e[2][0],
                        b = "channelsLast" === u ? e[1][1] : e[2][1],
                        x = "channelsLast" === u ? e[2][0] : e[3][0],
                        w = "channelsLast" === u ? e[2][1] : e[3][1];
                    l = {
                        top: y,
                        bottom: b,
                        left: x,
                        right: w,
                        type: 0 === y && 0 === b && 0 === x && 0 === w ? "VALID" : "EXPLICIT"
                    }, c = Ox((t - i + y + b) / r + 1, s), p = Ox((n - o + x + w) / a + 1, s)
                }
                return {
                    padInfo: l,
                    outHeight: c,
                    outWidth: p
                }
            }(a, l, c, g, y, k, N, i, s),
            S = I.padInfo,
            T = I.outHeight,
            C = I.outWidth,
            E = o ? m * p : m;
        return "channelsFirst" === s ? h = [u, E, T, C] : "channelsLast" === s && (h = [u, T, C, E]), {
            batchSize: u,
            dataFormat: s,
            inHeight: l,
            inWidth: c,
            inChannels: p,
            outHeight: T,
            outWidth: C,
            outChannels: E,
            padInfo: S,
            strideHeight: g,
            strideWidth: y,
            filterHeight: f,
            filterWidth: d,
            effectiveFilterHeight: k,
            effectiveFilterWidth: N,
            dilationHeight: x,
            dilationWidth: w,
            inShape: e,
            outShape: h,
            filterShape: t
        }
    }

    function Rx(e, t, n, r, a, i, o, s) {
        void 0 === i && (i = !1), void 0 === o && (o = "channelsLast");
        var u = -1,
            l = -1,
            c = -1,
            p = -1,
            h = -1;
        if ("channelsLast" === o) u = e[0], l = e[1], c = e[2], p = e[3], h = e[4];
        else {
            if ("channelsFirst" !== o) throw new Error("Unknown dataFormat " + o);
            u = e[0], h = e[1], l = e[2], c = e[3], p = e[4]
        }
        var f, d = t[0],
            m = t[1],
            v = t[2],
            g = t[4],
            y = _x(n),
            b = y[0],
            x = y[1],
            w = y[2],
            k = _x(r),
            N = k[0],
            I = k[1],
            S = k[2],
            T = Dx(d, N),
            C = Dx(m, I),
            E = Dx(v, S),
            R = function (e, t, n, r, a, i, o, s, u, l, c) {
                var p, h, f, d;
                if ("number" == typeof e) {
                    p = {
                        top: e,
                        bottom: e,
                        left: e,
                        right: e,
                        front: e,
                        back: e,
                        type: 0 === e ? "VALID" : "NUMBER"
                    };
                    var m = function (e, t, n, r, a, i) {
                        null == a && (a = Ax(e, t, r));
                        var o = e[1],
                            s = e[2];
                        return [Ox((e[0] - t + 2 * a) / r + 1, i), Ox((o - t + 2 * a) / r + 1, i), Ox((s - t + 2 * a) / r + 1, i), 1]
                    }([t, n, r, 1], s, 0, a, e, c);
                    h = m[0], f = m[1], d = m[2]
                } else if ("same" === e) {
                    var v = ((h = Math.ceil(t / a)) - 1) * a + s - t,
                        g = ((f = Math.ceil(n / i)) - 1) * i + u - n,
                        y = ((d = Math.ceil(r / o)) - 1) * o + l - r,
                        b = Math.floor(v / 2),
                        x = v - b,
                        w = Math.floor(g / 2),
                        k = g - w,
                        N = Math.floor(y / 2);
                    p = {
                        top: w,
                        bottom: k,
                        left: N,
                        right: y - N,
                        front: b,
                        back: x,
                        type: "SAME"
                    }
                } else {
                    if ("valid" !== e) throw Error("Unknown padding parameter: " + e);
                    p = {
                        top: 0,
                        bottom: 0,
                        left: 0,
                        right: 0,
                        front: 0,
                        back: 0,
                        type: "VALID"
                    }, h = Math.ceil((t - s + 1) / a), f = Math.ceil((n - u + 1) / i), d = Math.ceil((r - l + 1) / o)
                }
                return {
                    padInfo: p,
                    outDepth: h,
                    outHeight: f,
                    outWidth: d
                }
            }(a, l, c, p, b, x, w, T, C, E, s),
            A = R.padInfo,
            F = R.outDepth,
            _ = R.outHeight,
            D = R.outWidth,
            O = i ? g * h : g;
        return "channelsFirst" === o ? f = [u, O, F, _, D] : "channelsLast" === o && (f = [u, F, _, D, O]), {
            batchSize: u,
            dataFormat: o,
            inDepth: l,
            inHeight: c,
            inWidth: p,
            inChannels: h,
            outDepth: F,
            outHeight: _,
            outWidth: D,
            outChannels: O,
            padInfo: A,
            strideDepth: b,
            strideHeight: x,
            strideWidth: w,
            filterDepth: d,
            filterHeight: m,
            filterWidth: v,
            effectiveFilterDepth: T,
            effectiveFilterHeight: C,
            effectiveFilterWidth: E,
            dilationDepth: N,
            dilationHeight: I,
            dilationWidth: S,
            inShape: e,
            outShape: f,
            filterShape: t
        }
    }

    function Ax(e, t, n, r) {
        void 0 === r && (r = 1);
        var a = Dx(t, r);
        return Math.floor((e[0] * (n - 1) - n + a) / 2)
    }

    function Fx(e) {
        return "number" == typeof e ? [e, e, e] : 2 === e.length ? [e[0], e[1], 1] : e
    }

    function _x(e) {
        return "number" == typeof e ? [e, e, e] : e
    }

    function Dx(e, t) {
        return t <= 1 ? e : e + (e - 1) * (t - 1)
    }

    function Ox(e, t) {
        if (!t) return Math.trunc(e);
        switch (t) {
            case "round":
                return Math.round(e);
            case "ceil":
                return Math.ceil(e);
            case "floor":
                return Math.floor(e);
            default:
                throw new Error("Unknown roundingMode " + t)
        }
    }

    function Mx(e) {
        var t = Fx(e),
            n = t[0],
            r = t[1],
            a = t[2];
        return 1 === n && 1 === r && 1 === a
    }

    function Lx(e, t) {
        return Mx(e) || Mx(t)
    }

    function zx(e) {
        if ("NHWC" === e) return "channelsLast";
        if ("NCHW" === e) return "channelsFirst";
        throw new Error("Unknown dataFormat " + e)
    }
    var Px = $g({
            reshape_: function (e, t) {
                var n = {
                        x: Zg(e, "x", "reshape", "string_or_numeric")
                    },
                    r = {
                        shape: t
                    };
                return Gg.runKernel("Reshape", n, r)
            }
        }),
        Bx = $g({
            avgPool_: function (e, t, n, r, a) {
                var i = Zg(e, "x", "avgPool", "float32");
                nv(Lx(n, 1), function () {
                    return "Error in avgPool: Either strides or dilations must be 1. Got strides " + n + " and dilations '1'"
                });
                var o = i,
                    s = !1;
                3 === i.rank && (s = !0, o = Px(i, [1, i.shape[0], i.shape[1], i.shape[2]])), nv(4 === o.rank, function () {
                    return "Error in avgPool: x must be rank 4 but got rank " + o.rank + "."
                }), null != a && nv(uv(r), function () {
                    return "Error in avgPool: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + r + "."
                });
                var u = {
                        x: o
                    },
                    l = {
                        filterSize: t,
                        strides: n,
                        pad: r,
                        dimRoundingMode: a
                    },
                    c = Gg.runKernel("AvgPool", u, l);
                return c = Ky(c, i.dtype), s ? Px(c, [c.shape[1], c.shape[2], c.shape[3]]) : c
            }
        }),
        Wx = $g({
            avgPool3d_: function (e, t, n, r, a, i) {
                void 0 === i && (i = "NDHWC");
                var o = Zg(e, "x", "avgPool3d", "float32"),
                    s = o,
                    u = !1;
                4 === o.rank && (u = !0, s = Px(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]])), nv(5 === s.rank, function () {
                    return "Error in avgPool3d: x must be rank 5 but got rank " + s.rank + "."
                }), nv("NDHWC" === i, function () {
                    return "Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of " + i
                }), null != a && nv(uv(r), function () {
                    return "Error in avgPool3d: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + r + "."
                });
                var l = {
                        x: s
                    },
                    c = {
                        filterSize: t,
                        strides: n,
                        pad: r,
                        dimRoundingMode: a,
                        dataFormat: i
                    },
                    p = Gg.runKernel("AvgPool3D", l, c);
                return p = Ky(p, s.dtype), u ? Px(p, [p.shape[1], p.shape[2], p.shape[3], p.shape[4]]) : p
            }
        }),
        Vx = $g({
            concat_: function (e, t) {
                void 0 === t && (t = 0), nv(e.length >= 1, function () {
                    return "Pass at least one tensor to concat"
                });
                var n = Qg(e, "tensors", "concat", "string_or_numeric");
                if ("complex64" === n[0].dtype && n.forEach(function (e) {
                        if ("complex64" !== e.dtype) throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype " + e.dtype + ". ")
                    }), 1 === n.length) return Xy(n[0]);
                var r = n,
                    a = {
                        axis: t
                    };
                return Gg.runKernel("Concat", r, a)
            }
        }),
        Ux = $g({
            sigmoid_: function (e) {
                var t = {
                    x: Zg(e, "x", "sigmoid")
                };
                return Gg.runKernel("Sigmoid", t)
            }
        }),
        Gx = $g({
            slice_: function (e, t, n) {
                var r = Zg(e, "x", "slice", "string_or_numeric");
                if (0 === r.rank) throw new Error("Slicing scalar is not possible");
                var a = {
                        x: r
                    },
                    i = {
                        begin: t,
                        size: n
                    };
                return Gg.runKernel("Slice", a, i)
            }
        }),
        jx = $g({
            tanh_: function (e) {
                var t = {
                    x: Zg(e, "x", "tanh")
                };
                return Gg.runKernel("Tanh", t)
            }
        }),
        Hx = $g({
            basicLSTMCell_: function (e, t, n, r, a, i) {
                var o = Zg(e, "forgetBias", "basicLSTMCell"),
                    s = Zg(t, "lstmKernel", "basicLSTMCell"),
                    u = Zg(n, "lstmBias", "basicLSTMCell"),
                    l = Zg(r, "data", "basicLSTMCell"),
                    c = Zg(a, "c", "basicLSTMCell"),
                    p = Zg(i, "h", "basicLSTMCell"),
                    h = Vx([l, p], 1),
                    f = fb(h, s),
                    d = ux(f, u),
                    m = d.shape[0],
                    v = d.shape[1] / 4,
                    g = [m, v],
                    y = Gx(d, [0, 0], g),
                    b = Gx(d, [0, v], g),
                    x = Gx(d, [0, 2 * v], g),
                    w = Gx(d, [0, 3 * v], g),
                    k = ux(px(Ux(y), jx(b)), px(c, Ux(ux(o, x))));
                return [k, px(jx(k), Ux(w))]
            }
        }),
        qx = $g({
            batchToSpaceND_: function (e, t, n) {
                var r = Zg(e, "x", "batchToSpaceND"),
                    a = t.reduce(function (e, t) {
                        return e * t
                    });
                nv(r.rank >= 1 + t.length, function () {
                    return "input rank is " + r.rank + " but should be > than blockShape.length " + t.length
                }), nv(n.length === t.length, function () {
                    return "crops.length is " + n.length + " but should be equal to blockShape.length  " + t.length
                }), nv(r.shape[0] % a == 0, function () {
                    return "input tensor batch is " + r.shape[0] + " but is not divisible by the product of the elements of blockShape " + t.join(" * ") + " === " + a
                });
                var i = {
                        x: r
                    },
                    o = {
                        blockShape: t,
                        crops: n
                    };
                return Gg.runKernel("BatchToSpaceND", i, o)
            }
        }),
        Kx = $g({
            batchNorm_: function (e, t, n, r, a, i) {
                null == i && (i = .001);
                var o, s, u = Zg(e, "x", "batchNorm"),
                    l = Zg(t, "mean", "batchNorm"),
                    c = Zg(n, "variance", "batchNorm");
                null != a && (o = Zg(a, "scale", "batchNorm")), null != r && (s = Zg(r, "offset", "batchNorm")), nv(l.rank === c.rank, function () {
                    return "Batch normalization gradient requires mean and variance to have equal ranks."
                }), nv(null == s || l.rank === s.rank, function () {
                    return "Batch normalization gradient requires mean and offset to have equal ranks."
                }), nv(null == o || l.rank === o.rank, function () {
                    return "Batch normalization gradient requires mean and scale to have equal ranks."
                });
                var p = {
                        x: function (e) {
                            return 0 === e.rank || 1 === e.rank ? Px(e, [1, 1, 1, e.size]) : 2 === e.rank ? Px(e, [1, 1, e.shape[0], e.shape[1]]) : 3 === e.rank ? Px(e, [1, e.shape[0], e.shape[1], e.shape[2]]) : e
                        }(u),
                        scale: o,
                        offset: s,
                        mean: l,
                        variance: c
                    },
                    h = {
                        varianceEpsilon: i
                    },
                    f = Gg.runKernel("FusedBatchNorm", p, h);
                return Px(f, u.shape)
            }
        }),
        Xx = $g({
            batchNorm2d_: function (e, t, n, r, a, i) {
                var o, s, u = Zg(e, "x", "batchNorm"),
                    l = Zg(t, "mean", "batchNorm"),
                    c = Zg(n, "variance", "batchNorm");
                return null != a && (o = Zg(a, "scale", "batchNorm")), null != r && (s = Zg(r, "offset", "batchNorm")), nv(2 === u.rank, function () {
                    return "Error in batchNorm2D: x must be rank 2 but got rank " + u.rank + "."
                }), nv(2 === l.rank || 1 === l.rank, function () {
                    return "Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank " + l.rank + "."
                }), nv(2 === c.rank || 1 === c.rank, function () {
                    return "Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank " + c.rank + "."
                }), null != o && nv(2 === o.rank || 1 === o.rank, function () {
                    return "Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank " + o.rank + "."
                }), null != s && nv(2 === s.rank || 1 === s.rank, function () {
                    return "Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank " + s.rank + "."
                }), Kx(u, l, c, s, o, i)
            }
        }),
        Yx = $g({
            batchNorm3d_: function (e, t, n, r, a, i) {
                var o, s, u = Zg(e, "x", "batchNorm"),
                    l = Zg(t, "mean", "batchNorm"),
                    c = Zg(n, "variance", "batchNorm");
                return null != a && (o = Zg(a, "scale", "batchNorm")), null != r && (s = Zg(r, "offset", "batchNorm")), nv(3 === u.rank, function () {
                    return "Error in batchNorm3D: x must be rank 3 but got rank " + u.rank + "."
                }), nv(3 === l.rank || 1 === l.rank, function () {
                    return "Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank " + l.rank + "."
                }), nv(3 === c.rank || 1 === c.rank, function () {
                    return "Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank " + c.rank + "."
                }), null != o && nv(3 === o.rank || 1 === o.rank, function () {
                    return "Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank " + o.rank + "."
                }), null != s && nv(3 === s.rank || 1 === s.rank, function () {
                    return "Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank " + s.rank + "."
                }), Kx(u, l, c, s, o, i)
            }
        }),
        Jx = $g({
            batchNorm4d_: function (e, t, n, r, a, i) {
                var o, s, u = Zg(e, "x", "batchNorm"),
                    l = Zg(t, "mean", "batchNorm"),
                    c = Zg(n, "variance", "batchNorm");
                return null != a && (o = Zg(a, "scale", "batchNorm")), null != r && (s = Zg(r, "offset", "batchNorm")), nv(4 === u.rank, function () {
                    return "Error in batchNorm4D: x must be rank 4 but got rank " + u.rank + "."
                }), nv(4 === l.rank || 1 === l.rank, function () {
                    return "Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank " + l.rank + "."
                }), nv(4 === c.rank || 1 === c.rank, function () {
                    return "Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank " + c.rank + "."
                }), null != o && nv(4 === o.rank || 1 === o.rank, function () {
                    return "Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank " + o.rank + "."
                }), null != s && nv(4 === s.rank || 1 === s.rank, function () {
                    return "Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank " + s.rank + "."
                }), Kx(u, l, c, s, o, i)
            }
        }),
        Zx = $g({
            bincount_: function (e, t, n) {
                var r = Zg(e, "x", "bincount"),
                    a = Zg(t, "weights", "bincount");
                nv("int32" === r.dtype, function () {
                    return "Error in bincount: input dtype must be int32, but got " + r.dtype
                }), nv(n >= 0, function () {
                    return "size must be non-negative, but got " + n + "."
                }), nv(a.size === r.size || 0 === a.size, function () {
                    return "Error in bincount: weights must have the same size as input or0-length, but got input shape: " + r.shape + ", weights shape: " + a.shape + "."
                });
                var i = {
                        x: r,
                        weights: a
                    },
                    o = {
                        size: n
                    };
                return Gg.runKernel("Bincount", i, o)
            }
        }),
        Qx = $g({
            broadcastTo_: function (e, t) {
                var n = Zg(e, "broadcastTo", "x"),
                    r = n.shape;
                if (t.some(function (e) {
                        return !(e > 0) || e % 1 != 0
                    })) throw new Error("broadcastTo(): Invalid broadcast shape [" + t + "].");
                if (t.length < n.rank) throw new Error("broadcastTo(): shape.length=" + t.length + " < input.rank=" + n.rank + ".");
                if (t.length > n.rank) {
                    for (var a = n.shape.slice(); a.length < t.length;) a.unshift(1);
                    n = Px(n, a)
                }
                for (var i = n.shape, o = Array.from(t), s = t.length - 1; s >= 0; s--)
                    if (i[s] === t[s]) o[s] = 1;
                    else if (1 !== n.shape[s]) throw new Error("broadcastTo(): [" + r + "] cannot be broadcast to [" + t + "].");
                if (0 === o.map(function (e, t) {
                        return e > 1 ? t : -1
                    }).filter(function (e) {
                        return e >= 0
                    }).length) return Xy(n);
                var u = {
                        x: n
                    },
                    l = {
                        reps: o
                    };
                return Gg.runKernel("Tile", u, l)
            }
        }),
        $x = $g({
            ceil_: function (e) {
                var t = {
                    x: Zg(e, "x", "ceil")
                };
                return Gg.runKernel("Ceil", t)
            }
        }),
        ew = $g({
            clipByValue_: function (e, t, n) {
                var r = Zg(e, "x", "clipByValue");
                nv(t <= n, function () {
                    return "Error in clip: min (" + t + ") must be less than or equal to max (" + n + ")."
                });
                var a = {
                        x: r
                    },
                    i = {
                        clipValueMin: t,
                        clipValueMax: n
                    };
                return Gg.runKernel("ClipByValue", a, i)
            }
        }),
        tw = $g({
            concat1d_: function (e) {
                return Vx(e, 0)
            }
        }),
        nw = $g({
            concat2d_: function (e, t) {
                return Vx(e, t)
            }
        }),
        rw = $g({
            concat3d_: function (e, t) {
                return Vx(e, t)
            }
        }),
        aw = $g({
            concat4d_: function (e, t) {
                return Vx(e, t)
            }
        }),
        iw = $g({
            conv2d_: function (e, t, n, r, a, i, o) {
                void 0 === a && (a = "NHWC"), void 0 === i && (i = [1, 1]);
                var s = Zg(e, "x", "conv2d"),
                    u = Zg(t, "filter", "conv2d"),
                    l = s,
                    c = !1;
                3 === s.rank && (c = !0, l = Px(s, [1, s.shape[0], s.shape[1], s.shape[2]])), nv(4 === l.rank, function () {
                    return "Error in conv2d: input must be rank 4, but got rank " + l.rank + "."
                }), nv(4 === u.rank, function () {
                    return "Error in conv2d: filter must be rank 4, but got rank " + u.rank + "."
                }), null != o && nv(uv(r), function () {
                    return "Error in conv2d: pad must be an integer when using, dimRoundingMode " + o + " but got pad " + r + "."
                });
                var p = "NHWC" === a ? l.shape[3] : l.shape[1];
                nv(p === u.shape[2], function () {
                    return "Error in conv2d: depth of input (" + p + ") must match input depth for filter " + u.shape[2] + "."
                }), nv(Lx(n, i), function () {
                    return "Error in conv2D: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + i + "'"
                });
                var h = {
                        x: l,
                        filter: u
                    },
                    f = {
                        strides: n,
                        pad: r,
                        dataFormat: a,
                        dilations: i,
                        dimRoundingMode: o
                    },
                    d = Gg.runKernel("Conv2D", h, f);
                return c ? Px(d, [d.shape[1], d.shape[2], d.shape[3]]) : d
            }
        }),
        ow = $g({
            conv1d_: function (e, t, n, r, a, i, o) {
                void 0 === a && (a = "NWC"), void 0 === i && (i = 1);
                var s = Zg(e, "x", "conv1d"),
                    u = Zg(t, "filter", "conv1d"),
                    l = s,
                    c = !1;
                2 === s.rank && (c = !0, l = Px(s, [1, s.shape[0], s.shape[1]])), nv(3 === l.rank, function () {
                    return "Error in conv1d: input must be rank 3, but got rank " + l.rank + "."
                }), nv(3 === u.rank, function () {
                    return "Error in conv1d: filter must be rank 3, but got rank " + u.rank + "."
                }), null != o && nv(uv(r), function () {
                    return "Error in conv1d: pad must be an integer when using, dimRoundingMode " + o + " but got pad " + r + "."
                }), nv(l.shape[2] === u.shape[1], function () {
                    return "Error in conv1d: depth of input (" + l.shape[2] + ") must match input depth for filter " + u.shape[1] + "."
                }), nv(Lx(n, i), function () {
                    return "Error in conv1D: Either stride or dilation must be 1. Got stride " + n + " and dilation '" + i + "'"
                }), nv("NWC" === a, function () {
                    return "Error in conv1d: got dataFormat of " + a + " but only NWC is currently supported."
                });
                var p = Px(u, [1, u.shape[0], u.shape[1], u.shape[2]]),
                    h = Px(l, [l.shape[0], 1, l.shape[1], l.shape[2]]),
                    f = iw(h, p, [1, n], r, "NHWC", [1, i], o);
                return Px(f, c ? [f.shape[2], f.shape[3]] : [f.shape[0], f.shape[2], f.shape[3]])
            }
        }),
        sw = $g({
            conv2DBackpropInput_: function (e, t, n, r, a, i, o) {
                void 0 === i && (i = "NHWC"), nv(e.length === t.rank, function () {
                    return "Length of inShape (" + e.length + ") and rank of dy (" + t.rank + ") must match"
                });
                var s = e,
                    u = t,
                    l = !1;
                3 === t.rank && (l = !0, u = Px(t, [1, t.shape[0], t.shape[1], t.shape[2]]), s = [1, e[0], e[1], e[2]]), nv(4 === s.length, function () {
                    return "Error in conv2dDerInput: inShape must be length 4, but got length " + s.length + "."
                }), nv(4 === u.rank, function () {
                    return "Error in conv2dDerInput: dy must be rank 4, but got rank " + u.rank
                }), nv(4 === n.rank, function () {
                    return "Error in conv2dDerInput: filter must be rank 4, but got rank " + n.rank
                });
                var c = "NHWC" === i ? s[3] : s[1],
                    p = "NHWC" === i ? u.shape[3] : u.shape[1];
                nv(c === n.shape[2], function () {
                    return "Error in conv2dDerInput: depth of input (" + c + ") must match input depth for filter " + n.shape[2] + "."
                }), nv(p === n.shape[3], function () {
                    return "Error in conv2dDerInput: depth of output (" + p + ") must match output depth for filter " + n.shape[3] + "."
                }), null != o && nv(uv(a), function () {
                    return "Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode " + o + " but got pad " + a + "."
                });
                var h = {
                        dy: u,
                        filter: n
                    },
                    f = {
                        strides: r,
                        pad: a,
                        dataFormat: i,
                        dimRoundingMode: o,
                        inputShape: s
                    },
                    d = Gg.runKernel("Conv2DBackpropInput", h, f);
                return l ? Px(d, [d.shape[1], d.shape[2], d.shape[3]]) : d
            }
        }),
        uw = $g({
            conv2dTranspose_: function (e, t, n, r, a, i) {
                var o = Zg(e, "x", "conv2dTranspose"),
                    s = Zg(t, "filter", "conv2dTranspose");
                return sw(n, o, s, r, a, "NHWC", i)
            }
        }),
        lw = $g({
            conv3d_: function (e, t, n, r, a, i) {
                void 0 === a && (a = "NDHWC"), void 0 === i && (i = [1, 1, 1]);
                var o = Zg(e, "x", "conv3d"),
                    s = Zg(t, "filter", "conv3d"),
                    u = o,
                    l = !1;
                4 === o.rank && (l = !0, u = Px(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]])), nv(5 === u.rank, function () {
                    return "Error in conv3d: input must be rank 5, but got rank " + u.rank + "."
                }), nv(5 === s.rank, function () {
                    return "Error in conv3d: filter must be rank 5, but got rank " + s.rank + "."
                }), nv(u.shape[4] === s.shape[3], function () {
                    return "Error in conv3d: depth of input (" + u.shape[4] + ") must match input depth for filter " + s.shape[3] + "."
                }), nv(Lx(n, i), function () {
                    return "Error in conv3D: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + i + "'"
                }), nv("NDHWC" === a, function () {
                    return "Error in conv3d: got dataFormat of " + a + " but only NDHWC is currently supported."
                });
                var c = {
                        x: u,
                        filter: s
                    },
                    p = {
                        strides: n,
                        pad: r,
                        dataFormat: a,
                        dilations: i
                    },
                    h = Gg.runKernel("Conv3D", c, p);
                return l ? Px(h, [h.shape[1], h.shape[2], h.shape[3], h.shape[4]]) : h
            }
        }),
        cw = $g({
            conv3DBackpropInput_: function (e, t, n, r, a) {
                nv(e.length === t.rank, function () {
                    return "Length of inShape (" + e.length + ") and rank of dy (" + t.rank + ") must match"
                });
                var i = e,
                    o = t,
                    s = !1;
                4 === t.rank && (s = !0, o = Px(t, [1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]]), i = [1, e[0], e[1], e[2], e[3]]);
                var u = i[4],
                    l = o.shape[4];
                nv(5 === i.length, function () {
                    return "Error in conv3dDerInput: inShape must be length 5, but got length " + i.length + "."
                }), nv(5 === o.rank, function () {
                    return "Error in conv3dDerInput: dy must be rank 5, but got rank " + o.rank
                }), nv(5 === n.rank, function () {
                    return "Error in conv3dDerInput: filter must be rank 5, but got rank " + n.rank
                }), nv(u === n.shape[3], function () {
                    return "Error in conv3dDerInput: depth of input (" + u + ") must match input depth for filter " + n.shape[3] + "."
                }), nv(l === n.shape[4], function () {
                    return "Error in conv3dDerInput: depth of output (" + l + ") must match output depth for filter " + n.shape[4] + "."
                });
                var c = {
                        dy: o,
                        filter: n
                    },
                    p = {
                        pad: a,
                        strides: r,
                        inputShape: i
                    },
                    h = Gg.runKernel("Conv3DBackpropInputV2", c, p);
                return s ? Px(h, [h.shape[1], h.shape[2], h.shape[3], h.shape[4]]) : h
            }
        }),
        pw = $g({
            conv3dTranspose_: function (e, t, n, r, a) {
                var i = Zg(e, "x", "conv3dTranspose"),
                    o = Zg(t, "filter", "conv3dTranspose");
                return cw(n, i, o, r, a)
            }
        }),
        hw = $g({
            cos_: function (e) {
                var t = {
                    x: Zg(e, "x", "cos")
                };
                return Gg.runKernel(jv, t)
            }
        }),
        fw = $g({
            cosh_: function (e) {
                var t = {
                    x: Zg(e, "x", "cosh")
                };
                return Gg.runKernel("Cosh", t)
            }
        }),
        dw = $g({
            cumsum_: function (e, t, n, r) {
                void 0 === t && (t = 0), void 0 === n && (n = !1), void 0 === r && (r = !1);
                var a = {
                        x: Zg(e, "x", "cumsum")
                    },
                    i = {
                        axis: t,
                        exclusive: n,
                        reverse: r
                    };
                return Gg.runKernel("Cumsum", a, i)
            }
        }),
        mw = $g({
            denseBincount_: function (e, t, n, r) {
                void 0 === r && (r = !1);
                var a = Zg(e, "x", "denseBincount"),
                    i = Zg(t, "weights", "denseBincount");
                nv("int32" === a.dtype, function () {
                    return "Error in denseBincount: input dtype must be int32, but got " + a.dtype
                }), nv(a.rank <= 2, function () {
                    return "Error in denseBincount: input must be at most rank 2, but got rank " + a.rank + "."
                }), nv(n >= 0, function () {
                    return "size must be non-negative, but got " + n + "."
                }), nv(i.size === a.size || 0 === i.size, function () {
                    return "Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: " + a.shape + ", weights shape: " + i.shape + "."
                });
                var o = {
                        x: a,
                        weights: i
                    },
                    s = {
                        size: n,
                        binaryOutput: r
                    };
                return Gg.runKernel("DenseBincount", o, s)
            }
        }),
        vw = $g({
            depthToSpace_: function (e, t, n) {
                void 0 === n && (n = "NHWC");
                var r = Zg(e, "x", "depthToSpace"),
                    a = "NHWC" === n ? r.shape[1] : r.shape[2],
                    i = "NHWC" === n ? r.shape[2] : r.shape[3],
                    o = "NHWC" === n ? r.shape[3] : r.shape[1];
                nv(a * t >= 0, function () {
                    return "Negative dimension size caused by overflow when multiplying\n    " + a + " and " + t + "  for depthToSpace with input shape\n    " + r.shape
                }), nv(i * t >= 0, function () {
                    return "Negative dimension size caused by overflow when multiplying\n    " + i + " and " + t + " for depthToSpace with input shape\n        " + r.shape
                }), nv(o % (t * t) == 0, function () {
                    return "Dimension size must be evenly divisible by " + t * t + " but is " + o + " for depthToSpace with input shape " + r.shape
                });
                var s = {
                        x: r
                    },
                    u = {
                        blockSize: t,
                        dataFormat: n
                    };
                return Gg.runKernel("DepthToSpace", s, u)
            }
        }),
        gw = $g({
            depthwiseConv2d_: function (e, t, n, r, a, i, o) {
                void 0 === a && (a = "NHWC"), void 0 === i && (i = [1, 1]);
                var s = Zg(e, "x", "depthwiseConv2d"),
                    u = Zg(t, "filter", "depthwiseConv2d"),
                    l = s,
                    c = !1;
                3 === s.rank && (c = !0, l = Px(s, [1, s.shape[0], s.shape[1], s.shape[2]])), nv(4 === l.rank, function () {
                    return "Error in depthwiseConv2d: input must be rank 4, but got rank " + l.rank + "."
                }), nv(4 === u.rank, function () {
                    return "Error in depthwiseConv2d: filter must be rank 4, but got rank " + u.rank + "."
                }), nv(l.shape[3] === u.shape[2], function () {
                    return "Error in depthwiseConv2d: number of input channels (" + l.shape[3] + ") must match the inChannels dimension in filter " + u.shape[2] + "."
                }), null != o && nv(uv(r), function () {
                    return "Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode " + o + " but got pad " + r + "."
                });
                var p = {
                        x: l,
                        filter: u
                    },
                    h = {
                        strides: n,
                        pad: r,
                        dataFormat: a,
                        dilations: i,
                        dimRoundingMode: o
                    },
                    f = Gg.runKernel("DepthwiseConv2dNative", p, h);
                return c ? Px(f, [f.shape[1], f.shape[2], f.shape[3]]) : f
            }
        }),
        yw = $g({
            diag_: function (e) {
                var t = {
                    x: Zg(e, "x", "diag")
                };
                return Gg.runKernel("Diag", t)
            }
        }),
        bw = $g({
            dilation2d_: function (e, t, n, r, a, i) {
                void 0 === a && (a = [1, 1]), void 0 === i && (i = "NHWC");
                var o = Zg(e, "x", "dilation2d"),
                    s = Zg(t, "filter", "dilation2d");
                nv(3 === o.rank || 4 === o.rank, function () {
                    return "Error in dilation2d: input must be rank 3 or 4, but got rank " + o.rank + "."
                }), nv(3 === s.rank, function () {
                    return "Error in dilation2d: filter must be rank 3, but got rank " + s.rank + "."
                }), nv("NHWC" === i, function () {
                    return "Error in dilation2d: Only NHWC is currently supported, but got dataFormat of " + i
                });
                var u = o,
                    l = !1;
                3 === o.rank && (u = Px(o, [1, o.shape[0], o.shape[1], o.shape[2]]), l = !0);
                var c = {
                        x: u,
                        filter: s
                    },
                    p = {
                        strides: n,
                        pad: r,
                        dilations: a
                    },
                    h = Gg.runKernel("Dilation2D", c, p);
                return l ? Px(h, [h.shape[1], h.shape[2], h.shape[3]]) : h
            }
        });

    function xw(e, t) {
        for (var n = e.length, r = [], a = 0; a < n; a++) {
            var i = n - 1 - a,
                o = e[i] || 1;
            (t[t.length - 1 - a] || 1) > 1 && 1 === o && r.unshift(i)
        }
        return r
    }

    function ww(e, t) {
        for (var n = [], r = 0; r < t.length; r++) {
            var a = e[e.length - r - 1],
                i = t.length - r - 1,
                o = t[i];
            (null == a || 1 === a && o > 1) && n.unshift(i)
        }
        return n
    }

    function kw(e, t) {
        for (var n = [], r = Math.max(e.length, t.length), a = 0; a < r; a++) {
            var i = e[e.length - a - 1];
            null == i && (i = 1);
            var o = t[t.length - a - 1];
            if (null == o && (o = 1), 1 === i) n.unshift(o);
            else if (1 === o) n.unshift(i);
            else {
                if (i !== o) throw Error("Operands could not be broadcast together with shapes " + e + " and " + t + ".");
                n.unshift(i)
            }
        }
        return n
    }
    var Nw = $g({
            equal_: function (e, t) {
                var n = Zg(e, "a", "equal"),
                    r = Zg(t, "b", "equal"),
                    a = Og(n, r);
                n = a[0], r = a[1], kw(n.shape, r.shape);
                var i = {
                    a: n,
                    b: r
                };
                return Gg.runKernel("Equal", i)
            }
        }),
        Iw = $g({
            where_: function (e, t, n) {
                var r = Zg(t, "a", "where"),
                    a = Zg(n, "b", "where"),
                    i = Zg(e, "condition", "where", "bool"),
                    o = kw(r.shape, a.shape),
                    s = Qx(r, o),
                    u = Qx(a, o);
                1 === i.rank && nv(i.shape[0] === r.shape[0], function () {
                    return "The first dimension of `a` must match the size of `condition`."
                }), 1 !== i.rank && rv(i.shape, u.shape, "Error in where: ");
                var l = {
                    condition: i,
                    t: s,
                    e: u
                };
                return Gg.runKernel("Select", l)
            }
        }),
        Sw = $g({
            zerosLike_: function (e) {
                var t = {
                    x: Zg(e, "x", "zerosLike")
                };
                return Gg.runKernel("ZerosLike", t)
            }
        }),
        Tw = $g({
            divNoNan_: function (e, t) {
                var n = Zg(e, "a", "div"),
                    r = Zg(t, "b", "div"),
                    a = Og(n, r);
                n = a[0], r = a[1];
                var i = cx(n, r),
                    o = Sw(i),
                    s = Nw(r, o);
                return Iw(s, o, i)
            }
        }),
        Cw = $g({
            dot_: function (e, t) {
                var n = Zg(e, "t1", "dot"),
                    r = Zg(t, "t2", "dot");
                nv(!(1 !== n.rank && 2 !== n.rank || 1 !== r.rank && 2 !== r.rank), function () {
                    return "Error in dot: inputs must all be rank 1 or 2, but got ranks " + n.rank + " and " + r.rank + "."
                });
                var a = 1 === n.rank ? n.size : n.shape[1],
                    i = 1 === r.rank ? r.size : r.shape[0];
                if (nv(a === i, function () {
                        return "Error in dot: inner dimensions of inputs must match, but got " + a + " and " + i + "."
                    }), 1 === n.rank && 1 === r.rank) {
                    var o = Px(n, [1, -1]),
                        s = Px(r, [-1, 1]),
                        u = fb(o, s);
                    return Px(u, [])
                }
                if (1 === n.rank && 2 === r.rank) {
                    var l = Px(n, [1, -1]),
                        c = Px(r, [r.shape[0], r.shape[1]]),
                        p = fb(l, c);
                    return Px(p, [p.size])
                }
                if (2 === n.rank && 1 === r.rank) {
                    var h = Px(r, [-1, 1]),
                        f = fb(n, h);
                    return Px(f, [f.size])
                }
                var d = Px(r, [r.shape[0], r.shape[1]]);
                return fb(n, d)
            }
        }),
        Ew = $g({
            elu_: function (e) {
                var t = {
                    x: Zg(e, "x", "elu")
                };
                return Gg.runKernel(Hv, t)
            }
        }),
        Rw = $g({
            erf_: function (e) {
                var t = Zg(e, "x", "erf");
                nv("int32" === t.dtype || "float32" === t.dtype, function () {
                    return "Input dtype must be `int32` or `float32`."
                }), "int32" === t.dtype && (t = Ky(t, "float32"));
                var n = {
                    x: t
                };
                return Gg.runKernel(qv, n)
            }
        }),
        Aw = $g({
            exp_: function (e) {
                var t = {
                    x: Zg(e, "x", "exp")
                };
                return Gg.runKernel(Kv, t)
            }
        }),
        Fw = $g({
            expandDims_: function (e, t) {
                void 0 === t && (t = 0);
                var n = Zg(e, "x", "expandDims", "string_or_numeric");
                nv(t <= n.rank, function () {
                    return "Axis must be <= rank of the tensor"
                });
                var r = {
                        input: n
                    },
                    a = {
                        dim: t
                    };
                return Gg.runKernel("ExpandDims", r, a)
            }
        }),
        _w = $g({
            expm1_: function (e) {
                var t = {
                    x: Zg(e, "x", "expm1")
                };
                return Gg.runKernel("Expm1", t)
            }
        }),
        Dw = $g({
            tile_: function (e, t) {
                var n = Zg(e, "x", "tile", "string_or_numeric");
                nv(n.rank === t.length, function () {
                    return "Error in transpose: rank of input " + n.rank + " must match length of reps " + t + "."
                });
                var r = {
                        x: n
                    },
                    a = {
                        reps: t
                    };
                return Gg.runKernel("Tile", r, a)
            }
        }),
        Ow = $g({
            eye_: function (e, t, n, r) {
                void 0 === r && (r = "float32"), null == t && (t = e);
                for (var a = qy([e, t], r), i = e <= t ? e : t, o = 0; o < i; ++o) a.set(1, o, o);
                var s = Px(a.toTensor(), [e, t]);
                if (null == n) return s;
                if (1 === n.length) return Dw(Fw(s, 0), [n[0], 1, 1]);
                if (2 === n.length) return Dw(Fw(Fw(s, 0), 0), [n[0], n[1], 1, 1]);
                if (3 === n.length) return Dw(Fw(Fw(Fw(s, 0), 0), 0), [n[0], n[1], n[2], 1, 1]);
                throw new Error("eye() currently supports only 1D and 2D batchShapes, but received " + n.length + "D.")
            }
        });

    function Mw(e, t, n) {
        var r = {
            shape: e,
            value: t,
            dtype: n
        };
        return Gg.runKernel("Fill", {}, r)
    }
    var Lw = $g({
            floor_: function (e) {
                var t = {
                    x: Zg(e, "x", "floor")
                };
                return Gg.runKernel("Floor", t)
            }
        }),
        zw = $g({
            gather_: function (e, t, n, r) {
                void 0 === n && (n = 0), void 0 === r && (r = 0);
                var a = {
                        x: Zg(e, "x", "gather"),
                        indices: Zg(t, "indices", "gather", "int32")
                    },
                    i = {
                        axis: n,
                        batchDims: r
                    };
                return Gg.runKernel("GatherV2", a, i)
            }
        }),
        Pw = $g({
            greater_: function (e, t) {
                var n = Zg(e, "a", "greater"),
                    r = Zg(t, "b", "greater"),
                    a = Og(n, r);
                n = a[0], r = a[1], kw(n.shape, r.shape);
                var i = {
                    a: n,
                    b: r
                };
                return Gg.runKernel("Greater", i)
            }
        }),
        Bw = $g({
            greaterEqual_: function (e, t) {
                var n = Zg(e, "a", "greaterEqual"),
                    r = Zg(t, "b", "greaterEqual"),
                    a = Og(n, r);
                n = a[0], r = a[1], kw(n.shape, r.shape);
                var i = {
                    a: n,
                    b: r
                };
                return Gg.runKernel("GreaterEqual", i)
            }
        }),
        Ww = $g({
            imag_: function (e) {
                var t = {
                    input: Zg(e, "input", "imag")
                };
                return Gg.runKernel("Imag", t)
            }
        }),
        Vw = $g({
            isFinite_: function (e) {
                var t = {
                    x: Zg(e, "x", "isFinite")
                };
                return Gg.runKernel("IsFinite", t)
            }
        }),
        Uw = $g({
            isInf_: function (e) {
                var t = {
                    x: Zg(e, "x", "isInf")
                };
                return Gg.runKernel("IsInf", t)
            }
        }),
        Gw = $g({
            isNaN_: function (e) {
                var t = {
                    x: Zg(e, "x", "isNaN")
                };
                return Gg.runKernel("IsNan", t)
            }
        }),
        jw = $g({
            leakyRelu_: function (e, t) {
                void 0 === t && (t = .2);
                var n = {
                        x: Zg(e, "x", "leakyRelu")
                    },
                    r = {
                        alpha: t
                    };
                return Gg.runKernel("LeakyRelu", n, r)
            }
        }),
        Hw = $g({
            less_: function (e, t) {
                var n = Zg(e, "a", "less"),
                    r = Zg(t, "b", "less"),
                    a = Og(n, r);
                n = a[0], r = a[1], kw(n.shape, r.shape);
                var i = {
                    a: n,
                    b: r
                };
                return Gg.runKernel("Less", i)
            }
        }),
        qw = $g({
            lessEqual_: function (e, t) {
                var n = Zg(e, "a", "lessEqual"),
                    r = Zg(t, "b", "lessEqual"),
                    a = Og(n, r);
                n = a[0], r = a[1], kw(n.shape, r.shape);
                var i = {
                    a: n,
                    b: r
                };
                return Gg.runKernel("LessEqual", i)
            }
        });

    function Kw(e, t, n) {
        if (n <= 0) throw new Error("The number of values should be positive.");
        var r = {
            start: e,
            stop: t,
            num: n
        };
        return Gg.runKernel("LinSpace", {}, r)
    }
    var Xw = $g({
            localResponseNormalization_: function (e, t, n, r, a) {
                void 0 === t && (t = 5), void 0 === n && (n = 1), void 0 === r && (r = 1), void 0 === a && (a = .5);
                var i = Zg(e, "x", "localResponseNormalization");
                nv(4 === i.rank || 3 === i.rank, function () {
                    return "Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank " + i.rank + "."
                }), nv(uv(t), function () {
                    return "Error in localResponseNormalization: depthRadius must be an integer but got depthRadius " + t + "."
                });
                var o = i,
                    s = !1;
                3 === i.rank && (s = !0, o = Px(i, [1, i.shape[0], i.shape[1], i.shape[2]]));
                var u = {
                        x: o
                    },
                    l = {
                        depthRadius: t,
                        bias: n,
                        alpha: r,
                        beta: a
                    },
                    c = Gg.runKernel("LRN", u, l);
                return s ? Px(c, [c.shape[1], c.shape[2], c.shape[3]]) : c
            }
        }),
        Yw = $g({
            log_: function (e) {
                var t = {
                    x: Zg(e, "x", "log")
                };
                return Gg.runKernel(Xv, t)
            }
        }),
        Jw = $g({
            log1p_: function (e) {
                var t = {
                    x: Zg(e, "x", "log1p")
                };
                return Gg.runKernel("Log1p", t)
            }
        });

    function Zw(e, t) {
        nv(Cv(e), function () {
            return "The f passed in variableGrads(f) must be a function"
        }), nv(null == t || Array.isArray(t) && t.every(function (e) {
            return e instanceof Ag
        }), function () {
            return "The varList passed in variableGrads(f, varList) must be an array of variables"
        });
        var n = null != t;
        if (!n)
            for (var r in t = [], Gg.registeredVariables) t.push(Gg.registeredVariables[r]);
        var a = n ? t.filter(function (e) {
                return !e.trainable
            }) : null,
            i = t.length;
        nv((t = t.filter(function (e) {
            return e.trainable
        })).length > 0, function () {
            return "variableGrads() expects at least one of the input variables to be trainable, but none of the " + i + " variables is trainable."
        });
        var o = Gg.gradients(e, t, null, !0),
            s = o.value,
            u = o.grads;
        nv(u.some(function (e) {
            return null != e
        }), function () {
            return "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."
        }), nv(0 === s.rank, function () {
            return "The f passed in variableGrads(f) must return a scalar, but it returned a rank-" + s.rank + " tensor"
        });
        var l = {};
        return t.forEach(function (e, t) {
            null != u[t] && (l[e.name] = u[t])
        }), null != a && a.forEach(function (e) {
            return l[e.name] = null
        }), {
            value: s,
            grads: l
        }
    }

    function Qw(e) {
        return Gg.customGrad(e)
    }

    function $w(e) {
        if (e.filter(function (e) {
                return null == e
            }).length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")
    }
    var ek = $g({
            neg_: function (e) {
                var t = {
                    x: Zg(e, "x", "neg")
                };
                return Gg.runKernel("Neg", t)
            }
        }),
        tk = $g({
            softplus_: function (e) {
                var t = {
                    x: Zg(e, "x", "softplus")
                };
                return Gg.runKernel("Softplus", t)
            }
        }),
        nk = $g({
            logSigmoid_: function (e) {
                var t = Zg(e, "x", "logSigmoid");
                return Qw(function (e) {
                    return {
                        value: ek(tk(ek(e))),
                        gradFunc: function (t) {
                            return px(t, Ux(ek(e)))
                        }
                    }
                })(t)
            }
        }),
        rk = $g({
            max_: function (e, t, n) {
                void 0 === t && (t = null), void 0 === n && (n = !1);
                var r = {
                        x: Zg(e, "x", "max")
                    },
                    a = {
                        reductionIndices: t,
                        keepDims: n
                    };
                return Gg.runKernel("Max", r, a)
            }
        }),
        ak = $g({
            sub_: function (e, t) {
                var n = Zg(e, "a", "sub"),
                    r = Zg(t, "b", "sub"),
                    a = Og(n, r),
                    i = {
                        a: n = a[0],
                        b: r = a[1]
                    };
                return Gg.runKernel(Qv, i)
            }
        }),
        ik = $g({
            sum_: function (e, t, n) {
                void 0 === t && (t = null), void 0 === n && (n = !1);
                var r = Zg(e, "x", "sum");
                "bool" === r.dtype && (r = Ky(r, "int32"));
                var a = {
                        x: r
                    },
                    i = {
                        axis: t,
                        keepDims: n
                    };
                return Gg.runKernel("Sum", a, i)
            }
        }),
        ok = $g({
            logSoftmax_: function (e, t) {
                void 0 === t && (t = -1);
                var n = Zg(e, "logits", "logSoftmax");
                if (-1 === t && (t = n.rank - 1), t !== n.rank - 1) throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank " + n.rank + " and axis was " + t);
                return Qw(function (e, n) {
                    var r = rk(e, t, !0),
                        a = ak(e, r),
                        i = ak(Ky(a, "float32"), Yw(ik(Aw(a), t, !0)));
                    return n([i]), {
                        value: i,
                        gradFunc: function (e, n) {
                            var r = n[0],
                                a = Aw(r);
                            return ak(e, px(ik(e, t, !0), a))
                        }
                    }
                })(n)
            }
        });

    function sk(e, t) {
        for (var n = 0; n < e.length; ++n)
            if (e[e.length - n - 1] !== t - 1 - n) return !1;
        return !0
    }

    function uk(e, t, n) {
        for (var r = e.length + t.length, a = [], i = 0, o = 0, s = 0; s < r; s++) - 1 === n.indexOf(s) ? a.push(e[i++]) : a.push(t[o++]);
        return a
    }

    function lk(e, t) {
        for (var n = [], r = e.length, a = 0; a < r; a++) - 1 === t.indexOf(a) && n.push(e[a]);
        return [n, t.map(function (t) {
            return e[t]
        })]
    }

    function ck(e, t) {
        return uk(e, t.map(function (e) {
            return 1
        }), t)
    }

    function pk(e, t, n) {
        nv(sk(t, n), function () {
            return e + " supports only inner-most axes for now. Got axes " + t + " and rank-" + n + " input."
        })
    }

    function hk(e, t) {
        if (sk(e, t)) return null;
        for (var n = [], r = 0; r < t; ++r) - 1 === e.indexOf(r) && n.push(r);
        return e.forEach(function (e) {
            return n.push(e)
        }), n
    }

    function fk(e) {
        return e.map(function (e, t) {
            return [t, e]
        }).sort(function (e, t) {
            return e[1] - t[1]
        }).map(function (e) {
            return e[0]
        })
    }

    function dk(e, t) {
        for (var n = [], r = t - e; r < t; ++r) n.push(r);
        return n
    }
    var mk = $g({
            logSumExp_: function (e, t, n) {
                void 0 === t && (t = null), void 0 === n && (n = !1);
                var r = Zg(e, "x", "logSumExp"),
                    a = fv(t, r.shape),
                    i = rk(r, a, !0),
                    o = ak(r, i),
                    s = Aw(o),
                    u = ik(s, a),
                    l = Yw(u),
                    c = ux(Px(i, l.shape), l);
                if (n) {
                    var p = ck(c.shape, a);
                    return Px(c, p)
                }
                return c
            }
        }),
        vk = $g({
            logicalAnd_: function (e, t) {
                var n = Zg(e, "a", "logicalAnd", "bool"),
                    r = Zg(t, "b", "logicalAnd", "bool");
                kw(n.shape, r.shape);
                var a = {
                    a: n,
                    b: r
                };
                return Gg.runKernel("LogicalAnd", a)
            }
        }),
        gk = $g({
            logicalNot_: function (e) {
                var t = {
                    x: Zg(e, "x", "logicalNot", "bool")
                };
                return Gg.runKernel("LogicalNot", t)
            }
        }),
        yk = $g({
            logicalOr_: function (e, t) {
                var n = Zg(e, "a", "logicalOr", "bool"),
                    r = Zg(t, "b", "logicalOr", "bool");
                kw(n.shape, r.shape);
                var a = {
                    a: n,
                    b: r
                };
                return Gg.runKernel("LogicalOr", a)
            }
        }),
        bk = $g({
            logicalXor_: function (e, t) {
                var n = Zg(e, "a", "logicalXor", "bool"),
                    r = Zg(t, "b", "logicalXor", "bool");
                return kw(n.shape, r.shape), vk(yk(e, t), gk(vk(e, t)))
            }
        }),
        xk = $g({
            maxPool_: function (e, t, n, r, a) {
                var i = Zg(e, "x", "maxPool"),
                    o = i,
                    s = !1;
                3 === i.rank && (s = !0, o = Px(i, [1, i.shape[0], i.shape[1], i.shape[2]])), nv(4 === o.rank, function () {
                    return "Error in maxPool: input must be rank 4 but got rank " + o.rank + "."
                }), nv(Lx(n, 1), function () {
                    return "Error in maxPool: Either strides or dilations must be 1. Got strides " + n + " and dilations '1'"
                }), null != a && nv(uv(r), function () {
                    return "Error in maxPool: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + r + "."
                });
                var u = {
                        x: o
                    },
                    l = {
                        filterSize: t,
                        strides: n,
                        pad: r,
                        dimRoundingMode: a
                    },
                    c = Gg.runKernel("MaxPool", u, l);
                return s ? Px(c, [c.shape[1], c.shape[2], c.shape[3]]) : c
            }
        }),
        wk = $g({
            maxPool3d_: function (e, t, n, r, a, i) {
                void 0 === t && (t = [1, 1, 1]), void 0 === i && (i = "NDHWC");
                var o = Zg(e, "x", "maxPool3d"),
                    s = o,
                    u = !1;
                4 === o.rank && (u = !0, s = Px(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]])), nv(5 === s.rank, function () {
                    return "Error in maxPool3d: x must be rank 5 but got rank " + s.rank + "."
                }), nv("NDHWC" === i, function () {
                    return "Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of " + i
                }), null != a && nv(uv(r), function () {
                    return "Error in maxPool3d: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + r + "."
                });
                var l = {
                        x: s
                    },
                    c = {
                        filterSize: t,
                        strides: n,
                        pad: r,
                        dimRoundingMode: a,
                        dataFormat: i
                    },
                    p = Gg.runKernel("MaxPool3D", l, c);
                return u ? Px(p, [p.shape[1], p.shape[2], p.shape[3], p.shape[4]]) : p
            }
        }),
        kk = $g({
            maxPoolWithArgmax_: function (e, t, n, r, a) {
                void 0 === a && (a = !1);
                var i = {
                        x: Zg(e, "x", "maxPoolWithArgmax")
                    },
                    o = {
                        filterSize: t,
                        strides: n,
                        pad: r,
                        includeBatchInIndex: a
                    },
                    s = Gg.runKernel("MaxPoolWithArgmax", i, o);
                return {
                    result: s[0],
                    indexes: s[1]
                }
            }
        }),
        Nk = $g({
            maximum_: function (e, t) {
                var n = Zg(e, "a", "maximum"),
                    r = Zg(t, "b", "maximum"),
                    a = Og(n, r);
                n = a[0], r = a[1], "bool" === n.dtype && (n = Ky(n, "int32"), r = Ky(r, "int32")), kw(n.shape, r.shape);
                var i = {
                    a: n,
                    b: r
                };
                return Gg.runKernel("Maximum", i)
            }
        }),
        Ik = $g({
            mean_: function (e, t, n) {
                void 0 === t && (t = null), void 0 === n && (n = !1);
                var r = {
                        x: Zg(e, "x", "mean")
                    },
                    a = {
                        axis: t,
                        keepDims: n
                    };
                return Gg.runKernel("Mean", r, a)
            }
        }),
        Sk = $g({
            min_: function (e, t, n) {
                void 0 === t && (t = null), void 0 === n && (n = !1);
                var r = {
                        x: Zg(e, "x", "min")
                    },
                    a = {
                        axis: t,
                        keepDims: n
                    };
                return Gg.runKernel("Min", r, a)
            }
        }),
        Tk = $g({
            minimum_: function (e, t) {
                var n = Zg(e, "a", "minimum"),
                    r = Zg(t, "b", "minimum"),
                    a = Og(n, r);
                n = a[0], r = a[1], "bool" === n.dtype && (n = Ky(n, "int32"), r = Ky(r, "int32")), kw(n.shape, r.shape);
                var i = {
                    a: n,
                    b: r
                };
                return Gg.runKernel("Minimum", i)
            }
        }),
        Ck = $g({
            mirrorPad_: function (e, t, n) {
                nv("reflect" === n || "symmetric" === n, function () {
                    return "Invalid mode. Mode must be either reflect or symmetric. Got " + n + "."
                });
                var r = Zg(e, "x", "mirrorPad");
                if (0 === r.rank) throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");
                nv(t.length === r.rank, function () {
                    return "Padding doesn't match input. Must be " + r.rank + ". Got " + t.length + "."
                });
                for (var a = "reflect" === n ? 1 : 0, i = function (e) {
                        nv(2 === t[e].length, function () {
                            return "Invalid number of paddings. Must be length of 2 each."
                        }), nv(t[e][0] >= 0 && t[e][0] <= r.shape[e] - a && t[e][1] >= 0 && t[e][1] <= r.shape[e] - a, function () {
                            return "Padding in dimension " + e + " cannot be greater than or equal to " + (r.shape[e] - a) + " or less than 0 for input of shape " + r.shape
                        })
                    }, o = 0; o < r.rank; o++) i(o);
                var s = {
                        paddings: t,
                        mode: n
                    },
                    u = {
                        x: r
                    };
                return Gg.runKernel("MirrorPad", u, s)
            }
        }),
        Ek = $g({
            mod_: function (e, t) {
                var n = Zg(e, "a", "mod"),
                    r = Zg(t, "b", "mod"),
                    a = Og(n, r),
                    i = {
                        a: n = a[0],
                        b: r = a[1]
                    };
                return Gg.runKernel(Yv, i)
            }
        }),
        Rk = $g({
            square_: function (e) {
                var t = Zg(e, "x", "square");
                return Gg.runKernel("Square", {
                    x: t
                }, {})
            }
        }),
        Ak = $g({
            moments_: function (e, t, n) {
                void 0 === t && (t = null), void 0 === n && (n = !1);
                var r = fv(t, (e = Zg(e, "x", "moments")).shape),
                    a = Ik(e, r, n),
                    i = a.shape;
                n || (i = ck(a.shape, r));
                var o = Rk(ak(Ky(e, "float32"), Px(a, i)));
                return {
                    mean: a,
                    variance: Ik(o, r, n)
                }
            }
        }),
        Fk = $g({
            multiRNNCell_: function (e, t, n, r) {
                for (var a = Zg(t, "data", "multiRNNCell"), i = Qg(n, "c", "multiRNNCell"), o = Qg(r, "h", "multiRNNCell"), s = a, u = [], l = 0; l < e.length; l++) {
                    var c = e[l](s, i[l], o[l]);
                    u.push(c[0]), u.push(c[1]), s = c[1]
                }
                for (var p = [], h = [], f = 0; f < u.length; f += 2) p.push(u[f]), h.push(u[f + 1]);
                return [p, h]
            }
        }),
        _k = $g({
            multinomial_: function (e, t, n, r) {
                void 0 === r && (r = !1);
                var a = Zg(e, "logits", "multinomial"),
                    i = a.size,
                    o = a.rank;
                if (i < 2) throw new Error("Error in multinomial: you need at least 2 outcomes, but got " + i + ".");
                if (o > 2) throw new Error("Rank of probabilities must be 1 or 2, but is " + o);
                n = n || Math.random();
                var s = {
                        logits: 1 === o ? Px(a, [1, -1]) : a
                    },
                    u = {
                        numSamples: t,
                        seed: n,
                        normalized: r
                    },
                    l = Gg.runKernel("Multinomial", s, u);
                return 1 === o ? Px(l, [l.size]) : l
            }
        }),
        Dk = $g({
            notEqual_: function (e, t) {
                var n = Zg(e, "a", "notEqual"),
                    r = Zg(t, "b", "notEqual"),
                    a = Og(n, r);
                n = a[0], r = a[1], kw(n.shape, r.shape);
                var i = {
                    a: n,
                    b: r
                };
                return Gg.runKernel("NotEqual", i)
            }
        });

    function Ok(e, t) {
        if (void 0 === t && (t = "float32"), "complex64" === t) {
            var n = Ok(e, "float32"),
                r = Ok(e, "float32");
            return ey(n, r)
        }
        var a = _v(ov(e), t);
        return Gg.makeTensor(a, e, t)
    }

    function Mk(e, t) {
        if (void 0 === t && (t = "float32"), "complex64" === t) {
            var n = Mk(e, "float32"),
                r = Ok(e, "float32");
            return ey(n, r)
        }
        var a = Fv(ov(e), t);
        return Gg.makeTensor(a, e, t)
    }
    var Lk = $g({
            onesLike_: function (e) {
                var t = {
                    x: Zg(e, "x", "onesLike")
                };
                return Gg.runKernel("OnesLike", t)
            }
        }),
        zk = $g({
            outerProduct_: function (e, t) {
                var n = Zg(e, "v1", "outerProduct"),
                    r = Zg(t, "v2", "outerProduct");
                nv(1 === n.rank && 1 === r.rank, function () {
                    return "Error in outerProduct: inputs must be rank 1, but got ranks " + n.rank + " and " + r.rank + "."
                });
                var a = Px(n, [-1, 1]),
                    i = Px(r, [1, -1]);
                return fb(a, i)
            }
        }),
        Pk = $g({
            pad_: function (e, t, n) {
                void 0 === n && (n = 0);
                var r = Zg(e, "x", "pad");
                if (0 === r.rank) throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
                var a = {
                        paddings: t,
                        constantValue: n
                    },
                    i = {
                        x: r
                    };
                return Gg.runKernel("PadV2", i, a)
            }
        }),
        Bk = $g({
            pad1d_: function (e, t, n) {
                return void 0 === n && (n = 0), nv(2 === t.length, function () {
                    return "Invalid number of paddings. Must be length of 2."
                }), Pk(e, [t], n)
            }
        }),
        Wk = $g({
            pad2d_: function (e, t, n) {
                return void 0 === n && (n = 0), nv(2 === t.length && 2 === t[0].length && 2 === t[1].length, function () {
                    return "Invalid number of paddings. Must be length of 2 each."
                }), Pk(e, t, n)
            }
        }),
        Vk = $g({
            pad3d_: function (e, t, n) {
                return void 0 === n && (n = 0), nv(3 === t.length && 2 === t[0].length && 2 === t[1].length && 2 === t[2].length, function () {
                    return "Invalid number of paddings. Must be length of 2 each."
                }), Pk(e, t, n)
            }
        }),
        Uk = $g({
            pad4d_: function (e, t, n) {
                return void 0 === n && (n = 0), nv(4 === t.length && 2 === t[0].length && 2 === t[1].length && 2 === t[2].length && 2 === t[3].length, function () {
                    return "Invalid number of paddings. Must be length of 2 each."
                }), Pk(e, t, n)
            }
        }),
        Gk = $g({
            spaceToBatchND_: function (e, t, n) {
                var r = Zg(e, "x", "spaceToBatchND");
                nv(r.rank >= 1 + t.length, function () {
                    return "input rank " + r.rank + " should be > than [blockShape] " + t.length
                }), nv(n.length === t.length, function () {
                    return "paddings.shape[0] " + n.length + " must be equal to [blockShape] " + t.length
                }), nv(r.shape.reduce(function (e, r, a) {
                    return a > 0 && a <= t.length ? e && (r + n[a - 1][0] + n[a - 1][1]) % t[a - 1] == 0 : e
                }, !0), function () {
                    return "input spatial dimensions " + r.shape.slice(1) + " with paddings " + n.toString() + " must be divisible by blockShapes " + t.toString()
                });
                var a = {
                        x: r
                    },
                    i = {
                        blockShape: t,
                        paddings: n
                    };
                return Gg.runKernel("SpaceToBatchND", a, i)
            }
        }),
        jk = $g({
            pool_: function (e, t, n, r, a, i) {
                null == a && (a = [1, 1]), null == i && (i = 1), 0 === r && (r = "valid");
                var o = Zg(e, "x", "maxPool"),
                    s = o,
                    u = !1;
                3 === o.rank && (u = !0, s = Px(o, [1, o.shape[0], o.shape[1], o.shape[2]])), nv(Lx(i, a), function () {
                    return "Error in pool: Either strides or dilations must be 1. Got strides " + i + " and dilations '" + a + "'"
                });
                var l, c = Tx(s.shape, t, i, a, r),
                    p = [c.dilationHeight, c.dilationWidth];
                l = "same" === r ? function (e, t) {
                    var n = e.map(function (e, n) {
                            return e + (e - 1) * (t[n] - 1)
                        }).map(function (e) {
                            return e - 1
                        }),
                        r = n.map(function (e) {
                            return Math.floor(e / 2)
                        }),
                        a = n.map(function (e, t) {
                            return e - r[t]
                        });
                    return n.map(function (e, t) {
                        return [r[t], a[t]]
                    })
                }([c.filterHeight, c.filterWidth], p) : [
                    [0, 0],
                    [0, 0]
                ];
                var h = 1 === p[0] && 1 === p[1],
                    f = function (e, t, n) {
                        var r = n.map(function (e) {
                                return e[0]
                            }),
                            a = n.map(function (e) {
                                return e[1]
                            }),
                            i = e.concat(r, a),
                            o = t.map(function (e, t) {
                                return (e - i[t] % e) % e
                            }),
                            s = a.map(function (e, t) {
                                return e + o[t]
                            });
                        return [t.map(function (e, t) {
                            return [r[t], s[t]]
                        }), t.map(function (e, t) {
                            return [0, o[t]]
                        })]
                    }([c.inHeight, c.inWidth], p, l),
                    d = f[0],
                    m = f[1],
                    v = h ? r : "valid",
                    g = h ? s : Gk(s, p, d),
                    y = ("avg" === n ? function () {
                        return Bx(g, t, i, v)
                    } : function () {
                        return xk(g, t, i, v)
                    })(),
                    b = h ? y : qx(y, p, m);
                return u ? Px(b, [b.shape[1], b.shape[2], b.shape[3]]) : b
            }
        }),
        Hk = $g({
            pow_: function (e, t) {
                var n = Zg(e, "base", "pow"),
                    r = Zg(t, "exp", "pow"),
                    a = Og(n, r),
                    i = {
                        a: n = a[0],
                        b: r = a[1]
                    };
                return Gg.runKernel(Jv, i)
            }
        }),
        qk = $g({
            prelu_: function (e, t) {
                var n = {
                    x: Zg(e, "x", "prelu"),
                    alpha: Zg(t, "alpha", "prelu")
                };
                return Gg.runKernel("Prelu", n)
            }
        }),
        Kk = $g({
            prod_: function (e, t, n) {
                void 0 === t && (t = null), void 0 === n && (n = !1);
                var r = Zg(e, "x", "prod");
                "bool" === r.dtype && (r = Ky(r, "int32"));
                var a = {
                        x: r
                    },
                    i = {
                        axis: t,
                        keepDims: n
                    };
                return Gg.runKernel("Prod", a, i)
            }
        }),
        Xk = $g({
            rand_: function (e, t, n) {
                var r = ov(e),
                    a = null;
                if (null == n || "float32" === n) a = new Float32Array(r);
                else if ("int32" === n) a = new Int32Array(r);
                else {
                    if ("bool" !== n) throw new Error("Unknown data type " + n);
                    a = new Uint8Array(r)
                }
                for (var i = 0; i < r; i++) a[i] = t();
                return Gg.makeTensor(a, e, n)
            }
        }),
        Yk = n(function (e) {
            ! function (e, t, n) {
                function r(e) {
                    var t, n = this,
                        r = (t = 4022871197, function (e) {
                            e = e.toString();
                            for (var n = 0; n < e.length; n++) {
                                var r = .02519603282416938 * (t += e.charCodeAt(n));
                                r -= t = r >>> 0, t = (r *= t) >>> 0, t += 4294967296 * (r -= t)
                            }
                            return 2.3283064365386963e-10 * (t >>> 0)
                        });
                    n.next = function () {
                        var e = 2091639 * n.s0 + 2.3283064365386963e-10 * n.c;
                        return n.s0 = n.s1, n.s1 = n.s2, n.s2 = e - (n.c = 0 | e)
                    }, n.c = 1, n.s0 = r(" "), n.s1 = r(" "), n.s2 = r(" "), n.s0 -= r(e), n.s0 < 0 && (n.s0 += 1), n.s1 -= r(e), n.s1 < 0 && (n.s1 += 1), n.s2 -= r(e), n.s2 < 0 && (n.s2 += 1), r = null
                }

                function a(e, t) {
                    return t.c = e.c, t.s0 = e.s0, t.s1 = e.s1, t.s2 = e.s2, t
                }

                function i(e, t) {
                    var n = new r(e),
                        i = t && t.state,
                        o = n.next;
                    return o.int32 = function () {
                        return 4294967296 * n.next() | 0
                    }, o.double = function () {
                        return o() + 1.1102230246251565e-16 * (2097152 * o() | 0)
                    }, o.quick = o, i && ("object" == typeof i && a(i, n), o.state = function () {
                        return a(n, {})
                    }), o
                }
                t && t.exports ? t.exports = i : this.alea = i
            }(0, e)
        }),
        Jk = n(function (e) {
            ! function (e, t, n) {
                function r(e) {
                    var t = this,
                        n = "";
                    t.x = 0, t.y = 0, t.z = 0, t.w = 0, t.next = function () {
                        var e = t.x ^ t.x << 11;
                        return t.x = t.y, t.y = t.z, t.z = t.w, t.w ^= t.w >>> 19 ^ e ^ e >>> 8
                    }, e === (0 | e) ? t.x = e : n += e;
                    for (var r = 0; r < n.length + 64; r++) t.x ^= 0 | n.charCodeAt(r), t.next()
                }

                function a(e, t) {
                    return t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, t
                }

                function i(e, t) {
                    var n = new r(e),
                        i = t && t.state,
                        o = function () {
                            return (n.next() >>> 0) / 4294967296
                        };
                    return o.double = function () {
                        do {
                            var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                        } while (0 === e);
                        return e
                    }, o.int32 = n.next, o.quick = o, i && ("object" == typeof i && a(i, n), o.state = function () {
                        return a(n, {})
                    }), o
                }
                t && t.exports ? t.exports = i : this.xor128 = i
            }(0, e)
        }),
        Zk = n(function (e) {
            ! function (e, t, n) {
                function r(e) {
                    var t = this,
                        n = "";
                    t.next = function () {
                        var e = t.x ^ t.x >>> 2;
                        return t.x = t.y, t.y = t.z, t.z = t.w, t.w = t.v, (t.d = t.d + 362437 | 0) + (t.v = t.v ^ t.v << 4 ^ e ^ e << 1) | 0
                    }, t.x = 0, t.y = 0, t.z = 0, t.w = 0, t.v = 0, e === (0 | e) ? t.x = e : n += e;
                    for (var r = 0; r < n.length + 64; r++) t.x ^= 0 | n.charCodeAt(r), r == n.length && (t.d = t.x << 10 ^ t.x >>> 4), t.next()
                }

                function a(e, t) {
                    return t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, t.v = e.v, t.d = e.d, t
                }

                function i(e, t) {
                    var n = new r(e),
                        i = t && t.state,
                        o = function () {
                            return (n.next() >>> 0) / 4294967296
                        };
                    return o.double = function () {
                        do {
                            var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                        } while (0 === e);
                        return e
                    }, o.int32 = n.next, o.quick = o, i && ("object" == typeof i && a(i, n), o.state = function () {
                        return a(n, {})
                    }), o
                }
                t && t.exports ? t.exports = i : this.xorwow = i
            }(0, e)
        }),
        Qk = n(function (e) {
            ! function (e, t, n) {
                function r(e) {
                    var t = this;
                    t.next = function () {
                            var e, n, r = t.x,
                                a = t.i;
                            return e = r[a], n = (e ^= e >>> 7) ^ e << 24, n ^= (e = r[a + 1 & 7]) ^ e >>> 10, n ^= (e = r[a + 3 & 7]) ^ e >>> 3, n ^= (e = r[a + 4 & 7]) ^ e << 7, e = r[a + 7 & 7], n ^= (e ^= e << 13) ^ e << 9, r[a] = n, t.i = a + 1 & 7, n
                        },
                        function (e, t) {
                            var n, r = [];
                            if (t === (0 | t)) r[0] = t;
                            else
                                for (t = "" + t, n = 0; n < t.length; ++n) r[7 & n] = r[7 & n] << 15 ^ t.charCodeAt(n) + r[n + 1 & 7] << 13;
                            for (; r.length < 8;) r.push(0);
                            for (n = 0; n < 8 && 0 === r[n]; ++n);
                            for (8 == n ? r[7] = -1 : r[n], e.x = r, e.i = 0, n = 256; n > 0; --n) e.next()
                        }(t, e)
                }

                function a(e, t) {
                    return t.x = e.x.slice(), t.i = e.i, t
                }

                function i(e, t) {
                    null == e && (e = +new Date);
                    var n = new r(e),
                        i = t && t.state,
                        o = function () {
                            return (n.next() >>> 0) / 4294967296
                        };
                    return o.double = function () {
                        do {
                            var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                        } while (0 === e);
                        return e
                    }, o.int32 = n.next, o.quick = o, i && (i.x && a(i, n), o.state = function () {
                        return a(n, {})
                    }), o
                }
                t && t.exports ? t.exports = i : this.xorshift7 = i
            }(0, e)
        }),
        $k = n(function (e) {
            ! function (e, t, n) {
                function r(e) {
                    var t = this;
                    t.next = function () {
                            var e, n, r = t.w,
                                a = t.X,
                                i = t.i;
                            return t.w = r = r + 1640531527 | 0, n = a[i + 34 & 127], e = a[i = i + 1 & 127], n ^= n << 13, e ^= e << 17, n ^= n >>> 15, e ^= e >>> 12, n = a[i] = n ^ e, t.i = i, n + (r ^ r >>> 16) | 0
                        },
                        function (e, t) {
                            var n, r, a, i, o, s = [],
                                u = 128;
                            for (t === (0 | t) ? (r = t, t = null) : (t += "\0", r = 0, u = Math.max(u, t.length)), a = 0, i = -32; i < u; ++i) t && (r ^= t.charCodeAt((i + 32) % t.length)), 0 === i && (o = r), r ^= r << 10, r ^= r >>> 15, r ^= r << 4, r ^= r >>> 13, i >= 0 && (o = o + 1640531527 | 0, a = 0 == (n = s[127 & i] ^= r + o) ? a + 1 : 0);
                            for (a >= 128 && (s[127 & (t && t.length || 0)] = -1), a = 127, i = 512; i > 0; --i) r = s[a + 34 & 127], n = s[a = a + 1 & 127], r ^= r << 13, n ^= n << 17, r ^= r >>> 15, n ^= n >>> 12, s[a] = r ^ n;
                            e.w = o, e.X = s, e.i = a
                        }(t, e)
                }

                function a(e, t) {
                    return t.i = e.i, t.w = e.w, t.X = e.X.slice(), t
                }

                function i(e, t) {
                    null == e && (e = +new Date);
                    var n = new r(e),
                        i = t && t.state,
                        o = function () {
                            return (n.next() >>> 0) / 4294967296
                        };
                    return o.double = function () {
                        do {
                            var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                        } while (0 === e);
                        return e
                    }, o.int32 = n.next, o.quick = o, i && (i.X && a(i, n), o.state = function () {
                        return a(n, {})
                    }), o
                }
                t && t.exports ? t.exports = i : this.xor4096 = i
            }(0, e)
        }),
        eN = n(function (e) {
            ! function (e, t, n) {
                function r(e) {
                    var t = this,
                        n = "";
                    t.next = function () {
                        var e = t.b,
                            n = t.c,
                            r = t.d,
                            a = t.a;
                        return e = e << 25 ^ e >>> 7 ^ n, n = n - r | 0, r = r << 24 ^ r >>> 8 ^ a, a = a - e | 0, t.b = e = e << 20 ^ e >>> 12 ^ n, t.c = n = n - r | 0, t.d = r << 16 ^ n >>> 16 ^ a, t.a = a - e | 0
                    }, t.a = 0, t.b = 0, t.c = -1640531527, t.d = 1367130551, e === Math.floor(e) ? (t.a = e / 4294967296 | 0, t.b = 0 | e) : n += e;
                    for (var r = 0; r < n.length + 20; r++) t.b ^= 0 | n.charCodeAt(r), t.next()
                }

                function a(e, t) {
                    return t.a = e.a, t.b = e.b, t.c = e.c, t.d = e.d, t
                }

                function i(e, t) {
                    var n = new r(e),
                        i = t && t.state,
                        o = function () {
                            return (n.next() >>> 0) / 4294967296
                        };
                    return o.double = function () {
                        do {
                            var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                        } while (0 === e);
                        return e
                    }, o.int32 = n.next, o.quick = o, i && ("object" == typeof i && a(i, n), o.state = function () {
                        return a(n, {})
                    }), o
                }
                t && t.exports ? t.exports = i : this.tychei = i
            }(0, e)
        }),
        tN = n(function (e) {
            ! function (t, n) {
                var r, a = this,
                    i = n.pow(256, 6),
                    o = n.pow(2, 52),
                    s = 2 * o;

                function u(e, u, f) {
                    var d = [],
                        m = p(function e(t, n) {
                            var r, a = [],
                                i = typeof t;
                            if (n && "object" == i)
                                for (r in t) try {
                                    a.push(e(t[r], n - 1))
                                } catch (e) {}
                            return a.length ? a : "string" == i ? t : t + "\0"
                        }((u = 1 == u ? {
                            entropy: !0
                        } : u || {}).entropy ? [e, h(t)] : null == e ? function () {
                            try {
                                var e;
                                return r && (e = r.randomBytes) ? e = e(256) : (e = new Uint8Array(256), (a.crypto || a.msCrypto).getRandomValues(e)), h(e)
                            } catch (e) {
                                var n = a.navigator,
                                    i = n && n.plugins;
                                return [+new Date, a, i, a.screen, h(t)]
                            }
                        }() : e, 3), d),
                        v = new l(d),
                        g = function () {
                            for (var e = v.g(6), t = i, n = 0; e < o;) e = 256 * (e + n), t *= 256, n = v.g(1);
                            for (; e >= s;) e /= 2, t /= 2, n >>>= 1;
                            return (e + n) / t
                        };
                    return g.int32 = function () {
                        return 0 | v.g(4)
                    }, g.quick = function () {
                        return v.g(4) / 4294967296
                    }, g.double = g, p(h(v.S), t), (u.pass || f || function (e, t, r, a) {
                        return a && (a.S && c(a, v), e.state = function () {
                            return c(v, {})
                        }), r ? (n.random = e, t) : e
                    })(g, m, "global" in u ? u.global : this == n, u.state)
                }

                function l(e) {
                    var t, n = e.length,
                        r = this,
                        a = 0,
                        i = r.i = r.j = 0,
                        o = r.S = [];
                    for (n || (e = [n++]); a < 256;) o[a] = a++;
                    for (a = 0; a < 256; a++) o[a] = o[i = 255 & i + e[a % n] + (t = o[a])], o[i] = t;
                    (r.g = function (e) {
                        for (var t, n = 0, a = r.i, i = r.j, o = r.S; e--;) t = o[a = 255 & a + 1], n = 256 * n + o[255 & (o[a] = o[i = 255 & i + t]) + (o[i] = t)];
                        return r.i = a, r.j = i, n
                    })(256)
                }

                function c(e, t) {
                    return t.i = e.i, t.j = e.j, t.S = e.S.slice(), t
                }

                function p(e, t) {
                    for (var n, r = e + "", a = 0; a < r.length;) t[255 & a] = 255 & (n ^= 19 * t[255 & a]) + r.charCodeAt(a++);
                    return h(t)
                }

                function h(e) {
                    return String.fromCharCode.apply(0, e)
                }
                if (n.seedrandom = u, p(n.random(), t), e.exports) {
                    e.exports = u;
                    try {
                        r = require("crypto")
                    } catch (e) {}
                }
            }([], Math)
        });
    tN.alea = Yk, tN.xor128 = Jk, tN.xorwow = Zk, tN.xorshift7 = Qk, tN.xor4096 = $k, tN.tychei = eN;
    var nN = tN.alea,
        rN = function () {
            function e(e, t, n, r, a) {
                this.mean = e, this.stdDev = t, this.dtype = n, this.nextVal = NaN, this.truncated = r, this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev);
                var i = a || Math.random();
                this.random = nN(i.toString())
            }
            var t = e.prototype;
            return t.nextValue = function () {
                if (!isNaN(this.nextVal)) {
                    var e = this.nextVal;
                    return this.nextVal = NaN, e
                }
                for (var t, n, r = !1; !r;) {
                    var a = void 0,
                        i = void 0,
                        o = void 0;
                    do {
                        o = (a = 2 * this.random() - 1) * a + (i = 2 * this.random() - 1) * i
                    } while (o >= 1 || 0 === o);
                    var s = Math.sqrt(-2 * Math.log(o) / o);
                    t = this.mean + this.stdDev * a * s, n = this.mean + this.stdDev * i * s, this.truncated && !this.isValidTruncated(t) || (r = !0)
                }
                return this.truncated && !this.isValidTruncated(n) || (this.nextVal = this.convertValue(n)), this.convertValue(t)
            }, t.convertValue = function (e) {
                return null == this.dtype || "float32" === this.dtype ? e : Math.round(e)
            }, t.isValidTruncated = function (e) {
                return e <= this.upper && e >= this.lower
            }, e
        }(),
        aN = function () {
            function e(e, t, n, r) {
                this.alpha = e, this.beta = 1 / t, this.dtype = n;
                var a = r || Math.random();
                this.randu = nN(a.toString()), this.randn = new rN(0, 1, n, !1, this.randu()), this.d = e < 1 ? e + 2 / 3 : e - 1 / 3, this.c = 1 / Math.sqrt(9 * this.d)
            }
            var t = e.prototype;
            return t.nextValue = function () {
                for (var e, t, n, r, a, i;;) {
                    do {
                        r = this.randn.nextValue(), i = 1 + this.c * r
                    } while (i <= 0);
                    if (i *= i * i, t = 1 - .331 * (e = r * r) * e, n = .5 * e + this.d * (1 - i + Math.log(i)), (a = this.randu()) < t || Math.log(a) < n) break
                }
                return i = 1 / this.beta * this.d * i, this.alpha < 1 && (i *= Math.pow(this.randu(), 1 / this.alpha)), this.convertValue(i)
            }, t.convertValue = function (e) {
                return "float32" === this.dtype ? e : Math.round(e)
            }, e
        }(),
        iN = function () {
            function e(e, t, n, r) {
                var a = this;
                if (void 0 === e && (e = 0), void 0 === t && (t = 1), this.canReturnFloat = function () {
                        return null == a.dtype || "float32" === a.dtype
                    }, this.min = e, this.range = t - e, this.dtype = n, null == r && (r = Math.random()), "number" == typeof r && (r = r.toString()), !this.canReturnFloat() && this.range <= 1) throw new Error("The difference between " + e + " - " + t + " <= 1 and dtype is not float");
                this.random = nN(r)
            }
            var t = e.prototype;
            return t.convertValue = function (e) {
                return this.canReturnFloat() ? e : Math.round(e)
            }, t.nextValue = function () {
                return this.convertValue(this.min + this.range * this.random())
            }, e
        }(),
        oN = $g({
            randomGamma_: function (e, t, n, r, a) {
                if (void 0 === n && (n = 1), void 0 === r && (r = "float32"), null == n && (n = 1), null == r && (r = "float32"), "float32" !== r && "int32" !== r) throw new Error("Unsupported data type " + r);
                for (var i = new aN(t, n, r, a), o = qy(e, r), s = 0; s < o.values.length; s++) o.values[s] = i.nextValue();
                return o.toTensor()
            }
        }),
        sN = $g({
            randomNormal_: function (e, t, n, r, a) {
                if (void 0 === t && (t = 0), void 0 === n && (n = 1), null != r && "bool" === r) throw new Error("Unsupported data type " + r);
                for (var i = new rN(t, n, r, !1, a), o = qy(e, r), s = 0; s < o.values.length; s++) o.values[s] = i.nextValue();
                return o.toTensor()
            }
        }),
        uN = $g({
            randomUniform_: function (e, t, n, r, a) {
                void 0 === t && (t = 0), void 0 === n && (n = 1), void 0 === r && (r = "float32");
                for (var i = qy(e, r), o = new iN(t, n, null, a), s = 0; s < i.values.length; s++) i.values[s] = o.nextValue();
                return i.toTensor()
            }
        });

    function lN(e, t, n, r) {
        if (void 0 === n && (n = 1), void 0 === r && (r = "float32"), 0 === n) throw new Error("Cannot have a step of zero");
        var a = {
            start: e,
            stop: t,
            step: n,
            dtype: r
        };
        return Gg.runKernel("Range", {}, a)
    }
    var cN = $g({
            real_: function (e) {
                var t = {
                    input: Zg(e, "input", "real")
                };
                return Gg.runKernel("Real", t)
            }
        }),
        pN = $g({
            reciprocal_: function (e) {
                var t = {
                    x: Zg(e, "x", "reciprocal")
                };
                return Gg.runKernel("Reciprocal", t)
            }
        }),
        hN = $g({
            relu_: function (e) {
                var t = {
                    x: Zg(e, "x", "relu")
                };
                return Gg.runKernel("Relu", t)
            }
        }),
        fN = $g({
            relu6_: function (e) {
                var t = {
                    x: Zg(e, "x", "relu6")
                };
                return Gg.runKernel("Relu6", t)
            }
        }),
        dN = $g({
            reverse_: function (e, t) {
                var n = {
                        x: Zg(e, "x", "reverse")
                    },
                    r = {
                        dims: t
                    };
                return Gg.runKernel("Reverse", n, r)
            }
        }),
        mN = $g({
            reverse1d_: function (e) {
                var t = Zg(e, "x", "reverse");
                return nv(1 === t.rank, function () {
                    return "Error in reverse1D: x must be rank 1 but got rank " + t.rank + "."
                }), dN(t, 0)
            }
        }),
        vN = $g({
            reverse2d_: function (e, t) {
                var n = Zg(e, "x", "reverse");
                return nv(2 === n.rank, function () {
                    return "Error in reverse2D: x must be rank 2 but got rank " + n.rank + "."
                }), dN(n, t)
            }
        }),
        gN = $g({
            reverse3d_: function (e, t) {
                var n = Zg(e, "x", "reverse");
                return nv(3 === n.rank, function () {
                    return "Error in reverse3D: x must be rank 3 but got rank " + n.rank + "."
                }), dN(n, t)
            }
        }),
        yN = $g({
            reverse4d_: function (e, t) {
                var n = Zg(e, "x", "reverse");
                return nv(4 === n.rank, function () {
                    return "Error in reverse4D: x must be rank 4 but got rank " + n.rank + "."
                }), dN(n, t)
            }
        }),
        bN = $g({
            round_: function (e) {
                var t = {
                    x: Zg(e, "x", "round")
                };
                return Gg.runKernel("Round", t)
            }
        }),
        xN = $g({
            rsqrt_: function (e) {
                var t = {
                    x: Zg(e, "x", "rsqrt")
                };
                return Gg.runKernel("Rsqrt", t)
            }
        });

    function wN(e, t) {
        if ((xv(e) && "string" !== t || Array.isArray(e)) && "complex64" !== t) throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
        if ("string" === t && xv(e) && !(e instanceof Uint8Array)) throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
        return ty(e, [], [], t)
    }
    var kN = $g({
            selu_: function (e) {
                var t = {
                    x: Zg(e, "x", "selu")
                };
                return Gg.runKernel("Selu", t)
            }
        }),
        NN = $g({
            separableConv2d_: function (e, t, n, r, a, i, o) {
                void 0 === i && (i = [1, 1]), void 0 === o && (o = "NHWC");
                var s = Zg(e, "x", "separableConv2d"),
                    u = Zg(t, "depthwiseFilter", "separableConv2d"),
                    l = Zg(n, "pointwiseFilter", "separableConv2d"),
                    c = s,
                    p = !1;
                if (3 === s.rank && (p = !0, c = Px(s, [1, s.shape[0], s.shape[1], s.shape[2]])), "NCHW" === o) throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
                nv(4 === c.rank, function () {
                    return "Error in separableConv2d: input must be rank 4, but got rank " + c.rank + "."
                }), nv(4 === u.rank, function () {
                    return "Error in separableConv2d: depthwise filter must be rank 4, but got rank " + u.rank + "."
                }), nv(4 === l.rank, function () {
                    return "Error in separableConv2d: pointwise filter must be rank 4, but got rank " + u.rank + "."
                }), nv(1 === l.shape[0], function () {
                    return "Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got " + l.shape[0] + "."
                }), nv(1 === l.shape[1], function () {
                    return "Error in separableConv2d: the second dimension of pointwise filter must be 1, but got " + l.shape[1] + "."
                });
                var h = u.shape[2],
                    f = u.shape[3];
                nv(l.shape[2] === h * f, function () {
                    return "Error in separableConv2d: the third dimension of pointwise filter must be " + h * f + ", but got " + l.shape[2] + "."
                });
                var d = gw(c, u, r, a, o, i),
                    m = iw(d, l, 1, "valid", o);
                return p ? Px(m, [m.shape[1], m.shape[2], m.shape[3]]) : m
            }
        });

    function IN() {
        return (IN = Pm(regeneratorRuntime.mark(function e(t, n) {
            var r, a, i, o, s, u, l, c, p, h, f;
            return regeneratorRuntime.wrap(function (e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return r = Zg(t, "x", "setdiff1d"), a = Zg(n, "y", "setdiff1d"), nv(r.dtype === a.dtype, function () {
                            return "x and y should have the same dtype, but got x (" + r.dtype + ") and y (" + a.dtype + ")."
                        }), nv(1 === r.rank, function () {
                            return "x should be 1D tensor, but got x (" + r.shape + ")."
                        }), nv(1 === a.rank, function () {
                            return "y should be 1D tensor, but got y (" + a.shape + ")."
                        }), e.next = 7, r.data();
                    case 7:
                        return i = e.sent, e.next = 10, a.data();
                    case 10:
                        for (o = e.sent, s = new Set(o), u = 0, l = 0; l < i.length; l++) s.has(i[l]) || u++;
                        for (c = new xg([u], r.dtype), p = new xg([u], "int32"), h = 0, f = 0; h < i.length; h++) s.has(i[h]) || (c.values[f] = i[h], p.values[f] = h, f++);
                        return e.abrupt("return", [c.toTensor(), p.toTensor()]);
                    case 18:
                    case "end":
                        return e.stop()
                }
            }, e)
        }))).apply(this, arguments)
    }
    var SN = function (e, t) {
            return IN.apply(this, arguments)
        },
        TN = $g({
            sign_: function (e) {
                var t = {
                    x: Zg(e, "x", "sign")
                };
                return Gg.runKernel("Sign", t)
            }
        }),
        CN = $g({
            sin_: function (e) {
                var t = {
                    x: Zg(e, "x", "sin")
                };
                return Gg.runKernel(Zv, t)
            }
        }),
        EN = $g({
            sinh_: function (e) {
                var t = {
                    x: Zg(e, "x", "sinh")
                };
                return Gg.runKernel("Sinh", t)
            }
        }),
        RN = $g({
            slice1d_: function (e, t, n) {
                var r = Zg(e, "x", "slice1d");
                return nv(1 === r.rank, function () {
                    return "slice1d expects a rank-1 tensor, but got a rank-" + r.rank + " tensor"
                }), Gx(r, [t], [n])
            }
        }),
        AN = $g({
            slice2d_: function (e, t, n) {
                var r = Zg(e, "x", "slice2d");
                return nv(2 === r.rank, function () {
                    return "slice2d expects a rank-2 tensor, but got a rank-" + r.rank + " tensor"
                }), Gx(r, t, n)
            }
        }),
        FN = $g({
            slice3d_: function (e, t, n) {
                var r = Zg(e, "x", "slice3d");
                return nv(3 === r.rank, function () {
                    return "slice3d expects a rank-3 tensor, but got a rank-" + r.rank + " tensor"
                }), Gx(r, t, n)
            }
        }),
        _N = $g({
            slice4d_: function (e, t, n) {
                var r = Zg(e, "x", "slice4d");
                return nv(4 === r.rank, function () {
                    return "slice4d expects a rank-4 tensor, but got a rank-" + r.rank + " tensor"
                }), Gx(r, t, n)
            }
        }),
        DN = $g({
            softmax_: function (e, t) {
                void 0 === t && (t = -1);
                var n = Zg(e, "logits", "softmax", "float32");
                if (-1 === t && (t = n.rank - 1), t !== n.rank - 1) throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank " + n.rank + " and dim was " + t);
                var r = {
                        logits: n
                    },
                    a = {
                        dim: t
                    };
                return Gg.runKernel("Softmax", r, a)
            }
        }),
        ON = $g({
            fft_: function (e) {
                nv("complex64" === e.dtype, function () {
                    return "The dtype for tf.spectral.fft() must be complex64 but got " + e.dtype + "."
                });
                var t = {
                    input: e
                };
                return Gg.runKernel("FFT", t)
            }
        }),
        MN = $g({
            ifft_: function (e) {
                nv("complex64" === e.dtype, function () {
                    return "The dtype for tf.spectral.ifft() must be complex64 but got " + e.dtype + "."
                });
                var t = {
                    input: e
                };
                return Gg.runKernel("IFFT", t)
            }
        }),
        LN = $g({
            irfft_: function (e) {
                var t, n = e.shape[e.shape.length - 1],
                    r = e.size / n;
                if (n <= 2) {
                    var a = Px(e, [r, n]);
                    t = MN(a)
                } else {
                    var i = [r, 2 * (n - 1)],
                        o = Px(cN(e), [r, n]),
                        s = Px(Ww(e), [r, n]),
                        u = dN(Gx(o, [0, 1], [r, n - 2]), 1),
                        l = px(dN(Gx(s, [0, 1], [r, n - 2]), 1), wN(-1)),
                        c = Vx([o, u], 1),
                        p = Vx([s, l], 1),
                        h = Px(ey(c, p), [i[0], i[1]]);
                    t = MN(h)
                }
                if (t = cN(t), 3 === e.rank && 0 !== e.shape[0]) {
                    var f = t,
                        d = e.shape[0];
                    t = Px(t, [d, t.shape[0] / d, t.shape[1]]), f.dispose()
                }
                return t
            }
        }),
        zN = $g({
            split_: function (e, t, n) {
                void 0 === n && (n = 0);
                var r = {
                        x: Zg(e, "x", "split")
                    },
                    a = {
                        numOrSizeSplits: t,
                        axis: n
                    };
                return Gg.runKernel("SplitV", r, a)
            }
        }),
        PN = $g({
            rfft_: function (e, t) {
                nv("float32" === e.dtype, function () {
                    return "The dtype for rfft() must be real value but got " + e.dtype
                });
                var n, r = e.shape[e.shape.length - 1],
                    a = e.size / r;
                if (null != t && t < r) {
                    var i = e.shape.map(function (e) {
                            return 0
                        }),
                        o = e.shape.map(function (e) {
                            return e
                        });
                    o[e.shape.length - 1] = t, n = Gx(e, i, o), r = t
                } else if (null != t && t > r) {
                    var s = e.shape.map(function (e) {
                        return e
                    });
                    s[e.shape.length - 1] = t - r, n = Vx([e, Ok(s)], e.shape.length - 1), r = t
                } else n = e;
                var u = Sw(n),
                    l = Px(ey(n, u), [a, r]),
                    c = ON(l),
                    p = Math.floor(r / 2) + 1,
                    h = cN(c),
                    f = Ww(c),
                    d = zN(h, [p, r - p], h.shape.length - 1),
                    m = zN(f, [p, r - p], f.shape.length - 1),
                    v = n.shape.slice();
                return v[n.shape.length - 1] = p, Px(ey(d[0], m[0]), v)
            }
        }),
        BN = $g({
            sqrt_: function (e) {
                var t = {
                    x: Zg(e, "x", "sqrt")
                };
                return Gg.runKernel("Sqrt", t)
            }
        }),
        WN = $g({
            squaredDifference_: function (e, t) {
                var n = Zg(e, "a", "squaredDifference"),
                    r = Zg(t, "b", "squaredDifference"),
                    a = Og(n, r);
                n = a[0], r = a[1], kw(n.shape, r.shape);
                var i = {
                    a: n,
                    b: r
                };
                return Gg.runKernel("SquaredDifference", i, {})
            }
        }),
        VN = $g({
            squeeze_: function (e, t) {
                var n = Zg(e, "x", "squeeze");
                return Px(n, dv(n.shape, t).newShape)
            }
        }),
        UN = $g({
            stack_: function (e, t) {
                void 0 === t && (t = 0);
                var n = Qg(e, "tensors", "stack", "string_or_numeric");
                nv(n.length >= 1, function () {
                    return "Pass at least one tensor to tf.stack"
                }), n.length > 0 && nv(t <= n[0].rank, function () {
                    return "Axis must be <= rank of the tensor"
                });
                var r = n,
                    a = {
                        axis: t
                    };
                return Gg.runKernel("Pack", r, a)
            }
        }),
        GN = $g({
            step_: function (e, t) {
                void 0 === t && (t = 0);
                var n = {
                        x: Zg(e, "x", "step")
                    },
                    r = {
                        alpha: t
                    };
                return Gg.runKernel("Step", n, r)
            }
        }),
        jN = $g({
            stridedSlice_: function (e, t, n, r, a, i, o, s, u) {
                void 0 === a && (a = 0), void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === s && (s = 0), void 0 === u && (u = 0);
                var l = {
                        x: Zg(e, "x", "stridedSlice")
                    },
                    c = {
                        begin: t,
                        end: n,
                        strides: r,
                        beginMask: a,
                        endMask: i,
                        ellipsisMask: o,
                        newAxisMask: s,
                        shrinkAxisMask: u
                    };
                return Gg.runKernel("StridedSlice", l, c)
            }
        }),
        HN = $g({
            tan_: function (e) {
                var t = {
                    x: Zg(e, "x", "tan")
                };
                return Gg.runKernel($v, t)
            }
        });

    function qN(e, t) {
        av(e);
        var n = Yg(e, t);
        if (1 !== n.length) throw new Error("tensor1d() requires values to be a flat/TypedArray");
        return ty(e, null, n, t)
    }

    function KN(e, t, n) {
        if (av(e), null != t && 2 !== t.length) throw new Error("tensor2d() requires shape to have two numbers");
        var r = Yg(e, n);
        if (2 !== r.length && 1 !== r.length) throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
        if (1 === r.length && null == t) throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
        return ty(e, t, r, n)
    }
    var XN = $g({
            topk_: function (e, t, n) {
                void 0 === t && (t = 1), void 0 === n && (n = !0);
                var r = Zg(e, "x", "topk");
                if (0 === r.rank) throw new Error("topk() expects the input to be of rank 1 or higher");
                var a = r.shape[r.shape.length - 1];
                if (t > a) throw new Error("'k' passed to topk() must be <= the last dimension (" + a + ") but got " + t);
                var i = {
                        x: r
                    },
                    o = {
                        k: t,
                        sorted: n
                    },
                    s = Gg.runKernel("TopK", i, o);
                return {
                    values: s[0],
                    indices: s[1]
                }
            }
        }),
        YN = $g({
            truncatedNormal_: function (e, t, n, r, a) {
                if (void 0 === t && (t = 0), void 0 === n && (n = 1), null != r && "bool" === r) throw new Error("Unsupported data type $ { dtype }");
                for (var i = new rN(t, n, r, !0, a), o = qy(e, r), s = 0; s < o.values.length; s++) o.values[s] = i.nextValue();
                return o.toTensor()
            }
        }),
        JN = $g({
            unique_: function (e, t) {
                void 0 === t && (t = 0);
                var n = Zg(e, "x", "unique", "string_or_numeric");
                nv(n.rank > 0, function () {
                    return "The input tensor must be at least 1D"
                });
                var r = {
                        x: n
                    },
                    a = {
                        axis: t
                    },
                    i = Gg.runKernel("Unique", r, a);
                return {
                    values: i[0],
                    indices: i[1]
                }
            }
        }),
        ZN = $g({
            unsortedSegmentSum_: function (e, t, n) {
                var r = Zg(e, "x", "unsortedSegmentSum"),
                    a = Zg(t, "segmentIds", "unsortedSegmentSum", "int32");
                nv(uv(n), function () {
                    return "numSegments must be of dtype int"
                });
                var i = {
                        x: r,
                        segmentIds: a
                    },
                    o = {
                        numSegments: n
                    };
                return Gg.runKernel("UnsortedSegmentSum", i, o)
            }
        }),
        QN = $g({
            unstack_: function (e, t) {
                void 0 === t && (t = 0);
                var n = Zg(e, "x", "unstack", "string_or_numeric");
                nv(t >= -n.shape.length && t < n.shape.length, function () {
                    return "Axis = " + t + " is not in [-" + n.shape.length + ", " + n.shape.length + ")"
                });
                var r = {
                        value: n
                    },
                    a = {
                        axis: t
                    };
                return Gg.runKernel("Unpack", r, a)
            }
        });

    function $N(e, t, n, r) {
        return void 0 === t && (t = !0), Gg.makeVariable(e, t, n, r)
    }

    function eI(e, t) {
        for (var n = [], r = 0; r < t.length; r++) t[r] && n.push(r);
        for (var a = qy(e, "int32"), i = qy([n.length, e.length], "int32"), o = 0; o < n.length; o++) {
            var s = a.indexToLoc(n[o]),
                u = o * e.length;
            i.values.set(s, u)
        }
        return i.toTensor()
    }

    function tI() {
        return (tI = Pm(regeneratorRuntime.mark(function e(t) {
            var n, r, a;
            return regeneratorRuntime.wrap(function (e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return n = Zg(t, "condition", "whereAsync", "bool"), e.next = 3, n.data();
                    case 3:
                        return r = e.sent, a = eI(n.shape, r), t !== n && n.dispose(), e.abrupt("return", a);
                    case 7:
                    case "end":
                        return e.stop()
                }
            }, e)
        }))).apply(this, arguments)
    }
    var nI = function (e) {
        return tI.apply(this, arguments)
    };

    function rI() {
        return (rI = Pm(regeneratorRuntime.mark(function e(t, n, r) {
            var a, i, o, s, u, l, c, p, h, f, d, m, v;
            return regeneratorRuntime.wrap(function (e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        for (a = Zg(t, "tensor", "boolMask"), i = Zg(n, "mask", "boolMask", "bool"), o = null == r ? 0 : r, s = i.rank, u = a.shape, nv(s > 0, function () {
                                return "mask cannot be scalar"
                            }), rv(u.slice(o, o + s), i.shape, "mask's shape must match the first K dimensions of tensor's shape,"), l = 1, c = o; c < o + s; c++) l *= u[c];
                        return p = u.slice(0, o).concat([l], u.slice(o + s)), h = Px(a, p), f = Px(i, [-1]), e.next = 14, nI(f);
                    case 14:
                        return d = e.sent, m = VN(d, [1]), v = zw(h, m, o), t !== a && a.dispose(), n !== i && i.dispose(), m.dispose(), h.dispose(), f.dispose(), d.dispose(), e.abrupt("return", v);
                    case 24:
                    case "end":
                        return e.stop()
                }
            }, e)
        }))).apply(this, arguments)
    }
    var aI = $g({
            norm_: function (e, t, n, r) {
                void 0 === t && (t = "euclidean"), void 0 === n && (n = null), void 0 === r && (r = !1);
                var a = function e(t, n, r) {
                        if (void 0 === r && (r = null), 0 === t.rank) return hx(t);
                        if (1 !== t.rank && null === r) return e(Px(t, [-1]), n, r);
                        if (1 === t.rank || "number" == typeof r || Array.isArray(r) && 1 === r.length) {
                            if (1 === n) return ik(hx(t), r);
                            if (n === 1 / 0) return rk(hx(t), r);
                            if (n === -1 / 0) return Sk(hx(t), r);
                            if ("euclidean" === n || 2 === n) return BN(ik(Hk(hx(t), wN(2, "int32")), r));
                            throw new Error("Error in norm: invalid ord value: " + n)
                        }
                        if (Array.isArray(r) && 2 === r.length) {
                            if (1 === n) return rk(ik(hx(t), r[0]), r[1] - 1);
                            if (n === 1 / 0) return rk(ik(hx(t), r[1]), r[0]);
                            if (n === -1 / 0) return Sk(ik(hx(t), r[1]), r[0]);
                            if ("fro" === n || "euclidean" === n) return BN(ik(Rk(t), r));
                            throw new Error("Error in norm: invalid ord value: " + n)
                        }
                        throw new Error("Error in norm: invalid axis: " + r)
                    }(e = Zg(e, "x", "norm"), t, n),
                    i = a.shape;
                if (r) {
                    var o = fv(n, e.shape);
                    i = ck(a.shape, o)
                }
                return Px(a, i)
            }
        }),
        iI = $g({
            movingAverage_: function (e, t, n, r, a) {
                void 0 === a && (a = !0);
                var i = Zg(e, "v", "movingAverage"),
                    o = Zg(t, "x", "movingAverage"),
                    s = Zg(n, "decay", "movingAverage");
                Mg(i, o), nv(sv(i.shape, o.shape), function () {
                    return "Shape mismatch in v and x"
                });
                var u = wN(1),
                    l = ak(u, s),
                    c = px(ak(o, i), l);
                if (a) {
                    nv(null != r, function () {
                        return "When using zeroDebias: true, step is required."
                    });
                    var p = Zg(r, "step", "movingAverage");
                    c = cx(c, ak(u, Hk(s, p)))
                }
                return ux(i, c)
            }
        }),
        oI = $g({
            scatterND_: function (e, t, n) {
                var r = Zg(e, "indices", "scatterND", "int32"),
                    a = Zg(t, "updates", "scatterND");
                Cb(a, r, n);
                var i = {
                        indices: r,
                        updates: a
                    },
                    o = {
                        shape: n
                    };
                return Gg.runKernel("ScatterNd", i, o)
            }
        }),
        sI = $g({
            sparseToDense_: function (e, t, n, r) {
                void 0 === r && (r = 0);
                var a = Zg(e, "sparseIndices", "sparseToDense", "int32"),
                    i = Zg(t, "sparseValues", "sparseToDense"),
                    o = Zg(r, "defaultValue", "sparseToDense", i.dtype);
                ! function (e, t, n, r) {
                    if ("int32" !== e.dtype) throw new Error("tf.sparseToDense() expects the indices to be int32 type, but the dtype was " + e.dtype + ".");
                    if (e.rank > 2) throw new Error("sparseIndices should be a scalar, vector, or matrix, but got shape " + e.shape + ".");
                    var a = e.rank > 0 ? e.shape[0] : 1,
                        i = e.rank > 1 ? e.shape[1] : 1;
                    if (n.length !== i) throw new Error("outputShape has incorrect number of elements:, " + n.length + ", should be: " + i + ".");
                    var o = t.size;
                    if (0 !== t.rank && (1 !== t.rank || o !== a)) throw new Error("sparseValues has incorrect shape " + t.shape + ", should be [] or [" + a + "]");
                    if (t.dtype !== r.dtype) throw new Error("sparseValues.dtype must match defaultValues.dtype")
                }(a, i, n, o);
                var s = {
                        sparseIndices: a,
                        sparseValues: i,
                        defaultValue: o
                    },
                    u = {
                        outputShape: n
                    };
                return Gg.runKernel("SparseToDense", s, u)
            }
        }),
        uI = $g({
            gatherND_: function (e, t) {
                var n = Zg(t, "indices", "gatherND", "int32"),
                    r = {
                        params: Zg(e, "x", "gatherND"),
                        indices: n
                    };
                return Gg.runKernel("GatherNd", r)
            }
        }),
        lI = $g({
            dropout_: function (e, t, n, r) {
                var a = Zg(e, "x", "dropout");
                if (nv("float32" === a.dtype, function () {
                        return "x has to be a floating point tensor since it's going to be scaled, but got a " + a.dtype + " tensor instead."
                    }), nv(t >= 0 && t < 1, function () {
                        return "rate must be a float in the range [0, 1), but got " + t + "."
                    }), 0 === t) return e instanceof Ng ? a.clone() : a;
                var i = function (e, t) {
                        if (null == t) return e.shape.slice();
                        if (sv(e.shape, t)) return t;
                        if (e.shape.length === t.length) {
                            for (var n = [], r = 0; r < e.shape.length; r++) null == t[r] && null != e.shape[r] ? n.push(e.shape[r]) : n.push(t[r]);
                            return n
                        }
                        return t
                    }(a, n),
                    o = 1 - t,
                    s = cx(Lw(ux(uN(i, 0, 1, "float32", r), o)), o);
                return px(a, s)
            }
        });

    function cI(e) {
        return Math.floor(Math.pow(2, Math.ceil(Math.log(e) / Math.log(2))))
    }

    function pI(e, t, n) {
        for (var r = 1 - e % 2, a = new Float32Array(e), i = 0; i < e; ++i) {
            var o = 2 * Math.PI * i / (e + r - 1);
            a[i] = t - n * Math.cos(o)
        }
        return qN(a, "float32")
    }

    function hI() {
        return (hI = Pm(regeneratorRuntime.mark(function e(t, n, r) {
            var a, i, o, s, u, l, c, p, h, f, d, m, v, g;
            return regeneratorRuntime.wrap(function (e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return void 0 === r && (r = 1), a = Zg(t, "predictions", "inTopK"), i = Zg(n, "targets", "inTopK"), nv(a.rank > 1, function () {
                            return "inTopK() expects the predictions to be of rank 2 or higher, but got " + a.rank
                        }), nv(a.rank - 1 === i.rank, function () {
                            return "predictions rank should be 1 larger than targets rank, but got predictions rank " + a.rank + " and targets rank " + i.rank
                        }), rv(a.shape.slice(0, a.shape.length - 1), i.shape, "predictions's shape should be align with the targets' shape, except the last dimension."), o = a.shape[a.shape.length - 1], nv(r > 0 && r <= o, function () {
                            return "'k' passed to inTopK() must be > 0 && <= the predictions last dimension (" + o + "), but got " + r
                        }), e.next = 10, a.data();
                    case 10:
                        return s = e.sent, e.next = 13, i.data();
                    case 13:
                        u = e.sent, l = s.length / o, c = o, p = mv("bool", l), h = 0;
                    case 17:
                        if (!(h < l)) {
                            e.next = 35;
                            break
                        }
                        for (f = h * c, d = s.subarray(f, f + c), m = [], v = 0; v < d.length; v++) m.push({
                            value: d[v],
                            index: v
                        });
                        m.sort(function (e, t) {
                            return t.value - e.value
                        }), p[h] = 0, g = 0;
                    case 25:
                        if (!(g < r)) {
                            e.next = 32;
                            break
                        }
                        if (m[g].index !== u[h]) {
                            e.next = 29;
                            break
                        }
                        return p[h] = 1, e.abrupt("break", 32);
                    case 29:
                        g++, e.next = 25;
                        break;
                    case 32:
                        h++, e.next = 17;
                        break;
                    case 35:
                        return t !== a && a.dispose(), n !== i && i.dispose(), e.abrupt("return", ny(p, i.shape, "bool"));
                    case 38:
                    case "end":
                        return e.stop()
                }
            }, e)
        }))).apply(this, arguments)
    }
    var fI = $g({
        conv2DBackpropFilter_: function (e, t, n, r, a, i, o) {
            void 0 === i && (i = "NHWC");
            var s = e;
            3 === e.rank && (s = Px(e, [1, e.shape[0], e.shape[1], e.shape[2]]));
            var u = t;
            3 === u.rank && (u = Px(t, [1, t.shape[0], t.shape[1], t.shape[2]])), nv(4 === s.rank, function () {
                return "Error in conv2dDerFilter: input must be rank 4, but got shape " + s.shape + "."
            }), nv(4 === u.rank, function () {
                return "Error in conv2dDerFilter: dy must be rank 4, but got shape " + u.shape + "."
            }), nv(4 === n.length, function () {
                return "Error in conv2dDerFilter: filterShape must be length 4, but got " + n + "."
            });
            var l = "NHWC" === i ? s.shape[3] : s.shape[1],
                c = "NHWC" === i ? u.shape[3] : u.shape[1];
            nv(l === n[2], function () {
                return "Error in conv2dDerFilter: depth of input " + l + ") must match input depth in filter (" + n[2] + "."
            }), nv(c === n[3], function () {
                return "Error in conv2dDerFilter: depth of dy (" + c + ") must match output depth for filter (" + n[3] + ")."
            }), null != o && nv(uv(a), function () {
                return "Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode " + o + " but got pad " + a + "."
            });
            var p = {
                    x: s,
                    dy: u
                },
                h = {
                    strides: r,
                    pad: a,
                    dataFormat: i,
                    dimRoundingMode: o,
                    filterShape: n
                };
            return Gg.runKernel("Conv2DBackpropFilter", p, h)
        }
    });

    function dI(e, t, n) {
        if (null == n || "linear" === n) return e;
        if ("relu" === n) return px(e, GN(t));
        throw new Error("Cannot compute gradient for fused activation " + n + ".")
    }

    function mI(e, t) {
        var n = t,
            r = ww(e.shape, t.shape);
        return r.length > 0 && (n = ik(n, r)), Px(n, e.shape)
    }

    function vI(e, t, n, r) {
        if ("linear" === t) return e;
        if ("relu" === t) return hN(e);
        if ("elu" === t) return Ew(e);
        if ("relu6" === t) return fN(e);
        if ("prelu" === t) return qk(e, n);
        if ("leakyrelu" === t) return jw(e, r);
        throw new Error("Unknown fused activation " + t + ".")
    }
    var gI = function (e, t) {
            return !(e > 0) || "linear" === t
        },
        yI = $g({
            fusedConv2d_: function (e) {
                var t = e.x,
                    n = e.filter,
                    r = e.strides,
                    a = e.pad,
                    i = e.dataFormat,
                    o = void 0 === i ? "NHWC" : i,
                    s = e.dilations,
                    u = void 0 === s ? [1, 1] : s,
                    l = e.dimRoundingMode,
                    c = e.bias,
                    p = e.activation,
                    h = void 0 === p ? "linear" : p,
                    f = e.preluActivationWeights,
                    d = e.leakyreluAlpha;
                if (h = h || "linear", !1 === gI(Gg.state.gradientDepth, h)) {
                    var m = iw(t, n, r, a, o, u, l);
                    return null != c && (m = ux(m, c)), vI(m, h, f, d)
                }
                var v = Zg(t, "x", "conv2d"),
                    g = Zg(n, "filter", "conv2d"),
                    y = v,
                    b = !1;
                3 === v.rank && (b = !0, y = Px(v, [1, v.shape[0], v.shape[1], v.shape[2]])), nv(4 === y.rank, function () {
                    return "Error in fused conv2d: input must be rank 4, but got rank " + y.rank + "."
                }), nv(4 === g.rank, function () {
                    return "Error in fused conv2d: filter must be rank 4, but got rank " + g.rank + "."
                }), null != l && nv(uv(a), function () {
                    return "Error in fused conv2d: pad must be an integer when using, dimRoundingMode " + l + " but got pad " + a + "."
                }), nv(y.shape[3] === g.shape[2], function () {
                    return "Error in conv2d: depth of input (" + y.shape[3] + ") must match input depth for filter " + g.shape[2] + "."
                }), nv(Lx(r, u), function () {
                    return "Error in conv2D: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + u + "'"
                }), nv("NHWC" === o, function () {
                    return "Error in conv2d: got dataFormat of " + o + " but only NHWC is currently supported."
                });
                var x, w, k = Ex(y.shape, g.shape, r, u, a, l);
                null != c && (x = Og(x = Zg(c, "bias", "fused conv2d"), v)[0], kw(k.outShape, x.shape)), null != f && (w = Zg(f, "prelu weights", "fused conv2d"));
                var N = function (e, t) {
                        var n = t[0],
                            i = t[1],
                            o = t[2],
                            s = t[3],
                            l = dI(e, o, h);
                        nv(Mx(u), function () {
                            return "Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + u + "'"
                        });
                        var c = [sw(i.shape, l, n, r, a), fI(i, l, n.shape, r, a)];
                        if (null != s) {
                            var p = mI(s, l);
                            c.push(p)
                        }
                        return c
                    },
                    I = {
                        x: y,
                        filter: g,
                        bias: x,
                        preluActivationWeights: w
                    },
                    S = {
                        strides: r,
                        pad: a,
                        dataFormat: o,
                        dilations: u,
                        dimRoundingMode: l,
                        activation: h,
                        leakyreluAlpha: d
                    };
                return null == c ? Qw(function (e, t, n) {
                    var r = Gg.runKernel("FusedConv2D", I, S);
                    return n([t, e, r]), b && (r = Px(r, [r.shape[1], r.shape[2], r.shape[3]])), {
                        value: r,
                        gradFunc: N
                    }
                })(y, g) : Qw(function (e, t, n, r) {
                    var a = Gg.runKernel("FusedConv2D", I, S);
                    return r([t, e, a, n]), b && (a = Px(a, [a.shape[1], a.shape[2], a.shape[3]])), {
                        value: a,
                        gradFunc: N
                    }
                })(y, g, x)
            }
        }),
        bI = $g({
            depthwiseConv2dNativeBackpropFilter_: function (e, t, n, r, a, i, o) {
                void 0 === i && (i = [1, 1]);
                var s = e;
                3 === e.rank && (s = Px(e, [1, e.shape[0], e.shape[1], e.shape[2]]));
                var u = t;
                3 === u.rank && (u = Px(t, [1, t.shape[0], t.shape[1], t.shape[2]]));
                var l = {
                        x: s,
                        dy: u
                    },
                    c = {
                        strides: r,
                        pad: a,
                        dimRoundingMode: o,
                        dilations: i,
                        filterShape: n
                    };
                return Gg.runKernel("DepthwiseConv2dNativeBackpropFilter", l, c)
            }
        }),
        xI = $g({
            depthwiseConv2dNativeBackpropInput_: function (e, t, n, r, a, i, o) {
                void 0 === i && (i = [1, 1]);
                var s = t,
                    u = !1;
                3 === t.rank && (u = !0, s = Px(t, [1, t.shape[0], t.shape[1], t.shape[2]]));
                var l = {
                        dy: s,
                        filter: n
                    },
                    c = {
                        strides: r,
                        pad: a,
                        dimRoundingMode: o,
                        dilations: i,
                        inputShape: e
                    },
                    p = Gg.runKernel("DepthwiseConv2dNativeBackpropInput", l, c);
                return u ? Px(p, [p.shape[1], p.shape[2], p.shape[3]]) : p
            }
        }),
        wI = $g({
            fusedDepthwiseConv2d_: function (e) {
                var t = e.x,
                    n = e.filter,
                    r = e.strides,
                    a = e.pad,
                    i = e.dataFormat,
                    o = void 0 === i ? "NHWC" : i,
                    s = e.dilations,
                    u = void 0 === s ? [1, 1] : s,
                    l = e.dimRoundingMode,
                    c = e.bias,
                    p = e.activation,
                    h = void 0 === p ? "linear" : p,
                    f = e.preluActivationWeights,
                    d = e.leakyreluAlpha;
                if (!1 === gI(Gg.state.gradientDepth, h)) {
                    var m = gw(t, n, r, a, o, u, l);
                    return null != c && (m = ux(m, c)), vI(m, h, f, d)
                }
                var v = Zg(t, "x", "depthwiseConv2d"),
                    g = Zg(n, "filter", "depthwiseConv2d"),
                    y = v,
                    b = !1;
                3 === v.rank && (b = !0, y = Px(v, [1, v.shape[0], v.shape[1], v.shape[2]])), nv(4 === y.rank, function () {
                    return "Error in fused depthwiseConv2d: input must be rank 4, but got rank " + y.rank + "."
                }), nv(4 === g.rank, function () {
                    return "Error in fused depthwiseConv2d: filter must be rank 4, but got rank " + g.rank + "."
                }), nv(y.shape[3] === g.shape[2], function () {
                    return "Error in fused depthwiseConv2d: number of input channels (" + y.shape[3] + ") must match the inChannels dimension in filter " + g.shape[2] + "."
                }), null == u && (u = [1, 1]), nv(Lx(r, u), function () {
                    return "Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + u + "'"
                }), null != l && nv(uv(a), function () {
                    return "Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode " + l + " but got pad " + a + "."
                });
                var x, w, k = Ex(y.shape, g.shape, r, u, a, l, !0);
                if (null != c) {
                    var N = Og(x = Zg(c, "bias", "fused conv2d"), v);
                    x = N[0], kw(k.outShape, x.shape)
                }
                null != f && (w = Zg(f, "prelu weights", "fused depthwiseConv2d"));
                var I = function (e, t) {
                        nv(Mx(u), function () {
                            return "Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + u + "'"
                        });
                        var n = t[0],
                            i = t[1],
                            o = t[2],
                            s = t[3],
                            c = dI(e, o, h),
                            p = xI(i.shape, c, n, r, a, u, l),
                            f = bI(i, c, n.shape, r, a, u, l);
                        return null != s ? [p, f, mI(x, c)] : [p, f]
                    },
                    S = {
                        x: y,
                        filter: g,
                        bias: x,
                        preluActivationWeights: w
                    },
                    T = {
                        strides: r,
                        pad: a,
                        dataFormat: o,
                        dilations: u,
                        dimRoundingMode: l,
                        activation: h,
                        leakyreluAlpha: d
                    };
                return null == c ? Qw(function (e, t, n) {
                    var r = Gg.runKernel("FusedDepthwiseConv2D", S, T);
                    return n([t, e, r]), b && (r = Px(r, [r.shape[1], r.shape[2], r.shape[3]])), {
                        value: r,
                        gradFunc: I
                    }
                })(y, g) : Qw(function (e, t, n, r) {
                    var a = Gg.runKernel("FusedDepthwiseConv2D", S, T);
                    return r([t, e, a, n]), b && (a = Px(a, [a.shape[1], a.shape[2], a.shape[3]])), {
                        value: a,
                        gradFunc: I
                    }
                })(y, g, x)
            }
        }),
        kI = $g({
            fusedMatMul_: function (e) {
                var t = e.a,
                    n = e.b,
                    r = e.transposeA,
                    a = void 0 !== r && r,
                    i = e.transposeB,
                    o = void 0 !== i && i,
                    s = e.bias,
                    u = e.activation,
                    l = void 0 === u ? "linear" : u,
                    c = e.preluActivationWeights,
                    p = e.leakyreluAlpha;
                if (!1 === gI(Gg.state.gradientDepth, l)) {
                    var h = fb(t, n, a, o);
                    return null != s && (h = ux(h, s)), vI(h, l, c, p)
                }
                var f = Zg(t, "a", "fused matMul"),
                    d = Zg(n, "b", "fused matMul"),
                    m = Og(f, d);
                f = m[0], d = m[1];
                var v = a ? f.shape[f.rank - 2] : f.shape[f.rank - 1],
                    g = o ? d.shape[d.rank - 1] : d.shape[d.rank - 2],
                    y = a ? f.shape[f.rank - 1] : f.shape[f.rank - 2],
                    b = o ? d.shape[d.rank - 2] : d.shape[d.rank - 1],
                    x = f.shape.slice(0, -2),
                    w = d.shape.slice(0, -2),
                    k = ov(x),
                    N = ov(w);
                nv(f.rank >= 2 && d.rank >= 2 && f.rank === d.rank, function () {
                    return "Error in fused matMul: inputs must have the same rank of at least 2, got ranks " + f.rank + " and " + d.rank + "."
                }), nv(sv(x, w), function () {
                    return "Error in fused matMul: outer dimensions (" + x + ") and (" + w + ") of Tensors with shapes " + f.shape + " and " + d.shape + " must match."
                }), nv(v === g, function () {
                    return "Error in fused matMul: inner shapes (" + v + ") and (" + g + ") of Tensors with shapes " + f.shape + " and " + d.shape + " and transposeA=" + a + " and transposeB=" + o + " must match."
                });
                var I, S, T = f.shape.slice(0, -2).concat([y, b]),
                    C = Px(f, a ? [k, v, y] : [k, y, v]),
                    E = Px(d, o ? [N, b, g] : [N, g, b]);
                null != s && (I = Og(I = Zg(s, "bias", "fused matMul"), f)[0], kw(T, I.shape)), null != c && (S = Zg(c, "prelu weights", "fused matMul"));
                var R = function (e, t) {
                        var n, r, i = t[0],
                            u = t[1],
                            c = t[2],
                            p = t[3],
                            h = dI(Px(e, c.shape), c, l);
                        return a || o ? !a && o ? (n = fb(h, u, !1, !1), r = fb(h, i, !0, !1)) : a && !o ? (n = fb(u, h, !1, !0), r = fb(i, h, !1, !1)) : (n = fb(u, h, !0, !0), r = fb(h, i, !0, !0)) : (n = fb(h, u, !1, !0), r = fb(i, h, !0, !1)), null != s ? [n, r, mI(p, h)] : [n, r]
                    },
                    A = {
                        a: C,
                        b: E,
                        bias: I,
                        preluActivationWeights: S
                    },
                    F = {
                        transposeA: a,
                        transposeB: o,
                        activation: l,
                        leakyreluAlpha: p
                    };
                return null == s ? Qw(function (e, t, n) {
                    var r = Gg.runKernel("_FusedMatMul", A, F);
                    return n([e, t, r]), {
                        value: Px(r, T),
                        gradFunc: R
                    }
                })(C, E) : Qw(function (e, t, n, r) {
                    var a = Gg.runKernel("_FusedMatMul", A, F);
                    return r([e, t, a, n]), {
                        value: Px(a, T),
                        gradFunc: R
                    }
                })(C, E, I)
            }
        }),
        NI = {
            __proto__: null,
            conv2d: yI,
            depthwiseConv2d: wI,
            matMul: kI
        },
        II = $g({
            hammingWindow_: function (e) {
                return pI(e, .54, .46)
            }
        }),
        SI = $g({
            hannWindow_: function (e) {
                return pI(e, .5, .5)
            }
        }),
        TI = $g({
            frame_: function (e, t, n, r, a) {
                void 0 === r && (r = !1), void 0 === a && (a = 0);
                for (var i = 0, o = []; i + t <= e.size;) o.push(Gx(e, i, t)), i += n;
                if (r)
                    for (; i < e.size;) {
                        var s = i + t - e.size,
                            u = Vx([Gx(e, i, t - s), Mw([s], a)]);
                        o.push(u), i += n
                    }
                return 0 === o.length ? KN([], [0, t]) : Px(Vx(o), [o.length, t])
            }
        }),
        CI = $g({
            stft_: function (e, t, n, r, a) {
                void 0 === a && (a = SI), null == r && (r = cI(t));
                for (var i = TI(e, t, n), o = px(i, a(t)), s = [], u = 0; u < i.shape[0]; u++) s.push(PN(Gx(o, [u, 0], [1, t]), r));
                return Vx(s)
            }
        }),
        EI = $g({
            cropAndResize_: function (e, t, n, r, a, i) {
                void 0 === a && (a = "bilinear"), void 0 === i && (i = 0);
                var o = Zg(e, "image", "cropAndResize"),
                    s = Zg(t, "boxes", "cropAndResize", "float32"),
                    u = Zg(n, "boxInd", "cropAndResize", "int32"),
                    l = s.shape[0];
                nv(4 === o.rank, function () {
                    return "Error in cropAndResize: image must be rank 4,but got rank " + o.rank + "."
                }), nv(2 === s.rank && 4 === s.shape[1], function () {
                    return "Error in cropAndResize: boxes must be have size [" + l + ",4] but had shape " + s.shape + "."
                }), nv(1 === u.rank && u.shape[0] === l, function () {
                    return "Error in cropAndResize: boxInd must be have size [" + l + "] but had shape " + s.shape + "."
                }), nv(2 === r.length, function () {
                    return "Error in cropAndResize: cropSize must be of length 2, but got length " + r.length + "."
                }), nv(r[0] >= 1 && r[1] >= 1, function () {
                    return "cropSize must be atleast [1,1], but was " + r
                }), nv("bilinear" === a || "nearest" === a, function () {
                    return "method must be bilinear or nearest, but was " + a
                });
                var c = {
                        image: o,
                        boxes: s,
                        boxInd: u
                    },
                    p = {
                        method: a,
                        extrapolationValue: i,
                        cropSize: r
                    };
                return Gg.runKernel("CropAndResize", c, p)
            }
        }),
        RI = $g({
            flipLeftRight_: function (e) {
                var t = Zg(e, "image", "flipLeftRight", "float32");
                nv(4 === t.rank, function () {
                    return "Error in flipLeftRight: image must be rank 4,but got rank " + t.rank + "."
                });
                var n = {
                    image: t
                };
                return Gg.runKernel("FlipLeftRight", n, {})
            }
        }),
        AI = $g({
            rotateWithOffset_: function (e, t, n, r) {
                void 0 === n && (n = 0), void 0 === r && (r = .5);
                var a = Zg(e, "image", "rotateWithOffset", "float32");
                nv(4 === a.rank, function () {
                    return "Error in rotateWithOffset: image must be rank 4,but got rank " + a.rank + "."
                });
                var i = {
                        image: a
                    },
                    o = {
                        radians: t,
                        fillValue: n,
                        center: r
                    };
                return Gg.runKernel("RotateWithOffset", i, o)
            }
        });

    function FI(e, t, n, r, a, i) {
        null == r && (r = .5), null == a && (a = Number.NEGATIVE_INFINITY), null == i && (i = 0);
        var o = e.shape[0];
        return n = Math.min(n, o), nv(0 <= r && r <= 1, function () {
            return "iouThreshold must be in [0, 1], but was '" + r + "'"
        }), nv(2 === e.rank, function () {
            return "boxes must be a 2D tensor, but was of rank '" + e.rank + "'"
        }), nv(4 === e.shape[1], function () {
            return "boxes must have 4 columns, but 2nd dimension was " + e.shape[1]
        }), nv(1 === t.rank, function () {
            return "scores must be a 1D tensor"
        }), nv(t.shape[0] === o, function () {
            return "scores has incompatible shape with boxes. Expected " + o + ", but was " + t.shape[0]
        }), nv(0 <= i && i <= 1, function () {
            return "softNmsSigma must be in [0, 1], but was '" + i + "'"
        }), {
            maxOutputSize: n,
            iouThreshold: r,
            scoreThreshold: a,
            softNmsSigma: i
        }
    }
    var _I = $g({
        nonMaxSuppression_: function (e, t, n, r, a) {
            void 0 === r && (r = .5), void 0 === a && (a = Number.NEGATIVE_INFINITY);
            var i = Zg(e, "boxes", "nonMaxSuppression"),
                o = Zg(t, "scores", "nonMaxSuppression"),
                s = FI(i, o, n, r, a),
                u = {
                    maxOutputSize: n = s.maxOutputSize,
                    iouThreshold: r = s.iouThreshold,
                    scoreThreshold: a = s.scoreThreshold
                };
            return Gg.runKernel("NonMaxSuppressionV3", {
                boxes: i,
                scores: o
            }, u)
        }
    });

    function DI(e, t, n) {
        var r = function (e, t, n) {
                return function (e, t, n) {
                    for (var r = 0, a = e.length, i = 0, o = !1; r < a;) {
                        var s = n(t, e[i = r + (a - r >>> 1)]);
                        s > 0 ? r = i + 1 : (a = i, o = !s)
                    }
                    return o ? r : -r - 1
                }(e, t, n || OI)
            }(e, t, n),
            a = r < 0 ? -(r + 1) : r;
        e.splice(a, 0, t)
    }

    function OI(e, t) {
        return e > t ? 1 : e < t ? -1 : 0
    }

    function MI(e, t, n, r, a) {
        return PI(e, t, n, r, a, 0)
    }

    function LI(e, t, n, r, a, i) {
        return PI(e, t, n, r, a, 0, !1, i, !0)
    }

    function zI(e, t, n, r, a, i) {
        return PI(e, t, n, r, a, i, !0)
    }

    function PI(e, t, n, r, a, i, o, s, u) {
        void 0 === o && (o = !1), void 0 === s && (s = !1), void 0 === u && (u = !1);
        for (var l = [], c = 0; c < t.length; c++) t[c] > a && l.push({
            score: t[c],
            boxIndex: c,
            suppressBeginIndex: 0
        });
        l.sort(VI);
        for (var p = i > 0 ? -.5 / i : 0, h = [], f = []; h.length < n && l.length > 0;) {
            var d = l.pop(),
                m = d.score,
                v = d.boxIndex,
                g = d.suppressBeginIndex;
            if (m < a) break;
            for (var y = !1, b = h.length - 1; b >= g; --b) {
                var x = BI(e, v, h[b]);
                if (x >= r) {
                    y = !0;
                    break
                }
                if (d.score = d.score * WI(r, p, x), d.score <= a) break
            }
            d.suppressBeginIndex = h.length, y || (d.score === m ? (h.push(v), f.push(d.score)) : d.score > a && DI(l, d, VI))
        }
        var w = h.length,
            k = n - w;
        s && k > 0 && (h.push.apply(h, new Array(k).fill(0)), f.push.apply(f, new Array(k).fill(0)));
        var N = {
            selectedIndices: h
        };
        return o && (N.selectedScores = f), u && (N.validOutputs = w), N
    }

    function BI(e, t, n) {
        var r = e.subarray(4 * t, 4 * t + 4),
            a = e.subarray(4 * n, 4 * n + 4),
            i = Math.min(r[0], r[2]),
            o = Math.min(r[1], r[3]),
            s = Math.max(r[0], r[2]),
            u = Math.max(r[1], r[3]),
            l = Math.min(a[0], a[2]),
            c = Math.min(a[1], a[3]),
            p = Math.max(a[0], a[2]),
            h = Math.max(a[1], a[3]),
            f = (s - i) * (u - o),
            d = (p - l) * (h - c);
        if (f <= 0 || d <= 0) return 0;
        var m = Math.max(i, l),
            v = Math.max(o, c),
            g = Math.min(s, p),
            y = Math.min(u, h),
            b = Math.max(g - m, 0) * Math.max(y - v, 0);
        return b / (f + d - b)
    }

    function WI(e, t, n) {
        var r = Math.exp(t * n * n);
        return n <= e ? r : 0
    }

    function VI(e, t) {
        return e.score - t.score || e.score === t.score && t.boxIndex - e.boxIndex
    }

    function UI() {
        return (UI = Pm(regeneratorRuntime.mark(function e(t, n, r, a, i) {
            var o, s, u, l, c, p, h, f;
            return regeneratorRuntime.wrap(function (e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return void 0 === a && (a = .5), void 0 === i && (i = Number.NEGATIVE_INFINITY), o = Zg(t, "boxes", "nonMaxSuppressionAsync"), s = Zg(n, "scores", "nonMaxSuppressionAsync"), u = FI(o, s, r, a, i), r = u.maxOutputSize, a = u.iouThreshold, i = u.scoreThreshold, e.next = 10, Promise.all([o.data(), s.data()]);
                    case 10:
                        return l = e.sent, c = l[0], p = l[1], h = MI(c, p, r, a, i), f = h.selectedIndices, o !== t && o.dispose(), s !== n && s.dispose(), e.abrupt("return", qN(f, "int32"));
                    case 17:
                    case "end":
                        return e.stop()
                }
            }, e)
        }))).apply(this, arguments)
    }
    var GI = $g({
        nonMaxSuppressionWithScore_: function (e, t, n, r, a, i) {
            void 0 === r && (r = .5), void 0 === a && (a = Number.NEGATIVE_INFINITY), void 0 === i && (i = 0);
            var o = Zg(e, "boxes", "nonMaxSuppression"),
                s = Zg(t, "scores", "nonMaxSuppression"),
                u = FI(o, s, n, r, a, i),
                l = {
                    boxes: o,
                    scores: s
                },
                c = {
                    maxOutputSize: n = u.maxOutputSize,
                    iouThreshold: r = u.iouThreshold,
                    scoreThreshold: a = u.scoreThreshold,
                    softNmsSigma: i = u.softNmsSigma
                },
                p = Gg.runKernel("NonMaxSuppressionV5", l, c);
            return {
                selectedIndices: p[0],
                selectedScores: p[1]
            }
        }
    });

    function jI() {
        return (jI = Pm(regeneratorRuntime.mark(function e(t, n, r, a, i, o) {
            var s, u, l, c, p, h, f, d, m;
            return regeneratorRuntime.wrap(function (e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return void 0 === a && (a = .5), void 0 === i && (i = Number.NEGATIVE_INFINITY), void 0 === o && (o = 0), s = Zg(t, "boxes", "nonMaxSuppressionAsync"), u = Zg(n, "scores", "nonMaxSuppressionAsync"), l = FI(s, u, r, a, i, o), r = l.maxOutputSize, a = l.iouThreshold, i = l.scoreThreshold, o = l.softNmsSigma, e.next = 12, Promise.all([s.data(), u.data()]);
                    case 12:
                        return c = e.sent, p = c[0], h = c[1], f = zI(p, h, r, a, i, o), d = f.selectedIndices, m = f.selectedScores, s !== t && s.dispose(), u !== n && u.dispose(), e.abrupt("return", {
                            selectedIndices: qN(d, "int32"),
                            selectedScores: qN(m)
                        });
                    case 19:
                    case "end":
                        return e.stop()
                }
            }, e)
        }))).apply(this, arguments)
    }
    var HI = $g({
        nonMaxSuppressionPadded_: function (e, t, n, r, a, i) {
            void 0 === r && (r = .5), void 0 === a && (a = Number.NEGATIVE_INFINITY), void 0 === i && (i = !1);
            var o = Zg(e, "boxes", "nonMaxSuppression"),
                s = Zg(t, "scores", "nonMaxSuppression"),
                u = FI(o, s, n, r, a, null),
                l = {
                    boxes: o,
                    scores: s
                },
                c = {
                    maxOutputSize: u.maxOutputSize,
                    iouThreshold: u.iouThreshold,
                    scoreThreshold: u.scoreThreshold,
                    padToMaxOutputSize: i
                },
                p = Gg.runKernel("NonMaxSuppressionV4", l, c);
            return {
                selectedIndices: p[0],
                validOutputs: p[1]
            }
        }
    });

    function qI() {
        return (qI = Pm(regeneratorRuntime.mark(function e(t, n, r, a, i, o) {
            var s, u, l, c, p, h, f, d, m, v, g, y;
            return regeneratorRuntime.wrap(function (e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return void 0 === a && (a = .5), void 0 === i && (i = Number.NEGATIVE_INFINITY), void 0 === o && (o = !1), s = Zg(t, "boxes", "nonMaxSuppressionAsync"), u = Zg(n, "scores", "nonMaxSuppressionAsync"), l = FI(s, u, r, a, i, null), c = l.maxOutputSize, p = l.iouThreshold, h = l.scoreThreshold, e.next = 11, Promise.all([s.data(), u.data()]);
                    case 11:
                        return f = e.sent, d = f[0], m = f[1], v = LI(d, m, c, p, h, o), g = v.selectedIndices, y = v.validOutputs, s !== t && s.dispose(), u !== n && u.dispose(), e.abrupt("return", {
                            selectedIndices: qN(g, "int32"),
                            validOutputs: wN(y, "int32")
                        });
                    case 18:
                    case "end":
                        return e.stop()
                }
            }, e)
        }))).apply(this, arguments)
    }
    var KI = $g({
            resizeBilinear_: function (e, t, n, r) {
                void 0 === n && (n = !1), void 0 === r && (r = !1);
                var a = Zg(e, "images", "resizeBilinear");
                nv(3 === a.rank || 4 === a.rank, function () {
                    return "Error in resizeBilinear: x must be rank 3 or 4, but got rank " + a.rank + "."
                }), nv(2 === t.length, function () {
                    return "Error in resizeBilinear: new shape must 2D, but got shape " + t + "."
                }), nv(!1 === r || !1 === n, function () {
                    return "Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."
                });
                var i = a,
                    o = !1;
                3 === a.rank && (o = !0, i = Px(a, [1, a.shape[0], a.shape[1], a.shape[2]]));
                var s = {
                        images: i
                    },
                    u = {
                        alignCorners: n,
                        halfPixelCenters: r,
                        size: t
                    },
                    l = Gg.runKernel("ResizeBilinear", s, u);
                return o ? Px(l, [l.shape[1], l.shape[2], l.shape[3]]) : l
            }
        }),
        XI = $g({
            resizeNearestNeighbor_: function (e, t, n, r) {
                void 0 === n && (n = !1), void 0 === r && (r = !1);
                var a = Zg(e, "images", "resizeNearestNeighbor");
                nv(3 === a.rank || 4 === a.rank, function () {
                    return "Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank " + a.rank + "."
                }), nv(2 === t.length, function () {
                    return "Error in resizeNearestNeighbor: new shape must 2D, but got shape " + t + "."
                }), nv("float32" === a.dtype || "int32" === a.dtype, function () {
                    return "`images` must have `int32` or `float32` as dtype"
                }), nv(!1 === r || !1 === n, function () {
                    return "Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."
                });
                var i = a,
                    o = !1;
                3 === a.rank && (o = !0, i = Px(a, [1, a.shape[0], a.shape[1], a.shape[2]]));
                var s = {
                        images: i
                    },
                    u = {
                        alignCorners: n,
                        halfPixelCenters: r,
                        size: t
                    },
                    l = Gg.runKernel("ResizeNearestNeighbor", s, u);
                return o ? Px(l, [l.shape[1], l.shape[2], l.shape[3]]) : l
            }
        }),
        YI = $g({
            transform_: function (e, t, n, r, a, i) {
                void 0 === n && (n = "nearest"), void 0 === r && (r = "constant"), void 0 === a && (a = 0);
                var o = Zg(e, "image", "transform", "float32"),
                    s = Zg(t, "transforms", "transform", "float32");
                nv(4 === o.rank, function () {
                    return "Error in transform: image must be rank 4,but got rank " + o.rank + "."
                }), nv(2 === s.rank && (s.shape[0] === o.shape[0] || 1 === s.shape[0]) && 8 === s.shape[1], function () {
                    return "Error in transform: Input transform should be batch x 8 or 1 x 8"
                }), nv(null == i || 2 === i.length, function () {
                    return "Error in transform: outputShape must be [height, width] or null, but got " + i + "."
                });
                var u = {
                        image: o,
                        transforms: s
                    },
                    l = {
                        interpolation: n,
                        fillMode: r,
                        fillValue: a,
                        outputShape: i
                    };
                return Gg.runKernel("Transform", u, l)
            }
        }),
        JI = $g({
            bandPart_: function (e, t, n) {
                nv(t % 1 == 0, function () {
                    return "bandPart(): numLower must be an integer, got " + t + "."
                }), nv(n % 1 == 0, function () {
                    return "bandPart(): numUpper must be an integer, got " + n + "."
                });
                var r = Zg(e, "a", "bandPart");
                nv(r.rank >= 2, function () {
                    return "bandPart(): Rank must be at least 2, got " + r.rank + "."
                });
                var a = r.shape,
                    i = r.shape.slice(-2),
                    o = i[0],
                    s = i[1];
                if (!(t <= o)) throw new Error("bandPart(): numLower (" + t + ") must not be greater than the number of rows (" + o + ").");
                if (!(n <= s)) throw new Error("bandPart(): numUpper (" + n + ") must not be greater than the number of columns (" + s + ").");
                t < 0 && (t = o), n < 0 && (n = s);
                var u = Px(lN(0, o, 1, "int32"), [-1, 1]),
                    l = lN(0, s, 1, "int32"),
                    c = ak(u, l),
                    p = vk(qw(c, wN(+t, "int32")), Bw(c, wN(-n, "int32"))),
                    h = Ok([o, s], r.dtype);
                return Px(UN(QN(Px(r, [-1, o, s])).map(function (e) {
                    return Iw(p, e, h)
                })), a)
            }
        }),
        ZI = $g({
            gramSchmidt_: function (e) {
                var t;
                Array.isArray(e) ? function () {
                    t = !1, nv(null != e && e.length > 0, function () {
                        return "Gram-Schmidt process: input must not be null, undefined, or empty"
                    });
                    for (var n = e[0].shape[0], r = function (t) {
                            nv(e[t].shape[0] === n, function () {
                                return "Gram-Schmidt: Non-unique lengths found in the input vectors: (" + e[t].shape[0] + " vs. " + n + ")"
                            })
                        }, a = 1; a < e.length; ++a) r(a)
                }() : (t = !0, e = zN(e, e.shape[0], 0).map(function (e) {
                    return VN(e, [0])
                })), nv(e.length <= e[0].shape[0], function () {
                    return "Gram-Schmidt: Number of vectors (" + e.length + ") exceeds number of dimensions (" + e[0].shape[0] + ")."
                });
                for (var n = [], r = e, a = function (e) {
                        n.push(Gg.tidy(function () {
                            var t = r[e];
                            if (e > 0)
                                for (var a = 0; a < e; ++a) {
                                    var i = px(ik(px(n[a], t)), n[a]);
                                    t = ak(t, i)
                                }
                            return cx(t, aI(t, "euclidean"))
                        }))
                    }, i = 0; i < e.length; ++i) a(i);
                return t ? UN(n, 0) : n
            }
        });

    function QI(e, t) {
        return void 0 === t && (t = !1), Gg.tidy(function () {
            nv(2 === e.shape.length, function () {
                return "qr2d() requires a 2D Tensor, but got a " + e.shape.length + "D Tensor."
            });
            for (var n = e.shape[0], r = e.shape[1], a = Ow(n), i = Xy(e), o = KN([
                    [1]
                ], [1, 1]), s = Xy(o), u = n >= r ? r : n, l = function (e) {
                    var t = i,
                        u = s,
                        l = a,
                        c = Gg.tidy(function () {
                            var t = Gx(i, [e, e], [n - e, 1]),
                                u = aI(t),
                                l = Gx(i, [e, e], [1, 1]),
                                c = Iw(Pw(l, 0), KN([
                                    [-1]
                                ]), KN([
                                    [1]
                                ])),
                                p = ak(l, px(c, u)),
                                h = cx(t, p);
                            s = 1 === h.shape[0] ? Xy(o) : Vx([o, Gx(h, [1, 0], [h.shape[0] - 1, h.shape[1]])], 0);
                            var f = ek(cx(fb(c, p), u)),
                                d = Gx(i, [e, 0], [n - e, r]),
                                m = px(f, s),
                                v = mb(s);
                            if (0 === e) i = ak(d, fb(m, fb(v, d)));
                            else {
                                var g = ak(d, fb(m, fb(v, d)));
                                i = Vx([Gx(i, [0, 0], [e, r]), g], 0)
                            }
                            var y = mb(m),
                                b = Gx(a, [0, e], [n, a.shape[1] - e]);
                            if (0 === e) a = ak(b, fb(fb(b, s), y));
                            else {
                                var x = ak(b, fb(fb(b, s), y));
                                a = Vx([Gx(a, [0, 0], [n, e]), x], 1)
                            }
                            return [s, i, a]
                        });
                    s = c[0], i = c[1], a = c[2], ax([t, u, l])
                }, c = 0; c < u; ++c) l(c);
            return !t && n > r && (a = Gx(a, [0, 0], [n, r]), i = Gx(i, [0, 0], [r, r])), [a, i]
        })
    }
    var $I, eS = $g({
        qr_: function (e, t) {
            if (void 0 === t && (t = !1), nv(e.rank >= 2, function () {
                    return "qr() requires input tensor to have a rank >= 2, but got rank " + e.rank
                }), 2 === e.rank) return QI(e, t);
            var n = e.shape.slice(0, e.shape.length - 2).reduce(function (e, t) {
                    return e * t
                }),
                r = QN(Px(e, [n, e.shape[e.shape.length - 2], e.shape[e.shape.length - 1]]), 0),
                a = [],
                i = [];
            return r.forEach(function (e) {
                var n = QI(e, t),
                    r = n[0],
                    o = n[1];
                a.push(r), i.push(o)
            }), [Px(UN(a, 0), e.shape), Px(UN(i, 0), e.shape)]
        }
    });
    ($I = e.Reduction || (e.Reduction = {}))[$I.NONE = 0] = "NONE", $I[$I.MEAN = 1] = "MEAN", $I[$I.SUM = 2] = "SUM", $I[$I.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS";
    var tS = $g({
            computeWeightedLoss_: function (t, n, r) {
                void 0 === r && (r = e.Reduction.SUM_BY_NONZERO_WEIGHTS);
                var a = Zg(t, "losses", "computeWeightedLoss"),
                    i = null;
                null != n && (i = Zg(n, "weights", "computeWeightedLoss"));
                var o = null == i ? a : px(a, i);
                if (r === e.Reduction.NONE) return o;
                if (r === e.Reduction.SUM) return ik(o);
                if (r === e.Reduction.MEAN) {
                    if (null == i) return Ik(o);
                    var s = a.size / i.size,
                        u = cx(ik(o), ik(i));
                    return s > 1 ? cx(u, wN(s)) : u
                }
                if (r === e.Reduction.SUM_BY_NONZERO_WEIGHTS) {
                    if (null == i) return cx(ik(o), wN(a.size));
                    var l = px(i, Mk(a.shape)),
                        c = Ky(ik(Dk(l, wN(0))), "float32");
                    return cx(ik(o), c)
                }
                throw Error("Unknown reduction: " + r)
            }
        }),
        nS = $g({
            absoluteDifference_: function (t, n, r, a) {
                void 0 === a && (a = e.Reduction.SUM_BY_NONZERO_WEIGHTS);
                var i = Zg(t, "labels", "absoluteDifference"),
                    o = Zg(n, "predictions", "absoluteDifference"),
                    s = null;
                null != r && (s = Zg(r, "weights", "absoluteDifference")), rv(i.shape, o.shape, "Error in absoluteDifference: ");
                var u = hx(ak(i, o));
                return tS(u, s, a)
            }
        }),
        rS = $g({
            cosineDistance_: function (t, n, r, a, i) {
                void 0 === i && (i = e.Reduction.SUM_BY_NONZERO_WEIGHTS);
                var o = Zg(t, "labels", "cosineDistance"),
                    s = Zg(n, "predictions", "cosineDistance"),
                    u = null;
                null != a && (u = Zg(a, "weights", "cosineDistance")), rv(o.shape, s.shape, "Error in cosineDistance: ");
                var l = wN(1),
                    c = ak(l, ik(px(o, s), r, !0));
                return tS(c, u, i)
            }
        }),
        aS = $g({
            hingeLoss_: function (t, n, r, a) {
                void 0 === a && (a = e.Reduction.SUM_BY_NONZERO_WEIGHTS);
                var i = Zg(t, "labels", "hingeLoss"),
                    o = Zg(n, "predictions", "hingeLoss"),
                    s = null;
                null != r && (s = Zg(r, "weights", "hingeLoss")), rv(i.shape, o.shape, "Error in hingeLoss: ");
                var u = wN(1);
                i = ak(px(wN(2), i), u);
                var l = hN(ak(u, px(i, o)));
                return tS(l, s, a)
            }
        }),
        iS = $g({
            huberLoss_: function (t, n, r, a, i) {
                void 0 === a && (a = 1), void 0 === i && (i = e.Reduction.SUM_BY_NONZERO_WEIGHTS);
                var o = Zg(t, "labels", "huberLoss"),
                    s = Zg(n, "predictions", "huberLoss"),
                    u = null;
                null != r && (u = Zg(r, "weights", "huberLoss")), rv(o.shape, s.shape, "Error in huberLoss: ");
                var l = wN(a),
                    c = hx(ak(s, o)),
                    p = Tk(c, l),
                    h = ak(c, p),
                    f = ux(px(wN(.5), Rk(p)), px(l, h));
                return tS(f, u, i)
            }
        }),
        oS = $g({
            logLoss_: function (t, n, r, a, i) {
                void 0 === a && (a = 1e-7), void 0 === i && (i = e.Reduction.SUM_BY_NONZERO_WEIGHTS);
                var o = Zg(t, "labels", "logLoss"),
                    s = Zg(n, "predictions", "logLoss"),
                    u = null;
                null != r && (u = Zg(r, "weights", "logLoss")), rv(o.shape, s.shape, "Error in logLoss: ");
                var l = wN(1),
                    c = wN(a),
                    p = ek(px(o, Yw(ux(s, c)))),
                    h = px(ak(l, o), Yw(ux(ak(l, s), c))),
                    f = ak(p, h);
                return tS(f, u, i)
            }
        }),
        sS = $g({
            meanSquaredError_: function (t, n, r, a) {
                void 0 === a && (a = e.Reduction.SUM_BY_NONZERO_WEIGHTS);
                var i = Zg(t, "labels", "meanSquaredError"),
                    o = Zg(n, "predictions", "meanSquaredError"),
                    s = null;
                null != r && (s = Zg(r, "weights", "meanSquaredError")), rv(i.shape, o.shape, "Error in meanSquaredError: ");
                var u = WN(i, o);
                return tS(u, s, a)
            }
        }),
        uS = $g({
            sigmoidCrossEntropy_: function (t, n, r, a, i) {
                void 0 === a && (a = 0), void 0 === i && (i = e.Reduction.SUM_BY_NONZERO_WEIGHTS);
                var o = Zg(t, "multiClassLabels", "sigmoidCrossEntropy"),
                    s = Zg(n, "logits", "sigmoidCrossEntropy"),
                    u = null;
                if (null != r && (u = Zg(r, "weights", "sigmoidCrossEntropy")), rv(o.shape, s.shape, "Error in sigmoidCrossEntropy: "), a > 0) {
                    var l = wN(a),
                        c = wN(1),
                        p = wN(.5);
                    o = ux(px(o, ak(c, l)), px(p, l))
                }
                var h = function (e, t) {
                    var n = Zg(e, "labels", "sigmoidCrossEntropyWithLogits"),
                        r = Zg(t, "logits", "sigmoidCrossEntropyWithLogits");
                    rv(n.shape, r.shape, "Error in sigmoidCrossEntropyWithLogits: ");
                    var a = hN(r),
                        i = px(r, n),
                        o = Jw(Aw(ek(hx(r))));
                    return ux(ak(a, i), o)
                }(o, s);
                return tS(h, u, i)
            }
        }),
        lS = $g({
            softmaxCrossEntropy_: function (t, n, r, a, i) {
                void 0 === a && (a = 0), void 0 === i && (i = e.Reduction.SUM_BY_NONZERO_WEIGHTS);
                var o = Zg(t, "onehotLabels", "softmaxCrossEntropy"),
                    s = Zg(n, "logits", "softmaxCrossEntropy"),
                    u = null;
                if (null != r && (u = Zg(r, "weights", "softmaxCrossEntropy")), rv(o.shape, s.shape, "Error in softmaxCrossEntropy: "), a > 0) {
                    var l = wN(a),
                        c = wN(1),
                        p = wN(o.shape[1]);
                    o = ux(px(o, ak(c, l)), cx(l, p))
                }
                var h = function (e, t, n) {
                    if (void 0 === n && (n = -1), -1 === n && (n = t.rank - 1), n !== t.rank - 1) throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank " + t.rank + " and dim was " + n);
                    return Qw(function (e, t, r) {
                        var a = mk(t, [n], !0),
                            i = ak(Ky(t, "float32"), a);
                        r([e, i]);
                        var o = ek(px(i, e));
                        return {
                            value: ik(o, [n]),
                            gradFunc: function (e, t) {
                                var r = t[0],
                                    a = t[1],
                                    i = ck(e.shape, [n]);
                                return [px(Px(e, i), ak(Ky(r, "float32"), Aw(a))), px(Px(e, i), ak(Aw(a), Ky(r, "float32")))]
                            }
                        }
                    })(e, t)
                }(o, s);
                return tS(h, u, i)
            }
        }),
        cS = {
            fft: ON,
            ifft: MN,
            rfft: PN,
            irfft: LN
        },
        pS = {
            hammingWindow: II,
            hannWindow: SI,
            frame: TI,
            stft: CI
        },
        hS = {
            flipLeftRight: RI,
            resizeNearestNeighbor: XI,
            resizeBilinear: KI,
            rotateWithOffset: AI,
            cropAndResize: EI,
            nonMaxSuppression: _I,
            nonMaxSuppressionAsync: function (e, t, n, r, a) {
                return UI.apply(this, arguments)
            },
            nonMaxSuppressionWithScore: GI,
            nonMaxSuppressionWithScoreAsync: function (e, t, n, r, a, i) {
                return jI.apply(this, arguments)
            },
            nonMaxSuppressionPadded: HI,
            nonMaxSuppressionPaddedAsync: function (e, t, n, r, a, i) {
                return qI.apply(this, arguments)
            },
            transform: YI
        },
        fS = {
            bandPart: JI,
            gramSchmidt: ZI,
            qr: eS
        },
        dS = {
            absoluteDifference: nS,
            computeWeightedLoss: tS,
            cosineDistance: rS,
            hingeLoss: aS,
            huberLoss: iS,
            logLoss: oS,
            meanSquaredError: sS,
            sigmoidCrossEntropy: uS,
            softmaxCrossEntropy: lS
        },
        mS = function (e) {
            function t() {
                return e.apply(this, arguments) || this
            }
            Vm(t, e);
            var n = t.prototype;
            return n.minimize = function (e, t, n) {
                void 0 === t && (t = !1);
                var r = this.computeGradients(e, n),
                    a = r.value,
                    i = r.grads;
                if (null != n) {
                    var o = n.map(function (e) {
                        return {
                            name: e.name,
                            tensor: i[e.name]
                        }
                    });
                    this.applyGradients(o)
                } else this.applyGradients(i);
                return ax(i), t ? a : (a.dispose(), null)
            }, n.incrementIterations = function () {
                this.iterations_ = this.iterations + 1
            }, n.computeGradients = function (e, t) {
                return Zw(e, t)
            }, n.dispose = function () {
                null != this.iterations_ && ax(this.iterations_)
            }, n.saveIterations = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return null == this.iterations_ && (this.iterations_ = 0), e.abrupt("return", {
                                    name: "iter",
                                    tensor: wN(this.iterations_, "int32")
                                });
                            case 2:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), n.getWeights = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                throw new Error("getWeights() is not implemented for this optimizer yet.");
                            case 1:
                            case "end":
                                return e.stop()
                        }
                    }, e)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), n.setWeights = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                throw new Error("setWeights() is not implemented for this optimizer class " + this.getClassName());
                            case 1:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), n.extractIterations = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, t[0].tensor.data();
                            case 2:
                                return this.iterations_ = e.sent[0], e.abrupt("return", t.slice(1));
                            case 4:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), Wm(t, [{
                key: "iterations",
                get: function () {
                    return null == this.iterations_ && (this.iterations_ = 0), this.iterations_
                }
            }]), t
        }(Kb);
    Object.defineProperty(mS, Symbol.hasInstance, {
        value: function (e) {
            return null != e.minimize && null != e.computeGradients && null != e.applyGradients
        }
    });
    var vS = function (e) {
        function t(t, n, r) {
            var a;
            return void 0 === r && (r = null), (a = e.call(this) || this).learningRate = t, a.rho = n, a.epsilon = r, a.accumulatedGrads = [], a.accumulatedUpdates = [], null == r && (a.epsilon = Gg.backend.epsilon()), a
        }
        Vm(t, e);
        var n = t.prototype;
        return n.applyGradients = function (e) {
            var t = this;
            (Array.isArray(e) ? e.map(function (e) {
                return e.name
            }) : Object.keys(e)).forEach(function (n, r) {
                var a = Gg.registeredVariables[n];
                null == t.accumulatedGrads[r] && (t.accumulatedGrads[r] = {
                    originalName: n + "/accum_grad",
                    variable: rx(function () {
                        return Sw(a).variable(!1)
                    })
                }), null == t.accumulatedUpdates[r] && (t.accumulatedUpdates[r] = {
                    originalName: n + "/accum_var",
                    variable: rx(function () {
                        return Sw(a).variable(!1)
                    })
                });
                var i = Array.isArray(e) ? e[r].tensor : e[n];
                if (null != i) {
                    var o = t.accumulatedGrads[r].variable,
                        s = t.accumulatedUpdates[r].variable;
                    rx(function () {
                        var e = ux(px(o, t.rho), px(Rk(i), 1 - t.rho)),
                            n = px(cx(BN(ux(s, t.epsilon)), BN(ux(o, t.epsilon))), i),
                            r = ux(px(s, t.rho), px(Rk(n), 1 - t.rho));
                        o.assign(e), s.assign(r);
                        var u = ux(px(n, -t.learningRate), a);
                        a.assign(u)
                    })
                }
            }), this.incrementIterations()
        }, n.dispose = function () {
            null != this.accumulatedUpdates && (ax(this.accumulatedGrads.map(function (e) {
                return e.variable
            })), ax(this.accumulatedUpdates.map(function (e) {
                return e.variable
            })))
        }, n.getWeights = function () {
            var e = Pm(regeneratorRuntime.mark(function e() {
                var t;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return t = [].concat(this.accumulatedGrads, this.accumulatedUpdates), e.next = 3, this.saveIterations();
                        case 3:
                            return e.t0 = e.sent, e.abrupt("return", [e.t0].concat(t.map(function (e) {
                                return {
                                    name: e.originalName,
                                    tensor: e.variable
                                }
                            })));
                        case 5:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function () {
                return e.apply(this, arguments)
            }
        }(), n.setWeights = function () {
            var e = Pm(regeneratorRuntime.mark(function e(t) {
                var n;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return e.next = 2, this.extractIterations(t);
                        case 2:
                            t = e.sent, n = t.length / 2, this.accumulatedGrads = t.slice(0, n).map(function (e) {
                                return {
                                    originalName: e.name,
                                    variable: e.tensor.variable(!1)
                                }
                            }), this.accumulatedUpdates = t.slice(n, 2 * n).map(function (e) {
                                return {
                                    originalName: e.name,
                                    variable: e.tensor.variable(!1)
                                }
                            });
                        case 7:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function (t) {
                return e.apply(this, arguments)
            }
        }(), n.getConfig = function () {
            return {
                learningRate: this.learningRate,
                rho: this.rho,
                epsilon: this.epsilon
            }
        }, t.fromConfig = function (e, t) {
            return new e(t.learningRate, t.rho, t.epsilon)
        }, t
    }(mS);
    vS.className = "Adadelta", Yb(vS);
    var gS = function (e) {
        function t(t, n) {
            var r;
            return void 0 === n && (n = .1), (r = e.call(this) || this).learningRate = t, r.initialAccumulatorValue = n, r.accumulatedGrads = [], r
        }
        Vm(t, e);
        var n = t.prototype;
        return n.applyGradients = function (e) {
            var t = this;
            (Array.isArray(e) ? e.map(function (e) {
                return e.name
            }) : Object.keys(e)).forEach(function (n, r) {
                var a = Gg.registeredVariables[n];
                null == t.accumulatedGrads[r] && (t.accumulatedGrads[r] = {
                    originalName: n + "/accumulator",
                    variable: rx(function () {
                        return Mw(a.shape, t.initialAccumulatorValue).variable(!1)
                    })
                });
                var i = Array.isArray(e) ? e[r].tensor : e[n];
                if (null != i) {
                    var o = t.accumulatedGrads[r].variable;
                    rx(function () {
                        var e = ux(o, Rk(i));
                        o.assign(e);
                        var n = ux(px(cx(i, BN(ux(e, Gg.backend.epsilon()))), -t.learningRate), a);
                        a.assign(n)
                    })
                }
            }), this.incrementIterations()
        }, n.dispose = function () {
            null != this.accumulatedGrads && ax(this.accumulatedGrads.map(function (e) {
                return e.variable
            }))
        }, n.getWeights = function () {
            var e = Pm(regeneratorRuntime.mark(function e() {
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return e.next = 2, this.saveIterations();
                        case 2:
                            return e.t0 = e.sent, e.abrupt("return", [e.t0].concat(this.accumulatedGrads.map(function (e) {
                                return {
                                    name: e.originalName,
                                    tensor: e.variable
                                }
                            })));
                        case 4:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function () {
                return e.apply(this, arguments)
            }
        }(), n.setWeights = function () {
            var e = Pm(regeneratorRuntime.mark(function e(t) {
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return e.next = 2, this.extractIterations(t);
                        case 2:
                            t = e.sent, this.accumulatedGrads = t.map(function (e) {
                                return {
                                    originalName: e.name,
                                    variable: e.tensor.variable(!1)
                                }
                            });
                        case 5:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function (t) {
                return e.apply(this, arguments)
            }
        }(), n.getConfig = function () {
            return {
                learningRate: this.learningRate,
                initialAccumulatorValue: this.initialAccumulatorValue
            }
        }, t.fromConfig = function (e, t) {
            return new e(t.learningRate, t.initialAccumulatorValue)
        }, t
    }(mS);
    gS.className = "Adagrad", Yb(gS);
    var yS = function (e) {
        function t(t, n, r, a) {
            var i;
            return void 0 === a && (a = null), (i = e.call(this) || this).learningRate = t, i.beta1 = n, i.beta2 = r, i.epsilon = a, i.accumulatedFirstMoment = [], i.accumulatedSecondMoment = [], rx(function () {
                i.accBeta1 = wN(n).variable(), i.accBeta2 = wN(r).variable()
            }), null == a && (i.epsilon = Gg.backend.epsilon()), i
        }
        Vm(t, e);
        var n = t.prototype;
        return n.applyGradients = function (e) {
            var t = this,
                n = Array.isArray(e) ? e.map(function (e) {
                    return e.name
                }) : Object.keys(e);
            rx(function () {
                var r = ak(1, t.accBeta1),
                    a = ak(1, t.accBeta2);
                n.forEach(function (n, i) {
                    var o = Gg.registeredVariables[n];
                    null == t.accumulatedFirstMoment[i] && (t.accumulatedFirstMoment[i] = {
                        originalName: n + "/m",
                        variable: rx(function () {
                            return Sw(o).variable(!1)
                        })
                    }), null == t.accumulatedSecondMoment[i] && (t.accumulatedSecondMoment[i] = {
                        originalName: n + "/v",
                        variable: rx(function () {
                            return Sw(o).variable(!1)
                        })
                    });
                    var s = Array.isArray(e) ? e[i].tensor : e[n];
                    if (null != s) {
                        var u = t.accumulatedFirstMoment[i].variable,
                            l = t.accumulatedSecondMoment[i].variable,
                            c = ux(px(u, t.beta1), px(s, 1 - t.beta1)),
                            p = ux(px(l, t.beta2), px(Rk(s), 1 - t.beta2)),
                            h = cx(c, r),
                            f = cx(p, a);
                        u.assign(c), l.assign(p);
                        var d = ux(px(cx(h, ux(BN(f), t.epsilon)), -t.learningRate), o);
                        o.assign(d)
                    }
                }), t.accBeta1.assign(px(t.accBeta1, t.beta1)), t.accBeta2.assign(px(t.accBeta2, t.beta2))
            }), this.incrementIterations()
        }, n.dispose = function () {
            this.accBeta1.dispose(), this.accBeta2.dispose(), null != this.accumulatedFirstMoment && ax(this.accumulatedFirstMoment.map(function (e) {
                return e.variable
            })), null != this.accumulatedSecondMoment && ax(this.accumulatedSecondMoment.map(function (e) {
                return e.variable
            }))
        }, n.getWeights = function () {
            var e = Pm(regeneratorRuntime.mark(function e() {
                var t;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return t = [].concat(this.accumulatedFirstMoment, this.accumulatedSecondMoment), e.next = 3, this.saveIterations();
                        case 3:
                            return e.t0 = e.sent, e.abrupt("return", [e.t0].concat(t.map(function (e) {
                                return {
                                    name: e.originalName,
                                    tensor: e.variable
                                }
                            })));
                        case 5:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function () {
                return e.apply(this, arguments)
            }
        }(), n.setWeights = function () {
            var e = Pm(regeneratorRuntime.mark(function e(t) {
                var n, r = this;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return e.next = 2, this.extractIterations(t);
                        case 2:
                            t = e.sent, rx(function () {
                                r.accBeta1.assign(Hk(r.beta1, r.iterations_ + 1)), r.accBeta2.assign(Hk(r.beta2, r.iterations_ + 1))
                            }), n = t.length / 2, this.accumulatedFirstMoment = t.slice(0, n).map(function (e) {
                                return {
                                    originalName: e.name,
                                    variable: e.tensor.variable(!1)
                                }
                            }), this.accumulatedSecondMoment = t.slice(n, 2 * n).map(function (e) {
                                return {
                                    originalName: e.name,
                                    variable: e.tensor.variable(!1)
                                }
                            });
                        case 8:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function (t) {
                return e.apply(this, arguments)
            }
        }(), n.getConfig = function () {
            return {
                learningRate: this.learningRate,
                beta1: this.beta1,
                beta2: this.beta2,
                epsilon: this.epsilon
            }
        }, t.fromConfig = function (e, t) {
            return new e(t.learningRate, t.beta1, t.beta2, t.epsilon)
        }, t
    }(mS);
    yS.className = "Adam", Yb(yS);
    var bS = function (e) {
        function t(t, n, r, a, i) {
            var o;
            return void 0 === a && (a = null), void 0 === i && (i = 0), (o = e.call(this) || this).learningRate = t, o.beta1 = n, o.beta2 = r, o.epsilon = a, o.decay = i, o.accumulatedFirstMoment = [], o.accumulatedWeightedInfNorm = [], rx(function () {
                o.iteration = wN(0).variable(), o.accBeta1 = wN(n).variable()
            }), null == a && (o.epsilon = Gg.backend.epsilon()), o
        }
        Vm(t, e);
        var n = t.prototype;
        return n.applyGradients = function (e) {
            var t = this,
                n = Array.isArray(e) ? e.map(function (e) {
                    return e.name
                }) : Object.keys(e);
            rx(function () {
                var r = ak(1, t.accBeta1),
                    a = cx(-t.learningRate, ux(px(t.iteration, t.decay), 1));
                n.forEach(function (n, i) {
                    var o = Gg.registeredVariables[n];
                    null == t.accumulatedFirstMoment[i] && (t.accumulatedFirstMoment[i] = {
                        originalName: n + "/m",
                        variable: Sw(o).variable(!1)
                    }), null == t.accumulatedWeightedInfNorm[i] && (t.accumulatedWeightedInfNorm[i] = {
                        originalName: n + "/v",
                        variable: Sw(o).variable(!1)
                    });
                    var s = Array.isArray(e) ? e[i].tensor : e[n];
                    if (null != s) {
                        var u = t.accumulatedFirstMoment[i].variable,
                            l = t.accumulatedWeightedInfNorm[i].variable,
                            c = ux(px(u, t.beta1), px(s, 1 - t.beta1)),
                            p = px(l, t.beta2),
                            h = hx(s),
                            f = Nk(p, h);
                        u.assign(c), l.assign(f);
                        var d = ux(px(cx(a, r), cx(c, ux(f, t.epsilon))), o);
                        o.assign(d)
                    }
                }), t.iteration.assign(ux(t.iteration, 1)), t.accBeta1.assign(px(t.accBeta1, t.beta1))
            }), this.incrementIterations()
        }, n.dispose = function () {
            this.accBeta1.dispose(), this.iteration.dispose(), null != this.accumulatedFirstMoment && ax(this.accumulatedFirstMoment.map(function (e) {
                return e.variable
            })), null != this.accumulatedWeightedInfNorm && ax(this.accumulatedWeightedInfNorm.map(function (e) {
                return e.variable
            }))
        }, n.getWeights = function () {
            var e = Pm(regeneratorRuntime.mark(function e() {
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            throw new Error("getWeights() is not implemented for Adamax yet.");
                        case 1:
                        case "end":
                            return e.stop()
                    }
                }, e)
            }));
            return function () {
                return e.apply(this, arguments)
            }
        }(), n.setWeights = function () {
            var e = Pm(regeneratorRuntime.mark(function e(t) {
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            throw new Error("setWeights() is not implemented for Adamax yet.");
                        case 1:
                        case "end":
                            return e.stop()
                    }
                }, e)
            }));
            return function (t) {
                return e.apply(this, arguments)
            }
        }(), n.getConfig = function () {
            return {
                learningRate: this.learningRate,
                beta1: this.beta1,
                beta2: this.beta2,
                epsilon: this.epsilon,
                decay: this.decay
            }
        }, t.fromConfig = function (e, t) {
            return new e(t.learningRate, t.beta1, t.beta2, t.epsilon, t.decay)
        }, t
    }(mS);
    bS.className = "Adamax", Yb(bS);
    var xS = function (e) {
        function t(t) {
            var n;
            return (n = e.call(this) || this).learningRate = t, n.setLearningRate(t), n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.applyGradients = function (e) {
            var t = this;
            (Array.isArray(e) ? e.map(function (e) {
                return e.name
            }) : Object.keys(e)).forEach(function (n, r) {
                var a = Array.isArray(e) ? e[r].tensor : e[n];
                if (null != a) {
                    var i = Gg.registeredVariables[n];
                    rx(function () {
                        var e = ux(px(t.c, a), i);
                        i.assign(e)
                    })
                }
            }), this.incrementIterations()
        }, n.setLearningRate = function (e) {
            this.learningRate = e, null != this.c && this.c.dispose(), this.c = ix(wN(-e))
        }, n.dispose = function () {
            this.c.dispose()
        }, n.getWeights = function () {
            var e = Pm(regeneratorRuntime.mark(function e() {
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return e.next = 2, this.saveIterations();
                        case 2:
                            return e.t0 = e.sent, e.abrupt("return", [e.t0]);
                        case 4:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function () {
                return e.apply(this, arguments)
            }
        }(), n.setWeights = function () {
            var e = Pm(regeneratorRuntime.mark(function e(t) {
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return e.next = 2, this.extractIterations(t);
                        case 2:
                            if (0 === (t = e.sent).length) {
                                e.next = 5;
                                break
                            }
                            throw new Error("SGD optimizer does not have settable weights.");
                        case 5:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function (t) {
                return e.apply(this, arguments)
            }
        }(), n.getConfig = function () {
            return {
                learningRate: this.learningRate
            }
        }, t.fromConfig = function (e, t) {
            return new e(t.learningRate)
        }, t
    }(mS);
    xS.className = "SGD", Yb(xS);
    var wS = function (e) {
        function t(t, n, r) {
            var a;
            return void 0 === r && (r = !1), (a = e.call(this, t) || this).learningRate = t, a.momentum = n, a.useNesterov = r, a.accumulations = [], a.m = wN(a.momentum), a
        }
        Vm(t, e);
        var n = t.prototype;
        return n.applyGradients = function (e) {
            var t = this;
            (Array.isArray(e) ? e.map(function (e) {
                return e.name
            }) : Object.keys(e)).forEach(function (n, r) {
                var a = Gg.registeredVariables[n];
                null == t.accumulations[r] && (t.accumulations[r] = {
                    originalName: n + "/momentum",
                    variable: rx(function () {
                        return Sw(a).variable(!1)
                    })
                });
                var i = t.accumulations[r].variable,
                    o = Array.isArray(e) ? e[r].tensor : e[n];
                null != o && rx(function () {
                    var e, n = ux(px(t.m, i), o);
                    e = t.useNesterov ? ux(px(t.c, ux(o, px(n, t.m))), a) : ux(px(t.c, n), a), i.assign(n), a.assign(e)
                })
            }), this.incrementIterations()
        }, n.dispose = function () {
            this.m.dispose(), null != this.accumulations && ax(this.accumulations.map(function (e) {
                return e.variable
            }))
        }, n.setMomentum = function (e) {
            this.momentum = e
        }, n.getWeights = function () {
            var e = Pm(regeneratorRuntime.mark(function e() {
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return e.next = 2, this.saveIterations();
                        case 2:
                            return e.t0 = e.sent, e.abrupt("return", [e.t0].concat(this.accumulations.map(function (e) {
                                return {
                                    name: e.originalName,
                                    tensor: e.variable
                                }
                            })));
                        case 4:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function () {
                return e.apply(this, arguments)
            }
        }(), n.setWeights = function () {
            var e = Pm(regeneratorRuntime.mark(function e(t) {
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return e.next = 2, this.extractIterations(t);
                        case 2:
                            t = e.sent, this.accumulations = t.map(function (e) {
                                return {
                                    originalName: e.name,
                                    variable: e.tensor.variable(!1)
                                }
                            });
                        case 5:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function (t) {
                return e.apply(this, arguments)
            }
        }(), n.getConfig = function () {
            return {
                learningRate: this.learningRate,
                momentum: this.momentum,
                useNesterov: this.useNesterov
            }
        }, t.fromConfig = function (e, t) {
            return new e(t.learningRate, t.momentum, t.useNesterov)
        }, t
    }(xS);
    wS.className = "Momentum", Yb(wS);
    var kS = function (e) {
        function t(t, n, r, a, i) {
            var o;
            if (void 0 === n && (n = .9), void 0 === r && (r = 0), void 0 === a && (a = null), void 0 === i && (i = !1), (o = e.call(this) || this).learningRate = t, o.decay = n, o.momentum = r, o.epsilon = a, o.accumulatedMeanSquares = [], o.accumulatedMoments = [], o.accumulatedMeanGrads = [], o.centered = i, null == a && (o.epsilon = Gg.backend.epsilon()), null == t) throw new Error("learningRate for RMSPropOptimizer must be defined.");
            return o
        }
        Vm(t, e);
        var n = t.prototype;
        return n.applyGradients = function (e) {
            var t = this;
            (Array.isArray(e) ? e.map(function (e) {
                return e.name
            }) : Object.keys(e)).forEach(function (n, r) {
                var a = Gg.registeredVariables[n];
                null == t.accumulatedMeanSquares[r] && (t.accumulatedMeanSquares[r] = {
                    originalName: n + "/rms",
                    variable: rx(function () {
                        return Sw(a).variable(!1)
                    })
                }), null == t.accumulatedMoments[r] && (t.accumulatedMoments[r] = {
                    originalName: n + "/momentum",
                    variable: rx(function () {
                        return Sw(a).variable(!1)
                    })
                }), null == t.accumulatedMeanGrads[r] && t.centered && (t.accumulatedMeanGrads[r] = {
                    originalName: n + "/mg",
                    variable: rx(function () {
                        return Sw(a).variable(!1)
                    })
                });
                var i = Array.isArray(e) ? e[r].tensor : e[n];
                if (null != i) {
                    var o = t.accumulatedMeanSquares[r].variable,
                        s = t.accumulatedMoments[r].variable;
                    rx(function () {
                        var e = ux(px(o, t.decay), px(Rk(i), 1 - t.decay));
                        if (t.centered) {
                            var n = t.accumulatedMeanGrads[r].variable,
                                u = ux(px(n, t.decay), px(i, 1 - t.decay)),
                                l = cx(px(i, t.learningRate), BN(ak(e, ux(Rk(u), t.epsilon)))),
                                c = ux(px(s, t.momentum), l);
                            o.assign(e), n.assign(u), s.assign(c);
                            var p = ak(a, c);
                            a.assign(p)
                        } else {
                            var h = ux(px(o, t.decay), px(Rk(i), 1 - t.decay)),
                                f = ux(px(s, t.momentum), cx(px(i, t.learningRate), BN(ux(h, t.epsilon))));
                            o.assign(h), s.assign(f);
                            var d = ak(a, f);
                            a.assign(d)
                        }
                    })
                }
            }), this.incrementIterations()
        }, n.dispose = function () {
            null != this.accumulatedMeanSquares && ax(this.accumulatedMeanSquares.map(function (e) {
                return e.variable
            })), null != this.accumulatedMeanGrads && this.centered && ax(this.accumulatedMeanGrads.map(function (e) {
                return e.variable
            })), null != this.accumulatedMoments && ax(this.accumulatedMoments.map(function (e) {
                return e.variable
            }))
        }, n.getWeights = function () {
            var e = Pm(regeneratorRuntime.mark(function e() {
                var t;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return t = [].concat(this.accumulatedMeanSquares, this.accumulatedMoments), this.centered && t.push.apply(t, this.accumulatedMeanGrads), e.next = 4, this.saveIterations();
                        case 4:
                            return e.t0 = e.sent, e.abrupt("return", [e.t0].concat(t.map(function (e) {
                                return {
                                    name: e.originalName,
                                    tensor: e.variable
                                }
                            })));
                        case 6:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function () {
                return e.apply(this, arguments)
            }
        }(), n.setWeights = function () {
            var e = Pm(regeneratorRuntime.mark(function e(t) {
                var n;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return e.next = 2, this.extractIterations(t);
                        case 2:
                            t = e.sent, n = this.centered ? t.length / 3 : t.length / 2, this.accumulatedMeanSquares = t.slice(0, n).map(function (e) {
                                return {
                                    originalName: e.name,
                                    variable: e.tensor.variable(!1)
                                }
                            }), this.accumulatedMoments = t.slice(n, 2 * n).map(function (e) {
                                return {
                                    originalName: e.name,
                                    variable: e.tensor.variable(!1)
                                }
                            }), this.centered && (this.accumulatedMeanGrads = t.slice(2 * n, 3 * n).map(function (e) {
                                return {
                                    originalName: e.name,
                                    variable: e.tensor.variable(!1)
                                }
                            }));
                        case 8:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function (t) {
                return e.apply(this, arguments)
            }
        }(), n.getConfig = function () {
            return {
                learningRate: this.learningRate,
                decay: this.decay,
                momentum: this.momentum,
                epsilon: this.epsilon,
                centered: this.centered
            }
        }, t.fromConfig = function (e, t) {
            return new e(t.learningRate, t.decay, t.momentum, t.epsilon, t.centered)
        }, t
    }(mS);
    kS.className = "RMSProp", Yb(kS);
    var NS = function () {
            function e() {}
            return e.sgd = function (e) {
                return new xS(e)
            }, e.momentum = function (e, t, n) {
                return void 0 === n && (n = !1), new wS(e, t, n)
            }, e.rmsprop = function (e, t, n, r, a) {
                return void 0 === t && (t = .9), void 0 === n && (n = 0), void 0 === r && (r = null), void 0 === a && (a = !1), new kS(e, t, n, r, a)
            }, e.adam = function (e, t, n, r) {
                return void 0 === e && (e = .001), void 0 === t && (t = .9), void 0 === n && (n = .999), void 0 === r && (r = null), new yS(e, t, n, r)
            }, e.adadelta = function (e, t, n) {
                return void 0 === e && (e = .001), void 0 === t && (t = .95), void 0 === n && (n = null), new vS(e, t, n)
            }, e.adamax = function (e, t, n, r, a) {
                return void 0 === e && (e = .002), void 0 === t && (t = .9), void 0 === n && (n = .999), void 0 === r && (r = null), void 0 === a && (a = 0), new bS(e, t, n, r, a)
            }, e.adagrad = function (e, t) {
                return void 0 === t && (t = .1), new gS(e, t)
            }, e
        }(),
        IS = {
            sgd: NS.sgd,
            momentum: NS.momentum,
            adadelta: NS.adadelta,
            adagrad: NS.adagrad,
            rmsprop: NS.rmsprop,
            adamax: NS.adamax,
            adam: NS.adam
        },
        SS = "undefined" != typeof requestAnimationFrame ? requestAnimationFrame : "undefined" != typeof setImmediate ? setImmediate : function (e) {
            return e()
        };

    function TS() {
        return new Promise(function (e) {
            return SS(function () {
                return e()
            })
        })
    }

    function CS(e, t) {
        var n = e[0].length;
        e.forEach(function (e, t) {
            nv(e.length === n, function () {
                return "Error in concat" + n + "D: rank of tensors[" + t + "] must be the same as the rank of the rest (" + n + ")"
            })
        }), nv(t >= 0 && t < n, function () {
            return "Error in concat" + n + "D: axis must be between 0 and " + (n - 1) + "."
        });
        var r = e[0];
        e.forEach(function (e, a) {
            for (var i = 0; i < n; i++) nv(i === t || e[i] === r[i], function () {
                return "Error in concat" + n + "D: Shape of tensors[" + a + "] (" + e + ") does not match the shape of the rest (" + r + ") along the non-concatenated axis " + a + "."
            })
        })
    }

    function ES(e, t) {
        for (var n = e[0].slice(), r = 1; r < e.length; r++) n[t] += e[r][t];
        return n
    }

    function RS(e) {
        return e <= 30 ? e : Ev(e, Math.floor(Math.sqrt(e)))
    }

    function AS(e, t, n) {
        return [n * ("number" == typeof e ? e : e[0]), t * ("number" == typeof e ? e : e[1])]
    }

    function FS(e, t, n, r) {
        void 0 === r && (r = !0);
        var a = [];
        if (r)(a = a.concat(t.slice(0))).push(e[0] / n), a = a.concat(e.slice(1));
        else {
            a = a.concat(e[0]);
            for (var i = t.length, o = 0; o < i; ++o) a = a.concat([e[o + 1] / t[o], t[o]]);
            a = a.concat(e.slice(i + 1))
        }
        return a
    }

    function _S(e, t, n) {
        void 0 === n && (n = !0);
        var r = [];
        if (n) {
            r.push(t);
            for (var a = t + 1; a < e; ++a) a <= 2 * t ? (r.push(a), r.push(a - (t + 1))) : r.push(a)
        } else {
            for (var i = [], o = [], s = 1; s < e; ++s) s >= 2 * t + 1 || s % 2 == 1 ? o.push(s) : i.push(s);
            r.push.apply(r, i), r.push(0), r.push.apply(r, o)
        }
        return r
    }

    function DS(e, t, n, r) {
        void 0 === r && (r = !0);
        var a = [];
        r ? a.push(e[0] / n) : a.push(e[0] * n);
        for (var i = 1; i < e.length; ++i) i <= t.length ? r ? a.push(t[i - 1] * e[i]) : a.push(e[i] / t[i - 1]) : a.push(e[i]);
        return a
    }

    function OS(e, t) {
        for (var n = [0], r = 0; r < t; ++r) n.push(e[r][0]);
        return n
    }

    function MS(e, t, n) {
        for (var r = e.slice(0, 1), a = 0; a < n; ++a) r.push(e[a + 1] - t[a][0] - t[a][1]);
        return r
    }
    var LS = 1.0507009873554805;

    function zS() {
        var e;
        Wv().getBool("IS_TEST") || (e = console).warn.apply(e, arguments)
    }

    function PS(e, t) {
        if (e.length !== t.length) throw new Error("Cannot merge real and imag arrays of different lengths. real:" + e.length + ", imag: " + t.length + ".");
        for (var n = new Float32Array(2 * e.length), r = 0; r < n.length; r += 2) n[r] = e[r / 2], n[r + 1] = t[r / 2];
        return n
    }

    function BS(e) {
        for (var t = new Float32Array(e.length / 2), n = new Float32Array(e.length / 2), r = 0; r < e.length; r += 2) t[r / 2] = e[r], n[r / 2] = e[r + 1];
        return {
            real: t,
            imag: n
        }
    }

    function WS(e) {
        for (var t = Math.ceil(e.length / 4), n = new Float32Array(t), r = new Float32Array(t), a = 0; a < e.length; a += 4) n[Math.floor(a / 4)] = e[a], r[Math.floor(a / 4)] = e[a + 1];
        return {
            real: n,
            imag: r
        }
    }

    function VS(e) {
        for (var t = Math.floor(e.length / 4), n = new Float32Array(t), r = new Float32Array(t), a = 2; a < e.length; a += 4) n[Math.floor(a / 4)] = e[a], r[Math.floor(a / 4)] = e[a + 1];
        return {
            real: n,
            imag: r
        }
    }

    function US(e, t) {
        return {
            real: e[2 * t],
            imag: e[2 * t + 1]
        }
    }

    function GS(e, t, n, r) {
        e[2 * r] = t, e[2 * r + 1] = n
    }

    function jS(e, t) {
        for (var n = new Float32Array(e / 2), r = new Float32Array(e / 2), a = 0; a < Math.ceil(e / 2); a++) {
            var i = (t ? 2 : -2) * Math.PI * (a / e);
            n[a] = Math.cos(i), r[a] = Math.sin(i)
        }
        return {
            real: n,
            imag: r
        }
    }

    function HS(e, t, n) {
        var r = (n ? 2 : -2) * Math.PI * (e / t);
        return {
            real: Math.cos(r),
            imag: Math.sin(r)
        }
    }

    function qS(e, t, n) {
        void 0 === n && (n = 0);
        var r = [];
        if ("number" == typeof t) nv(e.shape[n] % t == 0, function () {
            return "Number of splits must evenly divide the axis."
        }), r = new Array(t).fill(e.shape[n] / t);
        else {
            nv(t.reduce(function (e, t) {
                return -1 === t && (e += 1), e
            }, 0) <= 1, function () {
                return "There should be only one negative value in split array."
            });
            var a = t.indexOf(-1);
            if (-1 !== a) {
                var i = t.reduce(function (e, t) {
                    return t > 0 ? e + t : e
                });
                t[a] = e.shape[n] - i
            }
            nv(e.shape[n] === t.reduce(function (e, t) {
                return e + t
            }), function () {
                return "The sum of sizes must match the size of the axis dimension."
            }), r = t
        }
        return r
    }

    function KS(e, t) {
        var n, r = !1;
        for (e <= 30 ? (n = e, r = !0) : n = Ev(e, Math.floor(Math.sqrt(e))); !r;) n > t || n === e ? r = !0 : n = Ev(e, n + 1);
        return n
    }

    function XS(e, t, n) {
        for (var r = [], a = e.length, i = 0; i < a; i++) i !== t ? r.push(e[i]) : r.push(n);
        return r
    }

    function YS(e, t, n, r) {
        var a = t.shape.length,
            i = e.shape.length;
        if (0 !== r && (r < -a || r > a)) throw new Error("Expect batchDims in the range of [-" + a + ", " + a + "], but got " + r);
        if (r < 0 && (r += a), r > i) throw new Error("batchDims (" + r + ") must be less than rank(x) (\n    " + i + ").");
        if (n < r) throw new Error("batchDims (" + r + ") must be less than or equal to axis (" + n + ").");
        for (var o = 0; o < r; ++o)
            if (e.shape[o] !== t.shape[o]) throw new Error("x.shape[" + o + "]: " + e.shape[o] + " should be equal to indices.shape[" + o + "]: " + t.shape[o] + ".");
        for (var s = e.shape[n], u = [], l = 1, c = 1, p = 1, h = 0; h < r; ++h) u.push(e.shape[h]), l *= e.shape[h];
        for (var f = r; f < n; f++) u.push(e.shape[f]), c *= e.shape[f];
        for (var d = r; d < a; d++) u.push(t.shape[d]);
        for (var m = n + 1; m < i; m++) u.push(e.shape[m]), p *= e.shape[m];
        return {
            batchSize: l,
            sliceSize: p,
            outerSize: c,
            dimSize: s,
            outputShape: u
        }
    }

    function JS(e) {
        try {
            return e.map(function (e) {
                return fg(e)
            })
        } catch (e) {
            throw new Error("Failed to decode encoded string bytes into utf-8, error: " + e)
        }
    }

    function ZS(e) {
        return e.map(function (e) {
            return hg(e)
        })
    }
    var QS = {
            __proto__: null,
            slice_util: qb,
            segment_util: {
                __proto__: null,
                segOpComputeOptimalWindowSize: KS,
                computeOutShape: XS,
                collectGatherOpShapeInfo: YS
            },
            fromUint8ToStringArray: JS,
            fromStringArrayToUint8: ZS,
            upcastType: _g,
            axesAreInnerMostDims: sk,
            combineLocations: uk,
            computeOutAndReduceShapes: lk,
            expandShapeToKeepDim: ck,
            assertAxesAreInnerMostDims: pk,
            getAxesPermutation: hk,
            getUndoAxesPermutation: fk,
            getInnerMostAxes: dk,
            getBroadcastDims: xw,
            getReductionAxes: ww,
            assertAndGetBroadcastShape: kw,
            assertParamsConsistent: CS,
            computeOutShape: ES,
            computeDilation2DInfo: Sx,
            computePool2DInfo: Tx,
            computePool3DInfo: Cx,
            computeConv2DInfo: Ex,
            computeConv3DInfo: Rx,
            computeDefaultPad: Ax,
            tupleValuesAreOne: Mx,
            eitherStridesOrDilationsAreOne: Lx,
            convertConv2DDataFormat: zx,
            getFusedDyActivation: dI,
            getFusedBiasGradient: mI,
            applyActivation: vI,
            shouldFuse: gI,
            PARALLELIZE_THRESHOLD: 30,
            computeOptimalWindowSize: RS,
            getImageCenter: AS,
            getReshaped: FS,
            getPermuted: _S,
            getReshapedPermuted: DS,
            getSliceBeginCoords: OS,
            getSliceSize: MS,
            prepareAndValidate: Ib,
            validateUpdateShape: Tb,
            validateInput: Cb,
            calculateShapes: Eb,
            SELU_SCALEALPHA: 1.7580993408473768,
            SELU_SCALE: LS,
            ERF_P: .3275911,
            ERF_A1: .254829592,
            ERF_A2: -.284496736,
            ERF_A3: 1.421413741,
            ERF_A4: -1.453152027,
            ERF_A5: 1.061405429,
            warn: zS,
            log: function () {
                var e;
                Wv().getBool("IS_TEST") || (e = console).log.apply(e, arguments)
            },
            mergeRealAndImagArrays: PS,
            splitRealAndImagArrays: BS,
            complexWithEvenIndex: WS,
            complexWithOddIndex: VS,
            getComplexWithIndex: US,
            assignToTypedArray: GS,
            exponents: jS,
            exponent: HS,
            prepareSplitSize: qS
        },
        $S = {
            __proto__: null,
            nonMaxSuppressionV3Impl: MI,
            nonMaxSuppressionV4Impl: LI,
            nonMaxSuppressionV5Impl: zI,
            whereImpl: eI
        },
        eT = {
            kernelName: "Abs",
            inputsToSave: ["x"],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    x: function () {
                        return px(e, GN(Ky(n, "float32"), -1))
                    }
                }
            }
        },
        tT = {
            kernelName: "Acos",
            inputsToSave: ["x"],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    x: function () {
                        var t = Rk(Ky(n, "float32")),
                            r = BN(ak(wN(1), t));
                        return ek(cx(e, r))
                    }
                }
            }
        },
        nT = {
            kernelName: "Acosh",
            inputsToSave: ["x"],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    x: function () {
                        var t = BN(ak(Rk(Ky(n, "float32")), 1));
                        return cx(e, t)
                    }
                }
            }
        },
        rT = {
            kernelName: Gv,
            inputsToSave: ["a", "b"],
            gradFunc: function (e, t) {
                var n = t[0],
                    r = t[1],
                    a = kw(n.shape, r.shape);
                return {
                    a: function () {
                        var t = e,
                            r = ww(n.shape, a);
                        return r.length > 0 && (t = ik(t, r)), Px(t, n.shape)
                    },
                    b: function () {
                        var t = e,
                            n = ww(r.shape, a);
                        return n.length > 0 && (t = ik(t, n)), Px(t, r.shape)
                    }
                }
            }
        },
        aT = {
            kernelName: "ArgMax",
            inputsToSave: ["x"],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    x: function () {
                        return Sw(n)
                    }
                }
            }
        },
        iT = {
            kernelName: "ArgMin",
            inputsToSave: ["x"],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    x: function () {
                        return Sw(n)
                    }
                }
            }
        },
        oT = {
            kernelName: "Asin",
            inputsToSave: ["x"],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    x: function () {
                        return cx(e, BN(ak(wN(1), Rk(Ky(n, "float32")))))
                    }
                }
            }
        },
        sT = {
            kernelName: "Asinh",
            inputsToSave: ["x"],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    x: function () {
                        var t = BN(ux(wN(1), Rk(Ky(n, "float32"))));
                        return cx(e, t)
                    }
                }
            }
        },
        uT = {
            kernelName: "Atan2",
            inputsToSave: ["a", "b"],
            gradFunc: function (e, t) {
                var n = t[0],
                    r = t[1],
                    a = kw(n.shape, r.shape);
                return {
                    a: function () {
                        var t = ux(Rk(n), Rk(r)),
                            i = px(e, cx(r, t)),
                            o = ww(n.shape, a);
                        return o.length > 0 && (i = ik(i, o)), Px(i, n.shape)
                    },
                    b: function () {
                        var t = ux(Rk(n), Rk(r)),
                            i = ek(px(e, cx(n, t))),
                            o = ww(r.shape, a);
                        return o.length > 0 && (i = ik(i, o)), Px(i, r.shape)
                    }
                }
            }
        },
        lT = {
            kernelName: "Atan",
            inputsToSave: ["x"],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    x: function () {
                        return cx(e, ux(Rk(Ky(n, "float32")), 1))
                    }
                }
            }
        },
        cT = {
            kernelName: "Atanh",
            inputsToSave: ["x"],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    x: function () {
                        return cx(e, ak(wN(1), Rk(Ky(n, "float32"))))
                    }
                }
            }
        },
        pT = $g({
            avgPool3dGrad_: function (e, t, n, r, a, i) {
                var o = Zg(e, "dy", "avgPool3dGrad"),
                    s = Zg(t, "input", "avgPool3dGrad"),
                    u = o,
                    l = s,
                    c = !1;
                4 === s.rank && (c = !0, u = Px(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]]), l = Px(s, [1, s.shape[0], s.shape[1], s.shape[2], s.shape[3]])), nv(5 === u.rank, function () {
                    return "Error in avgPool3dGrad: dy must be rank 5 but got rank " + u.rank + "."
                }), nv(5 === l.rank, function () {
                    return "Error in avgPool3dGrad: input must be rank 5 but got rank " + l.rank + "."
                }), null != i && nv(uv(a), function () {
                    return "Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + a + "."
                });
                var p = {
                        dy: u,
                        input: l
                    },
                    h = {
                        filterSize: n,
                        strides: r,
                        pad: a,
                        dimRoundingMode: i
                    },
                    f = Gg.runKernel("AvgPool3DGrad", p, h);
                return c ? Px(f, [f.shape[1], f.shape[2], f.shape[3], f.shape[4]]) : f
            }
        }),
        hT = {
            kernelName: "AvgPool3D",
            inputsToSave: ["x"],
            gradFunc: function (e, t, n) {
                var r = t[0],
                    a = n.filterSize,
                    i = n.strides,
                    o = n.pad,
                    s = n.dimRoundingMode;
                return {
                    x: function () {
                        return pT(e, r, a, i, o, s)
                    }
                }
            }
        },
        fT = $g({
            avgPoolGrad_: function (e, t, n, r, a) {
                var i = Zg(e, "dy", "avgPoolGrad"),
                    o = Zg(t, "input", "avgPoolGrad");
                nv(o.rank === i.rank, function () {
                    return "Rank of input (" + o.rank + ") does not match rank of dy (" + i.rank + ")"
                });
                var s = o,
                    u = i,
                    l = !1;
                3 === o.rank && (l = !0, s = Px(o, [1, o.shape[0], o.shape[1], o.shape[2]]), u = Px(i, [1, i.shape[0], i.shape[1], i.shape[2]])), nv(4 === u.rank, function () {
                    return "Error in avgPoolGrad: dy must be rank 4 but got rank " + u.rank + "."
                }), nv(4 === s.rank, function () {
                    return "Error in avgPoolGrad: input must be rank 4 but got rank " + s.rank + "."
                });
                var c = {
                        dy: u,
                        input: s
                    },
                    p = {
                        filterSize: n,
                        strides: r,
                        pad: a
                    },
                    h = Gg.runKernel("AvgPoolGrad", c, p);
                return l ? Px(h, [h.shape[1], h.shape[2], h.shape[3]]) : h
            }
        }),
        dT = {
            kernelName: "AvgPool",
            inputsToSave: ["x"],
            gradFunc: function (e, t, n) {
                var r = t[0],
                    a = n.filterSize,
                    i = n.strides,
                    o = n.pad;
                return {
                    x: function () {
                        return fT(e, r, a, i, o)
                    }
                }
            }
        },
        mT = {
            kernelName: "BatchMatMul",
            inputsToSave: ["a", "b"],
            gradFunc: function (e, t, n) {
                var r = t[0],
                    a = t[1],
                    i = n.transposeA,
                    o = n.transposeB;
                return i || o ? !i && o ? {
                    a: function () {
                        return fb(e, a, !1, !1)
                    },
                    b: function () {
                        return fb(e, r, !0, !1)
                    }
                } : i && !o ? {
                    a: function () {
                        return fb(a, e, !1, !0)
                    },
                    b: function () {
                        return fb(r, e, !1, !1)
                    }
                } : {
                    a: function () {
                        return fb(a, e, !0, !0)
                    },
                    b: function () {
                        return fb(e, r, !0, !0)
                    }
                } : {
                    a: function () {
                        return fb(e, a, !1, !0)
                    },
                    b: function () {
                        return fb(r, e, !0, !1)
                    }
                }
            }
        },
        vT = {
            kernelName: "BatchToSpaceND",
            gradFunc: function (e, t, n) {
                var r = n.blockShape,
                    a = n.crops;
                return {
                    x: function () {
                        return Gk(e, r, a)
                    }
                }
            }
        },
        gT = {
            kernelName: "BroadcastTo",
            gradFunc: function (e, t, n) {
                for (var r = n, a = r.inputShape, i = r.shape, o = Array.from(i), s = a.length - 1; s >= 0; s--)
                    if (a[s] === i[s]) o[s] = 1;
                    else if (1 !== a[s]) throw new Error("broadcastTo(): [" + a + "] cannot be broadcast to [" + i + "].");
                for (var u = [], l = 0; l < o.length; l++) o[l] > 1 && u.push(l);
                return {
                    x: function () {
                        return ik(e, u, !0)
                    }
                }
            }
        },
        yT = {
            kernelName: "Ceil",
            gradFunc: function (e) {
                return {
                    x: function () {
                        return Sw(e)
                    }
                }
            }
        },
        bT = {
            kernelName: "ClipByValue",
            inputsToSave: ["x"],
            gradFunc: function (e, t, n) {
                var r = t[0],
                    a = n.clipValueMin,
                    i = n.clipValueMax;
                return {
                    x: function () {
                        return Iw(vk(Bw(r, a), qw(r, i)), e, Sw(e))
                    }
                }
            }
        },
        xT = {
            kernelName: "ComplexAbs",
            inputsToSave: ["x"],
            gradFunc: eT.gradFunc
        },
        wT = {
            kernelName: "Concat",
            saveAllInputs: !0,
            gradFunc: function (e, t, n) {
                var r = t.map(function (e) {
                        return e.shape
                    }),
                    a = fv(n.axis, t[0].shape)[0],
                    i = r.map(function (e) {
                        return e[a]
                    });
                return zN(e, i, a).map(function (e) {
                    return function () {
                        return e
                    }
                })
            }
        },
        kT = {
            kernelName: "Conv2D",
            inputsToSave: ["x", "filter"],
            gradFunc: function (e, t, n) {
                var r = t[0],
                    a = t[1],
                    i = n.dilations,
                    o = n.strides,
                    s = n.pad,
                    u = n.dataFormat;
                return nv(Mx(i), function () {
                    return "Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + i + "'"
                }), {
                    x: function () {
                        return sw(r.shape, e, a, o, s, u)
                    },
                    filter: function () {
                        return fI(r, e, a.shape, o, s, u)
                    }
                }
            }
        },
        NT = {
            kernelName: "Conv2DBackpropInput",
            inputsToSave: ["dy", "filter"],
            gradFunc: function (e, t, n) {
                var r = t[0],
                    a = t[1],
                    i = n.strides,
                    o = n.pad,
                    s = n.dataFormat,
                    u = n.dimRoundingMode;
                return {
                    dy: function () {
                        return iw(e, a, i, o, s, 1, u)
                    },
                    filter: function () {
                        return fI(e, r, a.shape, i, o, s, u)
                    }
                }
            }
        },
        IT = $g({
            conv3DBackpropFilter_: function (e, t, n, r, a) {
                var i = e;
                4 === e.rank && (i = Px(e, [1, e.shape[0], e.shape[1], e.shape[2], e.shape[3]]));
                var o = t;
                4 === o.rank && (o = Px(t, [1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]])), nv(5 === i.rank, function () {
                    return "Error in conv3dDerFilter: input must be rank 5, but got shape " + i.shape + "."
                }), nv(5 === o.rank, function () {
                    return "Error in conv3dDerFilter: dy must be rank 5, but got shape " + o.shape + "."
                }), nv(5 === n.length, function () {
                    return "Error in conv3dDerFilter: filterShape must be length 5, but got " + n + "."
                }), nv(i.shape[4] === n[3], function () {
                    return "Error in conv3dDerFilter: depth of input " + i.shape[4] + ") must match input depth in filter (" + n[3] + "."
                }), nv(o.shape[4] === n[4], function () {
                    return "Error in conv3dDerFilter: depth of dy (" + o.shape[4] + ") must match output depth for filter (" + n[4] + ")."
                });
                var s = {
                        x: i,
                        dy: o
                    },
                    u = {
                        strides: r,
                        pad: a,
                        filterShape: n
                    };
                return Gg.runKernel("Conv3DBackpropFilterV2", s, u)
            }
        }),
        ST = {
            kernelName: "Conv3D",
            inputsToSave: ["x", "filter"],
            gradFunc: function (e, t, n) {
                var r = n.dilations,
                    a = n.strides,
                    i = n.pad;
                nv(Mx(r), function () {
                    return "Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + r + "'"
                });
                var o = t[0],
                    s = t[1];
                return {
                    x: function () {
                        return cw(o.shape, e, s, a, i)
                    },
                    filter: function () {
                        return IT(o, e, s.shape, a, i)
                    }
                }
            }
        },
        TT = {
            kernelName: jv,
            inputsToSave: ["x"],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    x: function () {
                        return px(ek(CN(Ky(n, "float32"))), e)
                    }
                }
            }
        },
        CT = {
            kernelName: "Cosh",
            inputsToSave: ["x"],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    x: function () {
                        return px(EN(Ky(n, "float32")), e)
                    }
                }
            }
        },
        ET = {
            kernelName: "Cumsum",
            inputsToSave: ["x"],
            gradFunc: function (e, t, n) {
                var r = t[0],
                    a = n.axis,
                    i = n.exclusive,
                    o = n.reverse;
                return {
                    x: function () {
                        var t = hk([a], r.rank),
                            n = dw(e, a, i, !o);
                        return null != t && (n = mb(n, t)), n
                    }
                }
            }
        },
        RT = {
            kernelName: "DepthwiseConv2dNative",
            inputsToSave: ["x", "filter"],
            gradFunc: function (e, t, n) {
                var r = n.dilations,
                    a = n.strides,
                    i = n.pad,
                    o = n.dimRoundingMode,
                    s = null == r ? [1, 1] : r;
                nv(Mx(s), function () {
                    return "Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '" + s + "'"
                });
                var u = t[0],
                    l = t[1];
                return nv(4 === u.rank, function () {
                    return "Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank " + u.rank + "."
                }), nv(4 === l.rank, function () {
                    return "Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank " + l.rank + "."
                }), nv(u.shape[3] === l.shape[2], function () {
                    return "Error in gradient of depthwiseConv2d: number of input channels (" + u.shape[3] + ") must match the inChannels dimension in filter " + l.shape[2] + "."
                }), nv(Lx(a, s), function () {
                    return "Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides " + a + " and dilations '" + s + "'."
                }), null != o && nv(uv(i), function () {
                    return "Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode " + o + " but got pad " + i + "."
                }), {
                    x: function () {
                        return xI(u.shape, e, l, a, i, r, o)
                    },
                    filter: function () {
                        return bI(u, e, l.shape, a, i, r, o)
                    }
                }
            }
        },
        AT = {
            kernelName: "Dilation2D",
            inputsToSave: ["x", "filter"],
            gradFunc: function (e, t, n) {
                var r = t[0],
                    a = t[1],
                    i = {
                        x: r,
                        filter: a,
                        dy: e
                    },
                    o = {
                        x: r,
                        filter: a,
                        dy: e
                    };
                return {
                    x: function () {
                        return Gg.runKernel("Dilation2DBackpropInput", i, n)
                    },
                    filter: function () {
                        return Gg.runKernel("Dilation2DBackpropFilter", o, n)
                    }
                }
            }
        },
        FT = {
            kernelName: Hv,
            outputsToSave: [!0],
            gradFunc: function (e, t) {
                var n = {
                    dy: e,
                    y: t[0]
                };
                return {
                    x: function () {
                        return Gg.runKernel("EluGrad", n)
                    }
                }
            }
        },
        _T = {
            kernelName: qv,
            inputsToSave: ["x"],
            gradFunc: function (e, t) {
                var n = t[0],
                    r = px(Aw(ek(Rk(n))), 2 / Math.sqrt(Math.PI));
                return {
                    x: function () {
                        return px(e, r)
                    }
                }
            }
        },
        DT = {
            kernelName: Kv,
            outputsToSave: [!0],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    x: function () {
                        return px(e, n)
                    }
                }
            }
        },
        OT = {
            kernelName: "ExpandDims",
            inputsToSave: ["input"],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    input: function () {
                        return Px(e, n.shape)
                    }
                }
            }
        },
        MT = {
            kernelName: "Expm1",
            inputsToSave: ["x"],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    x: function () {
                        return px(e, Aw(n))
                    }
                }
            }
        },
        LT = {
            kernelName: "Floor",
            gradFunc: function (e) {
                return {
                    x: function () {
                        return Sw(e)
                    }
                }
            }
        },
        zT = {
            kernelName: "FloorDiv",
            inputsToSave: ["a", "b"],
            gradFunc: function (e, t) {
                var n = t[0],
                    r = t[1],
                    a = kw(n.shape, r.shape);
                return {
                    a: function () {
                        var t = cx(e, Ky(r, "float32")),
                            i = ww(n.shape, a);
                        return i.length > 0 ? Px(ik(t, i), n.shape) : t
                    },
                    b: function () {
                        var t = px(e, Ky(n, "float32")),
                            i = ww(r.shape, a);
                        i.length > 0 && (t = Px(ik(t, i), r.shape));
                        var o = Rk(r);
                        return ek(cx(t, Ky(o, "float32")))
                    }
                }
            }
        },
        PT = {
            kernelName: "FusedBatchNorm",
            inputsToSave: ["x", "mean", "variance", "scale"],
            gradFunc: function (e, t, n) {
                var r = n.varianceEpsilon,
                    a = t[0],
                    i = t[1],
                    o = t[2],
                    s = t[3],
                    u = null == s ? wN(1) : s,
                    l = ww(i.shape, a.shape),
                    c = [];
                if (1 === i.rank) {
                    for (var p = 0; p < a.shape.length - 1; ++p) c.push(a.shape[p]);
                    c.push(1)
                }
                var h = ak(a, i),
                    f = px(e, u),
                    d = xN(ux(o, wN(r))),
                    m = px(px(px(d, d), d), wN(-.5));
                return {
                    x: function () {
                        return 1 === i.rank ? Px(px(px(e, Dw(Px(d, [1, 1, 1, i.shape[0]]), c)), u), a.shape) : Px(px(px(e, d), u), a.shape)
                    },
                    mean: function () {
                        var e = px(px(d, wN(-1)), f);
                        return 1 === i.rank && (e = ik(e, l)), Px(e, i.shape)
                    },
                    variance: function () {
                        var e = px(px(m, h), f);
                        return 1 === i.rank && (e = ik(e, l)), Px(e, i.shape)
                    },
                    scale: function () {
                        var t = px(h, d),
                            n = px(e, t);
                        return 1 === i.rank && (n = ik(n, l)), Px(n, i.shape)
                    },
                    offset: function () {
                        var t = e;
                        return 1 === i.rank && (t = ik(t, l)), Px(t, i.shape)
                    }
                }
            }
        },
        BT = {
            kernelName: "GatherV2",
            inputsToSave: ["x", "indices"],
            gradFunc: function (e, t, n) {
                var r = t[0],
                    a = t[1],
                    i = n.axis,
                    o = fv(i, r.shape)[0];
                return {
                    x: function () {
                        var t = r.shape,
                            n = a.size,
                            s = t.slice(0, o),
                            u = s.length,
                            l = t.slice(i, t.length).slice(1),
                            c = l.length,
                            p = WT(0, u),
                            h = WT(u + 1, u + 1 + c),
                            f = VT([s, [n], l]),
                            d = Px(e, f),
                            m = Px(a, [n]),
                            v = VT([
                                [u], p, h
                            ]),
                            g = mb(d, v),
                            y = ZN(g, m, r.shape[o]),
                            b = fk(v);
                        return mb(y, b)
                    },
                    indices: function () {
                        return a
                    }
                }
            }
        };

    function WT(e, t) {
        for (var n = [], r = e; r < t; ++r) n.push(r);
        return n
    }

    function VT(e) {
        for (var t = [], n = 0; n < e.length; ++n)
            for (var r = 0; r < e[n].length; ++r) t.push(e[n][r]);
        return t
    }
    var UT = {
            kernelName: "GreaterEqual",
            inputsToSave: ["a", "b"],
            gradFunc: function (e, t) {
                var n = t[0],
                    r = t[1];
                return {
                    a: function () {
                        return Sw(n)
                    },
                    b: function () {
                        return Sw(r)
                    }
                }
            }
        },
        GT = {
            kernelName: "Identity",
            gradFunc: function (e) {
                return {
                    x: function () {
                        return Ky(e, "float32")
                    }
                }
            }
        },
        jT = {
            kernelName: "IsFinite",
            gradFunc: function (e) {
                return {
                    x: function () {
                        return Sw(e)
                    }
                }
            }
        },
        HT = {
            kernelName: "IsInf",
            gradFunc: function (e) {
                return {
                    x: function () {
                        return Sw(e)
                    }
                }
            }
        },
        qT = {
            kernelName: "IsNan",
            gradFunc: function (e) {
                return {
                    x: function () {
                        return Sw(e)
                    }
                }
            }
        },
        KT = {
            kernelName: "LeakyRelu",
            inputsToSave: ["x"],
            gradFunc: function (e, t, n) {
                var r = t[0],
                    a = n.alpha,
                    i = Pw(r, 0);
                return {
                    x: function () {
                        return Iw(i, e, px(e, a))
                    }
                }
            }
        },
        XT = {
            kernelName: "Log1p",
            inputsToSave: ["x"],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    x: function () {
                        return cx(e, ux(n, 1))
                    }
                }
            }
        },
        YT = {
            kernelName: Xv,
            inputsToSave: ["x"],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    x: function () {
                        return cx(e, Ky(n, "float32"))
                    }
                }
            }
        },
        JT = {
            kernelName: "LogSoftmax",
            inputsToSave: [],
            outputsToSave: [!0],
            gradFunc: function (e, t, n) {
                var r = t[0],
                    a = n.axis;
                return {
                    logits: function () {
                        var t = Aw(r);
                        return ak(e, px(ik(e, a, !0), t))
                    }
                }
            }
        },
        ZT = $g({
            localResponseNormalizationBackprop_: function (e, t, n, r, a, i, o) {
                void 0 === r && (r = 5), void 0 === a && (a = 1), void 0 === i && (i = 1), void 0 === o && (o = .5);
                var s = {
                        x: e,
                        y: t,
                        dy: n
                    },
                    u = {
                        depthRadius: r,
                        bias: a,
                        alpha: i,
                        beta: o
                    };
                return Gg.runKernel("LRNGrad", s, u)
            }
        }),
        QT = {
            kernelName: "LRN",
            inputsToSave: ["x"],
            outputsToSave: [!0],
            gradFunc: function (e, t, n) {
                var r = t[0],
                    a = t[1],
                    i = n.depthRadius,
                    o = n.bias,
                    s = n.alpha,
                    u = n.beta;
                return {
                    x: function () {
                        return ZT(r, a, e, i, o, s, u)
                    }
                }
            }
        };

    function $T(e, t, n, r) {
        return t.rank < n.rank && (t = Px(t, ck(t.shape, r))), e.rank < n.rank && (e = Px(e, ck(e.shape, r))), {
            x: function () {
                return px(e, Ky(Nw(n, t), e.dtype))
            }
        }
    }
    for (var eC, tC = {
            kernelName: "Max",
            inputsToSave: ["x"],
            outputsToSave: [!0],
            gradFunc: function (e, t, n) {
                var r = n.reductionIndices,
                    a = t[0],
                    i = $T(e, t[1], a, fv(r, a.shape));
                return {
                    x: function () {
                        return i.x()
                    }
                }
            }
        }, nC = {
            kernelName: "Maximum",
            inputsToSave: ["a", "b"],
            gradFunc: function (e, t) {
                var n = t[0],
                    r = t[1];
                return {
                    a: function () {
                        return px(e, Ky(Bw(n, r), "float32"))
                    },
                    b: function () {
                        return px(e, Ky(Hw(n, r), "float32"))
                    }
                }
            }
        }, rC = $g({
            maxPool3dGrad_: function (e, t, n, r, a, i, o) {
                var s = Zg(e, "dy", "maxPool3dGrad"),
                    u = Zg(t, "input", "maxPool3dGrad"),
                    l = Zg(n, "output", "maxPool3dGrad"),
                    c = s,
                    p = u,
                    h = l,
                    f = !1;
                4 === u.rank && (f = !0, c = Px(s, [1, s.shape[0], s.shape[1], s.shape[2], s.shape[3]]), p = Px(u, [1, u.shape[0], u.shape[1], u.shape[2], u.shape[3]]), h = Px(l, [1, l.shape[0], l.shape[1], l.shape[2], l.shape[3]])), nv(5 === c.rank, function () {
                    return "Error in maxPool3dGrad: dy must be rank 5 but got rank " + c.rank + "."
                }), nv(5 === p.rank, function () {
                    return "Error in maxPool3dGrad: input must be rank 5 but got rank " + p.rank + "."
                }), nv(5 === h.rank, function () {
                    return "Error in maxPool3dGrad: output must be rank 5 but got rank " + h.rank + "."
                }), null != o && nv(uv(i), function () {
                    return "Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode " + o + " but got pad " + i + "."
                });
                var d = {
                        dy: c,
                        input: p,
                        output: h
                    },
                    m = {
                        filterSize: r,
                        strides: a,
                        pad: i,
                        dimRoundingMode: o
                    },
                    v = Gg.runKernel("MaxPool3DGrad", d, m);
                return f ? Px(v, [v.shape[1], v.shape[2], v.shape[3], v.shape[4]]) : v
            }
        }), aC = {
            kernelName: "MaxPool3D",
            inputsToSave: ["x"],
            outputsToSave: [!0],
            gradFunc: function (e, t, n) {
                var r = t[0],
                    a = t[1],
                    i = n.filterSize,
                    o = n.strides,
                    s = n.pad,
                    u = n.dimRoundingMode;
                return {
                    x: function () {
                        return rC(e, r, a, i, o, s, u)
                    }
                }
            }
        }, iC = $g({
            maxPoolGrad_: function (e, t, n, r, a, i, o) {
                var s = Zg(e, "dy", "maxPoolGrad"),
                    u = Zg(t, "input", "maxPoolGrad"),
                    l = Zg(n, "output", "maxPoolGrad");
                nv(u.rank === s.rank, function () {
                    return "Rank of input (" + u.rank + ") does not match rank of dy (" + s.rank + ")"
                }), nv(4 === s.rank, function () {
                    return "Error in maxPoolGrad: dy must be rank 4 but got rank " + s.rank + "."
                }), nv(4 === u.rank, function () {
                    return "Error in maxPoolGrad: input must be rank 4 but got rank " + u.rank + "."
                }), null != o && nv(uv(i), function () {
                    return "Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode " + o + " but got pad " + i + "."
                });
                var c = {
                        dy: s,
                        input: u,
                        output: l
                    },
                    p = {
                        filterSize: r,
                        strides: a,
                        pad: i,
                        dimRoundingMode: o
                    };
                return Gg.runKernel("MaxPoolGrad", c, p)
            }
        }), oC = {
            kernelName: "PadV2",
            inputsToSave: ["x"],
            gradFunc: function (e, t, n) {
                var r = t[0],
                    a = n.paddings.map(function (e) {
                        return e[0]
                    });
                return {
                    x: function () {
                        return Gx(e, a, r.shape)
                    }
                }
            }
        }, sC = {
            kernelName: "SpaceToBatchND",
            gradFunc: function (e, t, n) {
                var r = n.blockShape,
                    a = n.paddings;
                return {
                    x: function () {
                        return qx(e, r, a)
                    }
                }
            }
        }, uC = {
            kernelName: "SplitV",
            gradFunc: function (e, t, n) {
                var r = n.axis;
                return {
                    x: function () {
                        return Vx(e, r)
                    }
                }
            }
        }, lC = 0, cC = [eT, tT, nT, rT, {
            kernelName: "AddN",
            saveAllInputs: !0,
            gradFunc: function (e, t) {
                var n = {};
                return t.forEach(function (t, r) {
                    n[r] = function () {
                        return e.clone()
                    }
                }), n
            }
        }, aT, iT, oT, sT, uT, lT, cT, hT, dT, mT, vT, gT, {
            kernelName: "Cast",
            gradFunc: function (e) {
                return {
                    x: function () {
                        return e.clone()
                    }
                }
            }
        }, yT, bT, xT, wT, NT, kT, ST, TT, CT, ET, RT, AT, {
            kernelName: "RealDiv",
            inputsToSave: ["a", "b"],
            gradFunc: function (e, t) {
                var n = t[0],
                    r = t[1],
                    a = kw(n.shape, r.shape);
                return {
                    a: function () {
                        var t = cx(e, Ky(r, "float32")),
                            i = ww(n.shape, a);
                        return i.length > 0 ? Px(ik(t, i), n.shape) : t
                    },
                    b: function () {
                        var t = px(e, Ky(n, "float32")),
                            i = ww(r.shape, a);
                        i.length > 0 && (t = Px(ik(t, i), r.shape));
                        var o = Rk(r);
                        return ek(cx(t, Ky(o, "float32")))
                    }
                }
            }
        }, FT, _T, DT, OT, MT, zT, LT, PT, BT, UT, GT, jT, HT, qT, KT, XT, YT, JT, QT, tC, tC, nC, aC, {
            kernelName: "MaxPool",
            inputsToSave: ["x"],
            outputsToSave: [!0],
            gradFunc: function (e, t, n) {
                var r = t[0],
                    a = t[1],
                    i = n.filterSize,
                    o = n.strides,
                    s = n.pad;
                return {
                    x: function () {
                        return iC(e, r, a, i, o, s)
                    }
                }
            }
        }, {
            kernelName: "Mean",
            inputsToSave: ["x"],
            gradFunc: function (e, t, n) {
                var r = t[0],
                    a = fv(n.axis, r.shape),
                    i = ov(lk(r.shape, a)[1]);
                return {
                    x: function () {
                        var t = r.shape.slice();
                        a.forEach(function (e) {
                            t[e] = 1
                        });
                        var n = Px(e, t);
                        return cx(px(n, Mk(r.shape, "float32")), i)
                    }
                }
            }
        }, {
            kernelName: "Min",
            inputsToSave: ["x"],
            outputsToSave: [!0],
            gradFunc: function (e, t, n) {
                var r = n.axis,
                    a = t[0],
                    i = $T(e, t[1], a, fv(r, a.shape));
                return {
                    x: function () {
                        return i.x()
                    }
                }
            }
        }, {
            kernelName: "Minimum",
            inputsToSave: ["a", "b"],
            gradFunc: function (e, t) {
                var n = t[0],
                    r = t[1];
                return {
                    a: function () {
                        return px(e, Ky(qw(n, r), "float32"))
                    },
                    b: function () {
                        return px(e, Ky(Pw(n, r), "float32"))
                    }
                }
            }
        }, {
            kernelName: "MirrorPad",
            inputsToSave: ["x"],
            gradFunc: function (e, t, n) {
                var r = t[0],
                    a = n.paddings.map(function (e) {
                        return e[0]
                    });
                return {
                    x: function () {
                        return Gx(e, a, r.shape)
                    }
                }
            }
        }, {
            kernelName: Yv,
            inputsToSave: ["a", "b"],
            gradFunc: function (e, t) {
                var n = t[0],
                    r = t[1],
                    a = kw(n.shape, r.shape);
                return {
                    a: function () {
                        var t = ww(n.shape, a);
                        return t.length > 0 ? Px(ik(e, t), n.shape) : e
                    },
                    b: function () {
                        var t = px(e, ek(Lw(cx(n, r)))),
                            i = ww(r.shape, a);
                        return i.length > 0 ? Px(ik(t, i), r.shape) : t
                    }
                }
            }
        }, {
            kernelName: "Multiply",
            inputsToSave: ["a", "b"],
            gradFunc: function (e, t) {
                var n = t[0],
                    r = t[1],
                    a = kw(n.shape, r.shape);
                return {
                    a: function () {
                        var t = px(e, Ky(r, "float32")),
                            i = ww(n.shape, a);
                        return i.length > 0 ? Px(ik(t, i), n.shape) : t
                    },
                    b: function () {
                        var t = px(e, Ky(n, "float32")),
                            i = ww(r.shape, a);
                        return i.length > 0 ? Px(ik(t, i), r.shape) : t
                    }
                }
            }
        }, {
            kernelName: "Neg",
            gradFunc: function (e) {
                return {
                    x: function () {
                        return ek(e)
                    }
                }
            }
        }, {
            kernelName: "OneHot",
            inputsToSave: ["indices"],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    indices: function () {
                        return Ok(n.shape, "float32")
                    }
                }
            }
        }, {
            kernelName: "OnesLike",
            gradFunc: function (e) {
                return {
                    x: function () {
                        return Sw(e)
                    }
                }
            }
        }, {
            kernelName: "Pack",
            saveAllInputs: !0,
            gradFunc: function (e, t, n) {
                var r = n.axis;
                return QN(e, r).map(function (e) {
                    return function () {
                        return e
                    }
                })
            }
        }, oC, oC, {
            kernelName: Jv,
            inputsToSave: ["a", "b"],
            outputsToSave: [!0],
            gradFunc: function (e, t) {
                var n = t[0],
                    r = t[1],
                    a = t[2],
                    i = n,
                    o = r,
                    s = kw(i.shape, o.shape);
                return {
                    a: function () {
                        var t = Ky(o, "float32"),
                            n = px(e, px(t, Hk(i, ak(t, wN(1))))),
                            r = ww(i.shape, s);
                        return r.length > 0 && (n = ik(n, r)), Px(n, i.shape)
                    },
                    b: function () {
                        var t = Pw(i, 0),
                            n = Iw(t, Yw(i), Sw(i)),
                            r = px(e, px(a, n)),
                            u = ww(o.shape, s);
                        return u.length > 0 && (r = ik(r, u)), Px(r, o.shape)
                    }
                }
            }
        }, {
            kernelName: "Prelu",
            inputsToSave: ["x", "alpha"],
            gradFunc: function (e, t) {
                var n = t[0],
                    r = t[1],
                    a = Pw(n, 0);
                return {
                    x: function () {
                        return Iw(a, e, px(e, r))
                    },
                    alpha: function () {
                        var t = Iw(a, Sw(e), px(e, n)),
                            i = ww(r.shape, e.shape);
                        return i.length > 0 && (t = ik(t, i)), Px(t, r.shape)
                    }
                }
            }
        }, {
            kernelName: "Reciprocal",
            inputsToSave: ["x"],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    x: function () {
                        return cx(e, ek(Rk(n)))
                    }
                }
            }
        }, {
            kernelName: "Relu6",
            inputsToSave: ["x"],
            gradFunc: function (e, t) {
                var n = t[0],
                    r = px(qw(n, 6), GN(n));
                return {
                    x: function () {
                        return px(e, Ky(r, "float32"))
                    }
                }
            }
        }, {
            kernelName: "Relu",
            inputsToSave: ["x"],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    x: function () {
                        return px(e, Ky(GN(n), "float32"))
                    }
                }
            }
        }, {
            kernelName: "Reshape",
            inputsToSave: ["x"],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    x: function () {
                        return Px(e, n.shape)
                    }
                }
            }
        }, {
            kernelName: "ResizeBilinear",
            inputsToSave: ["images"],
            gradFunc: function (e, t, n) {
                var r = {
                    dy: e,
                    images: t[0]
                };
                return {
                    images: function () {
                        return Gg.runKernel("ResizeBilinearGrad", r, n)
                    }
                }
            }
        }, {
            kernelName: "ResizeNearestNeighbor",
            inputsToSave: ["images"],
            gradFunc: function (e, t, n) {
                var r = {
                    dy: e,
                    images: t[0]
                };
                return {
                    images: function () {
                        return Gg.runKernel("ResizeNearestNeighborGrad", r, n)
                    }
                }
            }
        }, {
            kernelName: "Reverse",
            gradFunc: function (e, t, n) {
                var r = fv(n.dims, e.shape);
                return {
                    x: function () {
                        return dN(e, r)
                    }
                }
            }
        }, {
            kernelName: "Round",
            gradFunc: function (e) {
                return {
                    x: function () {
                        return Sw(e)
                    }
                }
            }
        }, {
            kernelName: "Rsqrt",
            inputsToSave: ["x"],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    x: function () {
                        return ek(cx(e, px(Hk(n, 1.5), 2)))
                    }
                }
            }
        }, {
            kernelName: "Select",
            inputsToSave: ["condition"],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    condition: function () {
                        return Ky(Sw(n), "float32")
                    },
                    t: function () {
                        return px(e, Ky(n, e.dtype))
                    },
                    e: function () {
                        return px(e, Ky(gk(n), e.dtype))
                    }
                }
            }
        }, {
            kernelName: "Selu",
            inputsToSave: ["x"],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    x: function () {
                        var t = Pw(n, wN(0)),
                            r = wN(1.7580993408473768),
                            a = wN(LS),
                            i = px(e, a),
                            o = px(px(e, r), Aw(Ky(n, "float32")));
                        return Iw(t, i, o)
                    }
                }
            }
        }, {
            kernelName: "Sigmoid",
            outputsToSave: [!0],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    x: function () {
                        return px(e, px(n, ak(wN(1), n)))
                    }
                }
            }
        }, {
            kernelName: "Sign",
            gradFunc: function (e) {
                return {
                    x: function () {
                        return Sw(e)
                    }
                }
            }
        }, {
            kernelName: Zv,
            inputsToSave: ["x"],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    x: function () {
                        return px(hw(Ky(n, "float32")), e)
                    }
                }
            }
        }, {
            kernelName: "Sinh",
            inputsToSave: ["x"],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    x: function () {
                        return px(fw(Ky(n, "float32")), e)
                    }
                }
            }
        }, {
            kernelName: "Slice",
            inputsToSave: ["x"],
            gradFunc: function (e, t, n) {
                for (var r = t[0], a = n.begin, i = n.size, o = r.shape, s = jb(r, a, i), u = s[0], l = s[1], c = [], p = 0; p < e.rank; p++) c.push([u[p], o[p] - u[p] - l[p]]);
                return {
                    x: function () {
                        return Pk(e, c)
                    }
                }
            }
        }, {
            kernelName: "Softmax",
            outputsToSave: [!0],
            gradFunc: function (e, t, n) {
                var r = t[0],
                    a = n.dim,
                    i = px(e, r);
                return {
                    logits: function () {
                        return ak(i, px(ik(i, [a], !0), r))
                    }
                }
            }
        }, {
            kernelName: "Softplus",
            inputsToSave: ["x"],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    x: function () {
                        return px(e, Ux(n))
                    }
                }
            }
        }, sC, sC, uC, uC, {
            kernelName: "Sqrt",
            inputsToSave: ["x"],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    x: function () {
                        return cx(e, px(BN(Ky(n, "float32")), 2))
                    }
                }
            }
        }, {
            kernelName: "SquaredDifference",
            inputsToSave: ["a", "b"],
            gradFunc: function (e, t) {
                var n = t[0],
                    r = t[1],
                    a = wN(2);
                return {
                    a: function () {
                        return px(e, px(a, ak(n, r)))
                    },
                    b: function () {
                        return px(e, px(a, ak(r, n)))
                    }
                }
            }
        }, {
            kernelName: "Square",
            inputsToSave: ["x"],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    x: function () {
                        return px(e, px(Ky(n, "float32"), 2))
                    }
                }
            }
        }, {
            kernelName: "Step",
            gradFunc: function (e) {
                return {
                    x: function () {
                        return Sw(e)
                    }
                }
            }
        }, {
            kernelName: Qv,
            inputsToSave: ["a", "b"],
            gradFunc: function (e, t) {
                var n = t[0],
                    r = t[1],
                    a = kw(n.shape, r.shape);
                return {
                    a: function () {
                        var t = e,
                            r = ww(n.shape, a);
                        return r.length > 0 && (t = ik(t, r)), Px(t, n.shape)
                    },
                    b: function () {
                        var t = e,
                            n = ww(r.shape, a);
                        return n.length > 0 && (t = ik(t, n)), Px(ek(t), r.shape)
                    }
                }
            }
        }, {
            kernelName: "Sum",
            inputsToSave: ["x"],
            gradFunc: function (e, t, n) {
                var r = t[0],
                    a = r.shape.slice();
                fv(n.axis, r.shape).forEach(function (e) {
                    a[e] = 1
                });
                var i = Px(e, a),
                    o = px(i, Mk(r.shape, "float32"));
                return {
                    x: function () {
                        return o
                    }
                }
            }
        }, {
            kernelName: $v,
            inputsToSave: ["x"],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    x: function () {
                        return cx(e, Rk(hw(n)))
                    }
                }
            }
        }, {
            kernelName: "Tanh",
            outputsToSave: [!0],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    x: function () {
                        return px(ak(wN(1), Rk(n)), e)
                    }
                }
            }
        }, {
            kernelName: "Tile",
            inputsToSave: ["x"],
            gradFunc: function (e, t, n) {
                var r = t[0],
                    a = n.reps;
                return {
                    x: function () {
                        var t = Sw(r);
                        if (1 === r.rank)
                            for (var n = 0; n < a[0]; ++n) t = ux(t, Gx(e, [n * r.shape[0]], [r.shape[0]]));
                        else if (2 === r.rank)
                            for (var i = 0; i < a[0]; ++i)
                                for (var o = 0; o < a[1]; ++o) t = ux(t, Gx(e, [i * r.shape[0], o * r.shape[1]], [r.shape[0], r.shape[1]]));
                        else if (3 === r.rank)
                            for (var s = 0; s < a[0]; ++s)
                                for (var u = 0; u < a[1]; ++u)
                                    for (var l = 0; l < a[2]; ++l) t = ux(t, Gx(e, [s * r.shape[0], u * r.shape[1], l * r.shape[2]], [r.shape[0], r.shape[1], r.shape[2]]));
                        else {
                            if (4 !== r.rank) throw new Error("Gradient for tile operation is not implemented for rank-" + r.rank + " tensors yet.");
                            for (var c = 0; c < a[0]; ++c)
                                for (var p = 0; p < a[1]; ++p)
                                    for (var h = 0; h < a[2]; ++h)
                                        for (var f = 0; f < a[3]; ++f) t = ux(t, Gx(e, [c * r.shape[0], p * r.shape[1], h * r.shape[2], f * r.shape[3]], [r.shape[0], r.shape[1], r.shape[2], r.shape[3]]))
                        }
                        return t
                    }
                }
            }
        }, {
            kernelName: "Transpose",
            gradFunc: function (e, t, n) {
                var r = fk(n.perm);
                return {
                    x: function () {
                        return mb(e, r)
                    }
                }
            }
        }, {
            kernelName: "Unpack",
            gradFunc: function (e, t, n) {
                var r = n.axis;
                return {
                    value: function () {
                        return UN(e, r)
                    }
                }
            }
        }, {
            kernelName: "UnsortedSegmentSum",
            inputsToSave: ["segmentIds"],
            gradFunc: function (e, t) {
                var n = t[0];
                return {
                    x: function () {
                        return function (e, t) {
                            for (var n = Nk(t, Sw(t)), r = zw(e, n), a = Bw(t, wN(0, "int32")), i = r.rank - a.rank, o = 0; o < i; ++o) a = Fw(a, o + 1);
                            a = vk(a, Mk(r.shape, "bool"));
                            var s = Sw(r);
                            return Iw(a, r, s)
                        }(e, n)
                    }
                }
            }
        }, {
            kernelName: "ZerosLike",
            gradFunc: function (e) {
                return {
                    x: function () {
                        return Sw(e)
                    }
                }
            }
        }]; lC < cC.length; lC++) og(cC[lC]);

    function pC() {
        return null == eC && (eC = sx().epsilon()), eC
    }
    Ig().prototype.abs = function () {
        return this.throwIfDisposed(), hx(this)
    }, Ig().prototype.acos = function () {
        return this.throwIfDisposed(), fx(this)
    }, Ig().prototype.acosh = function () {
        return this.throwIfDisposed(), dx(this)
    }, Ig().prototype.add = function (e) {
        return this.throwIfDisposed(), ux(this, e)
    }, Ig().prototype.all = function (e, t) {
        return this.throwIfDisposed(), vx(this, e, t)
    }, Ig().prototype.any = function (e, t) {
        return this.throwIfDisposed(), gx(this, e, t)
    }, Ig().prototype.argMax = function (e) {
        return this.throwIfDisposed(), yx(this, e)
    }, Ig().prototype.argMin = function (e) {
        return this.throwIfDisposed(), bx(this, e)
    }, Ig().prototype.asScalar = function () {
        return this.throwIfDisposed(), nv(1 === this.size, function () {
            return "The array must have only 1 element."
        }), Px(this, [])
    }, Ig().prototype.asType = function (e) {
        return this.throwIfDisposed(), Ky(this, e)
    }, Ig().prototype.as1D = function () {
        return this.throwIfDisposed(), Px(this, [this.size])
    }, Ig().prototype.as2D = function (e, t) {
        return this.throwIfDisposed(), Px(this, [e, t])
    }, Ig().prototype.as3D = function (e, t, n) {
        return this.throwIfDisposed(), Px(this, [e, t, n])
    }, Ig().prototype.as4D = function (e, t, n, r) {
        return this.throwIfDisposed(), Px(this, [e, t, n, r])
    }, Ig().prototype.as5D = function (e, t, n, r, a) {
        return this.throwIfDisposed(), Px(this, [e, t, n, r, a])
    }, Ig().prototype.asin = function () {
        return this.throwIfDisposed(), xx(this)
    }, Ig().prototype.asinh = function () {
        return this.throwIfDisposed(), wx(this)
    }, Ig().prototype.atan = function () {
        return this.throwIfDisposed(), kx(this)
    }, Ig().prototype.atan2 = function (e) {
        return this.throwIfDisposed(), Nx(this, e)
    }, Ig().prototype.atanh = function () {
        return this.throwIfDisposed(), Ix(this)
    }, Ig().prototype.avgPool = function (e, t, n, r) {
        return this.throwIfDisposed(), Bx(this, e, t, n, r)
    }, Ig().prototype.batchToSpaceND = function (e, t) {
        return this.throwIfDisposed(), qx(this, e, t)
    }, Ig().prototype.batchNorm = function (e, t, n, r, a) {
        return this.throwIfDisposed(), Kx(this, e, t, n, r, a)
    }, Ig().prototype.broadcastTo = function (e) {
        return this.throwIfDisposed(), Qx(this, e)
    }, Ig().prototype.cast = function (e) {
        return this.throwIfDisposed(), Ky(this, e)
    }, Ig().prototype.ceil = function () {
        return this.throwIfDisposed(), $x(this)
    }, Ig().prototype.clipByValue = function (e, t) {
        return this.throwIfDisposed(), ew(this, e, t)
    }, Ig().prototype.concat = function (e, t) {
        return this.throwIfDisposed(), e instanceof Ng && (e = [e]), Vx([this].concat(e), t)
    }, Ig().prototype.conv1d = function (e, t, n, r, a, i) {
        return this.throwIfDisposed(), ow(this, e, t, n, r, a, i)
    }, Ig().prototype.conv2dTranspose = function (e, t, n, r, a) {
        return this.throwIfDisposed(), uw(this, e, t, n, r, a)
    }, Ig().prototype.conv2d = function (e, t, n, r, a, i) {
        return this.throwIfDisposed(), iw(this, e, t, n, r, a, i)
    }, Ig().prototype.cos = function () {
        return this.throwIfDisposed(), hw(this)
    }, Ig().prototype.cosh = function () {
        return this.throwIfDisposed(), fw(this)
    }, Ig().prototype.cumsum = function (e, t, n) {
        return this.throwIfDisposed(), dw(this, e, t, n)
    }, Ig().prototype.depthToSpace = function (e, t) {
        return this.throwIfDisposed(), vw(this, e, t)
    }, Ig().prototype.depthwiseConv2d = function (e, t, n, r, a, i) {
        return this.throwIfDisposed(), gw(this, e, t, n, r, a, i)
    }, Ig().prototype.dilation2d = function (e, t, n, r, a) {
        return this.throwIfDisposed(), bw(this, e, t, n, r, a)
    }, Ig().prototype.divNoNan = function (e) {
        return this.throwIfDisposed(), Tw(this, e)
    }, Ig().prototype.div = function (e) {
        return this.throwIfDisposed(), cx(this, e)
    }, Ig().prototype.dot = function (e) {
        return this.throwIfDisposed(), Cw(this, e)
    }, Ig().prototype.elu = function () {
        return this.throwIfDisposed(), Ew(this)
    }, Ig().prototype.equal = function (e) {
        return this.throwIfDisposed(), Nw(this, e)
    }, Ig().prototype.erf = function () {
        return this.throwIfDisposed(), Rw(this)
    }, Ig().prototype.exp = function () {
        return this.throwIfDisposed(), Aw(this)
    }, Ig().prototype.expandDims = function (e) {
        return this.throwIfDisposed(), Fw(this, e)
    }, Ig().prototype.expm1 = function () {
        return this.throwIfDisposed(), _w(this)
    }, Ig().prototype.fft = function () {
        return this.throwIfDisposed(), ON(this)
    }, Ig().prototype.flatten = function () {
        return this.throwIfDisposed(), Px(this, [this.size])
    }, Ig().prototype.floor = function () {
        return this.throwIfDisposed(), Lw(this)
    }, Ig().prototype.floorDiv = function (e) {
        return this.throwIfDisposed(), lx(this, e)
    }, Ig().prototype.gather = function (e, t) {
        return this.throwIfDisposed(), zw(this, e, t)
    }, Ig().prototype.greaterEqual = function (e) {
        return this.throwIfDisposed(), Bw(this, e)
    }, Ig().prototype.greater = function (e) {
        return this.throwIfDisposed(), Pw(this, e)
    }, Ig().prototype.ifft = function () {
        return this.throwIfDisposed(), MN(this)
    }, Ig().prototype.irfft = function () {
        return this.throwIfDisposed(), LN(this)
    }, Ig().prototype.isFinite = function () {
        return this.throwIfDisposed(), Vw(this)
    }, Ig().prototype.isInf = function () {
        return this.throwIfDisposed(), Uw(this)
    }, Ig().prototype.isNaN = function () {
        return this.throwIfDisposed(), Gw(this)
    }, Ig().prototype.leakyRelu = function (e) {
        return this.throwIfDisposed(), jw(this, e)
    }, Ig().prototype.lessEqual = function (e) {
        return this.throwIfDisposed(), qw(this, e)
    }, Ig().prototype.less = function (e) {
        return this.throwIfDisposed(), Hw(this, e)
    }, Ig().prototype.localResponseNormalization = function (e, t, n, r) {
        return this.throwIfDisposed(), Xw(this, e, t, n, r)
    }, Ig().prototype.logSigmoid = function () {
        return this.throwIfDisposed(), nk(this)
    }, Ig().prototype.logSoftmax = function (e) {
        return this.throwIfDisposed(), ok(this, e)
    }, Ig().prototype.logSumExp = function (e, t) {
        return this.throwIfDisposed(), mk(this, e, t)
    }, Ig().prototype.log = function () {
        return this.throwIfDisposed(), Yw(this)
    }, Ig().prototype.log1p = function () {
        return this.throwIfDisposed(), Jw(this)
    }, Ig().prototype.logicalAnd = function (e) {
        return this.throwIfDisposed(), vk(this, e)
    }, Ig().prototype.logicalNot = function () {
        return this.throwIfDisposed(), gk(this)
    }, Ig().prototype.logicalOr = function (e) {
        return this.throwIfDisposed(), yk(this, e)
    }, Ig().prototype.logicalXor = function (e) {
        return this.throwIfDisposed(), bk(this, e)
    }, Ig().prototype.matMul = function (e, t, n) {
        return this.throwIfDisposed(), fb(this, e, t, n)
    }, Ig().prototype.maxPool = function (e, t, n, r) {
        return this.throwIfDisposed(), xk(this, e, t, n, r)
    }, Ig().prototype.max = function (e, t) {
        return this.throwIfDisposed(), rk(this, e, t)
    }, Ig().prototype.maximum = function (e) {
        return this.throwIfDisposed(), Nk(this, e)
    }, Ig().prototype.mean = function (e, t) {
        return this.throwIfDisposed(), Ik(this, e, t)
    }, Ig().prototype.min = function (e, t) {
        return this.throwIfDisposed(), Sk(this, e, t)
    }, Ig().prototype.minimum = function (e) {
        return this.throwIfDisposed(), Tk(this, e)
    }, Ig().prototype.mirrorPad = function (e, t) {
        return this.throwIfDisposed(), Ck(this, e, t)
    }, Ig().prototype.mod = function (e) {
        return this.throwIfDisposed(), Ek(this, e)
    }, Ig().prototype.mul = function (e) {
        return this.throwIfDisposed(), px(this, e)
    }, Ig().prototype.neg = function () {
        return this.throwIfDisposed(), ek(this)
    }, Ig().prototype.norm = function (e, t, n) {
        return this.throwIfDisposed(), aI(this, e, t, n)
    }, Ig().prototype.notEqual = function (e) {
        return this.throwIfDisposed(), Dk(this, e)
    }, Ig().prototype.oneHot = function (e, t, n) {
        return void 0 === t && (t = 1), void 0 === n && (n = 0), this.throwIfDisposed(), db(this, e, t, n)
    }, Ig().prototype.onesLike = function () {
        return this.throwIfDisposed(), Lk(this)
    }, Ig().prototype.pad = function (e, t) {
        return this.throwIfDisposed(), Pk(this, e, t)
    }, Ig().prototype.pool = function (e, t, n, r, a) {
        return this.throwIfDisposed(), jk(this, e, t, n, r, a)
    }, Ig().prototype.pow = function (e) {
        return this.throwIfDisposed(), Hk(this, e)
    }, Ig().prototype.prelu = function (e) {
        return this.throwIfDisposed(), qk(this, e)
    }, Ig().prototype.prod = function (e, t) {
        return this.throwIfDisposed(), Kk(this, e, t)
    }, Ig().prototype.reciprocal = function () {
        return this.throwIfDisposed(), pN(this)
    }, Ig().prototype.relu = function () {
        return this.throwIfDisposed(), hN(this)
    }, Ig().prototype.relu6 = function () {
        return this.throwIfDisposed(), fN(this)
    }, Ig().prototype.reshapeAs = function (e) {
        return this.throwIfDisposed(), Px(this, e.shape)
    }, Ig().prototype.reshape = function (e) {
        return this.throwIfDisposed(), Px(this, e)
    }, Ig().prototype.resizeBilinear = function (e, t, n) {
        return this.throwIfDisposed(), KI(this, e, t, n)
    }, Ig().prototype.resizeNearestNeighbor = function (e, t, n) {
        return this.throwIfDisposed(), XI(this, e, t, n)
    }, Ig().prototype.reverse = function (e) {
        return this.throwIfDisposed(), dN(this, e)
    }, Ig().prototype.rfft = function () {
        return this.throwIfDisposed(), PN(this)
    }, Ig().prototype.round = function () {
        return this.throwIfDisposed(), bN(this)
    }, Ig().prototype.rsqrt = function () {
        return this.throwIfDisposed(), xN(this)
    }, Ig().prototype.selu = function () {
        return this.throwIfDisposed(), kN(this)
    }, Ig().prototype.separableConv2d = function (e, t, n, r, a, i) {
        return this.throwIfDisposed(), NN(this, e, t, n, r, a, i)
    }, Ig().prototype.sigmoid = function () {
        return this.throwIfDisposed(), Ux(this)
    }, Ig().prototype.sign = function () {
        return this.throwIfDisposed(), TN(this)
    }, Ig().prototype.sin = function () {
        return this.throwIfDisposed(), CN(this)
    }, Ig().prototype.sinh = function () {
        return this.throwIfDisposed(), EN(this)
    }, Ig().prototype.slice = function (e, t) {
        return this.throwIfDisposed(), Gx(this, e, t)
    }, Ig().prototype.softmax = function (e) {
        return this.throwIfDisposed(), DN(this, e)
    }, Ig().prototype.softplus = function () {
        return this.throwIfDisposed(), tk(this)
    }, Ig().prototype.spaceToBatchND = function (e, t) {
        return this.throwIfDisposed(), Gk(this, e, t)
    }, Ig().prototype.split = function (e, t) {
        return this.throwIfDisposed(), zN(this, e, t)
    }, Ig().prototype.sqrt = function () {
        return this.throwIfDisposed(), BN(this)
    }, Ig().prototype.square = function () {
        return this.throwIfDisposed(), Rk(this)
    }, Ig().prototype.squaredDifference = function (e) {
        return this.throwIfDisposed(), WN(this, e)
    }, Ig().prototype.squeeze = function (e) {
        return this.throwIfDisposed(), VN(this, e)
    }, Ig().prototype.stack = function (e, t) {
        this.throwIfDisposed();
        var n = e instanceof Ng ? [this, e] : [this].concat(e);
        return UN(n, t)
    }, Ig().prototype.step = function (e) {
        return this.throwIfDisposed(), GN(this, e)
    }, Ig().prototype.stridedSlice = function (e, t, n, r, a, i, o, s) {
        return this.throwIfDisposed(), jN(this, e, t, n, r, a, i, o, s)
    }, Ig().prototype.sub = function (e) {
        return this.throwIfDisposed(), ak(this, e)
    }, Ig().prototype.sum = function (e, t) {
        return this.throwIfDisposed(), ik(this, e, t)
    }, Ig().prototype.tan = function () {
        return this.throwIfDisposed(), HN(this)
    }, Ig().prototype.tanh = function () {
        return this.throwIfDisposed(), jx(this)
    }, Ig().prototype.tile = function (e) {
        return this.throwIfDisposed(), Dw(this, e)
    }, Ig().prototype.toBool = function () {
        return this.throwIfDisposed(), Ky(this, "bool")
    }, Ig().prototype.toFloat = function () {
        return this.throwIfDisposed(), Ky(this, "float32")
    }, Ig().prototype.toInt = function () {
        return this.throwIfDisposed(), Ky(this, "int32")
    }, Ig().prototype.topk = function (e, t) {
        return this.throwIfDisposed(), XN(this, e, t)
    }, Ig().prototype.transpose = function (e) {
        return this.throwIfDisposed(), mb(this, e)
    }, Ig().prototype.unique = function (e) {
        return this.throwIfDisposed(), JN(this, e)
    }, Ig().prototype.unsortedSegmentSum = function (e, t) {
        return this.throwIfDisposed(), ZN(this, e, t)
    }, Ig().prototype.unstack = function (e) {
        return this.throwIfDisposed(), QN(this, e)
    }, Ig().prototype.where = function (e, t) {
        return this.throwIfDisposed(), Iw(e, this, t)
    }, Ig().prototype.zerosLike = function () {
        return this.throwIfDisposed(), Sw(this)
    };
    var hC = function (e) {
            function t(n) {
                var r;
                return r = e.call(this, n) || this, Object.setPrototypeOf(qm(r), t.prototype), r
            }
            return Vm(t, e), t
        }(Hm(Error)),
        fC = function (e) {
            function t(n) {
                var r;
                return r = e.call(this, n) || this, Object.setPrototypeOf(qm(r), t.prototype), r
            }
            return Vm(t, e), t
        }(Hm(Error)),
        dC = function (e) {
            function t(n) {
                var r;
                return r = e.call(this, n) || this, Object.setPrototypeOf(qm(r), t.prototype), r
            }
            return Vm(t, e), t
        }(Hm(Error)),
        mC = function (e) {
            function t(n) {
                var r;
                return r = e.call(this, n) || this, Object.setPrototypeOf(qm(r), t.prototype), r
            }
            return Vm(t, e), t
        }(Hm(Error)),
        vC = function (e) {
            function t(n) {
                var r;
                return r = e.call(this, n) || this, Object.setPrototypeOf(qm(r), t.prototype), r
            }
            return Vm(t, e), t
        }(Hm(Error));

    function gC(e, t) {
        if (Array.isArray(e)) {
            for (var n = [], r = 0; r < t; r++) n = n.concat(e);
            return n
        }
        var a = new Array(t);
        return a.fill(e), a
    }

    function yC(e, t) {
        if (!e) throw new vC(t)
    }

    function bC(e, t) {
        for (var n, r = 0, a = Xm(e); !(n = a()).done;) n.value === t && r++;
        return r
    }

    function xC(e) {
        return 1 === e.length ? e[0] : e
    }

    function wC(e) {
        return Array.isArray(e) ? e : [e]
    }

    function kC(e) {
        var t = e.replace(/(.)([A-Z][a-z0-9]+)/g, "$1_$2").replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
        return "_" !== t[0] ? t : "private" + t
    }

    function NC(e) {
        return e.length <= 1 || -1 === e.indexOf("_") ? e : e.replace(/[_]+(\w|$)/g, function (e, t) {
            return t.toUpperCase()
        })
    }
    Error;
    var IC = {};

    function SC(e) {
        if (null == e) return null;
        var t = {};
        return t.className = e.getClassName(), t.config = e.getConfig(), t
    }

    function TC(e, t, n, r, a) {
        if (void 0 === t && (t = {}), void 0 === n && (n = {}), void 0 === r && (r = "object"), void 0 === a && (a = !1), "string" == typeof e) {
            var i, o = e;
            if (o in n) i = n[o];
            else if (o in IC) i = IC[o];
            else if (null == (i = t[o])) throw new dC("Unknown " + r + ": " + e + ". This may be due to one of the following reasons:\n1. The " + r + " is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom " + r + " is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().");
            return i
        }
        var s = e;
        if (null == s.className || null == s.config) throw new dC(r + ": Improper config format: " + JSON.stringify(s) + ".\n'className' and 'config' must set.");
        var u, l, c = s.className;
        if (c in n) {
            var p = n[c];
            u = p[0], l = p[1]
        } else if (c in IC) {
            var h = IC.className;
            u = h[0], l = h[1]
        } else if (c in t) {
            var f = t[c];
            u = f[0], l = f[1]
        }
        if (null == u) throw new dC("Unknown " + r + ": " + c + ". This may be due to one of the following reasons:\n1. The " + r + " is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom " + r + " is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().");
        if (null != l) {
            for (var d = {}, m = 0, v = Object.keys(IC); m < v.length; m++) {
                var g = v[m];
                d[g] = IC[g]
            }
            for (var y = 0, b = Object.keys(n); y < b.length; y++) {
                var x = b[y];
                d[x] = n[x]
            }
            s.config.customObjects = d;
            for (var w = Object.assign({}, IC), k = 0, N = Object.keys(n); k < N.length; k++) {
                var I = N[k];
                IC[I] = n[I]
            }! function e(t) {
                if (null != t && "object" == typeof t)
                    if (Array.isArray(t)) t.forEach(function (t) {
                        return e(t)
                    });
                    else
                        for (var n = 0, r = Object.keys(t); n < r.length; n++) {
                            var a = r[n],
                                i = t[a];
                            null != i && "object" == typeof i && (Array.isArray(i) || "ndarray" !== i.type || "number" != typeof i.value ? e(i) : t[a] = i.value)
                        }
            }(s.config);
            var S = l(u, s.config, n, a);
            return IC = Object.assign({}, w), S
        }
        for (var T = Object.assign({}, IC), C = 0, E = Object.keys(n); C < E.length; C++) {
            var R = E[C];
            IC[R] = n[R]
        }
        var A = new u(s.config);
        return IC = Object.assign({}, T), A
    }

    function CC(e, t) {
        return -1 * function (e, t) {
            return e < t ? -1 : e > t ? 1 : 0
        }(e, t)
    }

    function EC(e) {
        if (null == e) return e;
        for (var t, n = [], r = Xm(e); !(t = r()).done;) {
            var a = t.value; - 1 === n.indexOf(a) && n.push(a)
        }
        return n
    }

    function RC(e) {
        if (null == e) throw new dC("Invalid value in obj: " + JSON.stringify(e));
        for (var t in e)
            if (e.hasOwnProperty(t)) return !1;
        return !0
    }

    function AC(e, t, n) {
        if (null != n && e.indexOf(n) < 0) throw new dC(n + " is not a valid " + t + ".  Valid values are " + e + " or null/undefined.")
    }

    function FC(e, t, n, r) {
        return void 0 === n && (n = 0), void 0 === r && (r = 1 / 0), yC(n >= 0), yC(r >= n), Array.isArray(e) && e.length >= n && e.length <= r && e.every(function (e) {
            return typeof e === t
        })
    }

    function _C(e, t) {
        Array.isArray(e) ? (nv(e.length > 0, function () {
            return t + " is unexpectedly an empty array."
        }), e.forEach(function (e, n) {
            return _C(e, "element " + (n + 1) + " of " + t)
        })) : nv(Number.isInteger(e) && e > 0, function () {
            return "Expected " + t + " to be a positive integer, but got " + function e(t) {
                return null === t ? "null" : Array.isArray(t) ? "[" + t.map(function (t) {
                    return e(t)
                }).join(",") + "]" : "string" == typeof t ? '"' + t + '"' : "" + t
            }(e) + "."
        })
    }

    function DC(e) {
        return "relu" === e ? "relu" : "linear" === e ? "linear" : "elu" === e ? "elu" : null
    }

    function OC(e, t) {
        return rx(function () {
            return BN(ik(px(e, e), t, !0))
        })
    }
    var MC = function (e) {
            function t() {
                return e.apply(this, arguments) || this
            }
            return Vm(t, e), t.prototype.getConfig = function () {
                return {}
            }, t
        }(Kb),
        LC = function (e) {
            function t(t) {
                var n;
                return (n = e.call(this) || this).defaultMaxValue = 2, n.defaultAxis = 0, n.maxValue = null != t.maxValue ? t.maxValue : n.defaultMaxValue, n.axis = null != t.axis ? t.axis : n.defaultAxis, n
            }
            Vm(t, e);
            var n = t.prototype;
            return n.apply = function (e) {
                var t = this;
                return rx(function () {
                    var n = OC(e, t.axis),
                        r = ew(n, 0, t.maxValue);
                    return px(e, cx(r, ux(pC(), n)))
                })
            }, n.getConfig = function () {
                return {
                    maxValue: this.maxValue,
                    axis: this.axis
                }
            }, t
        }(MC);
    LC.className = "MaxNorm", Yb(LC);
    var zC = function (e) {
        function t(t) {
            var n;
            return (n = e.call(this) || this).defaultAxis = 0, n.axis = null != t.axis ? t.axis : n.defaultAxis, n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.apply = function (e) {
            var t = this;
            return rx(function () {
                return cx(e, ux(pC(), OC(e, t.axis)))
            })
        }, n.getConfig = function () {
            return {
                axis: this.axis
            }
        }, t
    }(MC);
    zC.className = "UnitNorm", Yb(zC);
    var PC = function (e) {
        function t() {
            return e.apply(this, arguments) || this
        }
        return Vm(t, e), t.prototype.apply = function (e) {
            return hN(e)
        }, t
    }(MC);
    PC.className = "NonNeg", Yb(PC);
    var BC = function (e) {
        function t(t) {
            var n;
            return (n = e.call(this) || this).defaultMinValue = 0, n.defaultMaxValue = 1, n.defaultRate = 1, n.defaultAxis = 0, n.minValue = null != t.minValue ? t.minValue : n.defaultMinValue, n.maxValue = null != t.maxValue ? t.maxValue : n.defaultMaxValue, n.rate = null != t.rate ? t.rate : n.defaultRate, n.axis = null != t.axis ? t.axis : n.defaultAxis, n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.apply = function (e) {
            var t = this;
            return rx(function () {
                var n = OC(e, t.axis),
                    r = ux(px(t.rate, ew(n, t.minValue, t.maxValue)), px(1 - t.rate, n));
                return px(e, cx(r, ux(pC(), n)))
            })
        }, n.getConfig = function () {
            return {
                minValue: this.minValue,
                maxValue: this.maxValue,
                rate: this.rate,
                axis: this.axis
            }
        }, t
    }(MC);
    BC.className = "MinMaxNorm", Yb(BC);
    var WC = {
        maxNorm: "MaxNorm",
        minMaxNorm: "MinMaxNorm",
        nonNeg: "NonNeg",
        unitNorm: "UnitNorm"
    };

    function VC(e) {
        return SC(e)
    }

    function UC(e, t) {
        return void 0 === t && (t = {}), TC(e, Xb.getMap().classNameMap, t, "constraint")
    }

    function GC(e) {
        return null == e ? null : "string" == typeof e ? UC({
            className: e in WC ? WC[e] : e,
            config: {}
        }) : e instanceof MC ? e : UC(e)
    }
    var jC = {
            __proto__: null,
            maxNorm: function (e) {
                return new LC(e)
            },
            unitNorm: function (e) {
                return new zC(e)
            },
            nonNeg: function () {
                return new PC
            },
            minMaxNorm: function (e) {
                return new BC(e)
            }
        },
        HC = ["channelsFirst", "channelsLast"],
        qC = ["nearest", "bilinear"],
        KC = ["valid", "same", "causal"],
        XC = ["max", "avg"],
        YC = ["sum", "mul", "concat", "ave"],
        JC = new Map;

    function ZC(e) {
        AC(HC, "DataFormat", e)
    }

    function QC(e) {
        AC(KC, "PaddingMode", e)
    }

    function $C(e) {
        AC(XC, "PoolMode", e)
    }
    var eE = [];

    function tE(e, t) {
        eE.push(e);
        try {
            var n = t();
            return eE.pop(), n
        } catch (e) {
            throw eE.pop(), e
        }
    }

    function nE(e) {
        if (!iE(e)) throw new Error("Not a valid tensor name: '" + e + "'");
        return (0 === eE.length ? "" : eE.join("/") + "/") + e
    }

    function rE(e) {
        if (!iE(e)) throw new Error("Not a valid tensor name: '" + e + "'");
        JC.has(e) || JC.set(e, 0);
        var t = JC.get(e);
        if (JC.set(e, JC.get(e) + 1), t > 0) {
            var n = e + "_" + t;
            return JC.set(n, 1), n
        }
        return e
    }
    var aE = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);

    function iE(e) {
        return !!e.match(aE)
    }

    function oE(e, t, n) {
        null == t && (t = 0), null == n && (n = e.length);
        for (var r = 1, a = t; a < n; ++a) r *= e[a];
        return r
    }

    function sE(e) {
        return qN(e = Array.isArray(e) ? new Float32Array(e) : e)
    }

    function uE(e) {
        return Sk(sE(e)).dataSync()[0]
    }

    function lE(e) {
        return rk(sE(e)).dataSync()[0]
    }

    function cE(e, t) {
        if (t < e) throw new dC("end (" + t + ") < begin (" + e + ") is forbidden.");
        for (var n = [], r = e; r < t; ++r) n.push(r);
        return n
    }

    function pE(e, t) {
        return e.asType(t)
    }

    function hE(e, t) {
        void 0 === t && (t = -1);
        var n = e.shape.slice();
        return t < 0 && (t = n.length + t + 1), n.splice(t, 0, 1), e.reshape(n)
    }

    function fE(e, t, n) {
        return rx(function () {
            switch (e.rank) {
                case 1:
                    return RN(e, t, n);
                case 2:
                    return AN(e, [t, 0], [n, e.shape[1]]);
                case 3:
                    return FN(e, [t, 0, 0], [n, e.shape[1], e.shape[2]]);
                case 4:
                    return _N(e, [t, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3]]);
                case 5:
                    return Gx(e, [t, 0, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3], e.shape[4]]);
                case 6:
                    return Gx(e, [t, 0, 0, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3], e.shape[4], e.shape[5]]);
                default:
                    throw new dC("sliceAlongFirstAxis() received an unsupported tensor rank: " + e.rank)
            }
        })
    }

    function dE(e, t, n) {
        return rx(function () {
            switch (e.rank) {
                case 1:
                    return RN(e, t, n);
                case 2:
                    return AN(e, [0, t], [e.shape[0], n]);
                case 3:
                    return FN(e, [0, 0, t], [e.shape[0], e.shape[1], n]);
                case 4:
                    return _N(e, [0, 0, 0, t], [e.shape[0], e.shape[1], e.shape[2], n]);
                default:
                    throw new dC("sliceAlongLastAxis() received an unsupported tensor rank: " + e.rank)
            }
        })
    }

    function mE(e, t, n, r) {
        return rx(function () {
            switch (e.rank) {
                case 1:
                    return RN(e, t, n);
                case 2:
                    switch (r) {
                        case 1:
                            return fE(e, t, n);
                        case 2:
                            return dE(e, t, n);
                        default:
                            throw new dC("The axis is not within the rank of the tensor " + r)
                    }
                    case 3:
                        switch (r) {
                            case 1:
                                return fE(e, t, n);
                            case 2:
                                return FN(e, [0, t, 0], [e.shape[0], n, e.shape[2]]);
                            case 3:
                                return dE(e, t, n);
                            default:
                                throw new dC("The axis is not within the rank of the tensor " + r)
                        }
                        case 4:
                            switch (r) {
                                case 1:
                                    return fE(e, t, n);
                                case 2:
                                    return _N(e, [0, t, 0, 0], [e.shape[0], n, e.shape[2], e.shape[3]]);
                                case 3:
                                    return _N(e, [0, 0, t, 0], [e.shape[0], e.shape[1], n, e.shape[3]]);
                                case 4:
                                    return dE(e, t, n);
                                default:
                                    throw new dC("The axis is not within the rank of the tensor " + r)
                            }
                            default:
                                throw new dC("sliceAlongLastAxis() received an unsupported tensor rank: " + e.rank)
            }
        })
    }

    function vE(e, t) {
        var n;
        return void 0 === t && (t = -1), t < 0 && (t = 0 !== (n = e[0].rank) ? n : 0), t === e[0].rank && (t = -1), Vx(e, t)
    }

    function gE(e, t) {
        switch (e.rank) {
            case 1:
                return tw([e, t]);
            case 2:
                return nw([e, t], 0);
            case 3:
                return rw([e, t], 0);
            case 4:
                return aw([e, t], 0);
            default:
                throw new dC("concatAlongFirstAxis() received an unsupported tensor rank: " + e.rank)
        }
    }

    function yE(e, t) {
        if (Array.isArray(t) || (t = [t]), e.rank !== t.length) throw new dC("The length of input n (" + t.length + ") does not match the number of dimensions in input x (" + e.rank + ")");
        return Dw(e, t)
    }

    function bE(e, t, n, r, a) {
        return void 0 === t && (t = 0), void 0 === n && (n = 1), sN(e, t, n, r, a)
    }

    function xE(e, t, n, r) {
        if (e.rank < 2 || t.rank < 2) throw new mC("dot requires both inputs to be rank >= 2 but got x shape = " + e.shape + " and y shape = " + t.shape);
        if (t.rank >= 3 && e.shape.slice(-1)[0] !== t.shape.slice(-2)[0]) throw new mC("If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = " + e.shape + " and  y shape = " + t.shape);
        if (2 === e.rank && 2 === t.rank) return kI({
            a: e,
            b: t,
            transposeA: !1,
            transposeB: !1,
            bias: r ? NE(e.rank, r, "channelsLast") : null,
            activation: n
        });
        var a = e.shape.slice(),
            i = a.pop();
        e = e.reshape([-1, i]);
        var o = t.shape.slice(),
            s = o.pop(),
            u = o.pop(),
            l = [].concat(o, [s]),
            c = Array.from({
                length: t.rank
            }, function (e, n) {
                return 0 === n ? t.rank - 2 : n <= t.rank - 2 ? n - 1 : n
            });
        t = t.transpose(c).reshape([u, -1]);
        var p = [].concat(a, l);
        return kI({
            a: e,
            b: t,
            transposeA: !1,
            transposeB: !1,
            bias: r ? NE(e.rank, r, "channelsLast") : null,
            activation: n
        }).reshape(p)
    }

    function wE(e, t, n) {
        return rx(function () {
            return t = Array.isArray(t) ? qN(t, "int32") : t.toInt(), zw(e, t, n)
        })
    }

    function kE(e) {
        return px(e, e)
    }

    function NE(e, t, n) {
        var r = t.shape;
        if (1 !== t.rank && t.rank !== e) throw new dC("Unexpected bias dimensions: " + t.rank + "; expected it to be 1 or " + e);
        if (5 === e) {
            if ("channelsFirst" === n) return 1 === r.length ? t.reshape([1, r[0], 1, 1, 1]) : t.reshape([1, r[3], r[0], r[1], r[2]]);
            if ("channelsLast" === n) return 1 === r.length ? t.reshape([1, 1, 1, 1, r[0]]) : t.reshape([1].concat(r))
        } else if (4 === e) {
            if ("channelsFirst" === n) return 1 === r.length ? t.reshape([1, r[0], 1, 1]) : t.reshape([1, r[2], r[0], r[1]]);
            if ("channelsLast" === n) return 1 === r.length ? t.reshape([1, 1, 1, r[0]]) : t.reshape([1].concat(r))
        } else if (3 === e) {
            if ("channelsFirst" === n) return 1 === r.length ? t.reshape([1, r[0], 1]) : t.reshape([1, r[1], r[0]]);
            if ("channelsLast" === n) return 1 === r.length ? t.reshape([1, 1, r[0]]) : t.reshape([1].concat(r))
        } else if (e < 3) return t;
        throw new dC("Unsupported input rank by biasAdd: " + t.rank)
    }

    function IE(e, t, n) {
        return rx(function () {
            return null == n && (n = "channelsLast"), ZC(n), e.add(NE(e.rank, t, n))
        })
    }

    function SE(e, t, n, r) {
        return rx(function () {
            return lI(e, t, n, r)
        })
    }

    function TE(e, t, n) {
        return void 0 === n && (n = !1), n ? e() : t()
    }
    var CE = ["fanIn", "fanOut", "fanAvg"],
        EE = ["normal", "uniform", "truncatedNormal"],
        RE = function (e) {
            function t() {
                return e.apply(this, arguments) || this
            }
            Vm(t, e);
            var n = t.prototype;
            return n.fromConfigUsesCustomObjects = function () {
                return !1
            }, n.getConfig = function () {
                return {}
            }, t
        }(Kb),
        AE = function (e) {
            function t() {
                return e.apply(this, arguments) || this
            }
            return Vm(t, e), t.prototype.apply = function (e, t) {
                return Ok(e, t)
            }, t
        }(RE);
    AE.className = "Zeros", Yb(AE);
    var FE = function (e) {
        function t() {
            return e.apply(this, arguments) || this
        }
        return Vm(t, e), t.prototype.apply = function (e, t) {
            return Mk(e, t)
        }, t
    }(RE);
    FE.className = "Ones", Yb(FE);
    var _E = function (e) {
        function t(t) {
            var n;
            if (n = e.call(this) || this, "object" != typeof t) throw new dC("Expected argument of type ConstantConfig but got " + t);
            if (void 0 === t.value) throw new dC("config must have value set but got " + t);
            return n.value = t.value, n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.apply = function (e, t) {
            var n = this;
            return rx(function () {
                return px(wN(n.value), Mk(e, t))
            })
        }, n.getConfig = function () {
            return {
                value: this.value
            }
        }, t
    }(RE);
    _E.className = "Constant", Yb(_E);
    var DE = function (e) {
        function t(t) {
            var n;
            return (n = e.call(this) || this).DEFAULT_MINVAL = -.05, n.DEFAULT_MAXVAL = .05, n.minval = t.minval || n.DEFAULT_MINVAL, n.maxval = t.maxval || n.DEFAULT_MAXVAL, n.seed = t.seed, n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.apply = function (e, t) {
            return uN(e, this.minval, this.maxval, t)
        }, n.getConfig = function () {
            return {
                minval: this.minval,
                maxval: this.maxval,
                seed: this.seed
            }
        }, t
    }(RE);
    DE.className = "RandomUniform", Yb(DE);
    var OE = function (e) {
        function t(t) {
            var n;
            return (n = e.call(this) || this).DEFAULT_MEAN = 0, n.DEFAULT_STDDEV = .05, n.mean = t.mean || n.DEFAULT_MEAN, n.stddev = t.stddev || n.DEFAULT_STDDEV, n.seed = t.seed, n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.apply = function (e, t) {
            if ("float32" !== (t = t || "float32") && "int32" !== t) throw new mC("randomNormal does not support dType " + t + ".");
            return bE(e, this.mean, this.stddev, t, this.seed)
        }, n.getConfig = function () {
            return {
                mean: this.mean,
                stddev: this.stddev,
                seed: this.seed
            }
        }, t
    }(RE);
    OE.className = "RandomNormal", Yb(OE);
    var ME = function (e) {
        function t(t) {
            var n;
            return (n = e.call(this) || this).DEFAULT_MEAN = 0, n.DEFAULT_STDDEV = .05, n.mean = t.mean || n.DEFAULT_MEAN, n.stddev = t.stddev || n.DEFAULT_STDDEV, n.seed = t.seed, n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.apply = function (e, t) {
            if ("float32" !== (t = t || "float32") && "int32" !== t) throw new mC("truncatedNormal does not support dType " + t + ".");
            return YN(e, this.mean, this.stddev, t, this.seed)
        }, n.getConfig = function () {
            return {
                mean: this.mean,
                stddev: this.stddev,
                seed: this.seed
            }
        }, t
    }(RE);
    ME.className = "TruncatedNormal", Yb(ME);
    var LE = function (e) {
        function t(t) {
            var n;
            return (n = e.call(this) || this).gain = null != t.gain ? t.gain : 1, n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.apply = function (e, t) {
            var n = this;
            return rx(function () {
                if (2 !== e.length || e[0] !== e[1]) throw new dC("Identity matrix initializer can only be used for 2D square matrices.");
                return px(n.gain, Ow(e[0]))
            })
        }, n.getConfig = function () {
            return {
                gain: this.gain
            }
        }, t
    }(RE);
    LE.className = "Identity", Yb(LE);
    var zE = function (e) {
        function t(t) {
            var n, r;
            if (n = e.call(this) || this, t.scale < 0) throw new dC("scale must be a positive float. Got: " + t.scale);
            return n.scale = null == t.scale ? 1 : t.scale, n.mode = null == t.mode ? "fanIn" : t.mode, r = n.mode, AC(CE, "FanMode", r), n.distribution = null == t.distribution ? "normal" : t.distribution,
                function (e) {
                    AC(EE, "Distribution", e)
                }(n.distribution), n.seed = t.seed, n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.apply = function (e, t) {
            var n = function (e, t) {
                    var n, r;
                    if (void 0 === t && (t = "channelsLast"), ZC(t), 2 === e.length) n = e[0], r = e[1];
                    else if (-1 !== [3, 4, 5].indexOf(e.length)) {
                        if ("channelsFirst" === t) {
                            var a = oE(e, 2);
                            n = e[1] * a, r = e[0] * a
                        } else if ("channelsLast" === t) {
                            var i = oE(e, 0, e.length - 2);
                            n = e[e.length - 2] * i, r = e[e.length - 1] * i
                        }
                    } else {
                        var o = oE(e);
                        n = Math.sqrt(o), r = Math.sqrt(o)
                    }
                    return [n, r]
                }(e),
                r = n[0],
                a = n[1],
                i = this.scale;
            if ("fanIn" === this.mode ? i /= Math.max(1, r) : "fanOut" === this.mode ? i /= Math.max(1, a) : i /= Math.max(1, (r + a) / 2), "normal" === this.distribution) {
                var o = Math.sqrt(i);
                if ("float32" !== (t = t || "float32") && "int32" !== t) throw new mC(this.getClassName() + " does not support dType " + t + ".");
                return YN(e, 0, o, t, this.seed)
            }
            var s = Math.sqrt(3 * i);
            return uN(e, -s, s, t)
        }, n.getConfig = function () {
            return {
                scale: this.scale,
                mode: this.mode,
                distribution: this.distribution,
                seed: this.seed
            }
        }, t
    }(RE);
    zE.className = "VarianceScaling", Yb(zE);
    var PE = function (e) {
        function t(t) {
            return e.call(this, {
                scale: 1,
                mode: "fanAvg",
                distribution: "uniform",
                seed: null == t ? null : t.seed
            }) || this
        }
        return Vm(t, e), t.prototype.getClassName = function () {
            return zE.className
        }, t
    }(zE);
    PE.className = "GlorotUniform", Yb(PE);
    var BE = function (e) {
        function t(t) {
            return e.call(this, {
                scale: 1,
                mode: "fanAvg",
                distribution: "normal",
                seed: null == t ? null : t.seed
            }) || this
        }
        return Vm(t, e), t.prototype.getClassName = function () {
            return zE.className
        }, t
    }(zE);
    BE.className = "GlorotNormal", Yb(BE);
    var WE = function (e) {
        function t(t) {
            return e.call(this, {
                scale: 2,
                mode: "fanIn",
                distribution: "normal",
                seed: null == t ? null : t.seed
            }) || this
        }
        return Vm(t, e), t.prototype.getClassName = function () {
            return zE.className
        }, t
    }(zE);
    WE.className = "HeNormal", Yb(WE);
    var VE = function (e) {
        function t(t) {
            return e.call(this, {
                scale: 2,
                mode: "fanIn",
                distribution: "uniform",
                seed: null == t ? null : t.seed
            }) || this
        }
        return Vm(t, e), t.prototype.getClassName = function () {
            return zE.className
        }, t
    }(zE);
    VE.className = "HeUniform", Yb(VE);
    var UE = function (e) {
        function t(t) {
            return e.call(this, {
                scale: 1,
                mode: "fanIn",
                distribution: "normal",
                seed: null == t ? null : t.seed
            }) || this
        }
        return Vm(t, e), t.prototype.getClassName = function () {
            return zE.className
        }, t
    }(zE);
    UE.className = "LeCunNormal", Yb(UE);
    var GE = function (e) {
        function t(t) {
            return e.call(this, {
                scale: 1,
                mode: "fanIn",
                distribution: "uniform",
                seed: null == t ? null : t.seed
            }) || this
        }
        return Vm(t, e), t.prototype.getClassName = function () {
            return zE.className
        }, t
    }(zE);
    GE.className = "LeCunNormal", Yb(GE);
    var jE = function (e) {
        function t(t) {
            var n;
            if ((n = e.call(this) || this).DEFAULT_GAIN = 1, n.gain = null == t.gain ? n.DEFAULT_GAIN : t.gain, n.seed = t.seed, null != n.seed) throw new mC("Random seed is not implemented for Orthogonal Initializer yet.");
            return n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.apply = function (e, t) {
            var n = this;
            return rx(function () {
                if (e.length < 2) throw new mC("Shape must be at least 2D.");
                e[0] * e[1] > 2e3 && console.warn("Orthogonal initializer is being called on a matrix with more than 2000 (" + e[0] * e[1] + ") elements: Slowness may result.");
                var t = bE(e[0] > e[1] ? [e[1], e[0]] : e, 0, 1, "float32"),
                    r = fS.gramSchmidt(t);
                return e[0] > e[1] && (r = r.transpose()), px(n.gain, r)
            })
        }, n.getConfig = function () {
            return {
                gain: this.gain,
                seed: this.seed
            }
        }, t
    }(RE);
    jE.className = "Orthogonal", Yb(jE);
    var HE = {
        constant: "Constant",
        glorotNormal: "GlorotNormal",
        glorotUniform: "GlorotUniform",
        heNormal: "HeNormal",
        heUniform: "HeUniform",
        identity: "Identity",
        leCunNormal: "LeCunNormal",
        leCunUniform: "LeCunUniform",
        ones: "Ones",
        orthogonal: "Orthogonal",
        randomNormal: "RandomNormal",
        randomUniform: "RandomUniform",
        truncatedNormal: "TruncatedNormal",
        varianceScaling: "VarianceScaling",
        zeros: "Zeros"
    };

    function qE(e, t) {
        return void 0 === t && (t = {}), TC(e, Xb.getMap().classNameMap, t, "initializer")
    }

    function KE(e) {
        return SC(e)
    }

    function XE(e) {
        if ("string" == typeof e) {
            var t = e in HE ? HE[e] : e;
            if ("GlorotNormal" === t) return new BE;
            if ("GlorotUniform" === t) return new PE;
            if ("HeNormal" === t) return new WE;
            if ("HeUniform" === t) return new VE;
            if ("LeCunNormal" === t) return new UE;
            if ("LeCunUniform" === t) return new GE;
            var n = {};
            return n.className = t, n.config = {}, qE(n)
        }
        return e instanceof RE ? e : qE(e)
    }
    var YE = {
            __proto__: null,
            zeros: function () {
                return new AE
            },
            ones: function () {
                return new FE
            },
            constant: function (e) {
                return new _E(e)
            },
            randomUniform: function (e) {
                return new DE(e)
            },
            randomNormal: function (e) {
                return new OE(e)
            },
            truncatedNormal: function (e) {
                return new ME(e)
            },
            identity: function (e) {
                return new LE(e)
            },
            varianceScaling: function (e) {
                return new zE(e)
            },
            glorotUniform: function (e) {
                return new PE(e)
            },
            glorotNormal: function (e) {
                return new BE(e)
            },
            heNormal: function (e) {
                return new WE(e)
            },
            heUniform: function (e) {
                return new VE(e)
            },
            leCunNormal: function (e) {
                return new UE(e)
            },
            leCunUniform: function (e) {
                return new GE(e)
            },
            orthogonal: function (e) {
                return new jE(e)
            }
        },
        JE = 0;

    function ZE() {
        return JE++
    }
    var QE = {};

    function $E(e) {
        return void 0 === e && (e = ""), e in QE || (QE[e] = 0), QE[e] += 1, e + QE[e].toString()
    }

    function eR(e) {
        return Array.isArray(e) && Array.isArray(e[0])
    }

    function tR(e) {
        return 0 === e.length ? [] : Array.isArray(e[0]) ? e : [e]
    }

    function nR(e) {
        var t;
        if (Array.isArray(e)) {
            if (1 !== e.length) throw new dC("Expected Tensor length to be 1; got " + e.length);
            t = e[0]
        } else t = e;
        return t
    }

    function rR(e) {
        if (Array.isArray(e) && Array.isArray(e[0])) {
            if (1 === e.length) return (e = e)[0];
            throw new dC("Expected exactly 1 Shape; got " + e.length)
        }
        return e
    }

    function aR(e) {
        for (var t, n = 0, r = Xm(e); !(t = r()).done;) {
            var a = t.value;
            0 === a.shape.length ? n += 1 : n += a.shape.reduce(function (e, t) {
                return e * t
            })
        }
        return n
    }
    var iR = function () {
        function e(e, t, n, r, a) {
            void 0 === t && (t = "float32"), void 0 === n && (n = "Variable"), void 0 === r && (r = !0), void 0 === a && (a = null), this.dtype = null == t ? "float32" : t, this.shape = e.shape, this.id = ZE(), n = null == n ? "Variable" : n, this.originalName = nE(n), this.name = rE(this.originalName), this.trainable_ = r, this.constraint = a, this.val = $N(e, this.trainable_, this.name, this.dtype)
        }
        var t = e.prototype;
        return t.read = function () {
            return this.assertNotDisposed(), this.val
        }, t.write = function (e) {
            return this.assertNotDisposed(),
                function (e, t) {
                    if (e.shape.toString() !== t.shape.toString()) throw new Error("Shape mismatch: " + JSON.stringify(e.shape) + " vs. " + JSON.stringify(t.shape))
                }(this.val, e), this.val.id !== e.id && (this.val.assign(e), null != this.constraint && this.val.assign(this.constraint.apply(this.val))), this
        }, t.dispose = function () {
            this.assertNotDisposed(), this.val.dispose()
        }, t.assertNotDisposed = function () {
            if (this.val.isDisposed) throw new Error("LayersVariable " + this.name + " is already disposed.")
        }, Wm(e, [{
            key: "trainable",
            get: function () {
                return this.trainable_
            },
            set: function (e) {
                this.trainable_ = e, this.val.trainable = e
            }
        }]), e
    }();

    function oR(e) {
        return e.map(function (e) {
            return e.read()
        })
    }

    function sR(e) {
        e.forEach(function (e) {
            e[0].write(e[1])
        })
    }
    var uR, lR = function (e) {
            this.dtype = e.dtype, this.shape = e.shape, null != e.shape ? this.ndim = e.shape.length : this.ndim = e.ndim, this.maxNDim = e.maxNDim, this.minNDim = e.minNDim, this.axes = e.axes || {}
        },
        cR = function (e, t, n, r, a, i, o) {
            this.dtype = e, this.shape = t, this.sourceLayer = n, this.inputs = r, this.callArgs = a, this.outputTensorIndex = o, this.id = ZE(), null != i && (this.originalName = nE(i), this.name = rE(this.originalName)), this.rank = t.length
        },
        pR = 0,
        hR = function () {
            function e(e, t) {
                this.callArgs = t, this.id = pR++, this.outboundLayer = e.outboundLayer, this.inboundLayers = e.inboundLayers, this.nodeIndices = e.nodeIndices, this.tensorIndices = e.tensorIndices, this.inputTensors = e.inputTensors, this.outputTensors = e.outputTensors, this.inputMasks = e.inputMasks, this.outputMasks = e.outputMasks, this.inputShapes = e.inputShapes, this.outputShapes = e.outputShapes;
                for (var n, r = Xm(e.inboundLayers); !(n = r()).done;) {
                    var a = n.value;
                    null != a && a.outboundNodes.push(this)
                }
                e.outboundLayer.inboundNodes.push(this)
            }
            return e.prototype.getConfig = function () {
                for (var e, t = [], n = Xm(this.inboundLayers); !(e = n()).done;) {
                    var r = e.value;
                    null != r ? t.push(r.name) : t.push(null)
                }
                return {
                    outboundLayer: this.outboundLayer ? this.outboundLayer.name : null,
                    inboundLayers: t,
                    nodeIndices: this.nodeIndices,
                    tensorIndices: this.tensorIndices
                }
            }, e
        }(),
        fR = 0,
        dR = function (e) {
            function t(t) {
                var n;
                void 0 === t && (t = {}), (n = e.call(this) || this)._callHook = null, n._addedWeightNames = [], n._stateful = !1, n.id = fR++, n.activityRegularizer = null, n.inputSpec = null, n.supportsMasking = !1, n._trainableWeights = [], n._nonTrainableWeights = [], n._losses = [], n._updates = [], n._built = !1, n.inboundNodes = [], n.outboundNodes = [];
                var r = t.name;
                if (!r) {
                    var a = n.getClassName();
                    r = kC(a) + "_" + $E(a)
                }
                if (n.name = r, n.trainable_ = null == t.trainable || t.trainable, null != t.inputShape || null != t.batchInputShape) {
                    var i;
                    if (null != t.batchInputShape) i = t.batchInputShape;
                    else if (null != t.inputShape) {
                        var o = null;
                        null != t.batchSize && (o = t.batchSize), i = [o].concat(t.inputShape)
                    }
                    n.batchInputShape = i;
                    var s = t.dtype;
                    null == s && (s = t.inputDType), null == s && (s = "float32"), n.dtype = s
                }
                return null != t.weights ? n.initialWeights = t.weights : n.initialWeights = null, n._refCount = null, n.fastWeightInitDuringBuild = !1, n
            }
            Vm(t, e), t.nodeKey = function (e, t) {
                return e.name + "_ib-" + t.toString()
            };
            var n = t.prototype;
            return n.getNodeAtIndex = function (e, t) {
                if (0 === this.inboundNodes.length) throw new fC("The layer has never been called and thus has no defined " + t + ".");
                if (this.inboundNodes.length <= e) throw new dC("Asked to get " + t + " at node " + e + ", but the layer has only " + this.inboundNodes.length + " inbound nodes.");
                return this.inboundNodes[e]
            }, n.getInputAt = function (e) {
                return xC(this.getNodeAtIndex(e, "input").inputTensors)
            }, n.getOutputAt = function (e) {
                return xC(this.getNodeAtIndex(e, "output").outputTensors)
            }, n.calculateLosses = function () {
                return this.losses.map(function (e) {
                    return e()
                })
            }, n.resetStates = function () {
                if (!this.stateful) throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")
            }, n.assertInputCompatibility = function (e) {
                if (e = wC(e), null != this.inputSpec && 0 !== this.inputSpec.length) {
                    var t = wC(this.inputSpec);
                    if (e.length !== t.length) throw new dC("Layer " + this.name + " expects " + t.length + " inputs, but it received " + e.length + " input tensors. Input received: " + e);
                    for (var n = 0; n < e.length; n++) {
                        var r = e[n],
                            a = t[n];
                        if (null != a) {
                            var i = r.rank;
                            if (null != a.ndim && i !== a.ndim) throw new dC("Input " + n + " is incompatible with layer " + this.name + ": expected ndim=" + a.ndim + ", found ndim=" + i);
                            if (null != a.maxNDim && i > a.maxNDim) throw new dC("Input " + n + " is incompatible with layer " + this.name + ": expected max_ndim=" + a.maxNDim + ", found ndim=" + i);
                            if (null != a.minNDim && i < a.minNDim) throw new dC("Input " + n + " is incompatible with layer " + this.name + ": expected min_ndim=" + a.minNDim + ", found ndim=" + i + ".");
                            if (null != a.dtype && r.dtype !== a.dtype) throw new dC("Input " + n + " is incompatible with layer " + this.name + " : expected dtype=" + a.dtype + ", found dtype=" + r.dtype + ".");
                            if (a.axes) {
                                var o = r.shape;
                                for (var s in a.axes) {
                                    var u = Number(s),
                                        l = a.axes[s],
                                        c = u >= 0 ? o[u] : o[o.length + u];
                                    if (null != l && -1 === [l, null].indexOf(c)) throw new dC("Input " + n + " is incompatible with layer " + this.name + ": expected axis " + u + " of input shape to have value " + l + " but got shape " + o + ".")
                                }
                            }
                            if (null != a.shape)
                                for (var p = 0; p < a.shape.length; ++p) {
                                    var h = a.shape[p],
                                        f = r.shape[p];
                                    if (null != h && null != f && h !== f) throw new dC("Input " + n + " is incompatible with layer " + this.name + ": expected shape=" + a.shape + ", found shape=" + r.shape + ".")
                                }
                        }
                    }
                }
            }, n.call = function (e, t) {
                return e
            }, n.invokeCallHook = function (e, t) {
                null != this._callHook && this._callHook(e, t)
            }, n.setCallHook = function (e) {
                this._callHook = e
            }, n.clearCallHook = function () {
                this._callHook = null
            }, n.apply = function (e, t) {
                var n = this;
                t = t || {}, this.assertNotDisposed();
                for (var r, a = wC(e), i = !0, o = Xm(a); !(r = o()).done;)
                    if (!(r.value instanceof cR)) {
                        i = !1;
                        break
                    } for (var s, u = !0, l = Xm(a); !(s = l()).done;)
                    if (s.value instanceof cR) {
                        u = !1;
                        break
                    } if (i === u) throw new dC("Arguments to apply() must be all SymbolicTensors or all Tensors");
                return tE(this.name, function () {
                    if (!n.built) {
                        n.assertInputCompatibility(e);
                        for (var r, i = [], o = Xm(wC(e)); !(r = o()).done;) {
                            var s = r.value;
                            i.push(s.shape)
                        }
                        n.build(xC(i)), n.built = !0, n.initialWeights && n.setWeights(n.initialWeights), null === n._refCount && u && (n._refCount = 1)
                    }
                    if (n.assertInputCompatibility(e), u) {
                        for (var l, c = n.call(e, t), p = [], h = Xm(wC(c)); !(l = h()).done;) {
                            var f = l.value; - 1 !== a.indexOf(f) && (f = f.clone()), p.push(f)
                        }
                        if (c = xC(p), null != n.activityRegularizer) throw new mC("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
                        return c
                    }
                    var d, m = function (e) {
                            for (var t, n = [], r = Xm(e = wC(e)); !(t = r()).done;) {
                                var a = t.value;
                                n.push(a.shape)
                            }
                            return xC(n)
                        }(e),
                        v = n.computeOutputShape(m);
                    if (n.warnOnIncompatibleInputShape(Array.isArray(e) ? m[0] : m), d = null != v && v.length > 0 && Array.isArray(v[0]) ? v.map(function (r, a) {
                            return new cR("float32", r, n, wC(e), t, n.name, a)
                        }) : new cR("float32", v, n, wC(e), t, n.name), n.addInboundNode(e, d, null, null, m, v, t), n._refCount++, null != n.activityRegularizer) throw new mC("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
                    return d
                })
            }, n.warnOnIncompatibleInputShape = function (e) {
                if (null != this.batchInputShape)
                    if (e.length !== this.batchInputShape.length) console.warn("The rank of the input tensor provided (shape: " + JSON.stringify(e) + ") does not match that of the batchInputShape (" + JSON.stringify(this.batchInputShape) + ") of the layer " + this.name);
                    else {
                        var t = !1;
                        this.batchInputShape.forEach(function (n, r) {
                            null != n && null != e[r] && e[r] !== n && (t = !0)
                        }), t && console.warn("The shape of the input tensor (" + JSON.stringify(e) + ") does not match the expectation of layer " + this.name + ": " + JSON.stringify(this.batchInputShape))
                    }
            }, n.countParams = function () {
                if (!this.built) throw new fC("You tried to call countParams() on " + this.name + ", but the layer is not built yet. Build it first by calling build(batchInputShape).");
                return aR(this.weights)
            }, n.build = function (e) {
                this.built = !0
            }, n.getWeights = function (e) {
                return void 0 === e && (e = !1), oR(e ? this.trainableWeights : this.weights)
            }, n.setWeights = function (e) {
                var t = this;
                rx(function () {
                    var n = t.weights;
                    if (n.length !== e.length) throw new dC('You called setWeights(weights) on layer "' + t.name + '" with a weight list of length ' + e.length + ", but the layer was expecting " + n.length + " weights. Provided weights: " + e + "...");
                    if (0 !== n.length) {
                        for (var r = [], a = oR(n), i = 0; i < a.length; ++i) {
                            var o = a[i],
                                s = n[i],
                                u = e[i];
                            if (!sv(o.shape, u.shape)) throw new dC("Layer weight shape " + o.shape + " not compatible with provided weight shape " + u.shape);
                            r.push([s, u])
                        }
                        sR(r)
                    }
                })
            }, n.addWeight = function (e, t, n, r, a, i, o) {
                if (-1 !== this._addedWeightNames.indexOf(e)) throw new dC("Duplicate weight name " + e + " for layer " + this.name);
                this._addedWeightNames.push(e), null == n && (n = "float32"), this.fastWeightInitDuringBuild && (r = XE("zeros"));
                var s = r.apply(t, n),
                    u = new iR(s, n, e, i, o);
                return s.dispose(), null != a && this.addLoss(function () {
                    return a.apply(u.read())
                }), null == i && (i = !0), i ? this._trainableWeights.push(u) : this._nonTrainableWeights.push(u), u
            }, n.setFastWeightInitDuringBuild = function (e) {
                this.fastWeightInitDuringBuild = e
            }, n.addLoss = function (e) {
                var t;
                null == e || Array.isArray(e) && 0 === e.length || (e = wC(e), void 0 !== this._losses && null !== this._losses && (t = this.losses).push.apply(t, e))
            }, n.computeOutputShape = function (e) {
                return e
            }, n.computeMask = function (e, t) {
                var n = this;
                if (!this.supportsMasking) {
                    if (null != t) {
                        if (!Array.isArray(t)) throw new TypeError("Layer " + this.name + " does not support masking, but was passed an inputMask.");
                        t.forEach(function (e) {
                            if (null != e) throw new TypeError("Layer " + n.name + " does not support masking, but was passed an inputMask.")
                        })
                    }
                    return null
                }
                return t
            }, n.addInboundNode = function (e, t, n, r, a, i, o) {
                void 0 === o && (o = null);
                var s = wC(e);
                t = wC(t), n = wC(n), r = wC(r), a = tR(a), i = tR(i);
                for (var u, l = [], c = [], p = [], h = Xm(s); !(u = h()).done;) {
                    var f = u.value;
                    l.push(f.sourceLayer), c.push(f.nodeIndex), p.push(f.tensorIndex)
                }
                new hR({
                    outboundLayer: this,
                    inboundLayers: l,
                    nodeIndices: c,
                    tensorIndices: p,
                    inputTensors: s,
                    outputTensors: t,
                    inputMasks: n,
                    outputMasks: r,
                    inputShapes: a,
                    outputShapes: i
                }, o);
                for (var d = 0; d < t.length; d++) t[d].sourceLayer = this, t[d].nodeIndex = this.inboundNodes.length - 1, t[d].tensorIndex = d
            }, n.getConfig = function () {
                var e = {
                    name: this.name,
                    trainable: this.trainable
                };
                return null != this.batchInputShape && (e.batchInputShape = this.batchInputShape), null != this.dtype && (e.dtype = this.dtype), e
            }, n.disposeWeights = function () {
                return this.weights.forEach(function (e) {
                    return e.dispose()
                }), this.weights.length
            }, n.assertNotDisposed = function () {
                if (0 === this._refCount) throw new Error("Layer '" + this.name + "' is already disposed.")
            }, n.dispose = function () {
                if (!this.built) throw new Error("Cannot dispose Layer " + this.name + " because it has not been built yet.");
                if (null === this._refCount) throw new Error("Cannot dispose Layer " + this.name + " because it has not been used yet.");
                this.assertNotDisposed();
                var e = 0;
                return 0 == --this._refCount && (e = this.disposeWeights()), {
                    refCountAfterDispose: this._refCount,
                    numDisposedVariables: e
                }
            }, Wm(t, [{
                key: "input",
                get: function () {
                    if (this.inboundNodes.length > 1) throw new hC("Layer " + this.name + ' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');
                    if (0 === this.inboundNodes.length) throw new hC("Layer " + this.name + " is not connected, no input to return.");
                    return xC(this.getNodeAtIndex(0, "input").inputTensors)
                }
            }, {
                key: "output",
                get: function () {
                    if (0 === this.inboundNodes.length) throw new hC("Layer " + this.name + " has no inbound nodes.");
                    if (this.inboundNodes.length > 1) throw new hC("Layer " + this.name + ' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');
                    return xC(this.getNodeAtIndex(0, "output").outputTensors)
                }
            }, {
                key: "losses",
                get: function () {
                    return this._losses
                }
            }, {
                key: "updates",
                get: function () {
                    return this._updates
                }
            }, {
                key: "built",
                get: function () {
                    return this._built
                },
                set: function (e) {
                    this._built = e
                }
            }, {
                key: "trainable",
                get: function () {
                    return this.trainable_
                },
                set: function (e) {
                    this._trainableWeights.forEach(function (t) {
                        return t.trainable = e
                    }), this.trainable_ = e
                }
            }, {
                key: "trainableWeights",
                get: function () {
                    return this.trainable_ ? this._trainableWeights.filter(function (e) {
                        return e.trainable
                    }) : []
                },
                set: function (e) {
                    this._trainableWeights = e
                }
            }, {
                key: "nonTrainableWeights",
                get: function () {
                    return this.trainable ? this._trainableWeights.filter(function (e) {
                        return !e.trainable
                    }).concat(this._nonTrainableWeights) : this._trainableWeights.concat(this._nonTrainableWeights)
                },
                set: function (e) {
                    this._nonTrainableWeights = e
                }
            }, {
                key: "weights",
                get: function () {
                    return this.trainableWeights.concat(this.nonTrainableWeights)
                }
            }, {
                key: "stateful",
                get: function () {
                    return this._stateful
                }
            }, {
                key: "outputShape",
                get: function () {
                    if (null == this.inboundNodes || 0 === this.inboundNodes.length) throw new hC("The layer " + this.name + " has never been called and thus has no defined output shape.");
                    for (var e, t = [], n = Xm(this.inboundNodes); !(e = n()).done;) {
                        var r = e.value,
                            a = JSON.stringify(r.outputShapes); - 1 === t.indexOf(a) && t.push(a)
                    }
                    if (1 === t.length) {
                        var i = this.inboundNodes[0].outputShapes;
                        return Array.isArray(i) && Array.isArray(i[0]) && 1 === i.length ? i[0] : i
                    }
                    throw new hC("The layer " + this.name + ' has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.')
                }
            }]), t
        }(Kb),
        mR = function (e) {
            function t(t) {
                var n;
                if (n = e.call(this, {
                        dtype: t.dtype,
                        name: null != t.name ? t.name : $E("input").toString()
                    }) || this, null == t.batchSize && (t.batchSize = null), null == t.sparse && (t.sparse = !1), n.trainable = !1, n.built = !0, n.sparse = t.sparse, null != t.inputShape && null != t.batchInputShape) throw new dC("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");
                var r = t.batchInputShape;
                if (null == r) {
                    if (null == t.inputShape) throw new dC("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");
                    r = [t.batchSize].concat(t.inputShape)
                } else if (null != t.batchSize) throw new dC("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");
                var a = t.dtype || "float32";
                n.batchInputShape = r, n.dtype = a, n.inputSpec = [{
                    shape: r
                }];
                var i = new cR(n.dtype, n.batchInputShape, qm(n), [], {}, n.name);
                return i.nodeIndex = 0, i.tensorIndex = 0, new hR({
                    outboundLayer: qm(n),
                    inboundLayers: [],
                    nodeIndices: [],
                    tensorIndices: [],
                    inputTensors: [i],
                    outputTensors: [i],
                    inputMasks: [null],
                    outputMasks: [null],
                    inputShapes: [r],
                    outputShapes: [r]
                }), n
            }
            Vm(t, e);
            var n = t.prototype;
            return n.apply = function (e, t) {
                throw new dC("Cannot pass any input to an InputLayer's apply() method. InputLayer name: " + this.name)
            }, n.dispose = function () {
                return {
                    refCountAfterDispose: this._refCount,
                    numDisposedVariables: 0
                }
            }, n.getConfig = function () {
                return {
                    batchInputShape: this.batchInputShape,
                    dtype: this.dtype,
                    sparse: this.sparse,
                    name: this.name
                }
            }, t
        }(dR);

    function vR(e) {
        if (null == e.batchShape && null == e.shape) throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");
        if (null != e.batchShape && null != e.shape) throw new dC("Please provide either a `shape` or `batchShape` argument to Input, but not both.");
        var t = e.batchShape;
        null != e.shape && null == t && (t = [null].concat(e.shape));
        var n = e.dtype;
        return null == n && (n = "float32"), new mR({
            batchInputShape: t,
            name: e.name,
            dtype: n,
            sparse: e.sparse
        }).inboundNodes[0].outputTensors[0]
    }

    function gR(e) {
        return function () {
            return Pm(regeneratorRuntime.mark(function e(t) {
                var n, r, a, i, o, s, u, l;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (null != t) {
                                e.next = 2;
                                break
                            }
                            return e.abrupt("return");
                        case 2:
                            for (i in n = [], r = [], a = [], t) "number" != typeof (o = t[i]) && (s = o, n.push(s.data()), r.push(i), a.push(s));
                            if (!(n.length > 0)) {
                                e.next = 12;
                                break
                            }
                            return e.next = 9, Promise.all(n);
                        case 9:
                            for (u = e.sent, l = 0; l < u.length; ++l) t[r[l]] = u[l][0];
                            ax(a);
                        case 12:
                        case "end":
                            return e.stop()
                    }
                }, e)
            })).apply(this, arguments)
        }.apply(this, arguments)
    }

    function yR(e) {
        if (null != e)
            for (var t in e) {
                var n = e[t];
                "number" != typeof n && n.dispose()
            }
    }
    mR.className = "InputLayer", Yb(mR),
        function (e) {
            e[e.SILENT = 0] = "SILENT", e[e.VERBOSE = 1] = "VERBOSE"
        }(uR || (uR = {}));
    var bR = function () {
            function e() {
                this.validationData = null
            }
            var t = e.prototype;
            return t.setParams = function (e) {
                this.params = e
            }, t.onEpochBegin = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t, n) {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                            case "end":
                                return e.stop()
                        }
                    }, e)
                }));
                return function (t, n) {
                    return e.apply(this, arguments)
                }
            }(), t.onEpochEnd = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t, n) {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                            case "end":
                                return e.stop()
                        }
                    }, e)
                }));
                return function (t, n) {
                    return e.apply(this, arguments)
                }
            }(), t.onBatchBegin = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t, n) {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                            case "end":
                                return e.stop()
                        }
                    }, e)
                }));
                return function (t, n) {
                    return e.apply(this, arguments)
                }
            }(), t.onBatchEnd = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t, n) {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                            case "end":
                                return e.stop()
                        }
                    }, e)
                }));
                return function (t, n) {
                    return e.apply(this, arguments)
                }
            }(), t.onTrainBegin = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                            case "end":
                                return e.stop()
                        }
                    }, e)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), t.onTrainEnd = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                            case "end":
                                return e.stop()
                        }
                    }, e)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), t.setModel = function (e) {}, e
        }(),
        xR = function () {
            function e(e, t) {
                void 0 === t && (t = 10), null == e && (e = []), this.callbacks = e, this.queueLength = t
            }
            var t = e.prototype;
            return t.append = function (e) {
                this.callbacks.push(e)
            }, t.setParams = function (e) {
                for (var t, n = Xm(this.callbacks); !(t = n()).done;) t.value.setParams(e)
            }, t.setModel = function (e) {
                for (var t, n = Xm(this.callbacks); !(t = n()).done;) t.value.setModel(e)
            }, t.onEpochBegin = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t, n) {
                    var r, a, i;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                null == n && (n = {}), r = Xm(this.callbacks);
                            case 2:
                                if ((a = r()).done) {
                                    e.next = 8;
                                    break
                                }
                                return i = a.value, e.next = 6, i.onEpochBegin(t, n);
                            case 6:
                                e.next = 2;
                                break;
                            case 8:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t, n) {
                    return e.apply(this, arguments)
                }
            }(), t.onEpochEnd = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t, n) {
                    var r, a, i;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                null == n && (n = {}), r = Xm(this.callbacks);
                            case 2:
                                if ((a = r()).done) {
                                    e.next = 8;
                                    break
                                }
                                return i = a.value, e.next = 6, i.onEpochEnd(t, n);
                            case 6:
                                e.next = 2;
                                break;
                            case 8:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t, n) {
                    return e.apply(this, arguments)
                }
            }(), t.onBatchBegin = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t, n) {
                    var r, a, i;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                null == n && (n = {}), r = Xm(this.callbacks);
                            case 2:
                                if ((a = r()).done) {
                                    e.next = 8;
                                    break
                                }
                                return i = a.value, e.next = 6, i.onBatchBegin(t, n);
                            case 6:
                                e.next = 2;
                                break;
                            case 8:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t, n) {
                    return e.apply(this, arguments)
                }
            }(), t.onBatchEnd = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t, n) {
                    var r, a, i;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                null == n && (n = {}), r = Xm(this.callbacks);
                            case 2:
                                if ((a = r()).done) {
                                    e.next = 8;
                                    break
                                }
                                return i = a.value, e.next = 6, i.onBatchEnd(t, n);
                            case 6:
                                e.next = 2;
                                break;
                            case 8:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t, n) {
                    return e.apply(this, arguments)
                }
            }(), t.onTrainBegin = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    var n, r, a;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                null == t && (t = {}), n = Xm(this.callbacks);
                            case 2:
                                if ((r = n()).done) {
                                    e.next = 8;
                                    break
                                }
                                return a = r.value, e.next = 6, a.onTrainBegin(t);
                            case 6:
                                e.next = 2;
                                break;
                            case 8:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), t.onTrainEnd = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    var n, r, a;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                null == t && (t = {}), n = Xm(this.callbacks);
                            case 2:
                                if ((r = n()).done) {
                                    e.next = 8;
                                    break
                                }
                                return a = r.value, e.next = 6, a.onTrainEnd(t);
                            case 6:
                                e.next = 2;
                                break;
                            case 8:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), e
        }(),
        wR = function (e) {
            function t() {
                return e.call(this) || this
            }
            Vm(t, e);
            var n = t.prototype;
            return n.onEpochBegin = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                this.seen = 0, this.totals = {};
                            case 2:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), n.onBatchEnd = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t, n) {
                    var r, a, i, o = this;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                for (i in null == n && (n = {}), r = null == n.size ? 0 : n.size, this.seen += r, a = function (e) {
                                        var t = n[e];
                                        if ("number" == typeof t) o.totals.hasOwnProperty(e) || (o.totals[e] = 0), o.totals[e] = o.totals[e] + t * r;
                                        else {
                                            var a;
                                            e in o.totals ? a = o.totals[e] : o.totals[e] = 0;
                                            var i = rx(function () {
                                                return ux(o.totals[e], px(t, r))
                                            });
                                            o.totals[e] = i, null != a && a.dispose()
                                        }
                                    }, n) a(i);
                            case 5:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t, n) {
                    return e.apply(this, arguments)
                }
            }(), n.onEpochEnd = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t, n) {
                    var r, a, i, o = this;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (null == n) {
                                    e.next = 9;
                                    break
                                }
                                r = function () {
                                    var e = i.value;
                                    if (null == o.totals[e]) return "continue";
                                    "number" == typeof o.totals[e] ? n[e] = o.totals[e] / o.seen : rx(function () {
                                        var t = px(cx(1, o.seen), o.totals[e]);
                                        n[e] = t, o.totals[e].dispose(), ix(n[e])
                                    })
                                }, a = Xm(this.params.metrics);
                            case 3:
                                if ((i = a()).done) {
                                    e.next = 9;
                                    break
                                }
                                if ("continue" !== r()) {
                                    e.next = 7;
                                    break
                                }
                                return e.abrupt("continue", 7);
                            case 7:
                                e.next = 3;
                                break;
                            case 9:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t, n) {
                    return e.apply(this, arguments)
                }
            }(), t
        }(bR),
        kR = function (e) {
            function t() {
                return e.apply(this, arguments) || this
            }
            Vm(t, e);
            var n = t.prototype;
            return n.onTrainBegin = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                this.epoch = [], this.history = {};
                            case 2:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), n.onEpochEnd = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t, n) {
                    var r;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                for (r in null == n && (n = {}), this.epoch.push(t), n) null == this.history[r] && (this.history[r] = []), this.history[r].push(n[r]);
                            case 3:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t, n) {
                    return e.apply(this, arguments)
                }
            }(), n.syncData = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t, n, r, a, i, o, s, u, l;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                for (a in t = [], n = [], r = [], this.history)
                                    for (i = this.history[a], o = 0; o < i.length; ++o) "number" != typeof i[o] && (s = i[o], t.push(s.data()), n.push(a), r.push(o));
                                return e.next = 6, Promise.all(t);
                            case 6:
                                for (u = e.sent, l = 0; l < u.length; ++l) this.history[n[l]][r[l]].dispose(), this.history[n[l]][r[l]] = u[l][0];
                            case 8:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t
        }(bR),
        NR = function (e) {
            function t(t, n) {
                var r;
                if ((r = e.call(this) || this).currentEpoch = 0, r.yieldEvery = n || "auto", "auto" === r.yieldEvery && (r.yieldEvery = 125), "never" === r.yieldEvery && null != t.onYield) throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");
                return Sv(r.yieldEvery) && (r.maybeWait = function (e, t) {
                    var n, r = cg();
                    return function () {
                        var a = cg();
                        return a - r < t ? n : (r = a, n = e.apply(void 0, arguments))
                    }
                }(r.maybeWait.bind(qm(r)), r.yieldEvery)), r.trainBegin = t.onTrainBegin, r.trainEnd = t.onTrainEnd, r.epochBegin = t.onEpochBegin, r.epochEnd = t.onEpochEnd, r.batchBegin = t.onBatchBegin, r.batchEnd = t.onBatchEnd, r.yield = t.onYield, r
            }
            Vm(t, e);
            var n = t.prototype;
            return n.maybeWait = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t, n, r) {
                    var a;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (a = [], null == this.yield) {
                                    e.next = 5;
                                    break
                                }
                                return e.next = 4, gR(r);
                            case 4:
                                a.push(this.yield(t, n, r));
                            case 5:
                                return a.push(TS()), e.next = 8, Promise.all(a);
                            case 8:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t, n, r) {
                    return e.apply(this, arguments)
                }
            }(), n.onEpochBegin = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t, n) {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (this.currentEpoch = t, null == this.epochBegin) {
                                    e.next = 6;
                                    break
                                }
                                return e.next = 4, gR(n);
                            case 4:
                                return e.next = 6, this.epochBegin(t, n);
                            case 6:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t, n) {
                    return e.apply(this, arguments)
                }
            }(), n.onEpochEnd = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t, n) {
                    var r;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (r = [], null == this.epochEnd) {
                                    e.next = 5;
                                    break
                                }
                                return e.next = 4, gR(n);
                            case 4:
                                r.push(this.epochEnd(t, n));
                            case 5:
                                return "epoch" === this.yieldEvery && r.push(TS()), e.next = 8, Promise.all(r);
                            case 8:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t, n) {
                    return e.apply(this, arguments)
                }
            }(), n.onBatchBegin = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t, n) {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (null == this.batchBegin) {
                                    e.next = 5;
                                    break
                                }
                                return e.next = 3, gR(n);
                            case 3:
                                return e.next = 5, this.batchBegin(t, n);
                            case 5:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t, n) {
                    return e.apply(this, arguments)
                }
            }(), n.onBatchEnd = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t, n) {
                    var r;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (r = [], null == this.batchEnd) {
                                    e.next = 5;
                                    break
                                }
                                return e.next = 4, gR(n);
                            case 4:
                                r.push(this.batchEnd(t, n));
                            case 5:
                                return "batch" === this.yieldEvery ? r.push(TS()) : Sv(this.yieldEvery) && r.push(this.maybeWait(this.currentEpoch, t, n)), e.next = 8, Promise.all(r);
                            case 8:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t, n) {
                    return e.apply(this, arguments)
                }
            }(), n.onTrainBegin = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (null == this.trainBegin) {
                                    e.next = 5;
                                    break
                                }
                                return e.next = 3, gR(t);
                            case 3:
                                return e.next = 5, this.trainBegin(t);
                            case 5:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), n.onTrainEnd = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (null == this.trainEnd) {
                                    e.next = 5;
                                    break
                                }
                                return e.next = 3, gR(t);
                            case 3:
                                return e.next = 5, this.trainEnd(t);
                            case 5:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), t
        }(bR);

    function IR(e, t) {
        return null == e && (e = {}), e instanceof bR ? [e] : Array.isArray(e) && e[0] instanceof bR ? e : wC(e).map(function (e) {
            return new NR(e, t)
        })
    }
    var SR = function () {
        function e() {}
        return e.registerCallbackConstructor = function (t, n) {
            nv(t >= 0 && Number.isInteger(t), function () {
                return "Verbosity level is expected to be an integer >= 0, but got " + t
            }), e.checkForDuplicate(n), null == e.constructors[t] && (e.constructors[t] = []), e.constructors[t].push(n)
        }, e.checkForDuplicate = function (t) {
            for (var n in e.constructors) e.constructors[+n].forEach(function (e) {
                if (e === t) throw new dC("Duplicate callback constructor.")
            })
        }, e.clear = function () {
            e.constructors = {}
        }, e.createCallbacks = function (t) {
            var n = [];
            for (var r in e.constructors) {
                var a = +r;
                t >= a && n.push.apply(n, e.constructors[a])
            }
            return n.map(function (e) {
                return new e
            })
        }, e
    }();

    function TR(e, t, n, r, a, i, o, s, u) {
        var l = new kR,
            c = [new wR].concat(SR.createCallbacks(t));
        null != e && c.push.apply(c, e), c.push(l);
        var p = new xR(c);
        return p.setParams({
            epochs: n,
            initialEpoch: r,
            samples: a,
            steps: i,
            batchSize: o,
            verbose: t,
            doValidation: s,
            metrics: u
        }), {
            callbackList: p,
            history: l
        }
    }

    function CR(e, t, n) {
        return void 0 === t && (t = {}), void 0 === n && (n = !1), TC(e, Xb.getMap().classNameMap, t, "layer", n)
    }

    function ER(e, t) {
        return rx(function () {
            "float32" !== e.dtype && (e = e.asType("float32"));
            var n = ik(kE(e), t, !0),
                r = Mw(n.shape, pC()),
                a = BN(Nk(n, r));
            return cx(e, a)
        })
    }

    function RR(e, t) {
        return rx(function () {
            return Ik(kE(ak(t, e)), -1)
        })
    }

    function AR(e, t) {
        return rx(function () {
            return Ik(hx(ak(t, e)), -1)
        })
    }

    function FR(e, t) {
        return rx(function () {
            var n = ak(e, t),
                r = ew(hx(e), pC(), Number.MAX_VALUE),
                a = hx(cx(n, r));
            return px(100, Ik(a, -1))
        })
    }

    function _R(e, t, n) {
        return void 0 === n && (n = !1), rx(function () {
            if (n) t = DN(t);
            else {
                var r = ik(t, t.shape.length - 1, !0);
                t = cx(t, r)
            }
            return t = ew(t, pC(), 1 - pC()), ek(ik(px(e.toFloat(), Yw(t)), t.shape.length - 1))
        })
    }

    function DR(e, t, n) {
        return void 0 === n && (n = !1), rx(function () {
            var r, a, i = Lw((r = e, a = [oE(r.shape)], r.reshape(a))).toInt(),
                o = (t = ew(t, pC(), 1 - pC())).shape;
            return _R(db(i, o[o.length - 1]).reshape(o), t, n)
        })
    }

    function OR(e, t) {
        return rx(function () {
            var n;
            return n = ew(t, pC(), 1 - pC()), n = Yw(cx(n, ak(1, n))), Ik(function (e, t) {
                if (!sv(e.shape, t.shape)) throw new dC("logits and labels must have the same shape, but got shapes " + JSON.stringify(e.shape) + " and " + JSON.stringify(t.shape));
                return rx(function () {
                    var n = t.relu(),
                        r = t.abs().neg();
                    return n.sub(t.mul(e)).add(r.exp().log1p())
                })
            }(e, n), -1)
        })
    }

    function MR(e, t) {
        return rx(function () {
            var n = ER(e, -1),
                r = ER(t, -1),
                a = px(n, r);
            return ek(ik(a, -1))
        })
    }
    SR.constructors = {};
    var LR = {
        meanSquaredError: RR,
        meanAbsoluteError: AR,
        meanAbsolutePercentageError: FR,
        meanSquaredLogarithmicError: function (e, t) {
            return rx(function () {
                var n = ew(t, pC(), Number.MAX_VALUE),
                    r = Yw(ux(1, n)),
                    a = ew(e, pC(), Number.MAX_VALUE),
                    i = Yw(ux(1, a));
                return Ik(kE(ak(r, i)), -1)
            })
        },
        squaredHinge: function (e, t) {
            return rx(function () {
                var n = Nk(0, ak(1, px(e, t)));
                return Ik(kE(n), -1)
            })
        },
        hinge: function (e, t) {
            return rx(function () {
                var n = Nk(0, ak(1, px(e, t)));
                return Ik(n, -1)
            })
        },
        categoricalHinge: function (e, t) {
            return rx(function () {
                var n = ik(px(e, t), -1),
                    r = rk(px(ak(1, e), t), -1);
                return Nk(0, ux(1, ak(r, n)))
            })
        },
        logcosh: function (e, t) {
            return rx(function () {
                var n = Math.log(2),
                    r = ak(t, e),
                    a = ak(ux(r, tk(px(-2, r))), n);
                return Ik(a, -1)
            })
        },
        categoricalCrossentropy: _R,
        sparseCategoricalCrossentropy: DR,
        binaryCrossentropy: OR,
        kullbackLeiblerDivergence: function (e, t) {
            return rx(function () {
                var n = ew(e, pC(), 1),
                    r = ew(t, pC(), 1);
                return ik(px(e, Yw(cx(n, r))), -1)
            })
        },
        poisson: function (e, t) {
            return rx(function () {
                var n = Yw(ux(pC(), t));
                return Ik(ak(t, px(e, n)), -1)
            })
        },
        cosineProximity: MR
    };

    function zR(e) {
        if ("string" == typeof e) {
            if (e in LR) return LR[e];
            var t = "Unknown loss " + e;
            throw e.toLowerCase().includes("softmaxcrossentropy") && (t = "Unknown loss " + e + '. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'), new dC(t)
        }
        return e
    }

    function PR(e, t) {
        return rx(function () {
            var n = px(.5, Lk(t)),
                r = pE(Pw(t, n), e.dtype);
            return Ik(Nw(e, r), -1)
        })
    }

    function BR(e, t) {
        return rx(function () {
            return pE(Nw(yx(e, -1), yx(t, -1)), "float32")
        })
    }

    function WR(e, t) {
        return rx(function () {
            return vk(e.equal(1), t.equal(1)).sum().cast("float32")
        })
    }

    function VR(e, t) {
        return rx(function () {
            var n = WR(e, t),
                r = function (e, t) {
                    return rx(function () {
                        return vk(e.equal(0), t.equal(1)).sum().cast("float32")
                    })
                }(e, t),
                a = n.add(r);
            return Iw(Pw(a, 0), n.div(a), 0).cast("float32")
        })
    }

    function UR(e, t) {
        return OR(e, t)
    }

    function GR(e, t) {
        return e.rank === t.rank && (e = e.squeeze([e.rank - 1])), (t = t.argMax(-1)).dtype !== e.dtype && (t = t.asType(e.dtype)), Nw(e, t).asType("float32")
    }
    var jR = _R,
        HR = DR,
        qR = {
            binaryAccuracy: PR,
            categoricalAccuracy: BR,
            precision: VR,
            categoricalCrossentropy: jR,
            sparseCategoricalCrossentropy: HR,
            mse: RR,
            MSE: RR,
            mae: AR,
            MAE: AR,
            mape: FR,
            MAPE: FR,
            cosine: MR
        };

    function KR(e) {
        if ("string" == typeof e && e in qR) return qR[e];
        if ("string" != typeof e && null != e) return e;
        throw new dC("Unknown metric " + e)
    }

    function XR(e) {
        if (yC(null !== e, "Unknown LossOrMetricFn " + e), "string" == typeof e) return e;
        for (var t, n = 0, r = Object.keys(LR); n < r.length; n++) {
            var a = r[n];
            if (LR[a] === e) {
                t = a;
                break
            }
        }
        if (void 0 !== t) return t;
        for (var i = 0, o = Object.keys(qR); i < o.length; i++) {
            var s = o[i];
            if (qR[s] === e) {
                t = s;
                break
            }
        }
        return void 0 !== t ? t : e.name
    }

    function YR(e, t, n) {
        if (void 0 === n && (n = !1), null == e || "object" != typeof e || Object.getPrototypeOf(e) !== Object.prototype || ! function e(t) {
                if (null === t) return !0;
                if ("object" == typeof t) {
                    if (Object.getPrototypeOf(t) === Object.prototype) {
                        for (var n = 0, r = Object.keys(t); n < r.length; n++) {
                            var a = r[n];
                            if ("string" != typeof a) return !1;
                            if (!e(t[a])) return !1
                        }
                        return !0
                    }
                    if (Array.isArray(t)) {
                        for (var i, o = Xm(t); !(i = o()).done;) {
                            if (!e(i.value)) return !1
                        }
                        return !0
                    }
                    return !1
                }
                var s = typeof t;
                return "string" === s || "number" === s || "boolean" === s
            }(e)) throw new Error("User-defined metadata is expected to be a JSON object, but is not.");
        if (n) {
            var r = JSON.stringify(e);
            r.length > 1048576 && console.warn('User-defined metadata of model "' + t + '" is too large in size (length=' + r.length + " when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.")
        }
    }

    function JR(e, t, n) {
        void 0 === n && (n = console.log);
        for (var r = "", a = 0; a < e.length; ++a) a > 0 && (r = r.slice(0, r.length - 1) + " "), r = (r += e[a]).slice(0, t[a]), r += " ".repeat(t[a] - r.length);
        n(r)
    }

    function ZR(e, t, n) {
        var r;
        try {
            r = JSON.stringify(e.outputShape)
        } catch (e) {
            r = "multiple"
        }
        JR([e.name + " (" + e.getClassName() + ")", r, e.countParams().toString()], t, n)
    }

    function QR(e, t, n, r) {
        var a;
        try {
            a = JSON.stringify(e.outputShape)
        } catch (e) {
            a = "multiple"
        }
        for (var i, o = [], s = Xm(e.inboundNodes); !(i = s()).done;) {
            var u = i.value;
            if (!(null != n && n.length > 0 && -1 === n.indexOf(u)))
                for (var l = 0; l < u.inboundLayers.length; ++l) {
                    var c = u.inboundLayers[l].name,
                        p = u.nodeIndices[l],
                        h = u.tensorIndices[l];
                    o.push(c + "[" + p + "][" + h + "]")
                }
        }
        var f = e.name,
            d = e.getClassName(),
            m = 0 === o.length ? "" : o[0];
        JR([f + " (" + d + ")", a, e.countParams().toString(), m], t, r);
        for (var v = 1; v < o.length; ++v) JR(["", "", "", o[v]], t, r)
    }

    function $R(e, t, n) {
        return ("inboundNodes" === e || "outputLayers" === e || "inputLayers" === e) && 0 === t && "string" == typeof n
    }

    function eA(e, t) {
        if (null === e) return null;
        if ("string" == typeof e) return NC(e);
        if ("number" == typeof e || "boolean" == typeof e) return e;
        if (e instanceof Array) {
            for (var n = [], r = e.length, a = 0; a < r; ++a) {
                var i = e[a];
                $R(t, a, i) ? n.push(i) : n.push(eA(i, t))
            }
            return n
        }
        for (var o = {}, s = 0, u = Object.keys(e); s < u.length; s++) {
            var l = u[s],
                c = e[l];
            if ("name" === l && "string" == typeof c) o[l] = c;
            else {
                var p = NC(l);
                o[p] = eA(c, p)
            }
        }
        return o
    }
    var tA = function () {
            function e(t) {
                if (this.id2Value = {}, this.id2Mask = {}, this.name2Id = {}, t instanceof e)
                    for (var n in t.id2Value) this.id2Value[n] = t.id2Value[n], n in t.id2Mask && (this.id2Mask[n] = t.id2Mask[n]);
                else {
                    if (null == t) return;
                    for (var r, a = Xm(t); !(r = a()).done;) {
                        var i = r.value;
                        this.add(i.key, i.value)
                    }
                }
            }
            var t = e.prototype;
            return t.add = function (e, t, n) {
                if (null != this.id2Value[e.id]) throw new dC("Duplicate key: name=" + e.name + ", id=" + e.id);
                return this.id2Value[e.id] = function (e, t) {
                    if (null == e.dtype || e.dtype === t.dtype) return t;
                    try {
                        return Ky(t, e.dtype)
                    } catch (n) {
                        throw new dC("The dtype of the feed (" + t.dtype + ") can not be cast to the dtype of the key '" + e.name + "' (" + e.dtype + ").")
                    }
                }(e, t), this.name2Id[e.name] = e.id, null != n && (this.id2Mask[e.id] = n), this
            }, t.addFeed = function (e) {
                this.add(e.key, e.value)
            }, t.hasKey = function (e) {
                return null != this.id2Value[e.id]
            }, t.names = function () {
                return Object.keys(this.name2Id)
            }, t.getValue = function (e) {
                if (e instanceof cR) {
                    if (null == this.id2Value[e.id]) throw new dC("Nonexistent key: " + e.name);
                    return this.id2Value[e.id]
                }
                var t = this.name2Id[e];
                if (null == t) throw new dC("Feed dict has no SymbolicTensor name: " + e);
                return this.id2Value[t]
            }, t.getMask = function (e) {
                if (e instanceof cR) {
                    if (null == this.id2Value[e.id]) throw new dC("Nonexistent key: " + e.name);
                    return this.id2Mask[e.id]
                }
                var t = this.name2Id[e];
                if (null == t) throw new dC("Feed dict has no SymbolicTensor name: " + e);
                return this.id2Mask[t]
            }, t.disposeMasks = function () {
                null != this.id2Mask && ax(this.id2Mask)
            }, e
        }(),
        nA = {},
        rA = {};

    function aA(e, t, n, r) {
        for (var a, i = null != n && n.training, o = Array.isArray(e), s = o ? e : [e], u = s.map(function (e) {
                return e.name
            }), l = [], c = t.names(), p = Xm(u); !(a = p()).done;) {
            var h = a.value; - 1 !== c.indexOf(h) ? l.push(t.getValue(h)) : l.push(null)
        }
        null != r && (r.maxNumTensors = -1 / 0, r.minNumTensors = 1 / 0);
        var f, d, m = u.join(",") + "|" + t.names().join(",");
        if (null == nA[m]) {
            var v = function (e, t) {
                nv(null != e && e.length > 0, function () {
                    return "Expected at least one fetch, got none"
                });
                var n = [],
                    r = {};
                if (1 === e.length) {
                    var a = oA(e[0], t);
                    n = a.sorted, r = a.recipientMap
                } else
                    for (var i, o = new Set, s = Xm(e); !(i = s()).done;) {
                        for (var u, l = oA(i.value, t), c = l.sorted, p = l.recipientMap, h = Xm(c); !(u = h()).done;) {
                            var f = u.value;
                            o.has(f.name) || (n.push(f), o.add(f.name))
                        }
                        var d = function (e) {
                            null == r[e] && (r[e] = new Set), p[e].forEach(function (t) {
                                return r[e].add(t)
                            })
                        };
                        for (var m in p) d(m)
                    }
                return {
                    sorted: n,
                    recipientCounts: iA(r)
                }
            }(s, t);
            f = v.sorted, d = v.recipientCounts, nA[m] = f, rA[m] = d
        }
        f = nA[m], d = {}, i || Object.assign(d, rA[m]);
        for (var g = new tA(t), y = 0; y < f.length; ++y) {
            if (null != r) {
                var b = nx().numTensors;
                b > r.maxNumTensors && (r.maxNumTensors = b), b < r.minNumTensors && (r.minNumTensors = b)
            }
            var x = f[y],
                w = x.sourceLayer;
            if (!(w instanceof mR)) {
                for (var k, N = [], I = [], S = [], T = !1, C = Xm(x.inputs); !(k = C()).done;) {
                    var E = k.value,
                        R = g.getValue(E),
                        A = g.getMask(E);
                    N.push(R), I.push(A), null != A && (T = !0), i || (d[E.name]--, 0 !== d[E.name] || t.hasKey(E) || -1 !== u.indexOf(E.name) || R.isDisposed || !0 === E.sourceLayer.stateful || S.push(R))
                }
                T && ((n = n || {}).mask = I[0]);
                var F = wC(w.apply(N, n)),
                    _ = null;
                w.supportsMasking && (_ = w.computeMask(N, I));
                for (var D = sA(x), O = Array.isArray(D) ? D : [D], M = 0; M < O.length; ++M) {
                    g.hasKey(O[M]) || g.add(O[M], F[M], Array.isArray(_) ? _[0] : _);
                    var L = u.indexOf(O[M].name); - 1 !== L && (l[L] = F[M])
                }
                i || ax(S)
            }
        }
        return g.disposeMasks(), o ? l : l[0]
    }

    function iA(e) {
        var t = {};
        for (var n in e) t[n] = e[n].size;
        return t
    }

    function oA(e, t) {
        for (var n, r = new Set, a = [], i = {}, o = Xm(t.names()); !(n = o()).done;) {
            var s = n.value;
            r.add(s)
        }
        var u = [],
            l = [];
        for (u.push(e); u.length > 0;) {
            var c = u[u.length - 1];
            if (r.has(c.name)) u.pop();
            else {
                var p = l[l.length - 1] === u.length - 1;
                if (0 === c.inputs.length || p) u.pop(), a.push(c), r.add(c.name), p && l.pop();
                else {
                    l.push(u.length - 1);
                    for (var h, f = Xm(c.inputs); !(h = f()).done;) {
                        var d = h.value;
                        null == i[d.name] && (i[d.name] = new Set), i[d.name].add(c.name), r.has(d.name) || u.push(d)
                    }
                }
            }
        }
        return {
            sorted: a,
            recipientMap: i
        }
    }

    function sA(e) {
        var t;
        if (1 === e.sourceLayer.inboundNodes.length) t = e.sourceLayer.output;
        else {
            for (var n = null, r = 0; r < e.sourceLayer.inboundNodes.length; ++r)
                for (var a, i = Xm(e.sourceLayer.inboundNodes[r].outputTensors); !(a = i()).done;)
                    if (a.value.id === e.id) {
                        n = r;
                        break
                    } t = e.sourceLayer.getOutputAt(n)
        }
        return t
    }

    function uA(e, t) {
        return function (e, t, n) {
            var r = t.length;
            if (null == e || Array.isArray(e) && 0 === e.length) return t.map(function (e) {
                return null
            });
            if (1 === r) return Array.isArray(e) && 1 === e.length ? e : "object" == typeof e && t[0] in e ? [e[t[0]]] : [e];
            if (Array.isArray(e)) {
                if (e.length !== r) throw new Error("Provided " + n + " is an array of " + e.length + " element(s), but the model has " + r + " outputs. Make sure a set of weights is provided for each model output.");
                return e
            }
            if ("object" == typeof e && Object.keys(e).length > 0 && "object" == typeof e[Object.keys(e)[0]]) {
                var a = [];
                return t.forEach(function (t) {
                    t in e ? a.push(e[t]) : a.push(null)
                }), a
            }
            throw new Error("The model has multiple (" + r + ") outputs, so " + n + " must be either an array with " + r + " elements or an object with " + t + " keys. Provided " + n + " not understood: " + JSON.stringify(e))
        }(e, t, "classWeight")
    }

    function lA(e, t, n, r) {
        return function () {
            return Pm(regeneratorRuntime.mark(function e(t, n, r, a) {
                var i, o, s;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (null == n && null == a) {
                                e.next = 2;
                                break
                            }
                            throw new Error("Support sampleWeight is not implemented yet");
                        case 2:
                            if (null == r) {
                                e.next = 15;
                                break
                            }
                            return i = rx(function () {
                                if (1 === t.shape.length) return t.clone();
                                if (2 === t.shape.length) {
                                    if (t.shape[1] > 1) return t.argMax(1);
                                    if (1 === t.shape[1]) return t.reshape([t.shape[0]]);
                                    throw new Error("Encountered unexpected last-dimension size (" + t.shape[1] + ") during handling of class weights. The size is expected to be >= 1.")
                                }
                                throw new Error("Unexpected rank of target (y) tensor (" + t.rank + ") during handling of class weights. The rank is expected to be 1 or 2.")
                            }), e.t0 = Array, e.next = 7, i.data();
                        case 7:
                            return e.t1 = e.sent, o = e.t0.from.call(e.t0, e.t1), ax(i), s = [], o.forEach(function (e) {
                                if (null == r[e]) throw new Error("classWeight must contain all classes in the training data. The class " + e + " exists in the data but not in classWeight");
                                s.push(r[e])
                            }), e.abrupt("return", qN(s, "float32"));
                        case 15:
                            return e.abrupt("return", null);
                        case 16:
                        case "end":
                            return e.stop()
                    }
                }, e)
            })).apply(this, arguments)
        }.apply(this, arguments)
    }

    function cA(e, t) {
        return px(e, t)
    }

    function pA(e, t) {
        var n, r, a = t;
        n = a.xs, r = a.ys, nv(null != n && null != r, function () {
            return "A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates " + t
        });
        var i = hA("input", e.inputNames, n),
            o = hA("output", e.outputNames, r),
            s = i[0].shape[0];
        nv(i.length === e.inputs.length, function () {
            return "LayersModel has " + e.inputs.length + " inputs, but the dataset provides " + i.length + " inputs.  (Expected input keys: " + JSON.stringify(e.inputNames) + ")"
        }), nv(o.length === e.outputs.length, function () {
            return "LayersModel has " + e.outputs.length + " outputs, but the dataset provides " + o.length + " outputs.  (Expected output keys: " + JSON.stringify(e.outputNames) + ")"
        });
        for (var u = function (t) {
                nv(i[t].shape[0] === s, function () {
                    return "Batch size mismatch: input " + e.inputNames[t] + " has " + i[t].shape[0] + "; expected  " + s + " based on input " + e.inputNames[0] + "."
                })
            }, l = 0; l < i.length; l++) u(l);
        for (var c = function (t) {
                nv(o[t].shape[0] === s, function () {
                    return "Batch size mismatch: output " + e.outputNames[t] + " has " + o[t].shape[0] + "; expected  " + s + " based on input " + e.inputNames[0] + "."
                })
            }, p = 0; p < o.length; p++) c(p);
        return {
            xs: i,
            ys: o
        }
    }

    function hA(e, t, n) {
        if (n instanceof Ng) return [n];
        if (Array.isArray(n)) return nv(n.length === t.length, function () {
            return "Received an array of " + n.length + " Tensors, but expected " + t.length + " to match the " + e + " keys " + t + "."
        }), n;
        for (var r, a = [], i = Xm(t); !(r = i()).done;) {
            var o = r.value;
            if (null == n[o]) throw new dC("The feature data generated by the dataset lacks the required " + e + " key '" + o + "'.");
            a.push(n[o])
        }
        return a
    }

    function fA(e) {
        if (3 === e.length) throw new mC("Validation with sample weights is not implemented yet.");
        return {
            xs: e[0],
            ys: e[1]
        }
    }

    function dA(e, t, n) {
        return function () {
            return Pm(regeneratorRuntime.mark(function e(t, n, r) {
                var a, i, o, s, u, l, c, p, h, f, d, m, v, g, y, b, x, w, k, N, I, S, T, C, E, R, A, F, _, D, O, M, L;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (a = null != r.batchesPerEpoch, nv(null != t.optimizer, function () {
                                    return "You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."
                                }), nv(null != r, function () {
                                    return "For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."
                                }), nv(null != r.epochs && r.epochs > 0 && Number.isInteger(r.epochs), function () {
                                    return "For fitDataset(), config.epochs is expected to be a positive integer, but got " + r.epochs
                                }), nv(!a || r.batchesPerEpoch > 0 && Number.isInteger(r.batchesPerEpoch), function () {
                                    return "For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got " + r.batchesPerEpoch
                                }), nv(null == r.validationSplit, function () {
                                    return "`validationSplit` is not supported by `fitDataset()`. Use validationData instead."
                                }), !t.isTraining) {
                                e.next = 8;
                                break
                            }
                            throw new Error("Cannot start training because another fit() call is ongoing.");
                        case 8:
                            return t.isTraining = !0, e.prev = 9, (i = null != r.validationData) && (vA(r.validationData) ? nv(null == r.validationBatches || r.validationBatches > 0 && Number.isInteger(r.validationBatches), function () {
                                return "For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got " + r.validationBatches
                            }) : (u = fA(r.validationData), o = u.xs, s = u.ys)), l = t.makeTrainFunction(), c = t.getDedupedMetricsNames(), p = i ? c.slice().concat(c.map(function (e) {
                                return "val_" + e
                            })) : c.slice(), h = IR(r.callbacks, r.yieldEvery), f = null == r.verbose ? 1 : r.verbose, d = TR(h, f, r.epochs, null, null, mA(n, r), null, i, p), m = d.callbackList, v = d.history, m.setModel(t), t.history = v, e.next = 22, m.onTrainBegin();
                        case 22:
                            return t.stopTraining_ = !1, g = null == r.initialEpoch ? 0 : r.initialEpoch, e.next = 26, n.iterator();
                        case 26:
                            y = e.sent;
                        case 27:
                            if (!(g < r.epochs)) {
                                e.next = 98;
                                break
                            }
                            return b = {}, e.next = 31, m.onEpochBegin(g);
                        case 31:
                            if (x = 0, w = 0, a) {
                                e.next = 37;
                                break
                            }
                            return e.next = 36, n.iterator();
                        case 36:
                            y = e.sent;
                        case 37:
                            if (a && !(x < r.batchesPerEpoch)) {
                                e.next = 91;
                                break
                            }
                            return e.next = 40, y.next();
                        case 40:
                            if (k = e.sent, !a || !k.done) {
                                e.next = 44;
                                break
                            }
                            return console.warn("You provided `batchesPerEpoch` as " + r.batchesPerEpoch + ", but your dataset iterator ran out of data after " + x + " batches; interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, " + r.batchesPerEpoch * r.epochs + " batches). You may need to use the repeat() function when building your dataset."), e.abrupt("break", 91);
                        case 44:
                            if (null == k.value) {
                                e.next = 73;
                                break
                            }
                            return N = pA(t, k.value), I = N.xs, S = N.ys, (T = {}).batch = w, T.size = I[0].shape[0], e.next = 51, m.onBatchBegin(w, T);
                        case 51:
                            if (C = [], null == r.classWeight) {
                                e.next = 64;
                                break
                            }
                            E = uA(r.classWeight, t.outputNames), R = 0;
                        case 55:
                            if (!(R < E.length)) {
                                e.next = 64;
                                break
                            }
                            return e.t0 = C, e.next = 59, lA(S[R], null, E[R]);
                        case 59:
                            e.t1 = e.sent, e.t0.push.call(e.t0, e.t1);
                        case 61:
                            ++R, e.next = 55;
                            break;
                        case 64:
                            for (A = I.concat(S).concat(C), F = l(A), ax(A), _ = 0; _ < c.length; ++_) D = c[_], O = F[_], T[D] = O, ix(O);
                            return e.next = 70, m.onBatchEnd(w, T);
                        case 70:
                            yR(T), w++, x++;
                        case 73:
                            if (!(a ? x >= r.batchesPerEpoch : k.done)) {
                                e.next = 87;
                                break
                            }
                            if (!i) {
                                e.next = 86;
                                break
                            }
                            if (M = void 0, !vA(r.validationData)) {
                                e.next = 84;
                                break
                            }
                            return e.t2 = wC, e.next = 80, t.evaluateDataset(r.validationData, {
                                batches: r.validationBatches
                            });
                        case 80:
                            e.t3 = e.sent, M = (0, e.t2)(e.t3), e.next = 85;
                            break;
                        case 84:
                            M = wC(t.evaluate(o, s, {
                                batchSize: null == r.validationBatchSize ? 32 : r.validationBatchSize,
                                verbose: 0
                            }));
                        case 85:
                            for (L = 0; L < t.metricsNames.length; ++L) b["val_" + t.metricsNames[L]] = M[L];
                        case 86:
                            return e.abrupt("break", 91);
                        case 87:
                            if (!t.stopTraining_) {
                                e.next = 89;
                                break
                            }
                            return e.abrupt("break", 91);
                        case 89:
                            e.next = 37;
                            break;
                        case 91:
                            return e.next = 93, m.onEpochEnd(g, b);
                        case 93:
                            if (g++, !t.stopTraining_) {
                                e.next = 96;
                                break
                            }
                            return e.abrupt("break", 98);
                        case 96:
                            e.next = 27;
                            break;
                        case 98:
                            return e.next = 100, m.onTrainEnd();
                        case 100:
                            return e.next = 102, t.history.syncData();
                        case 102:
                            return e.abrupt("return", t.history);
                        case 103:
                            return e.prev = 103, t.isTraining = !1, e.finish(103);
                        case 106:
                        case "end":
                            return e.stop()
                    }
                }, e, null, [
                    [9, , 103, 106]
                ])
            })).apply(this, arguments)
        }.apply(this, arguments)
    }

    function mA(e, t) {
        var n = null;
        return null != t.batchesPerEpoch ? n = t.batchesPerEpoch : Number.isFinite(e.size) && (n = e.size), n
    }

    function vA(e) {
        return "function" == typeof e.iterator
    }

    function gA(e) {
        return "function" == typeof e.next
    }

    function yA(e, t, n) {
        return function () {
            return Pm(regeneratorRuntime.mark(function e(t, n, r) {
                var a, i, o, s, u, l, c, p, h;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (a = null != (r = r || {}).batches, i = t.testFunction, o = [], !(r.verbose > 0)) {
                                e.next = 6;
                                break
                            }
                            throw new mC("Verbose mode is not implemented yet.");
                        case 6:
                            if (nv(!a || r.batches > 0 && Number.isInteger(r.batches), function () {
                                    return "Test loop expects `batches` to be a positive integer, but received " + JSON.stringify(r.batches)
                                }), !gA(n)) {
                                e.next = 11;
                                break
                            }
                            e.t0 = n, e.next = 14;
                            break;
                        case 11:
                            return e.next = 13, n.iterator();
                        case 13:
                            e.t0 = e.sent;
                        case 14:
                            s = e.t0, u = 0, l = 0, c = regeneratorRuntime.mark(function e() {
                                var n;
                                return regeneratorRuntime.wrap(function (e) {
                                    for (;;) switch (e.prev = e.next) {
                                        case 0:
                                            return e.next = 2, s.next();
                                        case 2:
                                            if (n = e.sent, o = rx(function () {
                                                    return n.value && function () {
                                                        var e = pA(t, n.value),
                                                            r = e.xs,
                                                            a = e.ys,
                                                            s = r.concat(a),
                                                            c = rx(function () {
                                                                return i(s)
                                                            });
                                                        if (ax(s), 0 === l)
                                                            for (var p = 0; p < c.length; ++p) o.push(wN(0));
                                                        for (var h = s[0].shape[0], f = function (e) {
                                                                var t = c[e],
                                                                    n = o[e];
                                                                o[e] = rx(function () {
                                                                    return ux(o[e], px(h, t))
                                                                }), l > 0 && ax(n)
                                                            }, d = 0; d < c.length; ++d) f(d);
                                                        ax(c), u += h, ++l
                                                    }(), o
                                                }), !n.done) {
                                                e.next = 7;
                                                break
                                            }
                                            return a && console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` batches (in this case, " + r.batches + " batches). You may need to use the repeat() function when building your dataset."), e.abrupt("return", "break");
                                        case 7:
                                        case "end":
                                            return e.stop()
                                    }
                                }, e)
                            });
                        case 18:
                            if (a && !(l < r.batches)) {
                                e.next = 25;
                                break
                            }
                            return e.delegateYield(c(), "t1", 20);
                        case 20:
                            if ("break" !== e.t1) {
                                e.next = 23;
                                break
                            }
                            return e.abrupt("break", 25);
                        case 23:
                            e.next = 18;
                            break;
                        case 25:
                            for (p = 0; p < o.length; ++p) h = o[p], o[p] = cx(o[p], u), ax(h);
                            return e.abrupt("return", xC(o));
                        case 27:
                        case "end":
                            return e.stop()
                    }
                }, e)
            })).apply(this, arguments)
        }.apply(this, arguments)
    }

    function bA(e) {
        nv(e > 0 && Number.isInteger(e), function () {
            return "batchSize is required to be a positive integer, but got " + e
        })
    }

    function xA(e, t, n) {
        return null == e ? [null] : Array.isArray(e) ? e.map(function (e) {
            return fE(e, t, n - t)
        }) : fE(e, t, n - t)
    }

    function wA(e, t) {
        return rx(function () {
            return null == e ? null : Array.isArray(e) ? e.map(function (e) {
                return wA(e, t)
            }) : wE(e, "int32" === t.dtype ? t : t.toInt())
        })
    }

    function kA(e, t) {
        for (var n = [], r = 0, a = null; r < e;)(a = r + t) >= e && (a = e), n.push([r, a]), r = a;
        return n
    }

    function NA(e, t, n, r, a, i, o, s, u, l, c, p, h, f, d) {
        return function () {
            return Pm(regeneratorRuntime.mark(function e(t, n, r, a, i, o, s, u, l, c, p, h, f, d, m) {
                var v, g, y, b, x, w, k, N;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (null == i && (i = 32), null == o && (o = 1), null == p && (p = !0), null == f && (f = 0), v = !1, null != l && null != c && (v = !0), null == m) {
                                e.next = 10;
                                break
                            }
                            if (v = !0, null != d) {
                                e.next = 10;
                                break
                            }
                            throw new dC("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");
                        case 10:
                            return null != (g = t.checkNumSamples(r, i, d, "steps_per_epoch")) && (y = cE(0, g)), null == s && (s = 1), b = TR(u, s, o, f, g, d, i, v, h), x = b.callbackList, w = b.history, x.setModel(t), t.history = w, e.next = 18, x.onTrainBegin();
                        case 18:
                            t.stopTraining_ = !1, k = regeneratorRuntime.mark(function e(o) {
                                var s;
                                return regeneratorRuntime.wrap(function (e) {
                                    for (;;) switch (e.prev = e.next) {
                                        case 0:
                                            return e.next = 2, x.onEpochBegin(o);
                                        case 2:
                                            if (s = {}, null == d) {
                                                e.next = 7;
                                                break
                                            }
                                            throw new mC("stepsPerEpoch mode is not implemented yet.");
                                        case 7:
                                            return e.delegateYield(regeneratorRuntime.mark(function e() {
                                                var o, u, h, f;
                                                return regeneratorRuntime.wrap(function (e) {
                                                    for (;;) switch (e.prev = e.next) {
                                                        case 0:
                                                            if ("batch" !== p) {
                                                                e.next = 4;
                                                                break
                                                            }
                                                            throw new mC("batch shuffling is not implemneted yet");
                                                        case 4:
                                                            p && Qm(y);
                                                        case 5:
                                                            o = qN(y), u = kA(g, i), h = regeneratorRuntime.mark(function e(p) {
                                                                var h;
                                                                return regeneratorRuntime.wrap(function (e) {
                                                                    for (;;) switch (e.prev = e.next) {
                                                                        case 0:
                                                                            return h = {}, e.next = 3, x.onBatchBegin(p, h);
                                                                        case 3:
                                                                            return rx(function () {
                                                                                var e = u[p][0],
                                                                                    f = u[p][1],
                                                                                    d = fE(o, e, f - e);
                                                                                h.batch = p, h.size = f - e;
                                                                                for (var m = wA(r, d), g = n(m), y = 0; y < a.length; ++y) {
                                                                                    var b = a[y],
                                                                                        x = g[y];
                                                                                    h[b] = x, ix(x)
                                                                                }
                                                                                if (p === u.length - 1 && v)
                                                                                    for (var w = t.testLoop(l, c, i), k = 0; k < a.length; ++k) {
                                                                                        var N = a[k],
                                                                                            I = w[k];
                                                                                        ix(I), s["val_" + N] = I
                                                                                    }
                                                                            }), e.next = 6, x.onBatchEnd(p, h);
                                                                        case 6:
                                                                            if (yR(h), !t.stopTraining_) {
                                                                                e.next = 9;
                                                                                break
                                                                            }
                                                                            return e.abrupt("return", "break");
                                                                        case 9:
                                                                        case "end":
                                                                            return e.stop()
                                                                    }
                                                                }, e)
                                                            }), f = 0;
                                                        case 9:
                                                            if (!(f < u.length)) {
                                                                e.next = 17;
                                                                break
                                                            }
                                                            return e.delegateYield(h(f), "t0", 11);
                                                        case 11:
                                                            if ("break" !== e.t0) {
                                                                e.next = 14;
                                                                break
                                                            }
                                                            return e.abrupt("break", 17);
                                                        case 14:
                                                            ++f, e.next = 9;
                                                            break;
                                                        case 17:
                                                            o.dispose();
                                                        case 18:
                                                        case "end":
                                                            return e.stop()
                                                    }
                                                }, e)
                                            })(), "t0", 8);
                                        case 8:
                                            return e.next = 10, x.onEpochEnd(o, s);
                                        case 10:
                                            if (!t.stopTraining_) {
                                                e.next = 12;
                                                break
                                            }
                                            return e.abrupt("return", "break");
                                        case 12:
                                        case "end":
                                            return e.stop()
                                    }
                                }, e)
                            }), N = f;
                        case 21:
                            if (!(N < o)) {
                                e.next = 29;
                                break
                            }
                            return e.delegateYield(k(N), "t0", 23);
                        case 23:
                            if ("break" !== e.t0) {
                                e.next = 26;
                                break
                            }
                            return e.abrupt("break", 29);
                        case 26:
                            ++N, e.next = 21;
                            break;
                        case 29:
                            return e.next = 31, x.onTrainEnd();
                        case 31:
                            return e.next = 33, t.history.syncData();
                        case 33:
                            return e.abrupt("return", t.history);
                        case 34:
                        case "end":
                            return e.stop()
                    }
                }, e)
            })).apply(this, arguments)
        }.apply(this, arguments)
    }

    function IA(e, t, n, r) {
        return function () {
            return Pm(regeneratorRuntime.mark(function e(t, n, r, a) {
                var i, o, s, u, l, c, p, h, f, d, m, v, g, y, b, x, w, k, N, I, S;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (void 0 === a && (a = {}), !t.isTraining) {
                                e.next = 3;
                                break
                            }
                            throw new Error("Cannot start training because another fit() call is ongoing.");
                        case 3:
                            return t.isTraining = !0, e.prev = 4, bA(h = null == a.batchSize ? 32 : a.batchSize), e.next = 10, t.standardizeUserData(n, r, a.sampleWeight, a.classWeight, !1, h);
                        case 10:
                            if (f = e.sent, i = f[0], o = f[1], p = f[2], d = !1, !(null != a.validationData && a.validationData.length > 0)) {
                                e.next = 36;
                                break
                            }
                            if (d = !0, 2 !== a.validationData.length) {
                                e.next = 22;
                                break
                            }
                            s = a.validationData[0], u = a.validationData[1], e.next = 27;
                            break;
                        case 22:
                            if (3 !== a.validationData.length) {
                                e.next = 26;
                                break
                            }
                            throw new mC("validationData including sample weights is not supported yet.");
                        case 26:
                            throw new dC("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; " + a.validationData + " is invalid.");
                        case 27:
                            return e.next = 30, t.standardizeUserData(s, u, null, null, !0, h);
                        case 30:
                            v = e.sent, l = v[0], c = v[1], m = l.concat(c), e.next = 37;
                            break;
                        case 36:
                            null != a.validationSplit && a.validationSplit > 0 && a.validationSplit < 1 ? (d = !0, g = Math.floor(i[0].shape[0] * (1 - a.validationSplit)), y = i[0].shape[0], l = xA(i, g, y), i = xA(i, 0, g), c = xA(o, g, y), o = xA(o, 0, g), m = l.concat(c)) : null != a.validationSteps && (d = !0);
                        case 37:
                            return b = i.concat(o).concat(p), t.checkTrainableWeightsConsistency(), x = t.makeTrainFunction(), w = t.getDedupedMetricsNames(), d ? (t.makeTestFunction(), k = t.testFunction, N = w.slice().concat(w.map(function (e) {
                                return "val_" + e
                            }))) : (k = null, m = [], N = w.slice()), I = IR(a.callbacks, a.yieldEvery), e.next = 45, NA(t, x, b, w, h, a.epochs, a.verbose, I, k, m, a.shuffle, N, a.initialEpoch, null, null);
                        case 45:
                            return S = e.sent, e.abrupt("return", S);
                        case 47:
                            return e.prev = 47, t.isTraining = !1, TA(i, n), TA(o, r), TA(l, s), TA(c, u), null != p && ax(p), e.finish(47);
                        case 55:
                        case "end":
                            return e.stop()
                    }
                }, e, null, [
                    [4, , 47, 55]
                ])
            })).apply(this, arguments)
        }.apply(this, arguments)
    }

    function SA(e) {
        var t = [];
        e instanceof Ng && (e = [e]);
        for (var n = 0; n < e.length; ++n) {
            var r = e[n];
            if (1 === r.rank) t.push(hE(r, 1));
            else {
                if (0 === r.rank) throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");
                t.push(r)
            }
        }
        return t
    }

    function TA(e, t) {
        if (null != e) {
            var n = [];
            if (t instanceof Ng) n.push(t.id);
            else if (Array.isArray(t)) t.forEach(function (e) {
                return n.push(e.id)
            });
            else if (null != t)
                for (var r in t) {
                    var a = t[r];
                    n.push(a.id)
                }
            var i = [];
            if (e instanceof Ng) - 1 === n.indexOf(e.id) && i.push(e);
            else if (Array.isArray(e)) e.forEach(function (e) {
                -1 === n.indexOf(e.id) && i.push(e)
            });
            else if (null != e)
                for (var o in e) {
                    var s = e[o]; - 1 === n.indexOf(s.id) && i.push(s)
                }
            i.forEach(function (e) {
                e.isDisposed || e.dispose()
            })
        }
    }

    function CA(e) {
        return Array.isArray(e)
    }

    function EA(e) {
        return ! function (e) {
            return e instanceof Ng
        }(e) && !CA(e)
    }

    function RA(e, t, n, r, a) {
        if (void 0 === r && (r = !0), void 0 === a && (a = ""), null == t || 0 === t.length) {
            if (null != e) {
                var i = !1;
                if (CA(e) && e.length > 0) i = !0;
                else if (EA(e)) {
                    for (var o in e)
                        if (e.hasOwnProperty(o)) {
                            i = !0;
                            break
                        }
                } else i = !0;
                if (i) throw new dC("Error when checking model " + a + " expected no data, but got " + e)
            }
            return []
        }
        if (null == e) return t.map(function (e) {
            return null
        });
        var s;
        if (EA(e)) {
            e = e, s = [];
            for (var u, l = Xm(t); !(u = l()).done;) {
                var c = u.value;
                if (null == e[c]) throw new dC('No data provided for "' + c + '". Need data for each key in: ' + t);
                s.push(e[c])
            }
        } else if (CA(e)) {
            if ((e = e).length !== t.length) throw new dC("Error when checking model " + a + ": the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see " + t.length + " Tensor(s), but instead got the following list of Tensor(s): " + e);
            s = e
        } else {
            if (e = e, t.length > 1) throw new dC("The model " + a + " expects " + t.length + " Tensor(s), but only received one Tensor. Found: Tensor with shape " + e.shape);
            s = [e]
        }
        if (s = SA(s), null != n)
            for (var p = 0; p < t.length; ++p)
                if (null != n[p]) {
                    var h = s[p];
                    if (h.shape.length !== n[p].length) throw new dC("Error when checking " + a + ": expected " + t[p] + " to have " + n[p].length + " dimension(s). but got array with shape " + h.shape);
                    for (var f = 0; f < n[p].length; ++f)
                        if (0 !== f || r) {
                            var d = h.shape[f],
                                m = n[p][f];
                            if (null != m && m >= 0 && d !== m) throw new dC("Error when checking " + a + ": expected " + t[p] + " to have shape [" + n[p] + "], but got array with shape [" + h.shape + "].")
                        }
                } return s
    }

    function AA(e, t, n, r, a) {
        var i;
        if (void 0 === r && (r = !0), void 0 === a && (a = ""), Array.isArray(e)) {
            if (e.length !== t.length) throw new dC("Error when checking model " + a + ": the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see " + t.length + " Tensor(s), but instead got " + e.length + " Tensors(s).");
            i = e
        } else {
            if (t.length > 1) throw new dC("The model expects " + t.length + " " + a + " Tensors, but only received one Tensor. Found: array with shape " + JSON.stringify(e.shape) + ".");
            i = [e]
        }
        if (null != n)
            for (var o = 0; o < t.length; ++o)
                if (null != n[o]) {
                    var s = i[o];
                    if (s.shape.length !== n[o].length) throw new dC("Error when checking " + a + ": expected " + t[o] + " to have " + n[o].length + " dimension(s), but got array with shape " + JSON.stringify(s.shape));
                    for (var u = 0; u < n[o].length; ++u)
                        if (0 !== u || r) {
                            var l = s.shape[u],
                                c = n[o][u];
                            if (null != c && c !== l) throw new dC("Error when checking " + a + ": expected " + t[o] + " to have shape " + JSON.stringify(n[o]) + " but got array with shape " + JSON.stringify(s.shape) + ".")
                        }
                }
    }
    var FA = function (e) {
        function t(t) {
            var n;
            return (n = e.call(this, t) || this).isTraining = !1, n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.summary = function (e, t, n) {
            if (void 0 === n && (n = console.log), !this.built) throw new dC("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");
            ! function (e, t, n, r) {
                void 0 === r && (r = console.log);
                var a, i = function (e) {
                        var t = !0,
                            n = [],
                            r = [];
                        for (var a in e.nodesByDepth) n.push(e.nodesByDepth[a]);
                        for (var i = 0, o = n; i < o.length; i++) {
                            var s = o[i];
                            if (s.length > 1 || 1 === s.length && s[0].inboundLayers.length > 1) {
                                t = !1;
                                break
                            }
                            r.push.apply(r, s)
                        }
                        if (t)
                            for (var u, l = Xm(e.layers); !(u = l()).done;) {
                                for (var c, p = !1, h = Xm(u.value.inboundNodes); !(c = h()).done;) {
                                    var f = c.value;
                                    if (-1 !== r.indexOf(f)) {
                                        if (p) {
                                            t = !1;
                                            break
                                        }
                                        p = !0
                                    }
                                }
                                if (!t) break
                            }
                        return t
                    }(e),
                    o = ["Layer (type)", "Output shape", "Param #"];
                if (i ? (t = t || 65, n = n || [.45, .85, 1]) : (t = t || 98, n = n || [.33, .55, .67, 1]), n[n.length - 1] <= 1 && (n = n.map(function (e) {
                        return Math.floor(t * e)
                    })), !i)
                    for (var s in o.push("Receives inputs"), a = [], e.nodesByDepth) {
                        var u;
                        (u = a).push.apply(u, e.nodesByDepth[s])
                    }
                r("_".repeat(t)), JR(o, n, r), r("=".repeat(t));
                for (var l = e.layers, c = 0; c < l.length; ++c) i ? ZR(l[c], n, r) : QR(l[c], n, a, r), r((c === l.length - 1 ? "=" : "_").repeat(t));
                e.checkTrainableWeightsConsistency();
                var p = function (e) {
                        return null != e.collectedTrainableWeights ? aR(e.collectedTrainableWeights) : aR(e.trainableWeights)
                    }(e),
                    h = aR(e.nonTrainableWeights);
                r("Total params: " + (p + h)), r("Trainable params: " + p), r("Non-trainable params: " + h), r("_".repeat(t))
            }(this, e, t, n)
        }, n.compile = function (e) {
            var t = this;
            if (null == e.loss && (e.loss = []), this.loss = e.loss, "string" == typeof e.optimizer) this.optimizer_ = function (e) {
                var t = {
                    Adagrad: function () {
                        return IS.adagrad(.01)
                    },
                    Adadelta: function () {
                        return IS.adadelta(1, .95, pC())
                    },
                    Adam: function () {
                        return IS.adam(.001, .9, .999, pC())
                    },
                    Adamax: function () {
                        return IS.adamax(.002, .9, .999, pC(), 0)
                    },
                    RMSProp: function () {
                        return IS.rmsprop(.001, .9, 0, pC())
                    },
                    SGD: function () {
                        return IS.sgd(.01)
                    }
                };
                if (t.adagrad = t.Adagrad, t.adadelta = t.Adadelta, t.adam = t.Adam, t.adamax = t.Adamax, t.rmsprop = t.RMSProp, t.sgd = t.SGD, e in t) return t[e]();
                throw new dC("Unknown Optimizer " + e)
            }(e.optimizer), this.isOptimizerOwned = !0;
            else {
                if (!(e.optimizer instanceof mS)) throw new dC("User-defined optimizer must be an instance of tf.Optimizer.");
                this.optimizer_ = e.optimizer, this.isOptimizerOwned = !1
            }
            var n = [];
            if (Array.isArray(e.loss) || "string" == typeof e.loss || "function" == typeof e.loss)
                if (Array.isArray(e.loss)) {
                    if (e.loss.length !== this.outputs.length) throw new dC("When passing an Array as loss, it should have one entry per model output. The model has " + this.outputs.length + " output(s), but you passed loss=" + e.loss + ".");
                    var r = e.loss;
                    n = r.map(function (e) {
                        return zR(e)
                    })
                } else {
                    var a = zR(e.loss);
                    this.outputs.forEach(function (e) {
                        n.push(a)
                    })
                }
            else {
                for (var i in e.loss = e.loss, e.loss)
                    if (-1 === this.outputNames.indexOf(i)) throw new dC('Unknown entry in loss dictionary: "' + i + '". Only expected the following keys: ' + this.outputNames);
                for (var o, s = Xm(this.outputNames); !(o = s()).done;) {
                    var u = o.value;
                    null == e.loss[u] && console.warn('Output "' + u + '" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ' + u + " during training"), n.push(zR(e.loss[u]))
                }
            }
            this.lossFunctions = n, this.feedOutputNames = [], this.feedOutputShapes = [], this.feedLossFns = [];
            for (var l = 0; l < this.outputs.length; ++l) {
                var c = this.internalOutputShapes[l],
                    p = this.outputNames[l];
                this.feedOutputNames.push(p), this.feedOutputShapes.push(c), this.feedLossFns.push(this.lossFunctions[l])
            }
            var h = [];
            this.metrics = e.metrics, this.metricsNames = ["loss"], this.metricsTensors = [], tE("loss", function () {
                for (var e = 0; e < t.outputs.length; ++e)
                    if (-1 === h.indexOf(e)) {
                        var n = t.lossFunctions[e];
                        t.outputs.length > 1 && (t.metricsTensors.push([n, e]), t.metricsNames.push(t.outputNames[e] + "_loss"))
                    }
            });
            var f = function (e, t) {
                    if (null == e || Array.isArray(e) && 0 === e.length) return t.map(function (e) {
                        return []
                    });
                    var n;
                    if ("string" == typeof e || "function" == typeof e) n = [e];
                    else {
                        if (!Array.isArray(e) && "object" != typeof e) throw new TypeError("Type of metrics argument not understood. Expected an string,function, Array, or Object, found: " + e);
                        n = e
                    }
                    if (Array.isArray(n)) return t.map(function (e) {
                        return n
                    });
                    for (var r, a = [], i = Xm(t); !(r = i()).done;) {
                        var o = r.value,
                            s = n.hasOwnProperty(o) ? n[o] : [];
                        Array.isArray(s) || (s = [s]), a.push(s)
                    }
                    return a
                }(e.metrics, this.outputNames),
                d = function (e, n, r) {
                    t.outputNames.length > 1 && (n = t.outputNames[e] + "_" + n), t.metricsNames.push(n), t.metricsTensors.push([r, e])
                };
            tE("metric", function () {
                for (var e = function (e) {
                        if (-1 !== h.indexOf(e)) return "continue";
                        ! function (n) {
                            for (var r, a, i, o, s = Xm(f[e]); !(o = s()).done;) {
                                var u = o.value;
                                if ("string" == typeof u && -1 !== ["accuracy", "acc", "crossentropy", "ce"].indexOf(u)) {
                                    var l = t.internalOutputShapes[e];
                                    1 === l[l.length - 1] || t.lossFunctions[e] === OR ? -1 !== ["accuracy", "acc"].indexOf(u) ? a = PR : -1 !== ["crossentropy", "ce"].indexOf(u) && (a = UR) : t.lossFunctions[e] === DR ? -1 !== ["accuracy", "acc"].indexOf(u) ? a = GR : -1 !== ["crossentropy", "ce"].indexOf(u) && (a = HR) : -1 !== ["accuracy", "acc"].indexOf(u) ? a = BR : -1 !== ["crossentropy", "ce"].indexOf(u) && (a = jR);
                                    var c = void 0; - 1 !== ["accuracy", "acc"].indexOf(u) ? c = "acc" : -1 !== ["crossentropy", "ce"].indexOf(u) && (c = "ce"), i = a, r = "" + c
                                } else {
                                    var p = KR(u);
                                    i = p, r = "" + XR(u)
                                }
                                var h = void 0;
                                tE(r, function () {
                                    h = i
                                }), d(e, r, h)
                            }
                        }()
                    }, n = 0; n < t.outputs.length; ++n) e(n)
            }), this.collectedTrainableWeights = this.trainableWeights
        }, n.checkTrainableWeightsConsistency = function () {
            null != this.collectedTrainableWeights && this.trainableWeights.length !== this.collectedTrainableWeights.length && console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")
        }, n.evaluate = function (e, t, n) {
            void 0 === n && (n = {});
            var r = null == n.batchSize ? 32 : n.batchSize;
            bA(r);
            var a = this.standardizeUserDataXY(e, t, !0, r);
            try {
                var i = a[0].concat(a[1]);
                this.makeTestFunction();
                var o = this.testFunction;
                return xC(this.testLoop(o, i, r, n.verbose, n.steps))
            } finally {
                TA(a[0], e), TA(a[1], t)
            }
        }, n.evaluateDataset = function () {
            var e = Pm(regeneratorRuntime.mark(function e(t, n) {
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return this.makeTestFunction(), e.abrupt("return", yA(this, t, n));
                        case 2:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function (t, n) {
                return e.apply(this, arguments)
            }
        }(), n.checkNumSamples = function (e, t, n, r) {
            var a;
            if (void 0 === r && (r = "steps"), null != n) {
                if (a = null, null != t) throw new dC("If " + r + " is set, batchSize must be null or undefined.Got batchSize = " + t)
            } else {
                if (null == e) throw new dC("Either the input data should have a defined shape, or " + r + " shoud be specified.");
                a = Array.isArray(e) ? e[0].shape[0] : e.shape[0]
            }
            return a
        }, n.execute = function (e, t) {
            if (Array.isArray(t) && 0 === t.length) throw new dC("`outputs` is an empty Array, which is not allowed.");
            var n = Array.isArray(t),
                r = n ? t : [t],
                a = this.retrieveSymbolicTensors(r),
                i = new tA;
            if (e instanceof Ng && (e = [e]), Array.isArray(e)) {
                if (e.length !== this.inputs.length) throw new dC("The number of inputs provided (" + e.length + ") does not match the number of inputs of this model (" + this.inputs.length + ").");
                for (var o = 0; o < this.inputs.length; ++o) i.add(this.inputs[o], e[o])
            } else
                for (var s, u = Xm(this.inputs); !(s = u()).done;) {
                    var l = s.value,
                        c = e[l.name];
                    if (null == c) throw new dC("No value is provided for the model's input " + l.name);
                    i.add(l, c)
                }
            var p = aA(a, i);
            return n ? p : p[0]
        }, n.retrieveSymbolicTensors = function (e) {
            for (var t, n = gC(null, e.length), r = e.length, a = Xm(this.layers); !(t = a()).done;) {
                for (var i = t.value, o = Array.isArray(i.output) ? i.output : [i.output], s = o.map(function (e) {
                        return e.name
                    }), u = 0; u < e.length; ++u) {
                    var l = s.indexOf(e[u]);
                    if (-1 !== l && (n[u] = o[l], r--), 0 === r) break
                }
                if (0 === r) break
            }
            if (r > 0) {
                var c = [];
                throw n.forEach(function (t, n) {
                    null == t && c.push(e[n])
                }), new dC("Cannot find SymbolicTensors for output name(s): " + JSON.stringify(c))
            }
            return n
        }, n.predictLoop = function (e, t, n) {
            var r = this;
            return void 0 === t && (t = 32), void 0 === n && (n = !1), rx(function () {
                var a = r.checkNumSamples(e);
                if (n) throw new mC("Verbose predictLoop() is not implemented yet.");
                for (var i = kA(a, t), o = r.outputs.map(function (e) {
                        return []
                    }), s = function (t) {
                        rx(function () {
                            var n = i[t][0],
                                a = i[t][1],
                                o = xA(e, n, a),
                                s = [];
                            if (Array.isArray(o))
                                for (var u = 0; u < o.length; ++u) s.push({
                                    key: r.inputs[u],
                                    value: o[u]
                                });
                            else s.push({
                                key: r.inputs[0],
                                value: o
                            });
                            var l = new tA(s);
                            return aA(r.outputs, l)
                        }).forEach(function (e, t) {
                            return o[t].push(e)
                        })
                    }, u = 0; u < i.length; ++u) s(u);
                return xC(o.map(function (e) {
                    return Vx(e, 0)
                }))
            })
        }, n.predict = function (e, t) {
            void 0 === t && (t = {});
            var n = SA(e);
            AA(n, this.inputNames, this.feedInputShapes, !1);
            try {
                var r = null == t.batchSize ? 32 : t.batchSize;
                return bA(r), this.predictLoop(n, r)
            } finally {
                TA(n, e)
            }
        }, n.predictOnBatch = function (e) {
            AA(e, this.inputNames, this.feedInputShapes, !0);
            var t = (Array.isArray(e) ? e[0] : e).shape[0];
            return this.predictLoop(e, t)
        }, n.standardizeUserDataXY = function (e, t, n, r) {
            if (void 0 === n && (n = !0), null == this.optimizer_) throw new fC("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");
            for (var a = [], i = 0; i < this.feedOutputShapes.length; ++i) {
                var o = this.feedOutputShapes[i];
                this.feedLossFns[i] === DR ? a.push(o.slice(0, o.length - 1).concat([1])) : a.push(o)
            }
            if (function (e, t, n) {
                    var r = EC(e.map(function (e) {
                        return e.shape[0]
                    }));
                    r.sort();
                    var a = EC(t.map(function (e) {
                        return e.shape[0]
                    }));
                    if (a.sort(), r.length > 1) throw new dC("All input Tensors (x) should have the same number of samples. Got array shapes: " + JSON.stringify(e.map(function (e) {
                        return e.shape
                    })));
                    if (a.length > 1) throw new dC("All target Tensors (y) should have the same number of samples. Got array shapes: " + JSON.stringify(t.map(function (e) {
                        return e.shape
                    })));
                    if (r.length > 0 && a.length > 0 && !sv(r, a)) throw new dC("Input Tensors should have the same number of samples as target Tensors. Found " + r[0] + " input sample(s) and " + a[0] + " target sample(s).")
                }(e = RA(e, this.feedInputNames, this.feedInputShapes, !1, "input"), t = RA(t, this.feedOutputNames, a, !1, "target")), function (e, t, n) {
                    for (var r = [RR, OR, _R], a = 0; a < e.length; ++a) {
                        var i = e[a],
                            o = t[a],
                            s = n[a];
                        if (null != o) {
                            if (o === _R && 1 === i.shape[i.shape.length - 1]) throw new dC("You are passing a target array of shape " + i.shape + " while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");
                            if (-1 !== r.indexOf(o))
                                for (var u = i.shape.slice(1), l = s.slice(1), c = 0; c < u.length; ++c) {
                                    var p = u[c],
                                        h = l[c];
                                    if (null != h && p !== h) throw new dC("A target Tensor with shape " + i.shape + " was passed for an output of shape " + s + ", while using a loss function that expects targets to have the same shape as the output.")
                                }
                        }
                    }
                }(t, this.feedLossFns, this.feedOutputShapes), this.stateful && null != r && r > 0 && e[0].shape[0] % r != 0) throw new dC("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size " + r + ". Found: " + e[0].shape[0] + " sample(s).");
            return [e, t]
        }, n.standardizeUserData = function () {
            var e = Pm(regeneratorRuntime.mark(function e(t, n, r, a, i, o) {
                var s, u, l, c, p, h;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (void 0 === i && (i = !0), s = this.standardizeUserDataXY(t, n, i, o), u = s[0], l = s[1], null == r) {
                                e.next = 4;
                                break
                            }
                            throw new Error("sample weight is not supported yet.");
                        case 4:
                            if (c = null, null == a) {
                                e.next = 18;
                                break
                            }
                            p = uA(a, this.outputNames), c = [], h = 0;
                        case 9:
                            if (!(h < p.length)) {
                                e.next = 18;
                                break
                            }
                            return e.t0 = c, e.next = 13, lA(l[h], null, p[h]);
                        case 13:
                            e.t1 = e.sent, e.t0.push.call(e.t0, e.t1);
                        case 15:
                            ++h, e.next = 9;
                            break;
                        case 18:
                            return e.abrupt("return", [u, l, c]);
                        case 19:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function (t, n, r, a, i, o) {
                return e.apply(this, arguments)
            }
        }(), n.testLoop = function (e, t, n, r, a) {
            var i = this;
            return void 0 === r && (r = 0), rx(function () {
                var o = i.checkNumSamples(t, n, a, "steps"),
                    s = [];
                if (r > 0) throw new mC("Verbose mode is not implemented yet.");
                if (null != a) throw new mC("steps mode in testLoop() is not implemented yet");
                for (var u = kA(o, n), l = qN(cE(0, o)), c = 0; c < u.length; ++c) {
                    var p = u[c][0],
                        h = u[c][1],
                        f = fE(l, p, h - p),
                        d = wA(t, f),
                        m = e(d);
                    if (0 === c)
                        for (var v = 0; v < m.length; ++v) s.push(wN(0));
                    for (var g = 0; g < m.length; ++g) {
                        var y = m[g];
                        s[g] = ux(s[g], px(h - p, y))
                    }
                }
                for (var b = 0; b < s.length; ++b) s[b] = cx(s[b], o);
                return s
            })
        }, n.getDedupedMetricsNames = function () {
            for (var e = this.metricsNames, t = [], n = 0; n < e.length; ++n) {
                var r = e[n],
                    a = r;
                bC(e, r) > 1 && (a += "_" + bC(e.slice(0, n), r)), t.push(a)
            }
            return t
        }, n.makeTrainFunction = function () {
            var e = this;
            return function (t) {
                var n = [],
                    r = t.slice(0, e.inputs.length),
                    a = t.slice(e.inputs.length, e.inputs.length + e.outputs.length),
                    i = t.slice(e.inputs.length + e.outputs.length, e.inputs.length + 2 * e.outputs.length),
                    o = [],
                    s = e.collectedTrainableWeights.map(function (e) {
                        return e.read()
                    });
                return [e.optimizer_.minimize(function () {
                    for (var t = [], s = 0; s < e.inputs.length; ++s) t.push({
                        key: e.inputs[s],
                        value: r[s]
                    });
                    for (var u, l = new tA(t), c = aA(e.outputs, l, {
                            training: !0
                        }), p = 0; p < e.lossFunctions.length; ++p) {
                        var h = (0, e.lossFunctions[p])(a[p], c[p]);
                        null != i[p] && (h = cA(h, i[p]));
                        var f = Ik(h);
                        n.push(f), u = 0 === p ? h : ux(u, h)
                    }
                    for (var d = 0; d < e.metricsTensors.length; ++d) {
                        var m = void 0;
                        if (e.outputs.length > 1 && d < e.outputs.length) m = n[d];
                        else {
                            var v = e.metricsTensors[d][0],
                                g = e.metricsTensors[d][1];
                            m = Ik(v(a[g], c[g]))
                        }
                        ix(m), o.push(m)
                    }
                    return u = Ik(u), e.calculateLosses().forEach(function (e) {
                        u = ux(u, e)
                    }), u
                }, !0, s)].concat(o)
            }
        }, n.makeTestFunction = function () {
            var e = this;
            this.testFunction = function (t) {
                return rx(function () {
                    for (var n, r = [], a = t.slice(0, e.inputs.length), i = t.slice(e.inputs.length, e.inputs.length + e.outputs.length), o = [], s = 0; s < e.inputs.length; ++s) o.push({
                        key: e.inputs[s],
                        value: a[s]
                    });
                    for (var u = new tA(o), l = aA(e.outputs, u), c = 0; c < e.lossFunctions.length; ++c) {
                        var p = e.lossFunctions[c],
                            h = Ik(p(i[c], l[c]));
                        n = 0 === c ? h : ux(n, h), r.push(n)
                    }
                    for (var f = 0; f < e.metricsTensors.length; ++f) {
                        var d = e.metricsTensors[f][0],
                            m = e.metricsTensors[f][1],
                            v = Ik(d(i[m], l[m]));
                        r.push(v)
                    }
                    return r
                })
            }
        }, n.fit = function () {
            var e = Pm(regeneratorRuntime.mark(function e(t, n, r) {
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return void 0 === r && (r = {}), e.abrupt("return", IA(this, t, n, r));
                        case 2:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function (t, n, r) {
                return e.apply(this, arguments)
            }
        }(), n.fitDataset = function () {
            var e = Pm(regeneratorRuntime.mark(function e(t, n) {
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return e.abrupt("return", dA(this, t, n));
                        case 1:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function (t, n) {
                return e.apply(this, arguments)
            }
        }(), n.trainOnBatch = function () {
            var e = Pm(regeneratorRuntime.mark(function e(t, n) {
                var r, a, i, o, s, u, l, c, p, h;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return e.next = 2, this.standardizeUserData(t, n);
                        case 2:
                            r = e.sent, a = r[0], i = r[1], o = this.makeTrainFunction(), s = o(a.concat(i)), u = [], l = Xm(s);
                        case 9:
                            if ((c = l()).done) {
                                e.next = 17;
                                break
                            }
                            return p = c.value, e.next = 13, p.data();
                        case 13:
                            h = e.sent, u.push(h[0]);
                        case 15:
                            e.next = 9;
                            break;
                        case 17:
                            return ax(s), e.abrupt("return", xC(u));
                        case 19:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function (t, n) {
                return e.apply(this, arguments)
            }
        }(), n.getNamedWeights = function (e) {
            for (var t = [], n = null != e && e.trainableOnly, r = n ? this.trainableWeights : this.weights, a = this.getWeights(n), i = 0; i < r.length; ++i) n && !r[i].trainable || t.push({
                name: r[i].originalName,
                tensor: a[i]
            });
            return t
        }, n.dispose = function () {
            var t = e.prototype.dispose.call(this);
            if (0 === t.refCountAfterDispose && null != this.optimizer && this.isOptimizerOwned) {
                var n = nx().numTensors;
                this.optimizer_.dispose(), t.numDisposedVariables += n - nx().numTensors
            }
            return t
        }, n.getLossIdentifiers = function () {
            var e;
            if ("string" == typeof this.loss) e = kC(this.loss);
            else if (Array.isArray(this.loss)) {
                for (var t, n = Xm(this.loss); !(t = n()).done;)
                    if ("string" != typeof t.value) throw new Error("Serialization of non-string loss is not supported.");
                e = this.loss.map(function (e) {
                    return kC(e)
                })
            } else {
                var r = Object.keys(this.loss);
                e = {};
                for (var a = this.loss, i = 0, o = r; i < o.length; i++) {
                    var s = o[i];
                    if ("string" != typeof a[s]) throw new Error("Serialization of non-string loss is not supported.");
                    e[s] = kC(a[s])
                }
            }
            return e
        }, n.getMetricIdentifiers = function () {
            if ("string" == typeof this.metrics || "function" == typeof this.metrics) return [kC(XR(this.metrics))];
            if (Array.isArray(this.metrics)) return this.metrics.map(function (e) {
                return kC(XR(e))
            });
            var e = {};
            for (var t in this.metrics) e[t] = kC(XR(this.metrics[t]));
            return e
        }, n.getTrainingConfig = function () {
            return {
                loss: this.getLossIdentifiers(),
                metrics: this.getMetricIdentifiers(),
                optimizer_config: {
                    class_name: this.optimizer.getClassName(),
                    config: this.optimizer.getConfig()
                }
            }
        }, n.loadTrainingConfig = function (e) {
            if (null != e.weighted_metrics) throw new Error("Loading weight_metrics is not supported yet.");
            if (null != e.loss_weights) throw new Error("Loading loss_weights is not supported yet.");
            if (null != e.sample_weight_mode) throw new Error("Loading sample_weight_mode is not supported yet.");
            var t, n, r = CR(eA(e.optimizer_config));
            if ("string" == typeof e.loss) t = NC(e.loss);
            else if (Array.isArray(e.loss)) t = e.loss.map(function (e) {
                return NC(e)
            });
            else if (null != e.loss)
                for (var a in t = {}, e.loss) t[a] = NC(e.loss[a]);
            if (Array.isArray(e.metrics)) n = e.metrics.map(function (e) {
                return NC(e)
            });
            else if (null != e.metrics)
                for (var i in n = {}, e.metrics) n[i] = NC(e.metrics[i]);
            this.compile({
                loss: t,
                metrics: n,
                optimizer: r
            })
        }, n.save = function () {
            var e = Pm(regeneratorRuntime.mark(function e(t, n) {
                var r, a, i, o, s, u, l, c, p;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if ("string" != typeof t) {
                                e.next = 9;
                                break
                            }
                            if (0 !== (r = vy(t)).length) {
                                e.next = 6;
                                break
                            }
                            throw new dC("Cannot find any save handlers for URL '" + t + "'");
                        case 6:
                            if (!(r.length > 1)) {
                                e.next = 8;
                                break
                            }
                            throw new dC("Found more than one (" + r.length + ") save handlers for URL '" + t + "'");
                        case 8:
                            t = r[0];
                        case 9:
                            if (null != t.save) {
                                e.next = 11;
                                break
                            }
                            throw new dC("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
                        case 11:
                            return e.next = 13, ay(this.getNamedWeights(n));
                        case 13:
                            if (a = e.sent, i = this.toJSON(null, !1), o = {
                                    modelTopology: i,
                                    format: "layers-model",
                                    generatedBy: "TensorFlow.js tfjs-layers v3.3.0",
                                    convertedBy: null
                                }, null == n || !n.includeOptimizer || null == this.optimizer) {
                                e.next = 34;
                                break
                            }
                            return o.trainingConfig = this.getTrainingConfig(), u = "optimizer", e.t0 = hb, e.next = 25, this.optimizer.getWeights();
                        case 25:
                            return e.t1 = e.sent, e.t2 = u, e.next = 29, e.t0.encodeWeights.call(e.t0, e.t1, e.t2);
                        case 29:
                            l = e.sent, c = l.data, p = l.specs, (s = a.specs).push.apply(s, p), a.data = py([a.data, c]);
                        case 34:
                            return null != this.userDefinedMetadata && (YR(this.userDefinedMetadata, this.name, !0), o.userDefinedMetadata = this.userDefinedMetadata), o.weightData = a.data, o.weightSpecs = a.specs, e.abrupt("return", t.save(o));
                        case 38:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function (t, n) {
                return e.apply(this, arguments)
            }
        }(), n.setUserDefinedMetadata = function (e) {
            YR(e, this.name), this.userDefinedMetadata = e
        }, n.getUserDefinedMetadata = function () {
            return this.userDefinedMetadata
        }, Wm(t, [{
            key: "stopTraining",
            set: function (e) {
                this.stopTraining_ = e
            },
            get: function () {
                return this.stopTraining_
            }
        }, {
            key: "optimizer",
            get: function () {
                return this.optimizer_
            },
            set: function (e) {
                this.optimizer_ !== e && (this.optimizer_ = e, this.isOptimizerOwned = !1)
            }
        }]), t
    }(function (e) {
        function t(n) {
            var r;
            if ((r = e.call(this, {}) || this).containerNodes = new Set, r.name = n.name, null == r.name) {
                var a = r.getClassName().toLowerCase();
                r.name = $E(a)
            }
            if (r.supportsMasking = !1, r.trainable_ = !0, Array.isArray(n.inputs) ? r.inputs = n.inputs.slice() : r.inputs = [n.inputs], Array.isArray(n.outputs) ? r.outputs = n.outputs.slice() : r.outputs = [n.outputs], EC(r.inputs).length !== r.inputs.length) throw new dC("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: " + r.inputs.map(function (e) {
                return e.name
            }));
            EC(r.outputs).length !== r.outputs.length && console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: " + r.outputs.map(function (e) {
                return e.name
            })), r.inputLayers = [], r.inputLayersNodeIndices = [], r.inputLayersTensorIndices = [], r.outputLayers = [], r.outputLayersNodeIndices = [], r.outputLayersTensorIndices = [], r.layers = [], r.internalContainerRefs = [];
            for (var i, o = Xm(r.outputs); !(i = o()).done;) {
                var s = i.value,
                    u = s.sourceLayer,
                    l = s.nodeIndex,
                    c = s.tensorIndex;
                r.outputLayers.push(u), r.outputLayersNodeIndices.push(l), r.outputLayersTensorIndices.push(c)
            }
            for (var p, h = Xm(r.inputs); !(p = h()).done;) {
                var f = p.value,
                    d = f.sourceLayer,
                    m = f.nodeIndex,
                    v = f.tensorIndex;
                yC(0 === m, "input layer has >1 nodes"), yC(0 === v, "input layer has >1 tensors"), r.inputLayers.push(d), r.inputLayersNodeIndices.push(m), r.inputLayersTensorIndices.push(v)
            }
            r.inputNames = [], r.outputNames = [], r.feedInputShapes = [], r.feedInputNames = [], r.feedOutputNames = [];
            for (var g = 0; g < r.inputLayers.length; g++) {
                var y = r.inputLayers[g];
                if (!(y instanceof mR)) throw new TypeError("Input layers to a LayersModel must be InputLayer objects. Received inputs: " + n.inputs + ". Input " + g + " (0-based) originates from layer type " + y.getClassName() + ".");
                r.inputNames.push(y.name), r.feedInputShapes.push(y.batchInputShape), r.feedInputNames.push(y.name)
            }
            for (var b, x = Xm(r.outputLayers); !(b = x()).done;) {
                var w = b.value;
                r.outputNames.push(w.name)
            }
            r.internalInputShapes = r.inputs.map(function (e) {
                return e.shape
            }), r.internalOutputShapes = r.outputs.map(function (e) {
                return e.shape
            });
            for (var k, N = {}, I = {}, S = {}, T = {}, C = {}, E = [], R = function e(n, a, i, o, s, u) {
                    null != o && null != s && null != u || (o = n.sourceLayer, s = n.nodeIndex, u = n.tensorIndex);
                    var l = o.inboundNodes[s];
                    if (-1 !== i.indexOf(l)) throw new fC("The tensor " + n.name + ' at layer "' + o.name + '" is part of a cycle.');
                    if (-1 === a.indexOf(l)) {
                        r.containerNodes.add(t.nodeKey(o, s)), o.id in C || (C[o.id] = Object.keys(C).length), -1 === i.indexOf(l) && i.push(l);
                        for (var c = l.inboundLayers.length, p = 0; p < c; p++) e(l.inputTensors[p], a, i, l.inboundLayers[p], l.nodeIndices[p], l.tensorIndices[p]);
                        for (a.push(l); i.indexOf(l) >= 0;) i.splice(i.indexOf(l), 1);
                        E.push(l)
                    }
                }, A = [], F = [], _ = Xm(r.outputs); !(k = _()).done;) R(k.value, A, F);
            for (var D, O = Xm(E.slice().reverse()); !(D = O()).done;) {
                var M = D.value;
                I[M.id] = M, M.id in N || (N[M.id] = 0);
                var L = N[M.id],
                    z = null == S[M.outboundLayer.id] ? 0 : S[M.outboundLayer.id];
                L = Math.max(L, z), S[M.outboundLayer.id] = L, T[M.outboundLayer.id] = M.outboundLayer, N[M.id] = L;
                for (var P = 0; P < M.inboundLayers.length; P++) {
                    var B = M.inboundLayers[P],
                        W = M.nodeIndices[P],
                        V = B.inboundNodes[W],
                        U = null == N[V.id] ? 0 : N[V.id];
                    N[V.id] = Math.max(L + 1, U), I[V.id] = V
                }
            }
            var G = {};
            for (var j in N) {
                var H = N[j];
                H in G || (G[H] = []), G[H].push(I[j])
            }
            var q = {};
            for (var K in S) {
                var X = S[K];
                X in q || (q[X] = []), q[X].push(T[K])
            }
            var Y = Object.keys(q).map(function (e) {
                return parseInt(e, 10)
            }).sort(CC);
            r.layers = [];
            for (var J, Z = Xm(Y); !(J = Z()).done;) {
                var Q = q[J.value];
                Q.sort(function (e, t) {
                    var n = C[e.id],
                        r = C[t.id];
                    return n < r ? -1 : n > r ? 1 : 0
                });
                for (var $, ee = Xm(Q); !($ = ee()).done;) {
                    var te = $.value;
                    te instanceof t && r.internalContainerRefs.push(te), r.layers.push(te)
                }
            }
            r.layersByDepth = q, Y = Object.keys(G).map(function (e) {
                return parseInt(e, 10)
            }).sort(CC);
            for (var ne, re = r.inputs.slice(), ae = [], ie = Xm(Y); !(ne = ie()).done;)
                for (var oe, se = Xm(G[ne.value]); !(oe = se()).done;) {
                    var ue = oe.value,
                        le = ue.outboundLayer;
                    if (null != le) {
                        for (var ce, pe = Xm(ue.inputTensors); !(ce = pe()).done;) {
                            var he = ce.value;
                            if (-1 === re.indexOf(he)) throw new fC("Graph disconnected: cannot obtain value for tensor " + he + ' at layer "' + le.name + '". The following previous layers were accessed without issue: ' + ae)
                        }
                        for (var fe, de = Xm(ue.outputTensors); !(fe = de()).done;) {
                            var me = fe.value;
                            re.push(me)
                        }
                        ae.push(le.name)
                    }
                }
            r.nodesByDepth = G;
            for (var ve, ge = r.layers.map(function (e) {
                    return e.name
                }), ye = function () {
                    var e = ve.value,
                        t = ge.filter(function (t) {
                            return t === e
                        }).length;
                    if (1 !== t) throw new fC('The name "' + e + '" is used ' + t + " times in the model. All layer names should be unique. Layer names: " + JSON.stringify(ge))
                }, be = Xm(ge); !(ve = be()).done;) ye();
            return r.outboundNodes = [], r.inboundNodes = [], new hR({
                outboundLayer: qm(r),
                inboundLayers: [],
                nodeIndices: [],
                tensorIndices: [],
                inputTensors: r.inputs,
                outputTensors: r.outputs,
                inputMasks: r.inputs.map(function (e) {
                    return null
                }),
                outputMasks: r.outputs.map(function (e) {
                    return null
                }),
                inputShapes: r.inputs.map(function (e) {
                    return e.shape
                }),
                outputShapes: r.outputs.map(function (e) {
                    return e.shape
                })
            }), r.built = !0, r._refCount = 1, r
        }
        Vm(t, e);
        var n = t.prototype;
        return n.assertNotDisposed = function () {
            if (0 === this._refCount) throw new Error("Container '" + this.name + "' is already disposed.")
        }, n.dispose = function () {
            this.assertNotDisposed();
            var e = {
                refCountAfterDispose: null,
                numDisposedVariables: 0
            };
            if (0 == --this._refCount) {
                for (var t, n = Xm(this.layers); !(t = n()).done;) {
                    var r = t.value;
                    e.numDisposedVariables += r.dispose().numDisposedVariables
                }
                for (var a, i = Xm(this.internalContainerRefs); !(a = i()).done;) {
                    var o = a.value;
                    e.numDisposedVariables += o.dispose().numDisposedVariables
                }
            }
            return e.refCountAfterDispose = this._refCount, e
        }, n.loadWeights = function (e, t) {
            void 0 === t && (t = !0);
            for (var n, r = {}, a = 0, i = Xm(this.layers); !(n = i()).done;)
                for (var o, s = Xm(n.value.weights); !(o = s()).done;) {
                    var u = o.value;
                    if (null != r[u.originalName]) throw new dC("Duplicate weight name: " + u.originalName);
                    r[u.originalName] = u, a++
                }
            var l = [];
            for (var c in e) {
                var p = c;
                if (null == r[c]) {
                    var h = c.split("/");
                    p = h.slice(0, -2).concat([h[h.length - 1]]).join("/")
                }
                if (null != r[p]) l.push([r[p], e[c]]);
                else if (t) throw new dC("Provided weight data has no target variable: " + c);
                delete r[p]
            }
            if (t) {
                var f = [];
                for (var d in r) f.push(d);
                if (f.length > 0) throw new dC(f.length + " of " + a + " weights are not set: " + f)
            }
            sR(l)
        }, n.updatedConfig = function () {
            var e = this.getConfig(),
                t = {};
            return t.className = this.getClassName(), t.config = e, t.kerasVersion = "tfjs-layers 3.3.0", t.backend = "TensorFlow.js", t
        }, n.toJSON = function (e, t) {
            void 0 === t && (t = !0);
            var n = function e(t, n) {
                if (null == t) return null;
                if ("string" == typeof t) return kC(t);
                if ("number" == typeof t || "boolean" == typeof t) return t;
                if (t instanceof Array) {
                    for (var r = [], a = t.length, i = 0; i < a; ++i) {
                        var o = t[i];
                        $R(n, i, o) ? r.push(o) : r.push(e(o, n))
                    }
                    return r
                }
                for (var s = {}, u = 0, l = Object.keys(t); u < l.length; u++) {
                    var c = l[u],
                        p = t[c];
                    s[kC(c)] = "name" !== c && "className" !== c || "string" != typeof p ? e(p, c) : p
                }
                return s
            }(this.updatedConfig());
            return t ? JSON.stringify(n) : n
        }, n.call = function (e, t) {
            var n = this;
            return rx(function () {
                e = wC(e);
                for (var r = new tA, a = 0; a < n.inputs.length; ++a) r.add(n.inputs[a], e[a]);
                return aA(n.outputs, r, t)
            })
        }, n.computeMask = function (e, t) {
            var n = this;
            return rx(function () {
                var r;
                return e = wC(e), r = null == t ? gC(null, e.length) : wC(t), n.runInternalGraph(e, r)[1]
            })
        }, n.computeOutputShape = function (e) {
            var t = tR(e);
            if (t.length !== this.inputLayers.length) throw new dC("Invalid inputShape argument " + e + ": model has " + this.inputLayers.length + " tensor inputs.");
            for (var n = {}, r = 0; r < t.length; r++) {
                var a = this.inputLayers[r],
                    i = t[r];
                n[a.name + "_0_0"] = i
            }
            var o = Object.keys(this.nodesByDepth).map(function (e) {
                return parseInt(e, 10)
            }).sort(CC);
            if (o.length > 1)
                for (var s, u = Xm(o); !(s = u()).done;)
                    for (var l, c = s.value, p = Xm(this.nodesByDepth[c]); !(l = p()).done;) {
                        var h = l.value,
                            f = h.outboundLayer;
                        if (-1 === this.inputLayers.map(function (e) {
                                return e.id
                            }).indexOf(f.id)) {
                            for (var d = [], m = 0; m < h.inboundLayers.length; m++) {
                                var v = h.inboundLayers[m],
                                    g = h.nodeIndices[m],
                                    y = h.tensorIndices[m],
                                    b = n[v.name + "_" + g + "_" + y];
                                d.push(b)
                            }
                            for (var x = tR(f.computeOutputShape(xC(d))), w = f.inboundNodes.indexOf(h), k = 0; k < x.length; k++) n[f.name + "_" + w + "_" + k] = x[k]
                        }
                    }
            for (var N = [], I = [], S = 0; S < this.outputLayers.length; S++) {
                var T = this.outputLayers[S],
                    C = this.outputLayersNodeIndices[S],
                    E = this.outputLayersTensorIndices[S],
                    R = T.name + "_" + C + "_" + E;
                I.push(R)
            }
            for (var A = 0; A < I.length; A++) {
                var F = I[A];
                yC(F in n), N.push(n[F])
            }
            return xC(N)
        }, n.runInternalGraph = function (e, t) {
            null == t && (t = gC(null, e.length));
            for (var n = {}, r = 0; r < this.inputs.length; ++r) {
                var a = this.inputs[r],
                    i = e[r],
                    o = t[r];
                n[a.id] = [i, o]
            }
            for (var s, u = Xm(Object.keys(this.nodesByDepth).map(function (e) {
                    return parseInt(e, 10)
                }).sort(CC)); !(s = u()).done;)
                for (var l, c = s.value, p = Xm(this.nodesByDepth[c]); !(l = p()).done;) {
                    for (var h, f = l.value, d = f.outboundLayer, m = f.inputTensors, v = f.outputTensors, g = new Array, y = Xm(m); !(h = y()).done;) {
                        var b = h.value;
                        b.id in n && g.push(n[b.id])
                    }
                    if (g.length === m.length) {
                        var x = {},
                            w = void 0,
                            k = void 0,
                            N = void 0,
                            I = void 0;
                        if (null != f.callArgs && (x = f.callArgs), 1 === g.length) {
                            var S = g[0],
                                T = S[0],
                                C = S[1];
                            null == x.mask && (x.mask = C), N = wC(d.call(T, x)), I = wC(d.computeMask(T, C)), w = [T], k = [C]
                        } else w = g.map(function (e) {
                            return e[0]
                        }), k = g.map(function (e) {
                            return e[1]
                        }), null == x.mask && (x.mask = k), N = wC(d.call(w, x)), I = wC(d.computeMask(w, k));
                        if (d.activityRegularizer) throw new mC("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");
                        for (var E = 0; E < v.length; ++E) {
                            var R = v[E],
                                A = N[E],
                                F = I[E];
                            n[R.id] = [A, F]
                        }
                    }
                }
            for (var _, D = [], O = [], M = [], L = Xm(this.outputs); !(_ = L()).done;) {
                var z = _.value;
                yC(z.id in n, "Could not compute output " + z.name + " : " + z.id);
                var P = n[z.id],
                    B = P[0],
                    W = P[1];
                M.push(B.shape), D.push(B), O.push(W)
            }
            return [D, O, M]
        }, n.buildNodeConversionMap = function (e) {
            for (var n, r, a = {}, i = Xm(this.layers); !(r = i()).done;) {
                var o = r.value;
                n = o instanceof t ? 1 : 0;
                for (var s = 0; s < o.inboundNodes.length; s++) {
                    var u = t.nodeKey(o, s);
                    this.containerNodes.has(u) && (a[u] = n, n += 1)
                }
            }
            return a
        }, n.getLayer = function (e, t) {
            if (null != t) {
                if (this.layers.length <= t) throw new dC("Was asked to retrieve layer at index " + t + ", but model only has " + this.layers.length + " layer(s).");
                return this.layers[t]
            }
            if (null == e) throw new dC("Provide either a layer name or layer index");
            for (var n, r = Xm(this.layers); !(n = r()).done;) {
                var a = n.value;
                if (a.name === e) return a
            }
            throw new dC("No such layer: " + e)
        }, n.calculateLosses = function () {
            var e = this;
            return rx(function () {
                for (var n, r = [], a = Xm(e.layers); !(n = a()).done;)
                    for (var i = n.value, o = 0; o < i.inboundNodes.length; ++o) {
                        var s = t.nodeKey(i, o);
                        e.containerNodes.has(s) && r.push.apply(r, i.calculateLosses())
                    }
                return r
            })
        }, n.getConfig = function () {
            for (var e, n = {
                    name: this.name
                }, r = this.buildNodeConversionMap(this.layers), a = [], i = Xm(this.layers); !(e = i()).done;) {
                for (var o = e.value, s = o.getClassName(), u = o.getConfig(), l = [], c = 0; c < o.inboundNodes.length; c++) {
                    var p = o.inboundNodes[c],
                        h = t.nodeKey(o, c),
                        f = {};
                    if (this.containerNodes.has(h)) {
                        if (p.callArgs) try {
                            JSON.stringify(p.callArgs), f = p.callArgs
                        } catch (e) {
                            console.warn("Layer " + o.name + " was passed non-serializable keyword arguments: " + p.callArgs + ". They will not be included in the serialized model (and thus will be missing at deserialization time)."), f = {}
                        }
                        if (p.inboundLayers.length > 0) {
                            for (var d = [], m = 0; m < p.inboundLayers.length; m++) {
                                var v = p.inboundLayers[m],
                                    g = p.nodeIndices[m],
                                    y = p.tensorIndices[m],
                                    b = r[t.nodeKey(v, g)];
                                null == b && (b = 0), d.push([v.name, b, y, f])
                            }
                            l.push(d)
                        }
                    }
                }
                var x = {};
                x.name = o.name, x.className = s, x.config = u, x.inboundNodes = l, a.push(x)
            }
            n.layers = a;
            for (var w = [], k = 0; k < this.inputLayers.length; k++) {
                var N = this.inputLayers[k],
                    I = this.inputLayersNodeIndices[k],
                    S = t.nodeKey(N, I);
                if (this.containerNodes.has(S)) {
                    var T = r[S];
                    null == T && (T = 0);
                    var C = this.inputLayersTensorIndices[k];
                    w.push([N.name, T, C])
                }
            }
            n.inputLayers = w;
            for (var E = [], R = 0; R < this.outputLayers.length; R++) {
                var A = this.outputLayers[R],
                    F = this.outputLayersNodeIndices[R],
                    _ = t.nodeKey(A, F);
                if (this.containerNodes.has(_)) {
                    var D = r[_];
                    null == D && (D = 0);
                    var O = this.outputLayersTensorIndices[R];
                    E.push([A.name, D, O])
                }
            }
            return n.outputLayers = E, n
        }, t.fromConfig = function (e, t, n, r) {
            void 0 === n && (n = {}), void 0 === r && (r = !1);
            var a = {},
                i = {};

            function o(e, t) {
                e.name in i ? i[e.name].push(t) : i[e.name] = [t]
            }

            function s(e, t) {
                for (var n, r, i = [], s = Xm(t); !(r = s()).done;) {
                    var u = r.value,
                        l = u[0],
                        c = u[1],
                        p = u[2];
                    if (n = null == u[3] ? {} : u[3], !(l in a)) return void o(e, t);
                    var h = a[l];
                    if (h.inboundNodes.length <= c) return void o(e, t);
                    var f = h.inboundNodes[c];
                    i.push(f.outputTensors[p])
                }
                i.length > 0 && e.apply(xC(i), n)
            }

            function u(e) {
                var n = e.name,
                    i = CR(e, null != t.customObjects ? t.customObjects : {});
                i.setFastWeightInitDuringBuild(r), a[n] = i, e.inboundNodes.forEach(function (e) {
                    if (!(e instanceof Array)) throw new dC("Corrupted configuration, expected array for nodeData: " + e);
                    o(i, e)
                })
            }
            for (var l, c = t.name, p = t.layers, h = Xm(p); !(l = h()).done;) u(l.value);
            for (; !RC(i);)
                for (var f, d = Xm(p); !(f = d()).done;) {
                    var m = f.value,
                        v = a[m.name];
                    if (v.name in i) {
                        var g = i[v.name];
                        delete i[v.name];
                        for (var y, b = Xm(g); !(y = b()).done;) s(v, y.value)
                    }
                }
            for (var x, w = [], k = [], N = Xm(t.inputLayers); !(x = N()).done;) {
                var I = x.value,
                    S = I[0],
                    T = I[1],
                    C = I[2];
                yC(S in a);
                var E = a[S].inboundNodes[T].outputTensors;
                w.push(E[C])
            }
            for (var R, A = Xm(t.outputLayers); !(R = A()).done;) {
                var F = R.value,
                    _ = F[0],
                    D = F[1],
                    O = F[2];
                yC(_ in a);
                var M = a[_].inboundNodes[D].outputTensors;
                k.push(M[O])
            }
            return new e({
                inputs: w,
                outputs: k,
                name: c
            })
        }, n.resetStates = function () {
            var e = this;
            rx(function () {
                e.layers.forEach(function (e) {
                    e.stateful && e.resetStates()
                })
            })
        }, Wm(t, [{
            key: "trainable",
            get: function () {
                return this.trainable_
            },
            set: function (e) {
                this.layers.forEach(function (t) {
                    t._trainableWeights.forEach(function (t) {
                        return t.trainable = e
                    })
                }), this.trainable_ = e
            }
        }, {
            key: "trainableWeights",
            get: function () {
                if (this._trainableWeights.length > 0) throw new dC("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");
                if (!this.trainable) return [];
                for (var e, t = [], n = Xm(this.layers); !(e = n()).done;) {
                    var r = e.value;
                    t = t.concat(r.trainableWeights)
                }
                return t
            }
        }, {
            key: "nonTrainableWeights",
            get: function () {
                for (var e, t = [], n = Xm(this.layers); !(e = n()).done;) {
                    var r = e.value;
                    t.push.apply(t, r.nonTrainableWeights)
                }
                if (!this.trainable) {
                    for (var a, i = [], o = Xm(this.layers); !(a = o()).done;) {
                        var s = a.value;
                        i.push.apply(i, s.trainableWeights)
                    }
                    return i.concat(t)
                }
                return t
            }
        }, {
            key: "weights",
            get: function () {
                return this.trainableWeights.concat(this.nonTrainableWeights)
            }
        }, {
            key: "stateful",
            get: function () {
                if (this._stateful) throw new dC("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");
                for (var e, t = Xm(this.layers); !(e = t()).done;)
                    if (e.value.stateful) return !0;
                return !1
            }
        }]), t
    }(dR));
    FA.className = "Model", Yb(FA);
    var _A = function (e) {
        function t() {
            return e.apply(this, arguments) || this
        }
        return Vm(t, e), t
    }(FA);

    function DA() {
        return (DA = Pm(regeneratorRuntime.mark(function e(t, n) {
            var r, a, i, o, s, u, l, c;
            return regeneratorRuntime.wrap(function (e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        if ("modelTopology" in t || (t = {
                                modelTopology: t
                            }), null != (r = (t = t).modelTopology).model_config && (r = r.model_config), a = eA(r), i = CR(a, n), null == t.weightsManifest) {
                            e.next = 14;
                            break
                        }
                        return e.next = 9, tb(t.weightsManifest, t.pathPrefix, i.weights.map(function (e) {
                            return e.originalName
                        }));
                    case 9:
                        for (o = e.sent, s = {}, u = Xm(i.weights); !(l = u()).done;) c = l.value, s[c.originalName] = o[c.originalName];
                        i.loadWeights(s), ax(o);
                    case 14:
                        return e.abrupt("return", i);
                    case 15:
                    case "end":
                        return e.stop()
                }
            }, e)
        }))).apply(this, arguments)
    }

    function OA() {
        return (OA = Pm(regeneratorRuntime.mark(function e(t, n) {
            var r;
            return regeneratorRuntime.wrap(function (e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        if (null == n && (n = {}), "string" != typeof t) {
                            e.next = 10;
                            break
                        }
                        if (0 !== (r = gy(t, n)).length) {
                            e.next = 7;
                            break
                        }
                        r.push(ub(t, n)), e.next = 9;
                        break;
                    case 7:
                        if (!(r.length > 1)) {
                            e.next = 9;
                            break
                        }
                        throw new dC("Found more than one (" + r.length + ") load handlers for URL '" + t + "'");
                    case 9:
                        t = r[0];
                    case 10:
                        return e.abrupt("return", MA(t, void 0, n));
                    case 11:
                    case "end":
                        return e.stop()
                }
            }, e)
        }))).apply(this, arguments)
    }

    function MA(e, t, n) {
        return function () {
            return Pm(regeneratorRuntime.mark(function e(t, n, r) {
                var a, i, o, s, u, l, c, p, h;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (null == r && (r = {}), null != t.load) {
                                e.next = 3;
                                break
                            }
                            throw new dC("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
                        case 3:
                            return e.next = 5, t.load();
                        case 5:
                            if (a = e.sent, null != (i = a.modelTopology).model_config && (i = i.model_config), o = null == r.strict || r.strict, s = null != a.weightData && null != a.weightSpecs && o, u = CR(eA(i), n, s), null != (l = a.trainingConfig) && u.loadTrainingConfig(l), null != a.userDefinedMetadata && u.setUserDefinedMetadata(a.userDefinedMetadata), null == a.weightData) {
                                e.next = 24;
                                break
                            }
                            if (null != a.weightSpecs) {
                                e.next = 17;
                                break
                            }
                            throw new dC("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");
                        case 17:
                            if (c = LA(a.weightData, a.weightSpecs), p = c.modelWeights, h = c.optimizerWeights, u.loadWeights(p, o), !(null != u.optimizer && h.length > 0)) {
                                e.next = 22;
                                break
                            }
                            return e.next = 22, u.optimizer.setWeights(h);
                        case 22:
                            ax(p), ax(h.map(function (e) {
                                return e.tensor
                            }));
                        case 24:
                            return e.abrupt("return", u);
                        case 25:
                        case "end":
                            return e.stop()
                    }
                }, e)
            })).apply(this, arguments)
        }.apply(this, arguments)
    }

    function LA(e, t) {
        var n = iy(e, t),
            r = {},
            a = [];
        return t.forEach(function (e) {
            "optimizer" === e.group ? a.push({
                name: e.name,
                tensor: n[e.name]
            }) : r[e.name] = n[e.name]
        }), {
            modelWeights: r,
            optimizerWeights: a
        }
    }
    _A.className = "Functional", Yb(_A);
    var zA = function (e) {
        function t(t) {
            var n;
            if (t = t || {}, (n = e.call(this, {
                    inputs: [],
                    outputs: []
                }) || this).trainable = !0, n.built = !1, n.name = null != t.name ? t.name : $E("sequential_"), null != t.layers)
                for (var r, a = Xm(t.layers); !(r = a()).done;) {
                    var i = r.value;
                    n.add(i)
                }
            return n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.checkShape = function (e) {
            if (e.inboundNodes[0].outputTensors[0].shape.some(function (e) {
                    return e < 0
                })) throw new dC("Negative dimension size caused by adding layer " + e.name + " with input shape [" + e.inboundNodes[0].inputTensors[0].shape + "]")
        }, n.add = function (e) {
            var n, r = e instanceof t || e instanceof FA;
            if (r) {
                if (1 !== (n = e).outputs.length) throw new dC("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
                if (1 !== n.inputs.length) throw new dC("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")
            }
            if (0 === this.outputs.length) {
                if (0 === e.inboundNodes.length) {
                    if (null == e.batchInputShape) throw new dC("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");
                    var a = vR({
                        batchShape: e.batchInputShape,
                        dtype: e.dtype,
                        name: e.name + "_input"
                    });
                    e.apply(a)
                }
                if (r) this.outputs = n.outputs, this.inputs = n.inputs;
                else {
                    if (1 !== e.inboundNodes.length) throw new dC("A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer " + e.name + " which has " + e.inboundNodes.length + " pre-existing inbound connections.");
                    if (1 !== e.inboundNodes[0].outputTensors.length) throw new dC("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
                    this.checkShape(e), this.outputs = [e.inboundNodes[0].outputTensors[0]], this.inputs = function e(t, n, r) {
                        if ((null == n || null != r && r > 0) && (n = t.sourceLayer, r = t.nodeIndex), 0 === n.inboundNodes.length) return [t];
                        var a = n.inboundNodes[r];
                        if (0 === a.inboundLayers.length) return a.inputTensors;
                        for (var i = [], o = 0; o < a.inboundLayers.length; o++)
                            for (var s, u = Xm(e(a.inputTensors[o], a.inboundLayers[o], a.nodeIndices[o])); !(s = u()).done;) {
                                var l = s.value; - 1 === i.indexOf(l) && i.push(l)
                            }
                        return i
                    }(this.outputs[0])
                }
                this.inboundNodes = [], new hR({
                    outboundLayer: this,
                    inboundLayers: [],
                    nodeIndices: [],
                    tensorIndices: [],
                    inputTensors: this.inputs,
                    outputTensors: this.outputs,
                    inputMasks: gC(null, this.inputs.length),
                    outputMasks: [null],
                    inputShapes: this.inputs.map(function (e) {
                        return e.shape
                    }),
                    outputShapes: this.outputs[0].shape
                })
            } else {
                var i = e.apply(this.outputs[0]);
                if (Array.isArray(i)) throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
                this.checkShape(e), this.outputs = [i], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape]
            }
            this.layers.push(e), this.built = !1
        }, n.pop = function () {
            if (0 === this.layers.length) throw new TypeError("There are no layers in the model.");
            if (this.layers.pop(), 0 === this.layers.length) this.outputs = [], this.inboundNodes = [], this.outboundNodes = [];
            else {
                var e = this.layers.length - 1;
                this.layers[e].outboundNodes = [], this.outputs = [this.layers[e].output], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape]
            }
        }, n.call = function (e, t) {
            return null == this.model && this.build(), this.model.call(e, t)
        }, n.build = function (e) {
            if (rR(e), 0 === this.inputs.length || 0 === this.outputs.length) throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");
            this.model = new FA({
                inputs: this.inputs,
                outputs: this.outputs[0],
                name: this.name + "_model"
            }), this.model.trainable = this.trainable, this.supportsMasking = this.model.supportsMasking, this.inputLayers = this.model.inputLayers, this.inputLayersNodeIndices = this.model.inputLayersNodeIndices, this.inputLayersTensorIndices = this.model.inputLayersTensorIndices, this.outputLayers = this.model.outputLayers, this.outputLayersNodeIndices = this.model.outputLayersNodeIndices, this.outputLayersTensorIndices = this.model.outputLayersTensorIndices, this.nodesByDepth = this.model.nodesByDepth, this.containerNodes = this.model.containerNodes, this.outputNames = this.model.outputNames, this.inputNames = this.model.inputNames, this.built = !0
        }, n.countParams = function () {
            return this.built || this.build(), e.prototype.countParams.call(this)
        }, n.summary = function (t, n, r) {
            void 0 === r && (r = console.log), this.built || this.build(), e.prototype.summary.call(this, t, n, r)
        }, n.setWeights = function (e) {
            null == this.model && this.build(), this.model.setWeights(e)
        }, n.evaluate = function (e, t, n) {
            if (void 0 === n && (n = {}), !this.built) throw new fC("The model needs to be compiled before being used.");
            return this.model.evaluate(e, t, n)
        }, n.evaluateDataset = function () {
            var e = Pm(regeneratorRuntime.mark(function e(t, n) {
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (this.built) {
                                e.next = 2;
                                break
                            }
                            throw new fC("The model needs to be compiled before being used.");
                        case 2:
                            return e.abrupt("return", this.model.evaluateDataset(t, n));
                        case 3:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function (t, n) {
                return e.apply(this, arguments)
            }
        }(), n.predict = function (e, t) {
            return void 0 === t && (t = {}), null == this.model && this.build(), this.model.predict(e, t)
        }, n.predictOnBatch = function (e) {
            return null == this.model && this.build(), this.model.predictOnBatch(e)
        }, n.compile = function (e) {
            this.build(), this.model.compile(e), this.optimizer_ = this.model.optimizer, this.isOptimizerOwned = this.model.isOptimizerOwned, this.loss = this.model.loss, this.metrics = this.model.metrics, this.metricsTensors = this.model.metricsTensors, this.metricsNames = this.model.metricsNames
        }, n.fit = function () {
            var e = Pm(regeneratorRuntime.mark(function e(t, n, r) {
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (void 0 === r && (r = {}), this.built) {
                                e.next = 3;
                                break
                            }
                            throw new fC("The model needs to be compiled before being used.");
                        case 3:
                            return e.abrupt("return", this.model.fit(t, n, r));
                        case 4:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function (t, n, r) {
                return e.apply(this, arguments)
            }
        }(), n.fitDataset = function () {
            var e = Pm(regeneratorRuntime.mark(function e(t, n) {
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (this.built) {
                                e.next = 2;
                                break
                            }
                            throw new fC("The model needs to be compiled before being used.");
                        case 2:
                            return e.abrupt("return", this.model.fitDataset(t, n));
                        case 3:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function (t, n) {
                return e.apply(this, arguments)
            }
        }(), n.trainOnBatch = function () {
            var e = Pm(regeneratorRuntime.mark(function e(t, n) {
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return e.abrupt("return", this.model.trainOnBatch(t, n));
                        case 1:
                        case "end":
                            return e.stop()
                    }
                }, e, this)
            }));
            return function (t, n) {
                return e.apply(this, arguments)
            }
        }(), t.fromConfig = function (e, n, r, a) {
            var i;
            void 0 === r && (r = {}), void 0 === a && (a = !1);
            var o = {};
            if (n instanceof Array) {
                if (null == n[0].className || "Merge" === n[0].className) throw new dC("Legacy serialization format not supported yet.");
                i = n
            } else nv(null != n.layers, function () {
                return "When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."
            }), i = n.layers, delete n.layers, o = n;
            var s = new e(o);
            if (!(s instanceof t)) throw new mC("Sequential.fromConfig called on non-Sequential input: " + s);
            for (var u, l = Xm(i); !(u = l()).done;) {
                var c = CR(u.value, void 0, a);
                a && c.setFastWeightInitDuringBuild(!0), s.add(c)
            }
            return s
        }, n.getConfig = function () {
            for (var e, t = [], n = Xm(this.layers); !(e = n()).done;) {
                var r = e.value,
                    a = {};
                a.className = r.getClassName(), a.config = r.getConfig(), t.push(a)
            }
            return {
                name: this.name,
                layers: t
            }
        }, Wm(t, [{
            key: "optimizer",
            get: function () {
                return null == this.model ? void 0 : this.model.optimizer
            },
            set: function (e) {
                this.model.optimizer = e
            }
        }, {
            key: "stopTraining",
            set: function (e) {
                if (null == this.model) throw new dC("Cannot set the stopTraining property of a sequential model before it is compiled.");
                this.model.stopTraining = e
            },
            get: function () {
                if (null == this.model) throw new dC("Cannot get the stopTraining property of a sequential model before it is compiled.");
                return this.model.stopTraining
            }
        }]), t
    }(FA);

    function PA(e) {
        return vR(e)
    }
    zA.className = "Sequential", Yb(zA);
    var BA = function (e) {
            function t() {
                return e.apply(this, arguments) || this
            }
            return Vm(t, e), t.prototype.getConfig = function () {
                return {}
            }, t
        }(Kb),
        WA = function (e) {
            function t() {
                return e.apply(this, arguments) || this
            }
            return Vm(t, e), t.prototype.apply = function (e, t) {
                return void 0 === t && (t = 1),
                    function (e, t) {
                        if (void 0 === t && (t = 1), 1 !== t) throw new mC("Support for alpha values other than 1 (" + t + ") is not implemented yet.");
                        return Ew(e)
                    }(e, t)
            }, t
        }(BA);
    WA.className = "elu", Yb(WA);
    var VA = function (e) {
        function t() {
            return e.apply(this, arguments) || this
        }
        return Vm(t, e), t.prototype.apply = function (e) {
            return kN(e)
        }, t
    }(BA);
    VA.className = "selu", Yb(VA);
    var UA = function (e) {
        function t() {
            return e.apply(this, arguments) || this
        }
        return Vm(t, e), t.prototype.apply = function (e) {
            return hN(e)
        }, t
    }(BA);
    UA.className = "relu", Yb(UA);
    var GA = function (e) {
        function t() {
            return e.apply(this, arguments) || this
        }
        return Vm(t, e), t.prototype.apply = function (e) {
            return rx(function () {
                return Tk(6, hN(e))
            })
        }, t
    }(BA);
    GA.className = "relu6", Yb(GA);
    var jA = function (e) {
        function t() {
            return e.apply(this, arguments) || this
        }
        return Vm(t, e), t.prototype.apply = function (e) {
            return e
        }, t
    }(BA);
    jA.className = "linear", Yb(jA);
    var HA = function (e) {
        function t() {
            return e.apply(this, arguments) || this
        }
        return Vm(t, e), t.prototype.apply = function (e) {
            return Ux(e)
        }, t
    }(BA);
    HA.className = "sigmoid", Yb(HA);
    var qA = function (e) {
        function t() {
            return e.apply(this, arguments) || this
        }
        return Vm(t, e), t.prototype.apply = function (e) {
            return function (e) {
                return rx(function () {
                    var t = ux(.5, px(.2, e));
                    return ew(t, 0, 1)
                })
            }(e)
        }, t
    }(BA);
    qA.className = "hardSigmoid", Yb(qA);
    var KA = function (e) {
        function t() {
            return e.apply(this, arguments) || this
        }
        return Vm(t, e), t.prototype.apply = function (e) {
            return tk(e)
        }, t
    }(BA);
    KA.className = "softplus", Yb(KA);
    var XA = function (e) {
        function t() {
            return e.apply(this, arguments) || this
        }
        return Vm(t, e), t.prototype.apply = function (e) {
            return function (e) {
                return rx(function () {
                    return cx(e, hx(e).add(1))
                })
            }(e)
        }, t
    }(BA);
    XA.className = "softsign", Yb(XA);
    var YA = function (e) {
        function t() {
            return e.apply(this, arguments) || this
        }
        return Vm(t, e), t.prototype.apply = function (e) {
            return jx(e)
        }, t
    }(BA);
    YA.className = "tanh", Yb(YA);
    var JA = function (e) {
        function t() {
            return e.apply(this, arguments) || this
        }
        return Vm(t, e), t.prototype.apply = function (e, t) {
            return void 0 === t && (t = -1), DN(e, t)
        }, t
    }(BA);
    JA.className = "softmax", Yb(JA);
    var ZA = function (e) {
        function t() {
            return e.apply(this, arguments) || this
        }
        return Vm(t, e), t.prototype.apply = function (e, t) {
            return void 0 === t && (t = -1), ok(e, t)
        }, t
    }(BA);
    ZA.className = "logSoftmax", Yb(ZA);
    var QA = function (e) {
        function t() {
            return e.apply(this, arguments) || this
        }
        return Vm(t, e), t.prototype.apply = function (e, t) {
            return void 0 === t && (t = 1), rx(function () {
                return Ux(e.mul(t)).mul(e)
            })
        }, t
    }(BA);

    function $A(e) {
        return e.getClassName()
    }

    function eF(e, t) {
        return void 0 === t && (t = {}), TC(e, Xb.getMap().classNameMap, t, "activation")
    }

    function tF(e) {
        if (null == e) {
            return eF({
                className: "linear",
                config: {}
            })
        }
        if ("string" == typeof e) {
            var t = {};
            return t.className = e, t.config = {}, eF(t)
        }
        return e instanceof BA ? e : eF(e)
    }

    function nF(e) {
        if (null != e && "object" != typeof e) throw new Error("Argument to L1L2 regularizer's constructor is expected to be an object, but received: " + e)
    }
    QA.className = "swish", Yb(QA);
    var rF = function (e) {
            function t() {
                return e.apply(this, arguments) || this
            }
            return Vm(t, e), t
        }(Kb),
        aF = function (e) {
            function t(t) {
                var n;
                return n = e.call(this) || this, nF(t), n.l1 = null == t || null == t.l1 ? .01 : t.l1, n.l2 = null == t || null == t.l2 ? .01 : t.l2, n.hasL1 = 0 !== n.l1, n.hasL2 = 0 !== n.l2, n
            }
            Vm(t, e);
            var n = t.prototype;
            return n.apply = function (e) {
                var t = this;
                return rx(function () {
                    var n = Ok([1]);
                    return t.hasL1 && (n = ux(n, ik(px(t.l1, hx(e))))), t.hasL2 && (n = ux(n, ik(px(t.l2, kE(e))))), n.asScalar()
                })
            }, n.getConfig = function () {
                return {
                    l1: this.l1,
                    l2: this.l2
                }
            }, t.fromConfig = function (e, t) {
                return new e({
                    l1: t.l1,
                    l2: t.l2
                })
            }, t
        }(rF);
    aF.className = "L1L2", Yb(aF);
    var iF = {
        l1l2: "L1L2"
    };

    function oF(e) {
        return SC(e)
    }

    function sF(e, t) {
        return void 0 === t && (t = {}), TC(e, Xb.getMap().classNameMap, t, "regularizer")
    }

    function uF(e) {
        return null == e ? null : "string" == typeof e ? sF({
            className: e in iF ? iF[e] : e,
            config: {}
        }) : e instanceof rF ? e : sF(e)
    }
    var lF = function (e) {
        function t(t) {
            var n;
            return (n = e.call(this, null == t ? {} : t) || this).supportsMasking = !0, null != t && (n.maxValue = t.maxValue), n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.call = function (e, t) {
            e = nR(e);
            var n = hN(e);
            return null != this.maxValue && (n = ew(n, 0, this.maxValue)), n
        }, n.computeOutputShape = function (e) {
            return e
        }, n.getConfig = function () {
            var t = {
                    maxValue: this.maxValue
                },
                n = e.prototype.getConfig.call(this);
            return Object.assign(t, n), t
        }, t
    }(dR);
    lF.className = "ReLU", Yb(lF);
    var cF = function (e) {
        function t(t) {
            var n;
            return (n = e.call(this, null == t ? {} : t) || this).DEFAULT_ALPHA = .3, null == t && (t = {}), n.alpha = null == t.alpha ? n.DEFAULT_ALPHA : t.alpha, n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.call = function (e, t) {
            var n = nR(e);
            return jw(n, this.alpha)
        }, n.computeOutputShape = function (e) {
            return e
        }, n.getConfig = function () {
            var t = {
                    alpha: this.alpha
                },
                n = e.prototype.getConfig.call(this);
            return Object.assign(t, n), t
        }, t
    }(dR);
    cF.className = "LeakyReLU", Yb(cF);
    var pF = function (e) {
        function t(t) {
            var n;
            if ((n = e.call(this, null == t ? {} : t) || this).DEFAULT_ALPHA_INITIALIZER = "zeros", null == t && (t = {}), n.supportsMasking = !0, n.alphaInitializer = XE(t.alphaInitializer || n.DEFAULT_ALPHA_INITIALIZER), n.alphaRegularizer = uF(t.alphaRegularizer), n.alphaConstraint = GC(t.alphaConstraint), null == t.sharedAxes) n.sharedAxes = null;
            else if (Array.isArray(t.sharedAxes)) n.sharedAxes = t.sharedAxes;
            else {
                if ("number" != typeof t.sharedAxes) throw new dC("Expected sharedAxes to be a number or an array of numbers, but got " + t.sharedAxes);
                n.sharedAxes = [t.sharedAxes]
            }
            return n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.build = function (e) {
            var t = (e = rR(e)).slice(1);
            if (null != this.sharedAxes)
                for (var n, r = Xm(this.sharedAxes); !(n = r()).done;) t[n.value - 1] = 1;
            this.alpha = this.addWeight("alpha", t, "float32", this.alphaInitializer, this.alphaRegularizer, !0, this.alphaConstraint);
            var a = {};
            if (null != this.sharedAxes)
                for (var i = 1; i < e.length; ++i) a[i] = e[i];
            this.inputSpec = [new lR({
                ndim: e.length,
                axes: a
            })], this.built = !0
        }, n.call = function (e, t) {
            return e = nR(e), qk(e, this.alpha.read())
        }, n.getConfig = function () {
            var t = {
                    alphaInitializer: KE(this.alphaInitializer),
                    alphaRegularizer: oF(this.alphaRegularizer),
                    alphaConstraint: VC(this.alphaConstraint),
                    sharedAxes: this.sharedAxes
                },
                n = e.prototype.getConfig.call(this);
            return Object.assign(t, n), t
        }, t
    }(dR);
    pF.className = "PReLU", Yb(pF);
    var hF = function (e) {
        function t(t) {
            var n;
            if ((n = e.call(this, null == t ? {} : t) || this).DEFAULT_ALPHA = 1, null == t && (t = {}), null != t.alpha && t.alpha !== n.DEFAULT_ALPHA) throw new mC("Non-default alpha value (" + t.alpha + ") is not supported by the ELU layer yet.");
            return n.alpha = null == t.alpha ? n.DEFAULT_ALPHA : t.alpha, n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.call = function (e, t) {
            var n = nR(e);
            return Ew(n)
        }, n.computeOutputShape = function (e) {
            return e
        }, n.getConfig = function () {
            var t = {
                    alpha: this.alpha
                },
                n = e.prototype.getConfig.call(this);
            return Object.assign(t, n), t
        }, t
    }(dR);
    hF.className = "ELU", Yb(hF);
    var fF = function (e) {
        function t(t) {
            var n;
            return (n = e.call(this, null == t ? {} : t) || this).DEFAULT_THETA = 1, null == t && (t = {}), n.theta = null == t.theta ? n.DEFAULT_THETA : t.theta, n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.call = function (e, t) {
            var n = nR(e);
            return n.mul(pE(n.greater(this.theta), "float32"))
        }, n.computeOutputShape = function (e) {
            return e
        }, n.getConfig = function () {
            var t = {
                    theta: this.theta
                },
                n = e.prototype.getConfig.call(this);
            return Object.assign(t, n), t
        }, t
    }(dR);
    fF.className = "ThresholdedReLU", Yb(fF);
    var dF = function (e) {
        function t(t) {
            var n;
            return (n = e.call(this, null == t ? {} : t) || this).DEFAULT_AXIS = 1, null == t && (t = {}), n.softmax = (new JA).apply, n.axis = null == t.axis ? n.DEFAULT_AXIS : t.axis, n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.call = function (e, t) {
            var n = nR(e);
            return this.softmax(n, this.axis)
        }, n.computeOutputShape = function (e) {
            return e
        }, n.getConfig = function () {
            var t = {
                    axis: this.axis
                },
                n = e.prototype.getConfig.call(this);
            return Object.assign(t, n), t
        }, t
    }(dR);

    function mF(e, t, n) {
        if ("number" == typeof e) return gC(e, t);
        if (e.length !== t) throw new dC("The " + n + " argument must be an integer or tuple of " + t + " integers. Received: " + e.length + " elements.");
        for (var r = 0; r < t; ++r) {
            var a = e[r];
            if ((i = a) !== parseInt(i.toString(), 10)) throw new dC("The " + n + " argument must be an integer or tuple of " + t + " integers. Received: " + JSON.stringify(e) + " including a non-integer number " + a)
        }
        return e;
        var i
    }

    function vF(e, t, n, r, a) {
        return void 0 === a && (a = 1), null == e ? e : (i = "same" === n ? e : e - (t + (t - 1) * (a - 1)) + 1, Math.floor((i + r - 1) / r));
        var i
    }

    function gF(e, t, n, r) {
        if (null == e) return null;
        if ("valid" === r) e = e * t + lE([n - t, 0]);
        else {
            if ("same" !== r) throw new dC("Unsupport padding mode: " + r + ".");
            e *= t
        }
        return e
    }

    function yF(e, t) {
        return rx(function () {
            return ZC(t), "channelsFirst" === t ? mb(e, [0, 2, 3, 1]) : e
        })
    }

    function bF(e, t) {
        return rx(function () {
            return ZC(t), "channelsFirst" === t ? mb(e, [0, 2, 3, 4, 1]) : e
        })
    }

    function xF(e, t, n, r, a, i, o, s) {
        return void 0 === r && (r = [1, 1]), void 0 === a && (a = "valid"), void 0 === s && (s = null), rx(function () {
            if (null == i && (i = "channelsLast"), ZC(i), 3 !== e.rank && 4 !== e.rank) throw new dC("conv2dWithBiasActivation expects input to be of rank 3 or 4, but received " + e.rank + ".");
            if (3 !== t.rank && 4 !== t.rank) throw new dC("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received " + e.rank + ".");
            var u = yF(e, i);
            if ("causal" === a) throw new mC("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
            return u = yI({
                x: u,
                filter: t,
                strides: r,
                pad: "same" === a ? "same" : "valid",
                dilations: o,
                dataFormat: "NHWC",
                bias: n,
                activation: s
            }), "channelsFirst" === i && (u = mb(u, [0, 3, 1, 2])), u
        })
    }
    dF.className = "Softmax", Yb(dF);
    var wF = function (e) {
            function t(n, r) {
                var a;
                if ((a = e.call(this, r) || this).bias = null, a.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", a.DEFAULT_BIAS_INITIALIZER = "zeros", t.verifyArgs(r), a.rank = n, _C(a.rank, "rank"), 1 !== a.rank && 2 !== a.rank && 3 !== a.rank) throw new mC("Convolution layer for rank other than 1, 2, or 3 (" + a.rank + ") is not implemented yet.");
                if (a.kernelSize = mF(r.kernelSize, n, "kernelSize"), a.strides = mF(null == r.strides ? 1 : r.strides, n, "strides"), a.padding = null == r.padding ? "valid" : r.padding, QC(a.padding), a.dataFormat = null == r.dataFormat ? "channelsLast" : r.dataFormat, ZC(a.dataFormat), a.activation = tF(r.activation), a.useBias = null == r.useBias || r.useBias, a.biasInitializer = XE(r.biasInitializer || a.DEFAULT_BIAS_INITIALIZER), a.biasConstraint = GC(r.biasConstraint), a.biasRegularizer = uF(r.biasRegularizer), a.activityRegularizer = uF(r.activityRegularizer), a.dilationRate = mF(null == r.dilationRate ? 1 : r.dilationRate, n, "dilationRate"), 1 === a.rank && Array.isArray(a.dilationRate) && 1 !== a.dilationRate.length) throw new dC("dilationRate must be a number or an array of a single number for 1D convolution, but received " + JSON.stringify(a.dilationRate));
                if (2 === a.rank) {
                    if ("number" == typeof a.dilationRate) a.dilationRate = [a.dilationRate, a.dilationRate];
                    else if (2 !== a.dilationRate.length) throw new dC("dilationRate must be a number or array of two numbers for 2D convolution, but received " + JSON.stringify(a.dilationRate))
                } else if (3 === a.rank)
                    if ("number" == typeof a.dilationRate) a.dilationRate = [a.dilationRate, a.dilationRate, a.dilationRate];
                    else if (3 !== a.dilationRate.length) throw new dC("dilationRate must be a number or array of three numbers for 3D convolution, but received " + JSON.stringify(a.dilationRate));
                return a
            }
            return Vm(t, e), t.verifyArgs = function (e) {
                if (yC("kernelSize" in e, "required key 'kernelSize' not in config"), "number" != typeof e.kernelSize && !FC(e.kernelSize, "number", 1, 3)) throw new dC("BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received " + JSON.stringify(e.kernelSize) + ".")
            }, t.prototype.getConfig = function () {
                var t = {
                        kernelSize: this.kernelSize,
                        strides: this.strides,
                        padding: this.padding,
                        dataFormat: this.dataFormat,
                        dilationRate: this.dilationRate,
                        activation: $A(this.activation),
                        useBias: this.useBias,
                        biasInitializer: KE(this.biasInitializer),
                        biasRegularizer: oF(this.biasRegularizer),
                        activityRegularizer: oF(this.activityRegularizer),
                        biasConstraint: VC(this.biasConstraint)
                    },
                    n = e.prototype.getConfig.call(this);
                return Object.assign(t, n), t
            }, t
        }(dR),
        kF = function (e) {
            function t(n, r) {
                var a;
                return (a = e.call(this, n, r) || this).kernel = null, t.verifyArgs(r), a.filters = r.filters, _C(a.filters, "filters"), a.kernelInitializer = XE(r.kernelInitializer || a.DEFAULT_KERNEL_INITIALIZER), a.kernelConstraint = GC(r.kernelConstraint), a.kernelRegularizer = uF(r.kernelRegularizer), a
            }
            Vm(t, e);
            var n = t.prototype;
            return n.build = function (e) {
                var t;
                e = rR(e);
                var n = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
                if (null == e[n]) throw new dC("The channel dimension of the input should be defined. Found " + e[n]);
                var r = e[n],
                    a = this.kernelSize.concat([r, this.filters]);
                this.kernel = this.addWeight("kernel", a, null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [{
                    ndim: this.rank + 2,
                    axes: (t = {}, t[n] = r, t)
                }], this.built = !0
            }, n.call = function (e, t) {
                var n = this;
                return rx(function () {
                    var t;
                    e = nR(e);
                    var r = null == n.bias ? null : n.bias.read(),
                        a = DC(n.activation.getClassName());
                    if (null != a && 2 === n.rank) t = xF(e, n.kernel.read(), r, n.strides, n.padding, n.dataFormat, n.dilationRate, a);
                    else {
                        if (1 === n.rank) t = function (e, t, n, r, a, i, o) {
                            return void 0 === r && (r = 1), void 0 === a && (a = "valid"), void 0 === o && (o = 1), rx(function () {
                                if (null == i && (i = "channelsLast"), ZC(i), 3 !== e.shape.length) throw new dC("The input of a conv1dWithBias operation should be 3, but is " + e.shape.length + " instead.");
                                if (3 !== t.shape.length) throw new dC("The kernel for a conv1dWithBias operation should be 3, but is " + t.shape.length + " instead");
                                if (null != n && 1 !== n.shape.length) throw new dC("The bias for a conv1dWithBias operation should be 1, but is " + t.shape.length + " instead");
                                if ("channelsFirst" === i && (e = mb(e, [0, 2, 1])), "causal" === a) throw new mC("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
                                var s = ow(e, t, r, "same" === a ? "same" : "valid", "NWC", o);
                                return null != n && (s = IE(s, n)), s
                            })
                        }(e, n.kernel.read(), r, n.strides[0], n.padding, n.dataFormat, n.dilationRate[0]);
                        else if (2 === n.rank) t = xF(e, n.kernel.read(), r, n.strides, n.padding, n.dataFormat, n.dilationRate);
                        else {
                            if (3 !== n.rank) throw new mC("convolutions greater than 3D are not implemented yet.");
                            t = function (e, t, n, r, a, i, o) {
                                return void 0 === r && (r = [1, 1, 1]), void 0 === a && (a = "valid"), rx(function () {
                                    if (null == i && (i = "channelsLast"), ZC(i), 4 !== e.rank && 5 !== e.rank) throw new dC("conv3dWithBias expects input to be of rank 4 or 5, but received " + e.rank + ".");
                                    if (4 !== t.rank && 5 !== t.rank) throw new dC("conv3dWithBias expects kernel to be of rank 4 or 5, but received " + e.rank + ".");
                                    var s = bF(e, i);
                                    if ("causal" === a) throw new mC("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");
                                    return s = lw(s, t, r, "same" === a ? "same" : "valid", "NDHWC", o), null != n && (s = IE(s, n)), "channelsFirst" === i && (s = mb(s, [0, 4, 1, 2, 3])), s
                                })
                            }(e, n.kernel.read(), r, n.strides, n.padding, n.dataFormat, n.dilationRate)
                        }
                        null != n.activation && (t = n.activation.apply(t))
                    }
                    return t
                })
            }, n.computeOutputShape = function (e) {
                e = rR(e);
                for (var t = [], n = "channelsLast" === this.dataFormat ? e.slice(1, e.length - 1) : e.slice(2), r = 0; r < n.length; ++r) {
                    var a = vF(n[r], this.kernelSize[r], this.padding, this.strides[r], "number" == typeof this.dilationRate ? this.dilationRate : this.dilationRate[r]);
                    t.push(a)
                }
                var i = [e[0]];
                return "channelsLast" === this.dataFormat ? (i = i.concat(t)).push(this.filters) : (i.push(this.filters), i = i.concat(t)), i
            }, n.getConfig = function () {
                var t = {
                        filters: this.filters,
                        kernelInitializer: KE(this.kernelInitializer),
                        kernelRegularizer: oF(this.kernelRegularizer),
                        kernelConstraint: VC(this.kernelConstraint)
                    },
                    n = e.prototype.getConfig.call(this);
                return Object.assign(t, n), t
            }, t.verifyArgs = function (e) {
                if (!("filters" in e) || "number" != typeof e.filters || e.filters < 1) throw new dC("Convolution layer expected config.filters to be a 'number' > 0 but got " + JSON.stringify(e.filters))
            }, t
        }(wF),
        NF = function (e) {
            function t(n) {
                var r;
                return r = e.call(this, 2, n) || this, t.verifyArgs(n), r
            }
            return Vm(t, e), t.prototype.getConfig = function () {
                var t = e.prototype.getConfig.call(this);
                return delete t.rank, t
            }, t.verifyArgs = function (e) {
                if ("number" != typeof e.kernelSize && !FC(e.kernelSize, "number", 1, 2)) throw new dC("Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received " + JSON.stringify(e.kernelSize) + ".")
            }, t
        }(kF);
    NF.className = "Conv2D", Yb(NF);
    var IF = function (e) {
        function t(n) {
            var r;
            return r = e.call(this, 3, n) || this, t.verifyArgs(n), r
        }
        return Vm(t, e), t.prototype.getConfig = function () {
            var t = e.prototype.getConfig.call(this);
            return delete t.rank, t
        }, t.verifyArgs = function (e) {
            if ("number" != typeof e.kernelSize && (!Array.isArray(e.kernelSize) || 1 !== e.kernelSize.length && 3 !== e.kernelSize.length)) throw new dC("Conv3D expects config.kernelSize to be number or [number, number, number], but received " + JSON.stringify(e.kernelSize) + ".")
        }, t
    }(kF);
    IF.className = "Conv3D", Yb(IF);
    var SF = function (e) {
        function t(t) {
            var n;
            if ((n = e.call(this, t) || this).inputSpec = [new lR({
                    ndim: 4
                })], "same" !== n.padding && "valid" !== n.padding) throw new dC("Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode " + n.padding);
            return n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.build = function (e) {
            var t;
            if (4 !== (e = rR(e)).length) throw new dC("Input should have rank 4; Received input shape: " + JSON.stringify(e));
            var n = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
            if (null == e[n]) throw new dC("The channel dimension of the inputs should be defined. Found `None`.");
            var r = e[n],
                a = this.kernelSize.concat([this.filters, r]);
            this.kernel = this.addWeight("kernel", a, "float32", this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [new lR({
                ndim: 4,
                axes: (t = {}, t[n] = r, t)
            })], this.built = !0
        }, n.call = function (e, t) {
            var n = this;
            return rx(function () {
                var t = nR(e);
                if (4 !== t.shape.length) throw new dC("Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-" + t.shape.length);
                var r, a, i = t.shape,
                    o = i[0];
                "channelsFirst" === n.dataFormat ? (r = 2, a = 3) : (r = 1, a = 2);
                var s = i[r],
                    u = i[a],
                    l = n.kernelSize[0],
                    c = n.kernelSize[1],
                    p = n.strides[0],
                    h = n.strides[1],
                    f = [o, gF(s, p, l, n.padding), gF(u, h, c, n.padding), n.filters];
                "channelsLast" !== n.dataFormat && (t = mb(t, [0, 2, 3, 1]));
                var d = uw(t, n.kernel.read(), f, n.strides, n.padding);
                return "channelsLast" !== n.dataFormat && (d = mb(d, [0, 3, 1, 2])), null != n.bias && (d = IE(d, n.bias.read(), n.dataFormat)), null != n.activation && (d = n.activation.apply(d)), d
            })
        }, n.computeOutputShape = function (e) {
            var t, n, r, a = (e = rR(e)).slice();
            "channelsFirst" === this.dataFormat ? (t = 1, n = 2, r = 3) : (t = 3, n = 1, r = 2);
            var i = this.kernelSize[0],
                o = this.kernelSize[1],
                s = this.strides[0],
                u = this.strides[1];
            return a[t] = this.filters, a[n] = gF(a[n], s, i, this.padding), a[r] = gF(a[r], u, o, this.padding), a
        }, n.getConfig = function () {
            var t = e.prototype.getConfig.call(this);
            return delete t.dilationRate, t
        }, t
    }(NF);
    SF.className = "Conv2DTranspose", Yb(SF);
    var TF = function (e) {
        function t(t, n) {
            var r;
            if ((r = e.call(this, t, n) || this).DEFAULT_DEPTHWISE_INITIALIZER = "glorotUniform", r.DEFAULT_POINTWISE_INITIALIZER = "glorotUniform", r.depthwiseKernel = null, r.pointwiseKernel = null, null == n.filters) throw new dC("The `filters` configuration field is required by SeparableConv, but is unspecified.");
            if (null != n.kernelInitializer || null != n.kernelRegularizer || null != n.kernelConstraint) throw new dC("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");
            if (null != n.padding && "same" !== n.padding && "valid" !== n.padding) throw new dC("SeparableConv" + r.rank + "D supports only padding modes: 'same' and 'valid', but received " + JSON.stringify(n.padding));
            return r.depthMultiplier = null == n.depthMultiplier ? 1 : n.depthMultiplier, r.depthwiseInitializer = XE(n.depthwiseInitializer || r.DEFAULT_DEPTHWISE_INITIALIZER), r.depthwiseRegularizer = uF(n.depthwiseRegularizer), r.depthwiseConstraint = GC(n.depthwiseConstraint), r.pointwiseInitializer = XE(n.depthwiseInitializer || r.DEFAULT_POINTWISE_INITIALIZER), r.pointwiseRegularizer = uF(n.pointwiseRegularizer), r.pointwiseConstraint = GC(n.pointwiseConstraint), r
        }
        Vm(t, e);
        var n = t.prototype;
        return n.build = function (e) {
            var t;
            if ((e = rR(e)).length < this.rank + 2) throw new dC("Inputs to SeparableConv" + this.rank + "D should have rank " + (this.rank + 2) + ", but received input shape: " + JSON.stringify(e));
            var n = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
            if (null == e[n] || e[n] < 0) throw new dC("The channel dimension of the inputs should be defined, but found " + JSON.stringify(e[n]));
            for (var r = e[n], a = this.kernelSize.concat([r, this.depthMultiplier]), i = [], o = 0; o < this.rank; ++o) i.push(1);
            i.push(r * this.depthMultiplier, this.filters), this.depthwiseKernel = this.addWeight("depthwise_kernel", a, "float32", this.depthwiseInitializer, this.depthwiseRegularizer, !0, this.depthwiseConstraint), this.pointwiseKernel = this.addWeight("pointwise_kernel", i, "float32", this.pointwiseInitializer, this.pointwiseRegularizer, !0, this.pointwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.inputSpec = [new lR({
                ndim: this.rank + 2,
                axes: (t = {}, t[n] = r, t)
            })], this.built = !0
        }, n.call = function (e, t) {
            var n = this;
            return rx(function () {
                var t;
                if (e = nR(e), 1 === n.rank) throw new mC("1D separable convolution is not implemented yet.");
                return 2 === n.rank && ("channelsFirst" === n.dataFormat && (e = mb(e, [0, 2, 3, 1])), t = NN(e, n.depthwiseKernel.read(), n.pointwiseKernel.read(), n.strides, n.padding, n.dilationRate, "NHWC")), n.useBias && (t = IE(t, n.bias.read(), n.dataFormat)), null != n.activation && (t = n.activation.apply(t)), "channelsFirst" === n.dataFormat && (t = mb(t, [0, 3, 1, 2])), t
            })
        }, n.getConfig = function () {
            var t = e.prototype.getConfig.call(this);
            return delete t.rank, delete t.kernelInitializer, delete t.kernelRegularizer, delete t.kernelConstraint, t.depthwiseInitializer = KE(this.depthwiseInitializer), t.pointwiseInitializer = KE(this.pointwiseInitializer), t.depthwiseRegularizer = oF(this.depthwiseRegularizer), t.pointwiseRegularizer = oF(this.pointwiseRegularizer), t.depthwiseConstraint = VC(this.depthwiseConstraint), t.pointwiseConstraint = VC(this.pointwiseConstraint), t
        }, t
    }(kF);
    TF.className = "SeparableConv";
    var CF = function (e) {
        function t(t) {
            return e.call(this, 2, t) || this
        }
        return Vm(t, e), t
    }(TF);
    CF.className = "SeparableConv2D", Yb(CF);
    var EF = function (e) {
        function t(n) {
            var r;
            return r = e.call(this, 1, n) || this, t.verifyArgs(n), r.inputSpec = [{
                ndim: 3
            }], r
        }
        return Vm(t, e), t.prototype.getConfig = function () {
            var t = e.prototype.getConfig.call(this);
            return delete t.rank, delete t.dataFormat, t
        }, t.verifyArgs = function (e) {
            if ("number" != typeof e.kernelSize && !FC(e.kernelSize, "number", 1, 1)) throw new dC("Conv1D expects config.kernelSize to be number or number[] with length 1, but received " + JSON.stringify(e.kernelSize) + ".")
        }, t
    }(kF);
    EF.className = "Conv1D", Yb(EF);
    var RF = function (e) {
        function t(t) {
            var n;
            return n = e.call(this, t) || this, "number" == typeof t.cropping ? n.cropping = [
                [t.cropping, t.cropping],
                [t.cropping, t.cropping]
            ] : "number" == typeof t.cropping[0] ? n.cropping = [
                [t.cropping[0], t.cropping[0]],
                [t.cropping[1], t.cropping[1]]
            ] : n.cropping = t.cropping, n.dataFormat = void 0 === t.dataFormat ? "channelsLast" : t.dataFormat, n.inputSpec = [{
                ndim: 4
            }], n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.computeOutputShape = function (e) {
            return "channelsFirst" === this.dataFormat ? [e[0], e[1], e[2] - this.cropping[0][0] - this.cropping[0][1], e[3] - this.cropping[1][0] - this.cropping[1][1]] : [e[0], e[1] - this.cropping[0][0] - this.cropping[0][1], e[2] - this.cropping[1][0] - this.cropping[1][1], e[3]]
        }, n.call = function (e, t) {
            var n = this;
            return rx(function () {
                if (e = nR(e), "channelsLast" === n.dataFormat) {
                    var t = mE(e, n.cropping[0][0], e.shape[1] - n.cropping[0][0] - n.cropping[0][1], 2);
                    return mE(t, n.cropping[1][0], e.shape[2] - n.cropping[1][1] - n.cropping[1][0], 3)
                }
                var r = mE(e, n.cropping[0][0], e.shape[2] - n.cropping[0][0] - n.cropping[0][1], 3);
                return mE(r, n.cropping[1][0], e.shape[3] - n.cropping[1][1] - n.cropping[1][0], 4)
            })
        }, n.getConfig = function () {
            var t = {
                    cropping: this.cropping,
                    dataFormat: this.dataFormat
                },
                n = e.prototype.getConfig.call(this);
            return Object.assign(t, n), t
        }, t
    }(dR);
    RF.className = "Cropping2D", Yb(RF);
    var AF = function (e) {
        function t(t) {
            var n, r;
            return (n = e.call(this, t) || this).DEFAULT_SIZE = [2, 2], n.inputSpec = [{
                ndim: 4
            }], n.size = null == t.size ? n.DEFAULT_SIZE : t.size, n.dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat, ZC(n.dataFormat), n.interpolation = null == t.interpolation ? "nearest" : t.interpolation, r = n.interpolation, AC(qC, "InterpolationFormat", r), n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.computeOutputShape = function (e) {
            if ("channelsFirst" === this.dataFormat) {
                var t = null == e[2] ? null : this.size[0] * e[2],
                    n = null == e[3] ? null : this.size[1] * e[3];
                return [e[0], e[1], t, n]
            }
            var r = null == e[1] ? null : this.size[0] * e[1],
                a = null == e[2] ? null : this.size[1] * e[2];
            return [e[0], r, a, e[3]]
        }, n.call = function (e, t) {
            var n = this;
            return rx(function () {
                var t = nR(e),
                    r = t.shape;
                if ("channelsFirst" === n.dataFormat) {
                    t = mb(t, [0, 2, 3, 1]);
                    var a = n.size[0] * r[2],
                        i = n.size[1] * r[3],
                        o = "nearest" === n.interpolation ? t.resizeNearestNeighbor([a, i]) : t.resizeBilinear([a, i]);
                    return mb(o, [0, 3, 1, 2])
                }
                var s = n.size[0] * r[1],
                    u = n.size[1] * r[2];
                return "nearest" === n.interpolation ? t.resizeNearestNeighbor([s, u]) : t.resizeBilinear([s, u])
            })
        }, n.getConfig = function () {
            var t = {
                    size: this.size,
                    dataFormat: this.dataFormat
                },
                n = e.prototype.getConfig.call(this);
            return Object.assign(t, n), t
        }, t
    }(dR);
    AF.className = "UpSampling2D", Yb(AF);
    var FF = function (e) {
        function t(t) {
            var n;
            return (n = e.call(this, 2, t) || this).depthwiseKernel = null, n.depthMultiplier = null == t.depthMultiplier ? 1 : t.depthMultiplier, n.depthwiseInitializer = XE(t.depthwiseInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.depthwiseConstraint = GC(t.depthwiseConstraint), n.depthwiseRegularizer = uF(t.depthwiseRegularizer), n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.build = function (e) {
            if ((e = rR(e)).length < 4) throw new dC("Inputs to DepthwiseConv2D should have rank 4. Received input shape: " + JSON.stringify(e) + ".");
            var t = "channelsFirst" === this.dataFormat ? 1 : 3;
            if (null == e[t] || e[t] < 0) throw new dC("The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (" + e[t] + ").");
            var n = e[t],
                r = [this.kernelSize[0], this.kernelSize[1], n, this.depthMultiplier];
            this.depthwiseKernel = this.addWeight("depthwise_kernel", r, null, this.depthwiseInitializer, this.depthwiseRegularizer, !0, this.depthwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [n * this.depthMultiplier], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.built = !0
        }, n.call = function (e, t) {
            var n = this;
            return rx(function () {
                e = nR(e);
                var t, r, a, i, o, s = (t = e, r = n.depthwiseKernel.read(), a = n.strides, i = n.padding, o = n.dataFormat, null, void 0 === a && (a = [1, 1]), void 0 === i && (i = "valid"), rx(function () {
                    null == o && (o = "channelsLast"), ZC(o);
                    var e = yF(t, o);
                    if (4 !== t.rank) throw new dC("Input for depthwiseConv2d is required to be 4-D, but is instead " + t.rank + "-D");
                    if (4 !== r.rank) throw new dC("depthwiseKernel is required to be 4-D, but is instead " + r.rank + "-D");
                    return e = gw(e, r, a, "same" === i ? "same" : "valid", "NHWC", null), "channelsFirst" === o && (e = mb(e, [0, 3, 1, 2])), e
                }));
                return n.useBias && (s = IE(s, n.bias.read(), n.dataFormat)), null != n.activation && (s = n.activation.apply(s)), s
            })
        }, n.computeOutputShape = function (e) {
            e = rR(e);
            var t = "channelsFirst" === this.dataFormat ? e[2] : e[1],
                n = "channelsFirst" === this.dataFormat ? e[3] : e[2],
                r = "channelsFirst" === this.dataFormat ? e[1] * this.depthMultiplier : e[3] * this.depthMultiplier,
                a = vF(t, this.kernelSize[0], this.padding, this.strides[0]),
                i = vF(n, this.kernelSize[1], this.padding, this.strides[1]);
            return "channelsFirst" === this.dataFormat ? [e[0], r, a, i] : [e[0], a, i, r]
        }, n.getConfig = function () {
            var t = e.prototype.getConfig.call(this);
            return t.depthMultiplier = this.depthMultiplier, t.depthwiseInitializer = KE(this.depthwiseInitializer), t.depthwiseRegularizer = oF(this.depthwiseRegularizer), t.depthwiseConstraint = VC(this.depthwiseRegularizer), t
        }, t
    }(wF);

    function _F(e, t, n, r) {
        if (Array.isArray(e)) {
            if (null != t || null != n) throw new dC("When inputs is an array, neither initialState or constants should be provided");
            null != r && (n = e.slice(e.length - r, e.length), e = e.slice(0, e.length - r)), e.length > 1 && (t = e.slice(1, e.length)), e = e[0]
        }

        function a(e) {
            return null == e || Array.isArray(e) ? e : [e]
        }
        return {
            inputs: e,
            initialState: t = a(t),
            constants: n = a(n)
        }
    }

    function DF(e, t, n, r, a, i, o, s) {
        return void 0 === r && (r = !1), void 0 === o && (o = !1), void 0 === s && (s = !1), rx(function () {
            var u = t.shape.length;
            if (u < 3) throw new dC("Input should be at least 3D, but is " + u + "D.");
            var l = [1, 0].concat(cE(2, u));
            if (t = mb(t, l), null != i) throw new mC("The rnn() functoin of the deeplearn.js backend does not support constants yet.");
            o && console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."), null != a && ((a = a.asType("bool").asType("float32")).rank === u - 1 && (a = Fw(a, -1)), a = mb(a, l)), r && (t = dN(t, 0), null != a && (a = dN(a, 0)));
            var c, p, h = [],
                f = n,
                d = t.shape[0],
                m = QN(t);
            null != a && (p = QN(a));
            for (var v, g = function (t) {
                    var n = m[t],
                        r = rx(function () {
                            return e(n, f)
                        });
                    if (null == a) c = r[0], f = r[1];
                    else {
                        var i = rx(function () {
                            var e = p[t],
                                n = Lk(e).sub(e);
                            return {
                                output: r[0].mul(e).add(f[0].mul(n)),
                                newStates: f.map(function (t, a) {
                                    return r[1][a].mul(e).add(t.mul(n))
                                })
                            }
                        });
                        c = i.output, f = i.newStates
                    }
                    s && h.push(c)
                }, y = 0; y < d; ++y) g(y);
            return s && (v = UN(h, 1)), [c, v, f]
        })
    }
    FF.className = "DepthwiseConv2D", Yb(FF);
    var OF = function (e) {
        function t(t) {
            var n, r;
            if (n = e.call(this, t) || this, null == t.cell) throw new dC("cell property is missing for the constructor of RNN.");
            if (null == (r = Array.isArray(t.cell) ? new UF({
                    cells: t.cell
                }) : t.cell).stateSize) throw new dC("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");
            return n.cell = r, n.returnSequences = null != t.returnSequences && t.returnSequences, n.returnState = null != t.returnState && t.returnState, n.goBackwards = null != t.goBackwards && t.goBackwards, n._stateful = null != t.stateful && t.stateful, n.unroll = null != t.unroll && t.unroll, n.supportsMasking = !0, n.inputSpec = [new lR({
                ndim: 3
            })], n.stateSpec = null, n.states_ = null, n.numConstants = null, n.keptStates = [], n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.getStates = function () {
            return null == this.states_ ? cE(0, Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1).map(function (e) {
                return null
            }) : this.states_
        }, n.setStates = function (e) {
            this.states_ = e
        }, n.computeOutputShape = function (e) {
            eR(e) && (e = e[0]), e = e;
            var t = this.cell.stateSize;
            Array.isArray(t) || (t = [t]);
            var n, r = t[0];
            if (n = this.returnSequences ? [e[0], e[1], r] : [e[0], r], this.returnState) {
                for (var a, i = [], o = Xm(t); !(a = o()).done;) {
                    var s = a.value;
                    i.push([e[0], s])
                }
                return [n].concat(i)
            }
            return n
        }, n.computeMask = function (e, t) {
            var n = this;
            return rx(function () {
                Array.isArray(t) && (t = t[0]);
                var e = n.returnSequences ? t : null;
                if (n.returnState) {
                    var r = n.states.map(function (e) {
                        return null
                    });
                    return [e].concat(r)
                }
                return e
            })
        }, n.build = function (e) {
            if (null != this.numConstants) throw new mC("Constants support is not implemented in RNN yet.");
            eR(e) && (e = e[0]), e = e;
            var t = this.stateful ? e[0] : null,
                n = e.slice(2);
            this.inputSpec[0] = new lR({
                shape: [t, null].concat(n)
            });
            var r, a = [e[0]].concat(e.slice(2));
            if (this.cell.build(a), r = Array.isArray(this.cell.stateSize) ? this.cell.stateSize : [this.cell.stateSize], null != this.stateSpec) {
                if (!sv(this.stateSpec.map(function (e) {
                        return e.shape[e.shape.length - 1]
                    }), r)) throw new dC("An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=" + this.stateSpec + "; However cell.stateSize is " + this.cell.stateSize)
            } else this.stateSpec = r.map(function (e) {
                return new lR({
                    shape: [null, e]
                })
            });
            this.stateful && this.resetStates()
        }, n.resetStates = function (e, t) {
            var n = this;
            void 0 === t && (t = !1), rx(function () {
                if (!n.stateful) throw new hC("Cannot call resetStates() on an RNN Layer that is not stateful.");
                var r = n.inputSpec[0].shape[0];
                if (null == r) throw new dC("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
                if (null == n.states_) Array.isArray(n.cell.stateSize) ? n.states_ = n.cell.stateSize.map(function (e) {
                    return Ok([r, e])
                }) : n.states_ = [Ok([r, n.cell.stateSize])];
                else if (null == e) ax(n.states_), null != n.keptStates && (ax(n.keptStates), n.keptStates = []), Array.isArray(n.cell.stateSize) ? n.states_ = n.cell.stateSize.map(function (e) {
                    return Ok([r, e])
                }) : n.states_[0] = Ok([r, n.cell.stateSize]);
                else {
                    if (Array.isArray(e) || (e = [e]), e.length !== n.states_.length) throw new dC("Layer " + n.name + " expects " + n.states_.length + " state(s), but it received " + e.length + " state value(s). Input received: " + e);
                    !0 === t ? n.keptStates.push(n.states_.slice()) : ax(n.states_);
                    for (var a = 0; a < n.states_.length; ++a) {
                        var i = e[a],
                            o = Array.isArray(n.cell.stateSize) ? n.cell.stateSize[a] : n.cell.stateSize,
                            s = [r, o];
                        if (!sv(i.shape, s)) throw new dC("State " + a + " is incompatible with layer " + n.name + ": expected shape=" + s + ", received shape=" + i.shape);
                        n.states_[a] = i
                    }
                }
                n.states_ = n.states_.map(function (e) {
                    return ix(e.clone())
                })
            })
        }, n.apply = function (t, n) {
            var r = null == n ? null : n.initialState,
                a = null == n ? null : n.constants;
            null == n && (n = {});
            var i = _F(t, r, a, this.numConstants);
            t = i.inputs, r = i.initialState, a = i.constants;
            var o = [],
                s = [];
            if (null != r) {
                n.initialState = r, o = o.concat(r), this.stateSpec = [];
                for (var u, l = Xm(r); !(u = l()).done;) {
                    var c = u.value;
                    this.stateSpec.push(new lR({
                        shape: c.shape
                    }))
                }
                s = s.concat(this.stateSpec)
            }
            if (null != a && (n.constants = a, o = o.concat(a), this.numConstants = a.length), o[0] instanceof cR) {
                var p = [t].concat(o),
                    h = this.inputSpec.concat(s),
                    f = this.inputSpec;
                this.inputSpec = h;
                var d = e.prototype.apply.call(this, p, n);
                return this.inputSpec = f, d
            }
            return e.prototype.apply.call(this, t, n)
        }, n.call = function (e, t) {
            var n = this;
            return rx(function () {
                var r = null == t ? null : t.mask,
                    a = null == t ? null : t.training,
                    i = null == t ? null : t.initialState;
                e = nR(e), null == i && (i = n.stateful ? n.states_ : n.getInitialState(e));
                var o = Array.isArray(n.cell.stateSize) ? n.cell.stateSize.length : 1;
                if (i.length !== o) throw new dC("RNN Layer has " + o + " state(s) but was passed " + i.length + " initial state(s).");
                n.unroll && console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");
                var s = {
                        training: a
                    },
                    u = DF(function (e, t) {
                        var r = n.cell.call([e].concat(t), s);
                        return [r[0], r.slice(1)]
                    }, e, i, n.goBackwards, r, null, n.unroll, n.returnSequences),
                    l = u[0],
                    c = u[1],
                    p = u[2];
                n.stateful && n.resetStates(p, a);
                var h = n.returnSequences ? c : l;
                return n.returnState ? [h].concat(p) : h
            })
        }, n.getInitialState = function (e) {
            var t = this;
            return rx(function () {
                var n = Ok(e.shape);
                return n = hE(n = ik(n, [1, 2])), Array.isArray(t.cell.stateSize) ? t.cell.stateSize.map(function (e) {
                    return e > 1 ? yE(n, [1, e]) : n
                }) : t.cell.stateSize > 1 ? [yE(n, [1, t.cell.stateSize])] : [n]
            })
        }, n.setFastWeightInitDuringBuild = function (t) {
            e.prototype.setFastWeightInitDuringBuild.call(this, t), null != this.cell && this.cell.setFastWeightInitDuringBuild(t)
        }, n.getConfig = function () {
            var n = e.prototype.getConfig.call(this),
                r = {
                    returnSequences: this.returnSequences,
                    returnState: this.returnState,
                    goBackwards: this.goBackwards,
                    stateful: this.stateful,
                    unroll: this.unroll
                };
            null != this.numConstants && (r.numConstants = this.numConstants);
            var a = this.cell.getConfig();
            return this.getClassName() === t.className && (r.cell = {
                className: this.cell.getClassName(),
                config: a
            }), Object.assign({}, a, n, r)
        }, t.fromConfig = function (e, t, n) {
            void 0 === n && (n = {});
            var r = CR(t.cell, n);
            return new e(Object.assign(t, {
                cell: r
            }))
        }, Wm(t, [{
            key: "states",
            get: function () {
                if (null == this.states_) {
                    for (var e = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1, t = [], n = 0; n < e; ++n) t.push(null);
                    return t
                }
                return this.states_
            },
            set: function (e) {
                this.states_ = e
            }
        }, {
            key: "trainableWeights",
            get: function () {
                return this.trainable ? this.cell.trainableWeights : []
            }
        }, {
            key: "nonTrainableWeights",
            get: function () {
                return this.trainable ? this.cell.nonTrainableWeights : this.cell.weights
            }
        }]), t
    }(dR);
    OF.className = "RNN", Yb(OF);
    var MF = function (e) {
            function t() {
                return e.apply(this, arguments) || this
            }
            return Vm(t, e), t
        }(dR),
        LF = function (e) {
            function t(t) {
                var n;
                return (n = e.call(this, t) || this).DEFAULT_ACTIVATION = "tanh", n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", n.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", n.DEFAULT_BIAS_INITIALIZER = "zeros", n.units = t.units, _C(n.units, "units"), n.activation = tF(null == t.activation ? n.DEFAULT_ACTIVATION : t.activation), n.useBias = null == t.useBias || t.useBias, n.kernelInitializer = XE(t.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.recurrentInitializer = XE(t.recurrentInitializer || n.DEFAULT_RECURRENT_INITIALIZER), n.biasInitializer = XE(t.biasInitializer || n.DEFAULT_BIAS_INITIALIZER), n.kernelRegularizer = uF(t.kernelRegularizer), n.recurrentRegularizer = uF(t.recurrentRegularizer), n.biasRegularizer = uF(t.biasRegularizer), n.kernelConstraint = GC(t.kernelConstraint), n.recurrentConstraint = GC(t.recurrentConstraint), n.biasConstraint = GC(t.biasConstraint), n.dropout = uE([1, lE([0, null == t.dropout ? 0 : t.dropout])]), n.recurrentDropout = uE([1, lE([0, null == t.recurrentDropout ? 0 : t.recurrentDropout])]), n.stateSize = n.units, n.dropoutMask = null, n.recurrentDropoutMask = null, n
            }
            Vm(t, e);
            var n = t.prototype;
            return n.build = function (e) {
                e = rR(e), this.kernel = this.addWeight("kernel", [e[e.length - 1], this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.built = !0
            }, n.call = function (e, t) {
                var n = this;
                return rx(function () {
                    if (2 !== (e = e).length) throw new dC("SimpleRNNCell expects 2 input Tensors, got " + e.length + ".");
                    var r = e[1];
                    e = e[0];
                    var a, i = null != t.training && t.training;
                    0 < n.dropout && n.dropout < 1 && null == n.dropoutMask && (n.dropoutMask = GF({
                        ones: function () {
                            return Lk(e)
                        },
                        rate: n.dropout,
                        training: i
                    })), 0 < n.recurrentDropout && n.recurrentDropout < 1 && null == n.recurrentDropoutMask && (n.recurrentDropoutMask = GF({
                        ones: function () {
                            return Lk(r)
                        },
                        rate: n.recurrentDropout,
                        training: i
                    }));
                    var o = n.dropoutMask,
                        s = n.recurrentDropoutMask;
                    a = xE(null != o ? px(e, o) : e, n.kernel.read()), null != n.bias && (a = IE(a, n.bias.read())), null != s && (r = px(r, s));
                    var u = ux(a, xE(r, n.recurrentKernel.read()));
                    return null != n.activation && (u = n.activation.apply(u)), [u, u]
                })
            }, n.getConfig = function () {
                var t = e.prototype.getConfig.call(this),
                    n = {
                        units: this.units,
                        activation: $A(this.activation),
                        useBias: this.useBias,
                        kernelInitializer: KE(this.kernelInitializer),
                        recurrentInitializer: KE(this.recurrentInitializer),
                        biasInitializer: KE(this.biasInitializer),
                        kernelRegularizer: oF(this.kernelRegularizer),
                        recurrentRegularizer: oF(this.recurrentRegularizer),
                        biasRegularizer: oF(this.biasRegularizer),
                        activityRegularizer: oF(this.activityRegularizer),
                        kernelConstraint: VC(this.kernelConstraint),
                        recurrentConstraint: VC(this.recurrentConstraint),
                        biasConstraint: VC(this.biasConstraint),
                        dropout: this.dropout,
                        recurrentDropout: this.recurrentDropout
                    };
                return Object.assign({}, t, n)
            }, t
        }(MF);
    LF.className = "SimpleRNNCell", Yb(LF);
    var zF = function (e) {
        function t(t) {
            return t.cell = new LF(t), e.call(this, t) || this
        }
        return Vm(t, e), t.prototype.call = function (t, n) {
            var r = this;
            return rx(function () {
                null != r.cell.dropoutMask && (ax(r.cell.dropoutMask), r.cell.dropoutMask = null), null != r.cell.recurrentDropoutMask && (ax(r.cell.recurrentDropoutMask), r.cell.recurrentDropoutMask = null);
                var a = null == n ? null : n.mask,
                    i = null == n ? null : n.training,
                    o = null == n ? null : n.initialState;
                return e.prototype.call.call(r, t, {
                    mask: a,
                    training: i,
                    initialState: o
                })
            })
        }, t.fromConfig = function (e, t) {
            return new e(t)
        }, t
    }(OF);
    zF.className = "SimpleRNN", Yb(zF);
    var PF = function (e) {
        function t(t) {
            var n;
            if ((n = e.call(this, t) || this).DEFAULT_ACTIVATION = "tanh", n.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", n.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", n.DEFAULT_BIAS_INITIALIZER = "zeros", t.resetAfter) throw new dC("GRUCell does not support reset_after parameter set to true.");
            return n.units = t.units, _C(n.units, "units"), n.activation = tF(void 0 === t.activation ? n.DEFAULT_ACTIVATION : t.activation), n.recurrentActivation = tF(void 0 === t.recurrentActivation ? n.DEFAULT_RECURRENT_ACTIVATION : t.recurrentActivation), n.useBias = null == t.useBias || t.useBias, n.kernelInitializer = XE(t.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.recurrentInitializer = XE(t.recurrentInitializer || n.DEFAULT_RECURRENT_INITIALIZER), n.biasInitializer = XE(t.biasInitializer || n.DEFAULT_BIAS_INITIALIZER), n.kernelRegularizer = uF(t.kernelRegularizer), n.recurrentRegularizer = uF(t.recurrentRegularizer), n.biasRegularizer = uF(t.biasRegularizer), n.kernelConstraint = GC(t.kernelConstraint), n.recurrentConstraint = GC(t.recurrentConstraint), n.biasConstraint = GC(t.biasConstraint), n.dropout = uE([1, lE([0, null == t.dropout ? 0 : t.dropout])]), n.recurrentDropout = uE([1, lE([0, null == t.recurrentDropout ? 0 : t.recurrentDropout])]), n.implementation = t.implementation, n.stateSize = n.units, n.dropoutMask = null, n.recurrentDropoutMask = null, n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.build = function (e) {
            var t = (e = rR(e))[e.length - 1];
            this.kernel = this.addWeight("kernel", [t, 3 * this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, 3 * this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [3 * this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.built = !0
        }, n.call = function (e, t) {
            var n = this;
            return rx(function () {
                if (2 !== (e = e).length) throw new dC("GRUCell expects 2 input Tensors (inputs, h, c), got " + e.length + ".");
                var r = null != t.training && t.training,
                    a = e[1];
                e = e[0], 0 < n.dropout && n.dropout < 1 && null == n.dropoutMask && (n.dropoutMask = GF({
                    ones: function () {
                        return Lk(e)
                    },
                    rate: n.dropout,
                    training: r,
                    count: 3
                })), 0 < n.recurrentDropout && n.recurrentDropout < 1 && null == n.recurrentDropoutMask && (n.recurrentDropoutMask = GF({
                    ones: function () {
                        return Lk(a)
                    },
                    rate: n.recurrentDropout,
                    training: r,
                    count: 3
                }));
                var i, o, s, u = n.dropoutMask,
                    l = n.recurrentDropoutMask;
                0 < n.dropout && n.dropout < 1 && (e = px(e, u[0]));
                var c = xE(e, n.kernel.read());
                n.useBias && (c = IE(c, n.bias.read())), 0 < n.recurrentDropout && n.recurrentDropout < 1 && (a = px(a, l[0]));
                var p = n.recurrentKernel.read(),
                    h = zN(p, [2 * n.units, n.units], p.rank - 1),
                    f = h[0],
                    d = h[1],
                    m = xE(a, f),
                    v = zN(c, 3, c.rank - 1),
                    g = v[0],
                    y = v[1],
                    b = v[2],
                    x = zN(m, 2, m.rank - 1),
                    w = x[0],
                    k = x[1];
                i = n.recurrentActivation.apply(ux(g, w)), o = n.recurrentActivation.apply(ux(y, k));
                var N = xE(px(o, a), d);
                s = n.activation.apply(ux(b, N));
                var I = ux(px(i, a), px(ux(1, ek(i)), s));
                return [I, I]
            })
        }, n.getConfig = function () {
            var t = e.prototype.getConfig.call(this),
                n = {
                    units: this.units,
                    activation: $A(this.activation),
                    recurrentActivation: $A(this.recurrentActivation),
                    useBias: this.useBias,
                    kernelInitializer: KE(this.kernelInitializer),
                    recurrentInitializer: KE(this.recurrentInitializer),
                    biasInitializer: KE(this.biasInitializer),
                    kernelRegularizer: oF(this.kernelRegularizer),
                    recurrentRegularizer: oF(this.recurrentRegularizer),
                    biasRegularizer: oF(this.biasRegularizer),
                    activityRegularizer: oF(this.activityRegularizer),
                    kernelConstraint: VC(this.kernelConstraint),
                    recurrentConstraint: VC(this.recurrentConstraint),
                    biasConstraint: VC(this.biasConstraint),
                    dropout: this.dropout,
                    recurrentDropout: this.recurrentDropout,
                    implementation: this.implementation,
                    resetAfter: !1
                };
            return Object.assign({}, t, n)
        }, t
    }(MF);
    PF.className = "GRUCell", Yb(PF);
    var BF = function (e) {
        function t(t) {
            return 0 === t.implementation && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), t.cell = new PF(t), e.call(this, t) || this
        }
        return Vm(t, e), t.prototype.call = function (t, n) {
            var r = this;
            return rx(function () {
                null != r.cell.dropoutMask && (ax(r.cell.dropoutMask), r.cell.dropoutMask = null), null != r.cell.recurrentDropoutMask && (ax(r.cell.recurrentDropoutMask), r.cell.recurrentDropoutMask = null);
                var a = null == n ? null : n.mask,
                    i = null == n ? null : n.training,
                    o = null == n ? null : n.initialState;
                return e.prototype.call.call(r, t, {
                    mask: a,
                    training: i,
                    initialState: o
                })
            })
        }, t.fromConfig = function (e, t) {
            return 0 === t.implmentation && (t.implementation = 1), new e(t)
        }, t
    }(OF);
    BF.className = "GRU", Yb(BF);
    var WF = function (e) {
        function t(t) {
            var n;
            return (n = e.call(this, t) || this).DEFAULT_ACTIVATION = "tanh", n.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", n.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", n.DEFAULT_BIAS_INITIALIZER = "zeros", n.units = t.units, _C(n.units, "units"), n.activation = tF(void 0 === t.activation ? n.DEFAULT_ACTIVATION : t.activation), n.recurrentActivation = tF(void 0 === t.recurrentActivation ? n.DEFAULT_RECURRENT_ACTIVATION : t.recurrentActivation), n.useBias = null == t.useBias || t.useBias, n.kernelInitializer = XE(t.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.recurrentInitializer = XE(t.recurrentInitializer || n.DEFAULT_RECURRENT_INITIALIZER), n.biasInitializer = XE(t.biasInitializer || n.DEFAULT_BIAS_INITIALIZER), n.unitForgetBias = t.unitForgetBias, n.kernelRegularizer = uF(t.kernelRegularizer), n.recurrentRegularizer = uF(t.recurrentRegularizer), n.biasRegularizer = uF(t.biasRegularizer), n.kernelConstraint = GC(t.kernelConstraint), n.recurrentConstraint = GC(t.recurrentConstraint), n.biasConstraint = GC(t.biasConstraint), n.dropout = uE([1, lE([0, null == t.dropout ? 0 : t.dropout])]), n.recurrentDropout = uE([1, lE([0, null == t.recurrentDropout ? 0 : t.recurrentDropout])]), n.implementation = t.implementation, n.stateSize = [n.units, n.units], n.dropoutMask = null, n.recurrentDropoutMask = null, n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.build = function (e) {
            var t, n, r = (e = rR(e))[e.length - 1];
            if (this.kernel = this.addWeight("kernel", [r, 4 * this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, 4 * this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias) {
                if (this.unitForgetBias) {
                    var a = this.biasInitializer,
                        i = this.units;
                    n = new((t = function (e) {
                        function t() {
                            return e.apply(this, arguments) || this
                        }
                        return Vm(t, e), t.prototype.apply = function (e, t) {
                            var n = a.apply([i]),
                                r = (new FE).apply([i]),
                                o = a.apply([2 * i]);
                            return gE(gE(n, r), o)
                        }, t
                    }(RE)).className = "CustomInit", t)
                } else n = this.biasInitializer;
                this.bias = this.addWeight("bias", [4 * this.units], null, n, this.biasRegularizer, !0, this.biasConstraint)
            } else this.bias = null;
            this.built = !0
        }, n.call = function (e, t) {
            var n = this;
            return rx(function () {
                var r = null != t.training && t.training;
                if (3 !== (e = e).length) throw new dC("LSTMCell expects 3 input Tensors (inputs, h, c), got " + e.length + ".");
                var a = e[1],
                    i = e[2];
                e = e[0], 0 < n.dropout && n.dropout < 1 && null == n.dropoutMask && (n.dropoutMask = GF({
                    ones: function () {
                        return Lk(e)
                    },
                    rate: n.dropout,
                    training: r,
                    count: 4
                })), 0 < n.recurrentDropout && n.recurrentDropout < 1 && null == n.recurrentDropoutMask && (n.recurrentDropoutMask = GF({
                    ones: function () {
                        return Lk(a)
                    },
                    rate: n.recurrentDropout,
                    training: r,
                    count: 4
                }));
                var o, s, u, l, c = n.dropoutMask,
                    p = n.recurrentDropoutMask;
                0 < n.dropout && n.dropout < 1 && (e = px(e, c[0]));
                var h = xE(e, n.kernel.read());
                0 < n.recurrentDropout && n.recurrentDropout < 1 && (a = px(a, p[0])), h = ux(h, xE(a, n.recurrentKernel.read())), n.useBias && (h = IE(h, n.bias.read()));
                var f = zN(h, 4, h.rank - 1),
                    d = f[0],
                    m = f[1],
                    v = f[2],
                    g = f[3];
                o = n.recurrentActivation.apply(d), s = n.recurrentActivation.apply(m), u = ux(px(s, i), px(o, n.activation.apply(v))), l = n.recurrentActivation.apply(g);
                var y = px(l, n.activation.apply(u));
                return [y, y, u]
            })
        }, n.getConfig = function () {
            var t = e.prototype.getConfig.call(this),
                n = {
                    units: this.units,
                    activation: $A(this.activation),
                    recurrentActivation: $A(this.recurrentActivation),
                    useBias: this.useBias,
                    kernelInitializer: KE(this.kernelInitializer),
                    recurrentInitializer: KE(this.recurrentInitializer),
                    biasInitializer: KE(this.biasInitializer),
                    unitForgetBias: this.unitForgetBias,
                    kernelRegularizer: oF(this.kernelRegularizer),
                    recurrentRegularizer: oF(this.recurrentRegularizer),
                    biasRegularizer: oF(this.biasRegularizer),
                    activityRegularizer: oF(this.activityRegularizer),
                    kernelConstraint: VC(this.kernelConstraint),
                    recurrentConstraint: VC(this.recurrentConstraint),
                    biasConstraint: VC(this.biasConstraint),
                    dropout: this.dropout,
                    recurrentDropout: this.recurrentDropout,
                    implementation: this.implementation
                };
            return Object.assign({}, t, n)
        }, t
    }(MF);
    WF.className = "LSTMCell", Yb(WF);
    var VF = function (e) {
        function t(t) {
            return 0 === t.implementation && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), t.cell = new WF(t), e.call(this, t) || this
        }
        return Vm(t, e), t.prototype.call = function (t, n) {
            var r = this;
            return rx(function () {
                null != r.cell.dropoutMask && (ax(r.cell.dropoutMask), r.cell.dropoutMask = null), null != r.cell.recurrentDropoutMask && (ax(r.cell.recurrentDropoutMask), r.cell.recurrentDropoutMask = null);
                var a = null == n ? null : n.mask,
                    i = null == n ? null : n.training,
                    o = null == n ? null : n.initialState;
                return e.prototype.call.call(r, t, {
                    mask: a,
                    training: i,
                    initialState: o
                })
            })
        }, t.fromConfig = function (e, t) {
            return 0 === t.implmentation && (t.implementation = 1), new e(t)
        }, t
    }(OF);
    VF.className = "LSTM", Yb(VF);
    var UF = function (e) {
        function t(t) {
            var n;
            return (n = e.call(this, t) || this).cells = t.cells, n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.call = function (e, t) {
            var n = this;
            return rx(function () {
                for (var r, a = (e = e).slice(1), i = [], o = Xm(n.cells.slice().reverse()); !(r = o()).done;) {
                    var s = r.value;
                    Array.isArray(s.stateSize) ? i.push(a.splice(0, s.stateSize.length)) : i.push(a.splice(0, 1))
                }
                i.reverse();
                for (var u, l = [], c = 0; c < n.cells.length; ++c) {
                    var p = n.cells[c];
                    a = i[c], u = 0 === c ? [e[0]].concat(a) : [u[0]].concat(a), u = p.call(u, t), l.push(u.slice(1))
                }
                a = [];
                for (var h, f = Xm(l.slice().reverse()); !(h = f()).done;) {
                    var d, m = h.value;
                    (d = a).push.apply(d, m)
                }
                return [u[0]].concat(a)
            })
        }, n.build = function (e) {
            var t;
            eR(e) && (e = e[0]), e = e, this.cells.forEach(function (n, r) {
                tE("RNNCell_" + r, function () {
                    n.build(e), t = Array.isArray(n.stateSize) ? n.stateSize[0] : n.stateSize, e = [e[0], t]
                })
            }), this.built = !0
        }, n.getConfig = function () {
            var t = e.prototype.getConfig.call(this),
                n = {
                    cells: this.cells.map(function (e) {
                        return {
                            className: e.getClassName(),
                            config: e.getConfig()
                        }
                    })
                };
            return Object.assign({}, t, n)
        }, t.fromConfig = function (e, t, n) {
            void 0 === n && (n = {});
            for (var r, a = [], i = Xm(t.cells); !(r = i()).done;) {
                var o = r.value;
                a.push(CR(o, n))
            }
            return new e({
                cells: a
            })
        }, n.getWeights = function () {
            for (var e, t = [], n = Xm(this.cells); !(e = n()).done;) {
                var r = e.value;
                t.push.apply(t, r.weights)
            }
            return oR(t)
        }, n.setWeights = function (e) {
            for (var t, n = [], r = Xm(this.cells); !(t = r()).done;)
                for (var a = t.value, i = a.weights.length, o = e.splice(i), s = 0; s < a.weights.length; ++s) n.push([a.weights[s], o[s]]);
            sR(n)
        }, Wm(t, [{
            key: "stateSize",
            get: function () {
                for (var e, t = [], n = Xm(this.cells.slice().reverse()); !(e = n()).done;) {
                    var r = e.value;
                    Array.isArray(r.stateSize) ? t.push.apply(t, r.stateSize) : t.push(r.stateSize)
                }
                return t
            }
        }, {
            key: "trainableWeights",
            get: function () {
                if (!this.trainable) return [];
                for (var e, t = [], n = Xm(this.cells); !(e = n()).done;) {
                    var r = e.value;
                    t.push.apply(t, r.trainableWeights)
                }
                return t
            }
        }, {
            key: "nonTrainableWeights",
            get: function () {
                for (var e, t = [], n = Xm(this.cells); !(e = n()).done;) {
                    var r = e.value;
                    t.push.apply(t, r.nonTrainableWeights)
                }
                if (!this.trainable) {
                    for (var a, i = [], o = Xm(this.cells); !(a = o()).done;) {
                        var s = a.value;
                        i.push.apply(i, s.trainableWeights)
                    }
                    return i.concat(t)
                }
                return t
            }
        }]), t
    }(MF);

    function GF(e) {
        var t = e.ones,
            n = e.rate,
            r = e.training,
            a = void 0 !== r && r,
            i = e.count,
            o = void 0 === i ? 1 : i,
            s = function () {
                return SE(t(), n)
            },
            u = function () {
                return TE(s, t, a)
            };
        return !o || o <= 1 ? ix(u().clone()) : Array(o).fill(void 0).map(u).map(function (e) {
            return ix(e.clone())
        })
    }
    UF.className = "StackedRNNCells", Yb(UF);
    var jF = function (e) {
        function t(t) {
            var n;
            if (t.unroll) throw new mC("Unrolling is not possible with convolutional RNNs.");
            if (Array.isArray(t.cell)) throw new mC("It is not possible at the moment to stack convolutional cells.");
            return (n = e.call(this, t) || this).inputSpec = [new lR({
                ndim: 5
            })], n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.call = function (t, n) {
            var r = this;
            return rx(function () {
                if (null != r.cell.dropoutMask && (ax(r.cell.dropoutMask), r.cell.dropoutMask = null), null != r.cell.recurrentDropoutMask && (ax(r.cell.recurrentDropoutMask), r.cell.recurrentDropoutMask = null), n && n.constants) throw new dC("ConvRNN2D cell does not support constants");
                var a = null == n ? null : n.mask,
                    i = null == n ? null : n.training,
                    o = null == n ? null : n.initialState;
                return e.prototype.call.call(r, t, {
                    mask: a,
                    training: i,
                    initialState: o
                })
            })
        }, n.computeOutputShape = function (e) {
            var t = this.computeSingleOutputShape(e);
            return this.returnSequences || (t = [t[0]].concat(t.slice(2))), this.returnState && (t = [t].concat(Array(2).fill([e[0]].concat(t.slice(-3))))), t
        }, n.getInitialState = function (e) {
            var t = this;
            return rx(function () {
                var n = t.cell.stateSize,
                    r = e.shape,
                    a = t.computeSingleOutputShape(r),
                    i = Ok([a[0]].concat(a.slice(2)));
                return Array.isArray(n) ? Array(n.length).fill(i) : [i]
            })
        }, n.resetStates = function (e, t) {
            var n = this;
            void 0 === t && (t = !1), rx(function () {
                if (!n.stateful) throw new hC("Cannot call resetStates() on an RNN Layer that is not stateful.");
                var r = n.inputSpec[0].shape,
                    a = n.computeSingleOutputShape(r),
                    i = [a[0]].concat(a.slice(2));
                if (null == r[0]) throw new dC("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
                if (null == n.getStates()) Array.isArray(n.cell.stateSize) ? n.states_ = n.cell.stateSize.map(function () {
                    return Ok(i)
                }) : n.states_ = [Ok(i)];
                else if (null == e) ax(n.states_), null != n.keptStates && (ax(n.keptStates), n.keptStates = []), Array.isArray(n.cell.stateSize) ? n.states_ = n.cell.stateSize.map(function () {
                    return Ok(i)
                }) : n.states_[0] = Ok(i);
                else {
                    if (Array.isArray(e) || (e = [e]), e.length !== n.states_.length) throw new dC("Layer " + n.name + " expects " + n.states_.length + " state(s), but it received " + e.length + " state value(s). Input received: " + e);
                    t ? n.keptStates.push(n.states_.slice()) : ax(n.states_);
                    for (var o = 0; o < n.states_.length; ++o) {
                        var s = e[o],
                            u = i;
                        if (!sv(s.shape, u)) throw new dC("State " + o + " is incompatible with layer " + n.name + ": expected shape=" + u + ", received shape=" + s.shape);
                        n.states_[o] = s
                    }
                }
                n.states_ = n.states_.map(function (e) {
                    return ix(e.clone())
                })
            })
        }, n.computeSingleOutputShape = function (e) {
            var t = this.cell,
                n = t.dataFormat,
                r = t.filters,
                a = t.kernelSize,
                i = t.padding,
                o = t.strides,
                s = t.dilationRate,
                u = "channelsFirst" === n,
                l = e[u ? 3 : 2],
                c = e[u ? 4 : 3],
                p = vF(l, a[0], i, o[0], s[0]),
                h = vF(c, a[1], i, o[1], s[1]);
            return [].concat(e.slice(0, 2), u ? [r, p, h] : [p, h, r])
        }, t
    }(OF);
    jF.className = "ConvRNN2D";
    var HF = function (e) {
        function t(t) {
            var n, r = t.filters,
                a = t.kernelSize,
                i = t.strides,
                o = t.padding,
                s = t.dataFormat,
                u = t.dilationRate;
            return (n = e.call(this, Object.assign({}, t, {
                units: r
            })) || this).filters = r, _C(n.filters, "filters"), n.kernelSize = mF(a, 2, "kernelSize"), n.kernelSize.forEach(function (e) {
                return _C(e, "kernelSize")
            }), n.strides = mF(i || 1, 2, "strides"), n.strides.forEach(function (e) {
                return _C(e, "strides")
            }), n.padding = o || "valid", QC(n.padding), n.dataFormat = s || "channelsLast", ZC(n.dataFormat), n.dilationRate = mF(u || 1, 2, "dilationRate"), n.dilationRate.forEach(function (e) {
                return _C(e, "dilationRate")
            }), n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.build = function (e) {
            var t;
            e = rR(e);
            var n = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
            if (null == e[n]) throw new dC("The channel dimension of the input should be defined. Found " + e[n]);
            var r = e[n],
                a = this.kernelSize.concat([r, 4 * this.filters]);
            this.kernel = this.addWeight("kernel", a, null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint);
            var i = this.kernelSize.concat([this.filters, 4 * this.filters]);
            if (this.recurrentKernel = this.addWeight("recurrent_kernel", i, null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias) {
                var o;
                if (this.unitForgetBias) {
                    var s = this.biasInitializer,
                        u = this.filters;
                    o = new((t = function (e) {
                        function t() {
                            return e.apply(this, arguments) || this
                        }
                        return Vm(t, e), t.prototype.apply = function (e, t) {
                            return vE([s.apply([u]), Mk([u]), s.apply([2 * u])])
                        }, t
                    }(RE)).className = "CustomInit", t)
                } else o = this.biasInitializer;
                this.bias = this.addWeight("bias", [4 * this.filters], null, o, this.biasRegularizer, !0, this.biasConstraint)
            }
            this.built = !0
        }, n.call = function (e, t) {
            var n = this;
            return rx(function () {
                if (3 !== e.length) throw new dC("ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got " + e.length + ".");
                var r = t.training || !1,
                    a = e[0],
                    i = e[1],
                    o = e[2];
                0 < n.dropout && n.dropout < 1 && null == n.dropoutMask && (n.dropoutMask = GF({
                    ones: function () {
                        return Lk(a)
                    },
                    rate: n.dropout,
                    training: r,
                    count: 4
                }));
                var s = n.dropoutMask,
                    u = function (e, t, n) {
                        return t && t[n] ? px(t[n], e) : e
                    },
                    l = u(a, s, 0),
                    c = u(a, s, 1),
                    p = u(a, s, 2),
                    h = u(a, s, 3);
                0 < n.recurrentDropout && n.recurrentDropout < 1 && null == n.recurrentDropoutMask && (n.recurrentDropoutMask = GF({
                    ones: function () {
                        return Lk(i)
                    },
                    rate: n.recurrentDropout,
                    training: r,
                    count: 4
                }));
                var f = n.recurrentDropoutMask,
                    d = u(i, f, 0),
                    m = u(i, f, 1),
                    v = u(i, f, 2),
                    g = u(i, f, 3),
                    y = zN(n.kernel.read(), 4, 3),
                    b = y[0],
                    x = y[1],
                    w = y[2],
                    k = y[3],
                    N = n.useBias ? zN(n.bias.read(), 4) : [null, null, null, null],
                    I = N[0],
                    S = N[1],
                    T = N[2],
                    C = N[3];
                l = n.inputConv(l, b, I, n.padding), c = n.inputConv(c, x, S, n.padding), p = n.inputConv(p, w, T, n.padding), h = n.inputConv(h, k, C, n.padding);
                var E = zN(n.recurrentKernel.read(), 4, 3),
                    R = E[0],
                    A = E[1],
                    F = E[2],
                    _ = E[3];
                d = n.recurrentConv(d, R), m = n.recurrentConv(m, A), v = n.recurrentConv(v, F), g = n.recurrentConv(g, _);
                var D = n.recurrentActivation.apply(ux(l, d)),
                    O = n.recurrentActivation.apply(ux(c, m)),
                    M = ux(px(O, o), px(D, n.activation.apply(ux(p, v)))),
                    L = px(n.recurrentActivation.apply(ux(h, g)), n.activation.apply(M));
                return [L, L, M]
            })
        }, n.getConfig = function () {
            var t = e.prototype.getConfig.call(this),
                n = (t.units, function (e, t) {
                    var n = {};
                    for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
                    if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
                        var a = 0;
                        for (r = Object.getOwnPropertySymbols(e); a < r.length; a++) t.indexOf(r[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[a]) && (n[r[a]] = e[r[a]])
                    }
                    return n
                }(t, ["units"])),
                r = {
                    filters: this.filters,
                    kernelSize: this.kernelSize,
                    padding: this.padding,
                    dataFormat: this.dataFormat,
                    dilationRate: this.dilationRate,
                    strides: this.strides
                };
            return Object.assign({}, n, r)
        }, n.inputConv = function (e, t, n, r) {
            var a = iw(e, t, this.strides, r || "valid", "channelsFirst" === this.dataFormat ? "NCHW" : "NHWC", this.dilationRate);
            return n ? IE(a, n, this.dataFormat) : a
        }, n.recurrentConv = function (e, t) {
            return iw(e, t, 1, "same", "channelsFirst" === this.dataFormat ? "NCHW" : "NHWC")
        }, t
    }(WF);
    HF.className = "ConvLSTM2DCell", Yb(HF);
    var qF = function (e) {
        function t(t) {
            var n = new HF(t);
            return e.call(this, Object.assign({}, t, {
                cell: n
            })) || this
        }
        return Vm(t, e), t.fromConfig = function (e, t) {
            return new e(t)
        }, t
    }(jF);
    qF.className = "ConvLSTM2D", Yb(qF);
    var KF = function (e) {
        function t(t) {
            var n;
            return (n = e.call(this, t) || this).rate = Math.max(Math.min(t.rate, 1), 0), n.noiseShape = t.noiseShape, n.seed = t.seed, n.supportsMasking = !0, n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.getNoiseShape = function (e) {
            if (null == this.noiseShape) return this.noiseShape;
            for (var t = e.shape, n = [], r = 0; r < this.noiseShape.length; ++r) n.push(null == this.noiseShape[r] ? t[r] : this.noiseShape[r]);
            return n
        }, n.call = function (e, t) {
            var n = this;
            return rx(function () {
                n.invokeCallHook(e, t);
                var r = nR(e);
                if (0 < n.rate && n.rate < 1) {
                    var a = null != t.training && t.training,
                        i = n.getNoiseShape(r);
                    return TE(function () {
                        return SE(r, n.rate, i, n.seed)
                    }, function () {
                        return r
                    }, a)
                }
                return e
            })
        }, n.getConfig = function () {
            var t = {
                    rate: this.rate,
                    noiseShape: this.noiseShape,
                    seed: this.seed
                },
                n = e.prototype.getConfig.call(this);
            return Object.assign(t, n), t
        }, n.dispose = function () {
            return e.prototype.dispose.call(this)
        }, t
    }(dR);
    KF.className = "Dropout", Yb(KF);
    var XF = function (e) {
        function t(t) {
            var n;
            return (n = e.call(this, t) || this).inputSpec = [{
                ndim: 3
            }], n
        }
        return Vm(t, e), t.prototype.getNoiseShape = function (e) {
            var t = e.shape;
            return [t[0], 1, t[2]]
        }, t
    }(KF);
    XF.className = "SpatialDropout1D", Yb(XF);
    var YF = function (e) {
        function t(t) {
            var n;
            if ((n = e.call(this, t) || this).activation = null, n.useBias = !0, n.kernel = null, n.bias = null, n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", n.DEFAULT_BIAS_INITIALIZER = "zeros", null == t.batchInputShape && null == t.inputShape && null != t.inputDim) {
                var r = null;
                null != t.batchSize && (r = t.batchSize), n.batchInputShape = [r, t.inputDim]
            }
            return n.units = t.units, _C(n.units, "units"), n.activation = tF(t.activation), null != t.useBias && (n.useBias = t.useBias), n.kernelInitializer = XE(t.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.biasInitializer = XE(t.biasInitializer || n.DEFAULT_BIAS_INITIALIZER), n.kernelConstraint = GC(t.kernelConstraint), n.biasConstraint = GC(t.biasConstraint), n.kernelRegularizer = uF(t.kernelRegularizer), n.biasRegularizer = uF(t.biasRegularizer), n.activityRegularizer = uF(t.activityRegularizer), n.supportsMasking = !0, n.inputSpec = [{
                minNDim: 2
            }], n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.build = function (e) {
            var t, n = (e = rR(e))[e.length - 1];
            null == this.kernel && (this.kernel = this.addWeight("kernel", [n, this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint))), this.inputSpec = [{
                minNDim: 2,
                axes: (t = {}, t[-1] = n, t)
            }], this.built = !0
        }, n.computeOutputShape = function (e) {
            var t = (e = rR(e)).slice();
            return t[t.length - 1] = this.units, t
        }, n.call = function (e, t) {
            var n = this;
            return rx(function () {
                n.invokeCallHook(e, t);
                var r, a = nR(e),
                    i = DC(n.activation.getClassName());
                return null != i ? r = xE(a, n.kernel.read(), i, n.bias ? n.bias.read() : null) : (r = xE(a, n.kernel.read()), null != n.bias && (r = IE(r, n.bias.read())), null != n.activation && (r = n.activation.apply(r))), r
            })
        }, n.getConfig = function () {
            var t = {
                    units: this.units,
                    activation: $A(this.activation),
                    useBias: this.useBias,
                    kernelInitializer: KE(this.kernelInitializer),
                    biasInitializer: KE(this.biasInitializer),
                    kernelRegularizer: oF(this.kernelRegularizer),
                    biasRegularizer: oF(this.biasRegularizer),
                    activityRegularizer: oF(this.activityRegularizer),
                    kernelConstraint: VC(this.kernelConstraint),
                    biasConstraint: VC(this.biasConstraint)
                },
                n = e.prototype.getConfig.call(this);
            return Object.assign(t, n), t
        }, t
    }(dR);
    YF.className = "Dense", Yb(YF);
    var JF = function (e) {
        function t(t) {
            var n;
            return t = t || {}, (n = e.call(this, t) || this).inputSpec = [{
                minNDim: 3
            }], n.dataFormat = t.dataFormat, n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.computeOutputShape = function (e) {
            for (var t, n = Xm((e = rR(e)).slice(1)); !(t = n()).done;)
                if (null == t.value) throw new dC('The shape of the input to "Flatten" is not fully defined (got ' + e.slice(1) + '). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.');
            return [e[0], oE(e, 1)]
        }, n.call = function (e, t) {
            var n = this;
            return rx(function () {
                n.invokeCallHook(e, t);
                var r = nR(e);
                if ("channelsFirst" === n.dataFormat && r.rank > 1) {
                    for (var a = [0], i = 2; i < r.rank; ++i) a.push(i);
                    a.push(1), r = r.transpose(a)
                }
                return function (e) {
                    if (e.rank <= 1) throw new dC("batchFlatten requires a minimum rank of 2. Got rank: " + e.rank + ".");
                    var t = [e.shape[0], oE(e.shape, 1)];
                    return e.reshape(t)
                }(r)
            })
        }, n.getConfig = function () {
            var t = {};
            null != this.dataFormat && (t.dataFormat = this.dataFormat);
            var n = e.prototype.getConfig.call(this);
            return Object.assign(t, n), t
        }, t
    }(dR);
    JF.className = "Flatten", Yb(JF);
    var ZF = function (e) {
        function t(t) {
            var n;
            return (n = e.call(this, t) || this).supportsMasking = !0, n.activation = tF(t.activation), n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.call = function (e, t) {
            var n = this;
            return rx(function () {
                n.invokeCallHook(e, t);
                var r = nR(e);
                return n.activation.apply(r)
            })
        }, n.getConfig = function () {
            var t = {
                    activation: $A(this.activation)
                },
                n = e.prototype.getConfig.call(this);
            return Object.assign(t, n), t
        }, t
    }(dR);
    ZF.className = "Activation", Yb(ZF);
    var QF = function (e) {
        function t(t) {
            var n;
            return (n = e.call(this, t) || this).n = t.n, n.inputSpec = [{
                ndim: 2
            }], n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.computeOutputShape = function (e) {
            return [e[0], this.n, e[1]]
        }, n.call = function (e, t) {
            var n = this;
            return rx(function () {
                return e = nR(e), t = e, r = n.n, rx(function () {
                    if (2 !== t.shape.length) throw new dC("repeat() expects a rank-2 tensor, but received a rank-" + t.shape.length + " tensor.");
                    return yE(hE(t, 1), [1, r, 1])
                });
                var t, r
            })
        }, n.getConfig = function () {
            var t = {
                    n: this.n
                },
                n = e.prototype.getConfig.call(this);
            return Object.assign(t, n), t
        }, t
    }(dR);
    QF.className = "RepeatVector", Yb(QF);
    var $F = function (e) {
        function t(t) {
            var n;
            (n = e.call(this, t) || this).targetShape = t.targetShape;
            for (var r = 0; r < n.targetShape.length; ++r) n.isUnknown(n.targetShape[r]) && (n.targetShape[r] = null);
            return n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.isUnknown = function (e) {
            return e < 0 || null == e
        }, n.fixUnknownDimension = function (e, t) {
            for (var n = "Total size of new array must be unchanged.", r = t.slice(), a = 1, i = null, o = 0; o < r.length; ++o) {
                var s = r[o];
                if (this.isUnknown(s)) {
                    if (null !== i) throw new dC("Can only specifiy one unknown dimension.");
                    i = o
                } else a *= s
            }
            var u = oE(e);
            if (null !== i) {
                if (0 === a || u % a != 0) throw new dC(n);
                r[i] = u / a
            } else if (u !== a) throw new dC(n);
            return r
        }, n.computeOutputShape = function (e) {
            for (var t = !1, n = 0; n < e.length; ++n)
                if (this.isUnknown(e[n])) {
                    t = !0;
                    break
                } return t ? e.slice(0, 1).concat(this.targetShape) : e.slice(0, 1).concat(this.fixUnknownDimension(e.slice(1), this.targetShape))
        }, n.call = function (e, t) {
            var n = this;
            return rx(function () {
                n.invokeCallHook(e, t);
                var r = nR(e),
                    a = r.shape,
                    i = a.slice(0, 1).concat(n.fixUnknownDimension(a.slice(1), n.targetShape));
                return r.reshape(i)
            })
        }, n.getConfig = function () {
            var t = {
                    targetShape: this.targetShape
                },
                n = e.prototype.getConfig.call(this);
            return Object.assign(t, n), t
        }, t
    }(dR);
    $F.className = "Reshape", Yb($F);
    var e_ = function (e) {
        function t(t) {
            var n;
            if (n = e.call(this, t) || this, null == t.dims) throw new Error("Required configuration field `dims` is missing during Permute constructor call.");
            if (!Array.isArray(t.dims)) throw new Error("Permute constructor requires `dims` to be an Array, but received " + t.dims + " instead.");
            var r = cE(1, t.dims.length + 1);
            if (!sv(t.dims.slice().sort(), r)) throw new Error("Invalid permutation `dims`: " + JSON.stringify(t.dims) + " `dims` must contain consecutive integers starting from 1.");
            return n.dims = t.dims, n.dimsIncludingBatch = [0].concat(n.dims), n.inputSpec = [new lR({
                ndim: n.dims.length + 1
            })], n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.computeOutputShape = function (e) {
            var t = (e = rR(e)).slice();
            return this.dims.forEach(function (n, r) {
                t[r + 1] = e[n]
            }), t
        }, n.call = function (e, t) {
            return mb(nR(e), this.dimsIncludingBatch)
        }, n.getConfig = function () {
            var t = {
                    dims: this.dims
                },
                n = e.prototype.getConfig.call(this);
            return Object.assign(t, n), t
        }, t
    }(dR);
    e_.className = "Permute", Yb(e_);
    var t_ = function (e) {
        function t(t) {
            var n;
            return (n = e.call(this, null == t ? {} : t) || this).supportsMasking = !0, n.maskValue = null != t ? null == t.maskValue ? 0 : t.maskValue : 0, n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.computeOutputShape = function (e) {
            return e
        }, n.getConfig = function () {
            var t = e.prototype.getConfig.call(this),
                n = {
                    maskValue: this.maskValue
                };
            return Object.assign(n, t), n
        }, n.computeMask = function (e, t) {
            var n = nR(e);
            return gx(Dk(n, this.maskValue), -1)
        }, n.call = function (e, t) {
            var n = this;
            return rx(function () {
                n.invokeCallHook(e, t);
                var r = nR(e),
                    a = gx(Dk(r, n.maskValue), -1, !0);
                return r.mul(a.asType(r.dtype))
            })
        }, t
    }(dR);
    t_.className = "Masking", Yb(t_);
    var n_ = function (e) {
        function t(t) {
            var n;
            if ((n = e.call(this, t) || this).embeddings = null, n.DEFAULT_EMBEDDINGS_INITIALIZER = "randomUniform", null == t.batchInputShape && null == t.inputShape) {
                var r = null;
                null != t.batchSize && (r = t.batchSize), null == t.inputLength ? n.batchInputShape = [r, null] : n.batchInputShape = [r].concat(wC(t.inputLength))
            }
            return n.inputDim = t.inputDim, _C(n.inputDim, "inputDim"), n.outputDim = t.outputDim, _C(n.outputDim, "outputDim"), n.embeddingsInitializer = XE(t.embeddingsInitializer || n.DEFAULT_EMBEDDINGS_INITIALIZER), n.embeddingsRegularizer = uF(t.embeddingsRegularizer), n.activityRegularizer = uF(t.activityRegularizer), n.embeddingsConstraint = GC(t.embeddingsConstraint), n.maskZero = t.maskZero, n.supportsMasking = t.maskZero, n.inputLength = t.inputLength, n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.build = function (e) {
            this.embeddings = this.addWeight("embeddings", [this.inputDim, this.outputDim], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, !0, this.embeddingsConstraint), this.built = !0
        }, n.warnOnIncompatibleInputShape = function (e) {}, n.computeMask = function (e, t) {
            var n = this;
            return rx(function () {
                return n.maskZero ? (e = nR(e), Dk(e, Sw(e))) : null
            })
        }, n.computeOutputShape = function (e) {
            if (e = rR(e), null == this.inputLength) return [].concat(e, [this.outputDim]);
            var t = wC(this.inputLength);
            if (t.length !== e.length - 1) throw new dC('"inputLength" is ' + this.inputLength + ", but received input shape has shape " + e);
            for (var n = 0, r = 0; r < t.length; ++r) {
                var a = t[r],
                    i = e[r + 1];
                if (null != a && null != i && a !== i) throw new dC('"inputLength" is ' + this.inputLength + ", but received input shape has shape " + e);
                null == a && (t[n] = i), n++
            }
            return [e[0]].concat(t, [this.outputDim])
        }, n.call = function (e, t) {
            var n = this;
            return rx(function () {
                n.invokeCallHook(e, t);
                var r = nR(e);
                return "int32" !== r.dtype && (r = pE(r, "int32")), wE(n.embeddings.read(), r.as1D()).reshape(rR(n.computeOutputShape(r.shape)))
            })
        }, n.getConfig = function () {
            var t = {
                    inputDim: this.inputDim,
                    outputDim: this.outputDim,
                    embeddingsInitializer: KE(this.embeddingsInitializer),
                    embeddingsRegularizer: oF(this.embeddingsRegularizer),
                    activityRegularizer: oF(this.activityRegularizer),
                    embeddingsConstraint: VC(this.embeddingsConstraint),
                    maskZero: this.maskZero,
                    inputLength: this.inputLength
                },
                n = e.prototype.getConfig.call(this);
            return Object.assign(t, n), t
        }, t
    }(dR);
    n_.className = "Embedding", Yb(n_);
    var r_ = function (e) {
            function t(t) {
                var n;
                return (n = e.call(this, t || {}) || this).supportsMasking = !0, n
            }
            Vm(t, e);
            var n = t.prototype;
            return n.mergeFunction = function (e) {
                throw new mC
            }, n.computeElementwiseOpOutputShape = function (e, t) {
                if (null == e || null == t) return null;
                if (e.length < t.length) return this.computeElementwiseOpOutputShape(t, e);
                if (0 === t.length) return e;
                for (var n = e.slice(0, e.length - t.length), r = 0; r < t.length; ++r) {
                    var a = e[e.length - t.length + r],
                        i = t[r];
                    if (null == a || null == i || a < 0 || i < 0) n.push(null);
                    else if (1 === a) n.push(i);
                    else if (1 === i) n.push(a);
                    else {
                        if (a !== i) throw new dC("Operands could not be broadcast together with shapes " + JSON.stringify(e) + " " + JSON.stringify(t));
                        n.push(a)
                    }
                }
                return n
            }, n.build = function (e) {
                if (Array.isArray(e) && !Array.isArray(e[0]) && (e = [rR(e)]), (e = e).length < 2) throw new dC("A merge layer should be called on an Array of at least 2 inputs. Got " + e.length + " input(s).");
                for (var t, n = [], r = Xm(e); !(t = r()).done;) {
                    var a = t.value;
                    null != a && null !== a[0] && n.push(a[0])
                }
                if ((n = EC(n)).length > 1) throw new dC("Can not merge tensors with different batch sizes. Got tensors with shapes: " + JSON.stringify(e) + ".");
                for (var i = null == e[0] ? null : e[0].slice(1), o = 1; o < e.length; ++o) {
                    var s = null == e[o] ? null : e[o].slice(1);
                    i = this.computeElementwiseOpOutputShape(i, s)
                }
                var u = e.map(function (e) {
                    return e.length
                }); - 1 === e.indexOf(null) && 1 === EC(u).length ? this.reshapeRequired = !1 : this.reshapeRequired = !0
            }, n.call = function (e, t) {
                var n = this;
                return rx(function () {
                    if (e = e, n.reshapeRequired) {
                        var t = [],
                            r = e.map(function (e) {
                                return e.rank
                            });
                        if (-1 === r.indexOf(null)) {
                            for (var a, i = lE(r), o = Xm(e); !(a = o()).done;) {
                                for (var s = a.value, u = s.rank, l = 0; l < i - u; ++l) s = hE(s, 1);
                                t.push(s)
                            }
                            return n.mergeFunction(t)
                        }
                        for (var c, p = !1, h = Xm(e); !(c = h()).done;) {
                            var f = c.value,
                                d = f.rank;
                            if (null == d) {
                                var m = f.shape,
                                    v = m[0],
                                    g = m.slice(1).concat([v]),
                                    y = f.reshape([v].concat(oE(m.slice(1))));
                                y = (y = mb(y, [1, 0])).reshape(g), t.push(y), p = !0
                            } else if (d > 1) {
                                var b = cE(1, d).concat([0]);
                                t.push(mb(f, b)), p = !0
                            } else t.push(f)
                        }
                        var x = n.mergeFunction(t),
                            w = x.rank;
                        if (p)
                            if (null == w) {
                                var k = x.shape,
                                    N = k[k.length - 1],
                                    I = [N].concat(k.slice(0, k.length - 1));
                                x = mb(x.reshape([-1, N]), [1, 0]).reshape(I)
                            } else if (w > 1) {
                            var S = [w - 1].concat(cE(0, w - 1));
                            x = mb(x, S)
                        }
                        return x
                    }
                    return n.mergeFunction(e)
                })
            }, n.computeOutputShape = function (e) {
                var t;
                t = null == (e = e)[0] ? null : e[0].slice(1);
                for (var n = 1; n < e.length; ++n) {
                    var r = null == e[n] ? null : e[n].slice(1);
                    t = this.computeElementwiseOpOutputShape(t, r)
                }
                for (var a, i = [], o = Xm(e); !(a = o()).done;) {
                    var s = a.value;
                    null != s && null !== s[0] && i.push(s[0])
                }
                return 1 === (i = EC(i)).length ? i.concat(t) : [null].concat(t)
            }, n.computeMask = function (e, t) {
                return rx(function () {
                    if (null == t) return null;
                    if (!Array.isArray(t)) throw new dC("`mask` should be an Array");
                    if (!Array.isArray(e)) throw new dC("`inputs` should be an Array");
                    if (t.length !== e.length) throw new dC("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (" + e.length + " vs " + t.length + ")");
                    if (t.every(function (e) {
                            return null == e
                        })) return null;
                    for (var n = (t = t.map(function (e) {
                            return null == e ? e : Fw(e, 0)
                        }))[0], r = 1; r < t.length - 1; ++r) n = vk(n, t[r]);
                    return n
                })
            }, t
        }(dR),
        a_ = function (e) {
            function t(t) {
                return e.call(this, t) || this
            }
            return Vm(t, e), t.prototype.mergeFunction = function (e) {
                return rx(function () {
                    for (var t = e[0].clone(), n = 1; n < e.length; ++n) t = ux(t, e[n]);
                    return t
                })
            }, t
        }(r_);
    a_.className = "Add", Yb(a_);
    var i_ = function (e) {
        function t(t) {
            return e.call(this, t) || this
        }
        return Vm(t, e), t.prototype.mergeFunction = function (e) {
            return rx(function () {
                for (var t = e[0].clone(), n = 1; n < e.length; ++n) t = px(t, e[n]);
                return t
            })
        }, t
    }(r_);
    i_.className = "Multiply", Yb(i_);
    var o_ = function (e) {
        function t(t) {
            return e.call(this, t) || this
        }
        return Vm(t, e), t.prototype.mergeFunction = function (e) {
            return rx(function () {
                for (var t = e[0].clone(), n = 1; n < e.length; ++n) t = ux(t, e[n]);
                return px(1 / e.length, t)
            })
        }, t
    }(r_);
    o_.className = "Average", Yb(o_);
    var s_ = function (e) {
        function t(t) {
            return e.call(this, t) || this
        }
        return Vm(t, e), t.prototype.mergeFunction = function (e) {
            return rx(function () {
                for (var t = e[0], n = 1; n < e.length; ++n) t = Nk(t, e[n]);
                return t
            })
        }, t
    }(r_);
    s_.className = "Maximum", Yb(s_);
    var u_ = function (e) {
        function t(t) {
            return e.call(this, t) || this
        }
        return Vm(t, e), t.prototype.mergeFunction = function (e) {
            return rx(function () {
                for (var t = e[0], n = 1; n < e.length; ++n) t = Tk(t, e[n]);
                return t
            })
        }, t
    }(r_);
    u_.className = "Minimum", Yb(u_);
    var l_ = function (e) {
        function t(t) {
            var n;
            return (n = e.call(this, t) || this).DEFAULT_AXIS = -1, null == t && (t = {}), n.axis = null == t.axis ? n.DEFAULT_AXIS : t.axis, n.supportsMasking = !0, n.reshapeRequired = !1, n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.build = function (e) {
            if (!Array.isArray(e) || !Array.isArray(e[0]) || 1 === e.length) throw new dC("A `Concatenate` layer should be called on a list of at least 2 inputs");
            for (var t, n = !0, r = Xm(e = e); !(t = r()).done;)
                if (null != t.value) {
                    n = !1;
                    break
                } if (!n) {
                for (var a = [], i = 0; i < e.length; ++i) {
                    var o = e[i].slice();
                    o.splice(this.axis, 1);
                    for (var s, u = !1, l = Xm(a); !(s = l()).done;)
                        if (sv(s.value, o)) {
                            u = !0;
                            break
                        } u || a.push(o)
                }
                if (a.length > 1) throw new dC("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: " + JSON.stringify(e))
            }
        }, n.mergeFunction = function (e) {
            var t = this;
            return rx(function () {
                return vE(e, t.axis)
            })
        }, n.computeOutputShape = function (e) {
            if (!Array.isArray(e) || !Array.isArray(e[0])) throw new dC("A `Concatenate` layer should be called on a list of inputs.");
            for (var t, n = e, r = n[0].slice(), a = this.axis < 0 ? r.length + this.axis : this.axis, i = Xm(n.slice(1)); !(t = i()).done;) {
                var o = t.value;
                if (null == r[a] || null == o[a]) {
                    r[a] = null;
                    break
                }
                r[a] += o[a]
            }
            return r
        }, n.computeMask = function (e, t) {
            var n = this;
            if (null == t) return null;
            if (!Array.isArray(t)) throw new dC("`mask` should be an array for Concatenate");
            if (!Array.isArray(e)) throw new dC("`inputs` should be an array for Concatenate");
            if (t.length !== e.length) throw new dC("Mismatch in the length of mask (" + t.length + ") and the legnth of inputs (" + e.length + ")");
            return rx(function () {
                var r = !0;
                if (t.forEach(function (e) {
                        null == e || (r = !1)
                    }), r) return null;
                for (var a = [], i = 0; i < e.length; ++i) null == t[i] ? a.push(Lk(e[i]).asType("bool")) : t[i].rank < e[i].rank ? a.push(Fw(t[i], -1)) : a.push(t[i]);
                var o = Vx(a, n.axis);
                return vx(o, -1, !1)
            })
        }, n.getConfig = function () {
            var t = {
                    axis: this.axis
                },
                n = e.prototype.getConfig.call(this);
            return Object.assign(t, n), t
        }, t
    }(r_);

    function c_(e, t) {
        for (; e < 0;) e += t;
        return e
    }
    l_.className = "Concatenate", Yb(l_);
    var p_ = function (e) {
        function t(t) {
            var n;
            return (n = e.call(this, t) || this).axes = t.axes, n.normalize = null != t.normalize && t.normalize, n.supportsMasking = !0, n.reshapeRequired = !1, n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.build = function (e) {
            nv(Array.isArray(e) && 2 === e.length && Array.isArray(e[0]) && Array.isArray(e[1]), function () {
                return "A `Dot` layer should be called on a list of exactly 2 inputs."
            });
            var t = e[0],
                n = e[1];
            if (t.length > 3 || n.length > 3) throw new mC("Dot layer does not support tensors of 4D or higher rank yet.");
            var r = this.interpretAxes(t, n);
            if (t[r[0]] !== n[r[1]]) throw new dC("Dimension incompatibility: " + t[r[0]] + " !== " + n[r[1]])
        }, n.mergeFunction = function (e) {
            if (2 !== e.length) throw new dC("A `Dot` layer must be called on exactly 2 inputs, but received " + e.length + " input(s).");
            var t, n = e[0],
                r = e[1];
            return t = Array.isArray(this.axes) ? this.axes.map(function (t, n) {
                    return c_(t, e[n].shape.length)
                }) : [c_(this.axes, n.shape.length), c_(this.axes, r.shape.length)], this.normalize && (n = ER(n, t[0]), r = ER(r, t[1])),
                function (e, t, n) {
                    if (e.shape.length > 3 || t.shape.length > 3) throw new mC("batchDot is not implemented for tensors of 4D or higher rank yet");
                    if (nv(e.shape.length >= 2, function () {
                            return "batchDot requires the rank of x to be >= 2, but got " + e.shape.length
                        }), nv(e.shape.length >= 2, function () {
                            return "batchDot requires the rank of y to be >= 2, but got " + t.shape.length
                        }), "number" == typeof n && (n = [n, n]), "complex64" === e.dtype || "complex64" === t.dtype) throw new mC("batchDot is not implemented for complex64-type Tensors yet.");
                    var r = e.shape.length,
                        a = t.shape.length;
                    null == n && (n = [r - 1, a - 2]);
                    var i = n;
                    return rx(function () {
                        var n, o;
                        if (r > a) {
                            n = r - a;
                            for (var s = [], u = 0; u < n; ++u) s.push(1);
                            t = t.reshape(t.shape.concat(s))
                        } else if (a > r) {
                            n = a - r;
                            for (var l = [], c = 0; c < n; ++c) l.push(1);
                            e = e.reshape(e.shape.concat(l))
                        } else n = 0;
                        if (2 === e.shape.length && 2 === t.shape.length) o = i[0] === i[1] ? e.mul(t).sum(i[0]) : e.transpose([1, 0]).mul(t).sum(i[1]);
                        else {
                            var p = i[0] !== e.shape.length - 1,
                                h = i[1] === t.shape.length - 1;
                            o = e.matMul(t, p, h)
                        }
                        if (n > 0) {
                            for (var f, d = [], m = f = r > a ? r + a - 3 : r - 1; m < f + n; ++m) d.push(m);
                            o = o.squeeze(d)
                        }
                        return 1 === o.shape.length && (o = o.expandDims(1)), o
                    })
                }(n, r, t)
        }, n.interpretAxes = function (e, t) {
            return Array.isArray(this.axes) ? this.axes : [c_(this.axes, e.length), c_(this.axes, t.length)]
        }, n.computeOutputShape = function (e) {
            nv(Array.isArray(e) && 2 === e.length && Array.isArray(e[0]) && Array.isArray(e[1]), function () {
                return "A `Dot` layer should be called on a list of exactly 2 inputs."
            });
            var t = e[0].slice(),
                n = e[1].slice();
            if (t.length > 3 || n.length > 3) throw new mC("Dot layer does not support tensors of 4D or higher rank yet.");
            var r = this.interpretAxes(t, n);
            t.splice(r[0], 1), n.splice(r[1], 1), n.splice(0, 1);
            var a = t.concat(n);
            return 1 === a.length && a.push(1), a
        }, n.computeMask = function (e, t) {
            return null
        }, n.getConfig = function () {
            var t = {
                    axes: this.axes,
                    normalize: this.normalize
                },
                n = e.prototype.getConfig.call(this);
            return Object.assign(t, n), t
        }, t
    }(r_);
    p_.className = "Dot", Yb(p_);
    var h_ = function (e) {
        function t(t) {
            var n;
            return (n = e.call(this, t) || this).supportsMasking = !0, n.stddev = t.stddev, n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.computeOutputShape = function (e) {
            return e
        }, n.getConfig = function () {
            var t = e.prototype.getConfig.call(this),
                n = {
                    stddev: this.stddev
                };
            return Object.assign(n, t), n
        }, n.call = function (e, t) {
            var n = this;
            return rx(function () {
                n.invokeCallHook(e, t);
                var r = nR(e);
                return TE(function () {
                    return bE(r.shape, 0, n.stddev).add(r)
                }, function () {
                    return r
                }, t.training || !1)
            })
        }, t
    }(dR);
    h_.className = "GaussianNoise", Yb(h_);
    var f_ = function (e) {
        function t(t) {
            var n;
            return (n = e.call(this, t) || this).supportsMasking = !0, n.rate = t.rate, n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.computeOutputShape = function (e) {
            return e
        }, n.getConfig = function () {
            var t = e.prototype.getConfig.call(this),
                n = {
                    rate: this.rate
                };
            return Object.assign(n, t), n
        }, n.call = function (e, t) {
            var n = this;
            return rx(function () {
                n.invokeCallHook(e, t);
                var r = nR(e);
                return n.rate > 0 && n.rate < 1 ? TE(function () {
                    var e = Math.sqrt(n.rate / (1 - n.rate));
                    return r.mul(bE(r.shape, 1, e))
                }, function () {
                    return r
                }, t.training || !1) : r
            })
        }, t
    }(dR);
    f_.className = "GaussianDropout", Yb(f_);
    var d_ = function (e) {
        function t(t) {
            var n;
            return (n = e.call(this, t) || this).supportsMasking = !0, n.rate = t.rate, n.noiseShape = t.noiseShape, n
        }
        Vm(t, e);
        var n = t.prototype;
        return n._getNoiseShape = function (e) {
            return this.noiseShape || nR(e).shape
        }, n.computeOutputShape = function (e) {
            return e
        }, n.getConfig = function () {
            var t = e.prototype.getConfig.call(this),
                n = {
                    rate: this.rate
                };
            return Object.assign(n, t), n
        }, n.call = function (e, t) {
            var n = this;
            return rx(function () {
                if (n.rate < 1 && n.rate > 0) {
                    var r = n._getNoiseShape(e);
                    return TE(function () {
                        var t = nR(e),
                            a = -1.7580993408473766,
                            i = Bw(uN(r), n.rate);
                        i = pE(i, "float32");
                        var o = Math.pow((1 - n.rate) * (1 + n.rate * Math.pow(a, 2)), -.5),
                            s = -o * a * n.rate;
                        return t.mul(i).add(i.add(-1).mul(a)).mul(o).add(s)
                    }, function () {
                        return nR(e)
                    }, t.training || !1)
                }
                return e
            })
        }, t
    }(dR);

    function m_(e, t, n, r, a, i) {
        var o;
        if (void 0 === i && (i = .001), 2 === e.rank) o = Xx(e, t, n, r, a, i);
        else if (3 === e.rank) o = Yx(e, t, n, r, a, i);
        else {
            if (4 !== e.rank) throw new mC("batchNormalization is not implemented for array of rank " + e.rank + " yet");
            o = Jx(e, t, n, r, a, i)
        }
        return o
    }
    d_.className = "AlphaDropout", Yb(d_);
    var v_ = function (e) {
        function t(t) {
            var n;
            return null == t && (t = {}), (n = e.call(this, t) || this).supportsMasking = !0, n.axis = null == t.axis ? -1 : t.axis, n.momentum = null == t.momentum ? .99 : t.momentum, n.epsilon = null == t.epsilon ? .001 : t.epsilon, n.center = null == t.center || t.center, n.scale = null == t.scale || t.scale, n.betaInitializer = XE(t.betaInitializer || "zeros"), n.gammaInitializer = XE(t.gammaInitializer || "ones"), n.movingMeanInitializer = XE(t.movingMeanInitializer || "zeros"), n.movingVarianceInitializer = XE(t.movingVarianceInitializer || "ones"), n.betaConstraint = GC(t.betaConstraint), n.gammaConstraint = GC(t.gammaConstraint), n.betaRegularizer = uF(t.betaRegularizer), n.gammaRegularizer = uF(t.gammaRegularizer), n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.build = function (e) {
            var t;
            e = rR(e);
            var n = this.axis >= 0 ? this.axis : this.axis + e.length,
                r = e[n];
            if (null == r) throw new dC("Axis " + n + " of input tensor should have a defined dimension but the layer received an input with shape " + JSON.stringify(e) + ".");
            this.inputSpec = [new lR({
                ndim: e.length,
                axes: (t = {}, t[n] = r, t)
            })];
            var a = [r];
            this.scale && (this.gamma = this.addWeight("gamma", a, null, this.gammaInitializer, this.gammaRegularizer, !0, this.gammaConstraint)), this.center && (this.beta = this.addWeight("beta", a, null, this.betaInitializer, this.betaRegularizer, !0, this.betaConstraint)), this.movingMean = this.addWeight("moving_mean", a, null, this.movingMeanInitializer, null, !1), this.movingVariance = this.addWeight("moving_variance", a, null, this.movingVarianceInitializer, null, !1), this.built = !0
        }, n.call = function (e, t) {
            var n = this;
            return rx(function () {
                var r = null != t.training && t.training,
                    a = nR(e),
                    i = a.shape,
                    o = i.length,
                    s = cE(0, o),
                    u = n.axis >= 0 ? n.axis : n.axis + o;
                s.splice(u, 1);
                var l = gC(1, o);
                l[u] = i[u];
                var c = s.slice();
                c.sort();
                var p = !sv(c, cE(0, o).slice(0, o - 1));
                if (!r) return function () {
                    if (p) {
                        var e = n.movingMean.read().reshape(l),
                            t = n.movingVariance.read().reshape(l),
                            r = n.center ? n.beta.read().reshape(l) : null,
                            i = n.scale ? n.gamma.read().reshape(l) : null;
                        return m_(a, e, t, r, i, n.epsilon)
                    }
                    return m_(a, n.movingMean.read(), n.movingVariance.read(), null == n.beta ? null : n.beta.read(), null == n.gamma ? null : n.gamma.read(), n.epsilon)
                }();
                var h = function (e, t, n, r, a) {
                        return void 0 === a && (a = .001), sv(r.slice().sort(), cE(0, e.rank - 1)) ? function (e, t, n, r, a) {
                            return void 0 === a && (a = .001), rx(function () {
                                var i = Ak(e, r),
                                    o = i.mean,
                                    s = i.variance;
                                return [m_(e, o, s, n, t, a), o, s]
                            })
                        }(e, t, n, r, a) : function (e, t, n, r, a) {
                            return void 0 === a && (a = .001), rx(function () {
                                for (var i, o = Ak(e, r), s = o.mean, u = o.variance, l = [], c = Xm(cE(0, e.rank)); !(i = c()).done;) {
                                    var p = i.value; - 1 !== r.indexOf(p) ? l.push(1) : l.push(e.shape[p])
                                }
                                var h = s.reshape(l),
                                    f = u.reshape(l),
                                    d = null == t ? null : t.reshape(l),
                                    m = null == n ? null : n.reshape(l);
                                return [m_(e, h, f, m, d, a), s, u]
                            })
                        }(e, t, n, r, a)
                    }(a, n.gamma.read(), n.beta.read(), s, n.epsilon),
                    f = h[0],
                    d = h[1],
                    m = h[2],
                    v = function (e, t, n) {
                        rx(function () {
                            var r = 1 - n,
                                a = e.read(),
                                i = a.sub(t).mul(r);
                            e.write(a.sub(i))
                        })
                    };
                return v(n.movingMean, d, n.momentum), v(n.movingVariance, m, n.momentum), f
            })
        }, n.getConfig = function () {
            var t = {
                    axis: this.axis,
                    momentum: this.momentum,
                    epsilon: this.epsilon,
                    center: this.center,
                    scale: this.scale,
                    betaInitializer: KE(this.betaInitializer),
                    gammaInitializer: KE(this.gammaInitializer),
                    movingMeanInitializer: KE(this.movingMeanInitializer),
                    movingVarianceInitializer: KE(this.movingVarianceInitializer),
                    betaRegularizer: oF(this.betaRegularizer),
                    gammaRegularizer: oF(this.gammaRegularizer),
                    betaConstraint: VC(this.betaConstraint),
                    gammaConstraint: VC(this.gammaConstraint)
                },
                n = e.prototype.getConfig.call(this);
            return Object.assign(t, n), t
        }, t
    }(dR);
    v_.className = "BatchNormalization", Yb(v_);
    var g_ = function (e) {
        function t(t) {
            var n;
            if (null == t && (t = {}), (n = e.call(this, t) || this).axis = null == t.axis ? -1 : t.axis, "number" == typeof n.axis) {
                if (!Number.isInteger(n.axis)) throw new Error("Expected axis to be an integer, but received " + n.axis)
            } else {
                if (!Array.isArray(n.axis)) throw new Error("Expected axis to be an integer or an array of integers, but received " + JSON.stringify(n.axis));
                for (var r, a = Xm(n.axis); !(r = a()).done;) {
                    var i = r.value;
                    if (!Number.isInteger(i)) throw new Error("Expected axis to be an array of integers, but received " + JSON.stringify(n.axis))
                }
            }
            return n.epsilon = null == t.epsilon ? .001 : t.epsilon, n.center = null == t.center || t.center, n.scale = null == t.scale || t.scale, n.betaInitializer = XE(t.betaInitializer || "zeros"), n.gammaInitializer = XE(t.gammaInitializer || "ones"), n.betaRegularizer = uF(t.betaRegularizer), n.gammaRegularizer = uF(t.gammaRegularizer), n.supportsMasking = !0, n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.build = function (e) {
            var t = (e = rR(e)).length;
            "number" == typeof this.axis && (this.axis = [this.axis]);
            for (var n = 0; n < this.axis.length; ++n) this.axis[n] < 0 && (this.axis[n] += t);
            for (var r, a = Xm(this.axis); !(r = a()).done;) {
                var i = r.value;
                if (i < 0 || i >= t) throw new Error("Invalid axis: " + i)
            }
            if (this.axis.length !== EC(this.axis).length) throw new Error("Found duplicate axes in: " + this.axis);
            var o = this.axis.map(function (t) {
                return e[t]
            });
            this.scale ? this.gamma = this.addWeight("gamma", o, "float32", this.gammaInitializer, this.gammaRegularizer, !0) : this.gamma = null, this.center ? this.beta = this.addWeight("beta", o, "float32", this.betaInitializer, this.betaRegularizer, !0) : this.beta = null, this.built = !0
        }, n.call = function (e, t) {
            var n = this,
                r = nR(e),
                a = r.shape,
                i = a.length;
            return rx(function () {
                for (var e, t = Ak(r, n.axis, !0), o = t.mean, s = t.variance, u = gC(1, i), l = Xm(n.axis); !(e = l()).done;) {
                    var c = e.value;
                    u[c] = a[c]
                }
                for (var p = function (e) {
                        return null != e && e.shape.length !== i && n.axis !== [i - 1] ? e.reshape(u) : e
                    }, h = p(n.gamma.read()), f = p(n.beta.read()), d = [], m = [], v = 0; v < i; ++v) - 1 !== n.axis.indexOf(v) ? (d.push(a[v]), m.push(1)) : (d.push(1), m.push(a[v]));
                return o = o.tile(d), s = s.tile(d), h = h.tile(m), f = f.tile(m), m_(r, o, s, f, h, n.epsilon)
            })
        }, n.getConfig = function () {
            var t = {
                    axis: this.axis,
                    epsilon: this.epsilon,
                    center: this.center,
                    scale: this.scale,
                    betaInitializer: KE(this.betaInitializer),
                    gammaInitializer: KE(this.gammaInitializer),
                    betaRegularizer: oF(this.betaRegularizer),
                    gammaRegularizer: oF(this.gammaRegularizer)
                },
                n = e.prototype.getConfig.call(this);
            return Object.assign(t, n), t
        }, t
    }(dR);
    g_.className = "LayerNormalization", Yb(g_);
    var y_ = function (e) {
        function t(t) {
            var n;
            if (null == t && (t = {}), (n = e.call(this, t) || this).dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat, null == t.padding) n.padding = [
                [1, 1],
                [1, 1]
            ];
            else if ("number" == typeof t.padding) n.padding = [
                [t.padding, t.padding],
                [t.padding, t.padding]
            ];
            else {
                if (t.padding = t.padding, 2 !== t.padding.length) throw new dC("ZeroPadding2D expects padding to be a length-2 array, but received a length-" + t.padding.length + " array.");
                var r, a;
                if ("number" == typeof t.padding[0]) r = [t.padding[0], t.padding[0]], a = [t.padding[1], t.padding[1]];
                else {
                    if (t.padding = t.padding, 2 !== t.padding[0].length) throw new dC("ZeroPadding2D expects height padding to be a length-2 array, but received a length-" + t.padding[0].length + " array.");
                    if (r = t.padding[0], 2 !== t.padding[1].length) throw new dC("ZeroPadding2D expects width padding to be a length-2 array, but received a length-" + t.padding[1].length + " array.");
                    a = t.padding[1]
                }
                n.padding = [r, a]
            }
            return n.inputSpec = [new lR({
                ndim: 4
            })], n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.computeOutputShape = function (e) {
            var t, n;
            return e = rR(e), "channelsFirst" === this.dataFormat ? (t = null != e[2] && e[2] >= 0 ? e[2] + this.padding[0][0] + this.padding[0][1] : null, n = null != e[3] && e[3] >= 0 ? e[3] + this.padding[1][0] + this.padding[1][1] : null, [e[0], e[1], t, n]) : (t = null != e[1] && e[1] >= 0 ? e[1] + this.padding[0][0] + this.padding[0][1] : null, n = null != e[2] && e[2] >= 0 ? e[2] + this.padding[1][0] + this.padding[1][1] : null, [e[0], t, n, e[3]])
        }, n.call = function (e, t) {
            var n = this;
            return rx(function () {
                return t = nR(e), r = n.padding, a = n.dataFormat, rx(function () {
                    if (4 !== t.rank) throw new dC("temporalPadding expects input tensor to be 4-D, but received a " + t.rank + "-D tensor.");
                    if (null == r && (r = [
                            [1, 1],
                            [1, 1]
                        ]), 2 !== r.length || 2 !== r[0].length || 2 !== r[1].length) throw new dC("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");
                    if (null == a && (a = "channelsLast"), "channelsLast" !== a && "channelsFirst" !== a) throw new dC("Unknown data format: " + a + ". Supported data formats are 'channelsLast' and 'channelsFirst.");
                    var e;
                    return e = "channelsFirst" === a ? [
                        [0, 0],
                        [0, 0], r[0], r[1]
                    ] : [
                        [0, 0], r[0], r[1],
                        [0, 0]
                    ], Pk(t, e)
                });
                var t, r, a
            })
        }, n.getConfig = function () {
            var t = {
                    padding: this.padding,
                    dataFormat: this.dataFormat
                },
                n = e.prototype.getConfig.call(this);
            return Object.assign(t, n), t
        }, t
    }(dR);

    function b_(e, t, n, r, a, i) {
        return rx(function () {
            var o;
            ZC(a), $C(i), QC(r), null == n && (n = [1, 1]), null == r && (r = "valid"), null == a && (a = "channelsLast"), null == i && (i = "max"), e = yF(e, a);
            var s = "same" === r ? "same" : "valid";
            return o = "max" === i ? xk(e, t, n, s) : Bx(e, t, n, s), "channelsFirst" === a && (o = mb(o, [0, 3, 1, 2])), o
        })
    }

    function x_(e, t, n, r, a, i) {
        return rx(function () {
            var o;
            ZC(a), $C(i), QC(r), null == n && (n = [1, 1, 1]), null == r && (r = "valid"), null == a && (a = "channelsLast"), null == i && (i = "max"), e = bF(e, a);
            var s = "same" === r ? "same" : "valid";
            return o = "max" === i ? wk(e, t, n, s) : Wx(e, t, n, s), "channelsFirst" === a && (o = mb(o, [0, 4, 1, 2, 3])), o
        })
    }
    y_.className = "ZeroPadding2D", Yb(y_);
    var w_ = function (e) {
            function t(t) {
                var n;
                if (null == t.poolSize && (t.poolSize = 2), n = e.call(this, t) || this, "number" == typeof t.poolSize) n.poolSize = [t.poolSize];
                else {
                    if (!Array.isArray(t.poolSize) || 1 !== t.poolSize.length || "number" != typeof t.poolSize[0]) throw new dC("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received " + JSON.stringify(t.poolSize));
                    n.poolSize = t.poolSize
                }
                if (_C(n.poolSize, "poolSize"), null == t.strides) n.strides = n.poolSize;
                else if ("number" == typeof t.strides) n.strides = [t.strides];
                else {
                    if (!Array.isArray(t.strides) || 1 !== t.strides.length || "number" != typeof t.strides[0]) throw new dC("strides for 1D convolutional layer must be a number or an Array of a single number, but received " + JSON.stringify(t.strides));
                    n.strides = t.strides
                }
                return _C(n.strides, "strides"), n.padding = null == t.padding ? "valid" : t.padding, QC(n.padding), n.inputSpec = [new lR({
                    ndim: 3
                })], n
            }
            Vm(t, e);
            var n = t.prototype;
            return n.computeOutputShape = function (e) {
                var t = vF((e = rR(e))[1], this.poolSize[0], this.padding, this.strides[0]);
                return [e[0], t, e[2]]
            }, n.call = function (e, t) {
                var n = this;
                return rx(function () {
                    n.invokeCallHook(e, t), e = hE(nR(e), 2);
                    var r = n.poolingFunction(nR(e), [n.poolSize[0], 1], [n.strides[0], 1], n.padding, "channelsLast");
                    return VN(r, [2])
                })
            }, n.getConfig = function () {
                var t = {
                        poolSize: this.poolSize,
                        padding: this.padding,
                        strides: this.strides
                    },
                    n = e.prototype.getConfig.call(this);
                return Object.assign(t, n), t
            }, t
        }(dR),
        k_ = function (e) {
            function t(t) {
                return e.call(this, t) || this
            }
            return Vm(t, e), t.prototype.poolingFunction = function (e, t, n, r, a) {
                return ZC(a), QC(r), b_(e, t, n, r, a, "max")
            }, t
        }(w_);
    k_.className = "MaxPooling1D", Yb(k_);
    var N_ = function (e) {
        function t(t) {
            return e.call(this, t) || this
        }
        return Vm(t, e), t.prototype.poolingFunction = function (e, t, n, r, a) {
            return ZC(a), QC(r), b_(e, t, n, r, a, "avg")
        }, t
    }(w_);
    N_.className = "AveragePooling1D", Yb(N_);
    var I_ = function (e) {
            function t(t) {
                var n;
                if (null == t.poolSize && (t.poolSize = [2, 2]), (n = e.call(this, t) || this).poolSize = Array.isArray(t.poolSize) ? t.poolSize : [t.poolSize, t.poolSize], null == t.strides) n.strides = n.poolSize;
                else if (Array.isArray(t.strides)) {
                    if (2 !== t.strides.length) throw new dC("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length " + t.strides.length + ".");
                    n.strides = t.strides
                } else n.strides = [t.strides, t.strides];
                return _C(n.poolSize, "poolSize"), _C(n.strides, "strides"), n.padding = null == t.padding ? "valid" : t.padding, n.dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat, ZC(n.dataFormat), QC(n.padding), n.inputSpec = [new lR({
                    ndim: 4
                })], n
            }
            Vm(t, e);
            var n = t.prototype;
            return n.computeOutputShape = function (e) {
                e = rR(e);
                var t = "channelsFirst" === this.dataFormat ? e[2] : e[1],
                    n = "channelsFirst" === this.dataFormat ? e[3] : e[2];
                return t = vF(t, this.poolSize[0], this.padding, this.strides[0]), n = vF(n, this.poolSize[1], this.padding, this.strides[1]), "channelsFirst" === this.dataFormat ? [e[0], e[1], t, n] : [e[0], t, n, e[3]]
            }, n.call = function (e, t) {
                var n = this;
                return rx(function () {
                    return n.invokeCallHook(e, t), n.poolingFunction(nR(e), n.poolSize, n.strides, n.padding, n.dataFormat)
                })
            }, n.getConfig = function () {
                var t = {
                        poolSize: this.poolSize,
                        padding: this.padding,
                        strides: this.strides,
                        dataFormat: this.dataFormat
                    },
                    n = e.prototype.getConfig.call(this);
                return Object.assign(t, n), t
            }, t
        }(dR),
        S_ = function (e) {
            function t(t) {
                return e.call(this, t) || this
            }
            return Vm(t, e), t.prototype.poolingFunction = function (e, t, n, r, a) {
                return ZC(a), QC(r), b_(e, t, n, r, a, "max")
            }, t
        }(I_);
    S_.className = "MaxPooling2D", Yb(S_);
    var T_ = function (e) {
        function t(t) {
            return e.call(this, t) || this
        }
        return Vm(t, e), t.prototype.poolingFunction = function (e, t, n, r, a) {
            return ZC(a), QC(r), b_(e, t, n, r, a, "avg")
        }, t
    }(I_);
    T_.className = "AveragePooling2D", Yb(T_);
    var C_ = function (e) {
            function t(t) {
                var n;
                if (null == t.poolSize && (t.poolSize = [2, 2, 2]), (n = e.call(this, t) || this).poolSize = Array.isArray(t.poolSize) ? t.poolSize : [t.poolSize, t.poolSize, t.poolSize], null == t.strides) n.strides = n.poolSize;
                else if (Array.isArray(t.strides)) {
                    if (3 !== t.strides.length) throw new dC("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length " + t.strides.length + ".");
                    n.strides = t.strides
                } else n.strides = [t.strides, t.strides, t.strides];
                return _C(n.poolSize, "poolSize"), _C(n.strides, "strides"), n.padding = null == t.padding ? "valid" : t.padding, n.dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat, ZC(n.dataFormat), QC(n.padding), n.inputSpec = [new lR({
                    ndim: 5
                })], n
            }
            Vm(t, e);
            var n = t.prototype;
            return n.computeOutputShape = function (e) {
                e = rR(e);
                var t = "channelsFirst" === this.dataFormat ? e[2] : e[1],
                    n = "channelsFirst" === this.dataFormat ? e[3] : e[2],
                    r = "channelsFirst" === this.dataFormat ? e[4] : e[3];
                return t = vF(t, this.poolSize[0], this.padding, this.strides[0]), n = vF(n, this.poolSize[1], this.padding, this.strides[1]), r = vF(r, this.poolSize[2], this.padding, this.strides[2]), "channelsFirst" === this.dataFormat ? [e[0], e[1], t, n, r] : [e[0], t, n, r, e[4]]
            }, n.call = function (e, t) {
                var n = this;
                return rx(function () {
                    return n.invokeCallHook(e, t), n.poolingFunction(nR(e), n.poolSize, n.strides, n.padding, n.dataFormat)
                })
            }, n.getConfig = function () {
                var t = {
                        poolSize: this.poolSize,
                        padding: this.padding,
                        strides: this.strides,
                        dataFormat: this.dataFormat
                    },
                    n = e.prototype.getConfig.call(this);
                return Object.assign(t, n), t
            }, t
        }(dR),
        E_ = function (e) {
            function t(t) {
                return e.call(this, t) || this
            }
            return Vm(t, e), t.prototype.poolingFunction = function (e, t, n, r, a) {
                return ZC(a), QC(r), x_(e, t, n, r, a, "max")
            }, t
        }(C_);
    E_.className = "MaxPooling3D", Yb(E_);
    var R_ = function (e) {
        function t(t) {
            return e.call(this, t) || this
        }
        return Vm(t, e), t.prototype.poolingFunction = function (e, t, n, r, a) {
            return ZC(a), QC(r), x_(e, t, n, r, a, "avg")
        }, t
    }(C_);
    R_.className = "AveragePooling3D", Yb(R_);
    var A_ = function (e) {
            function t(t) {
                var n;
                return (n = e.call(this, t) || this).inputSpec = [new lR({
                    ndim: 3
                })], n
            }
            Vm(t, e);
            var n = t.prototype;
            return n.computeOutputShape = function (e) {
                return [e[0], e[2]]
            }, n.call = function (e, t) {
                throw new mC
            }, t
        }(dR),
        F_ = function (e) {
            function t(t) {
                return e.call(this, t || {}) || this
            }
            return Vm(t, e), t.prototype.call = function (e, t) {
                return rx(function () {
                    var t = nR(e);
                    return Ik(t, 1)
                })
            }, t
        }(A_);
    F_.className = "GlobalAveragePooling1D", Yb(F_);
    var __ = function (e) {
        function t(t) {
            return e.call(this, t || {}) || this
        }
        return Vm(t, e), t.prototype.call = function (e, t) {
            return rx(function () {
                var t = nR(e);
                return rk(t, 1)
            })
        }, t
    }(A_);
    __.className = "GlobalMaxPooling1D", Yb(__);
    var D_ = function (e) {
            function t(t) {
                var n;
                return (n = e.call(this, t) || this).dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat, ZC(n.dataFormat), n.inputSpec = [new lR({
                    ndim: 4
                })], n
            }
            Vm(t, e);
            var n = t.prototype;
            return n.computeOutputShape = function (e) {
                return e = e, "channelsLast" === this.dataFormat ? [e[0], e[3]] : [e[0], e[1]]
            }, n.call = function (e, t) {
                throw new mC
            }, n.getConfig = function () {
                var t = {
                        dataFormat: this.dataFormat
                    },
                    n = e.prototype.getConfig.call(this);
                return Object.assign(t, n), t
            }, t
        }(dR),
        O_ = function (e) {
            function t() {
                return e.apply(this, arguments) || this
            }
            return Vm(t, e), t.prototype.call = function (e, t) {
                var n = this;
                return rx(function () {
                    var t = nR(e);
                    return "channelsLast" === n.dataFormat ? Ik(t, [1, 2]) : Ik(t, [2, 3])
                })
            }, t
        }(D_);
    O_.className = "GlobalAveragePooling2D", Yb(O_);
    var M_ = function (e) {
        function t() {
            return e.apply(this, arguments) || this
        }
        return Vm(t, e), t.prototype.call = function (e, t) {
            var n = this;
            return rx(function () {
                var t = nR(e);
                return "channelsLast" === n.dataFormat ? rk(t, [1, 2]) : rk(t, [2, 3])
            })
        }, t
    }(D_);
    M_.className = "GlobalMaxPooling2D", Yb(M_);
    var L_ = function (e) {
            function t(t) {
                var n;
                return (n = e.call(this, t) || this).layer = t.layer, n
            }
            Vm(t, e);
            var n = t.prototype;
            return n.build = function (e) {
                this.built = !0
            }, n.getWeights = function () {
                return this.layer.getWeights()
            }, n.setWeights = function (e) {
                this.layer.setWeights(e)
            }, n.getConfig = function () {
                var t = {
                        layer: {
                            className: this.layer.getClassName(),
                            config: this.layer.getConfig()
                        }
                    },
                    n = e.prototype.getConfig.call(this);
                return Object.assign(t, n), t
            }, n.setFastWeightInitDuringBuild = function (t) {
                e.prototype.setFastWeightInitDuringBuild.call(this, t), null != this.layer && this.layer.setFastWeightInitDuringBuild(t)
            }, t.fromConfig = function (e, t, n) {
                void 0 === n && (n = {});
                var r = CR(t.layer, n);
                delete t.layer;
                var a = {
                    layer: r
                };
                return Object.assign(a, t), new e(a)
            }, Wm(t, [{
                key: "trainable",
                get: function () {
                    return null != this.layer && this.layer.trainable
                },
                set: function (e) {
                    null != this.layer && (this.layer.trainable = e)
                }
            }, {
                key: "trainableWeights",
                get: function () {
                    return this.layer.trainableWeights
                }
            }, {
                key: "nonTrainableWeights",
                get: function () {
                    return this.layer.nonTrainableWeights
                }
            }, {
                key: "updates",
                get: function () {
                    return this.layer._updates
                }
            }, {
                key: "losses",
                get: function () {
                    return this.layer.losses
                }
            }]), t
        }(dR),
        z_ = function (e) {
            function t(t) {
                var n;
                return (n = e.call(this, t) || this).supportsMasking = !0, n
            }
            Vm(t, e);
            var n = t.prototype;
            return n.build = function (t) {
                if ((t = rR(t)).length < 3) throw new dC("TimeDistributed layer expects an input shape >= 3D, but received input shape " + JSON.stringify(t));
                this.inputSpec = [{
                    shape: t
                }];
                var n = [t[0]].concat(t.slice(2));
                this.layer.built || (this.layer.build(n), this.layer.built = !0), e.prototype.build.call(this, t)
            }, n.computeOutputShape = function (e) {
                var t = [(e = rR(e))[0]].concat(e.slice(2)),
                    n = this.layer.computeOutputShape(t),
                    r = e[1];
                return [n[0], r].concat(n.slice(1))
            }, n.call = function (e, t) {
                var n = this;
                return rx(function () {
                    return DF(function (e, r) {
                        return [nR(n.layer.call(e, t)), []]
                    }, e = nR(e), [], !1, null, null, !1, !0)[1]
                })
            }, t
        }(L_);
    z_.className = "TimeDistributed", Yb(z_);
    var P_ = function (e) {
        function t(t) {
            var n;
            n = e.call(this, t) || this;
            var r = t.layer.getConfig(),
                a = {};
            a.className = t.layer.getClassName(), a.config = r, n.forwardLayer = CR(a), r.goBackwards = !0 !== r.goBackwards;
            var i, o = {};
            if (o.className = t.layer.getClassName(), o.config = r, n.backwardLayer = CR(o), n.forwardLayer.name = "forward_" + n.forwardLayer.name, n.backwardLayer.name = "backward_" + n.backwardLayer.name, n.mergeMode = void 0 === t.mergeMode ? "concat" : t.mergeMode, i = n.mergeMode, AC(YC, "BidirectionalMergeMode", i), t.weights) throw new mC("weights support is not implemented for Bidirectional layer yet.");
            return n._stateful = t.layer.stateful, n.returnSequences = t.layer.returnSequences, n.returnState = t.layer.returnState, n.supportsMasking = !0, n._trainable = !0, n.inputSpec = t.layer.inputSpec, n.numConstants = null, n
        }
        Vm(t, e);
        var n = t.prototype;
        return n.getWeights = function () {
            return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())
        }, n.setWeights = function (e) {
            var t = e.length,
                n = Math.floor(t / 2);
            this.forwardLayer.setWeights(e.slice(0, n)), this.backwardLayer.setWeights(e.slice(n))
        }, n.computeOutputShape = function (e) {
            var t, n, r, a = this.forwardLayer.computeOutputShape(e);
            return Array.isArray(a) && Array.isArray(a[0]) || (a = [a]), a = a, this.returnState ? (r = a.slice(1), t = a[0]) : t = a[0], t = t, "concat" === this.mergeMode ? (t[t.length - 1] *= 2, n = [t]) : n = null == this.mergeMode ? [t, t.slice()] : [t], this.returnState ? null == this.mergeMode ? n.concat(r).concat(r.slice()) : [t].concat(r).concat(r.slice()) : xC(n)
        }, n.apply = function (t, n) {
            var r = null == n ? null : n.initialState,
                a = null == n ? null : n.constants;
            null == n && (n = {});
            var i = _F(t, r, a, this.numConstants);
            if (t = i.inputs, r = i.initialState, a = i.constants, Array.isArray(t) && (r = t.slice(1), t = t[0]), (null == r || 0 === r.length) && null == a) return e.prototype.apply.call(this, t, n);
            var o = [],
                s = [];
            if (null != r) {
                var u = r.length;
                if (u % 2 > 0) throw new dC("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");
                n.initialState = r, o.push.apply(o, r);
                var l = r.map(function (e) {
                    return new lR({
                        shape: e.shape
                    })
                });
                this.forwardLayer.stateSpec = l.slice(0, u / 2), this.backwardLayer.stateSpec = l.slice(u / 2), s.push.apply(s, l)
            }
            if (null != a) throw new mC("Support for constants in Bidirectional layers is not implemented yet.");
            for (var c = o[0] instanceof cR, p = 0, h = o; p < h.length; p++)
                if (h[p] instanceof cR !== c) throw new dC("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");
            if (c) {
                var f = [t].concat(o),
                    d = this.inputSpec.concat(s),
                    m = this.inputSpec;
                this.inputSpec = d;
                var v = e.prototype.apply.call(this, f, n);
                return this.inputSpec = m, v
            }
            return e.prototype.apply.call(this, t, n)
        }, n.call = function (e, t) {
            var n = this;
            return rx(function () {
                var r, a, i, o, s = t.initialState;
                if (null == s) r = n.forwardLayer.call(e, t), a = n.backwardLayer.call(e, t);
                else {
                    var u = s.slice(0, s.length / 2),
                        l = s.slice(s.length / 2);
                    r = n.forwardLayer.call(e, Object.assign(t, {
                        initialState: u
                    })), a = n.backwardLayer.call(e, Object.assign(t, {
                        initialState: l
                    }))
                }
                return n.returnState && (Array.isArray(r) && (i = r.slice(1).concat(a.slice(1))), r = r[0], a = a[0]), n.returnSequences && (a = dN(a, 1)), "concat" === n.mergeMode ? o = vE([r, a]) : "sum" === n.mergeMode ? o = ux(r, a) : "ave" === n.mergeMode ? o = px(.5, ux(r, a)) : "mul" === n.mergeMode ? o = px(r, a) : null == n.mergeMode && (o = [r, a]), n.returnState ? null == n.mergeMode ? o.concat(i) : [o].concat(i) : o
            })
        }, n.resetStates = function (e) {
            this.forwardLayer.resetStates(), this.backwardLayer.resetStates()
        }, n.build = function (e) {
            var t = this;
            tE(this.forwardLayer.name, function () {
                t.forwardLayer.build(e)
            }), tE(this.backwardLayer.name, function () {
                t.backwardLayer.build(e)
            }), this.built = !0
        }, n.computeMask = function (e, t) {
            var n;
            if (Array.isArray(t) && (t = t[0]), n = this.returnSequences ? null == this.mergeMode ? [t, t] : t : null == this.mergeMode ? [null, null] : null, this.returnState) {
                var r = this.forwardLayer.states.map(function (e) {
                    return null
                });
                return Array.isArray(n) ? n.concat(r).concat(r) : [n].concat(r).concat(r)
            }
            return n
        }, n.setFastWeightInitDuringBuild = function (t) {
            e.prototype.setFastWeightInitDuringBuild.call(this, t), null != this.forwardLayer && this.forwardLayer.setFastWeightInitDuringBuild(t), null != this.backwardLayer && this.backwardLayer.setFastWeightInitDuringBuild(t)
        }, n.getConfig = function () {
            var t = {
                    mergeMode: this.mergeMode
                },
                n = e.prototype.getConfig.call(this);
            return Object.assign(t, n), t
        }, t.fromConfig = function (e, t) {
            var n = CR(t.layer);
            if (delete t.layer, null != t.numConstants) throw new mC("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");
            var r = t;
            return r.layer = n, new e(r)
        }, Wm(t, [{
            key: "trainable",
            get: function () {
                return this._trainable
            },
            set: function (e) {
                this._trainable = e, null != this.forwardLayer && (this.forwardLayer.trainable = e), null != this.backwardLayer && (this.backwardLayer.trainable = e)
            }
        }, {
            key: "trainableWeights",
            get: function () {
                return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)
            }
        }, {
            key: "nonTrainableWeights",
            get: function () {
                return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)
            }
        }]), t
    }(L_);

    function B_(e) {
        return new N_(e)
    }

    function W_(e) {
        return new T_(e)
    }

    function V_(e) {
        return new R_(e)
    }

    function U_(e) {
        return new __(e)
    }

    function G_(e) {
        return new M_(e)
    }

    function j_(e) {
        return new k_(e)
    }

    function H_(e) {
        return new S_(e)
    }
    P_.className = "Bidirectional", Yb(P_);
    var q_ = {
            __proto__: null,
            inputLayer: function (e) {
                return new mR(e)
            },
            elu: function (e) {
                return new hF(e)
            },
            reLU: function (e) {
                return new lF(e)
            },
            leakyReLU: function (e) {
                return new cF(e)
            },
            prelu: function (e) {
                return new pF(e)
            },
            softmax: function (e) {
                return new dF(e)
            },
            thresholdedReLU: function (e) {
                return new fF(e)
            },
            conv1d: function (e) {
                return new EF(e)
            },
            conv2d: function (e) {
                return new NF(e)
            },
            conv2dTranspose: function (e) {
                return new SF(e)
            },
            conv3d: function (e) {
                return new IF(e)
            },
            separableConv2d: function (e) {
                return new CF(e)
            },
            cropping2D: function (e) {
                return new RF(e)
            },
            upSampling2d: function (e) {
                return new AF(e)
            },
            depthwiseConv2d: function (e) {
                return new FF(e)
            },
            activation: function (e) {
                return new ZF(e)
            },
            dense: function (e) {
                return new YF(e)
            },
            dropout: function (e) {
                return new KF(e)
            },
            spatialDropout1d: function (e) {
                return new XF(e)
            },
            flatten: function (e) {
                return new JF(e)
            },
            repeatVector: function (e) {
                return new QF(e)
            },
            reshape: function (e) {
                return new $F(e)
            },
            permute: function (e) {
                return new e_(e)
            },
            embedding: function (e) {
                return new n_(e)
            },
            add: function (e) {
                return new a_(e)
            },
            average: function (e) {
                return new o_(e)
            },
            concatenate: function (e) {
                return new l_(e)
            },
            maximum: function (e) {
                return new s_(e)
            },
            minimum: function (e) {
                return new u_(e)
            },
            multiply: function (e) {
                return new i_(e)
            },
            dot: function (e) {
                return new p_(e)
            },
            batchNormalization: function (e) {
                return new v_(e)
            },
            layerNormalization: function (e) {
                return new g_(e)
            },
            zeroPadding2d: function (e) {
                return new y_(e)
            },
            averagePooling1d: B_,
            avgPool1d: function (e) {
                return B_(e)
            },
            avgPooling1d: function (e) {
                return B_(e)
            },
            averagePooling2d: W_,
            avgPool2d: function (e) {
                return W_(e)
            },
            avgPooling2d: function (e) {
                return W_(e)
            },
            averagePooling3d: V_,
            avgPool3d: function (e) {
                return V_(e)
            },
            avgPooling3d: function (e) {
                return V_(e)
            },
            globalAveragePooling1d: function (e) {
                return new F_(e)
            },
            globalAveragePooling2d: function (e) {
                return new O_(e)
            },
            globalMaxPooling1d: U_,
            globalMaxPooling2d: G_,
            maxPooling1d: j_,
            maxPooling2d: H_,
            maxPooling3d: function (e) {
                return new E_(e)
            },
            gru: function (e) {
                return new BF(e)
            },
            gruCell: function (e) {
                return new PF(e)
            },
            lstm: function (e) {
                return new VF(e)
            },
            lstmCell: function (e) {
                return new WF(e)
            },
            simpleRNN: function (e) {
                return new zF(e)
            },
            simpleRNNCell: function (e) {
                return new LF(e)
            },
            convLstm2d: function (e) {
                return new qF(e)
            },
            convLstm2dCell: function (e) {
                return new HF(e)
            },
            rnn: function (e) {
                return new OF(e)
            },
            stackedRNNCells: function (e) {
                return new UF(e)
            },
            bidirectional: function (e) {
                return new P_(e)
            },
            timeDistributed: function (e) {
                return new z_(e)
            },
            globalMaxPool1d: U_,
            globalMaxPool2d: G_,
            maxPool1d: j_,
            maxPool2d: H_,
            Layer: dR,
            RNN: OF,
            RNNCell: MF,
            input: PA,
            gaussianNoise: function (e) {
                return new h_(e)
            },
            gaussianDropout: function (e) {
                return new f_(e)
            },
            alphaDropout: function (e) {
                return new d_(e)
            },
            masking: function (e) {
                return new t_(e)
            }
        },
        K_ = {
            __proto__: null,
            binaryAccuracy: function (e, t) {
                return PR(e, t)
            },
            binaryCrossentropy: function (e, t) {
                return UR(e, t)
            },
            sparseCategoricalAccuracy: function (e, t) {
                return GR(e, t)
            },
            categoricalAccuracy: function (e, t) {
                return BR(e, t)
            },
            categoricalCrossentropy: function (e, t) {
                return jR(e, t)
            },
            precision: function (e, t) {
                return VR(e, t)
            },
            recall: function (e, t) {
                return function (e, t) {
                    return rx(function () {
                        var n = WR(e, t),
                            r = function (e, t) {
                                return rx(function () {
                                    return vk(e.equal(1), t.equal(0)).sum().cast("float32")
                                })
                            }(e, t),
                            a = n.add(r);
                        return Iw(Pw(a, 0), n.div(a), 0).cast("float32")
                    })
                }(e, t)
            },
            cosineProximity: function (e, t) {
                return MR(e, t)
            },
            meanAbsoluteError: function (e, t) {
                return AR(e, t)
            },
            meanAbsolutePercentageError: function (e, t) {
                return FR(e, t)
            },
            MAPE: function (e, t) {
                return FR(e, t)
            },
            mape: function (e, t) {
                return FR(e, t)
            },
            meanSquaredError: function (e, t) {
                return RR(e, t)
            },
            MSE: function (e, t) {
                return RR(e, t)
            },
            mse: function (e, t) {
                return RR(e, t)
            }
        },
        X_ = {
            __proto__: null,
            modelFromJSON: function (e, t) {
                return DA.apply(this, arguments)
            }
        },
        Y_ = {
            __proto__: null,
            l1l2: function (e) {
                return new aF(e)
            },
            l1: function (e) {
                return nF(t = e), new aF({
                    l1: null != t ? t.l1 : null,
                    l2: 0
                });
                var t
            },
            l2: function (e) {
                return nF(t = e), new aF({
                    l2: null != t ? t.l2 : null,
                    l1: 0
                });
                var t
            }
        },
        J_ = function (e) {
            function t() {
                var t;
                return (t = e.apply(this, arguments) || this).model = null, t
            }
            return Vm(t, e), t.prototype.setModel = function (e) {
                if (!(e instanceof FA)) throw new Error("model must be a LayersModel, not some other Container");
                this.model = e
            }, t
        }(bR);

    function Z_(e, t) {
        return e < t
    }

    function Q_(e, t) {
        return e > t
    }
    var $_, eD, tD = function (e) {
            function t(t) {
                var n;
                if (n = e.call(this) || this, null == t && (t = {}), t.restoreBestWeights) throw new mC("restoreBestWeights = True is not implemented in EarlyStopping yet.");
                return n.monitor = t.monitor || "val_loss", n.minDelta = Math.abs(t.minDelta || 0), n.patience = t.patience || 0, n.verbose = t.verbose || 0, n.mode = t.mode || "auto", n.baseline = t.baseline, -1 === ["auto", "min", "max"].indexOf(n.mode) && (console.warn("EarlyStopping mode '" + n.mode + "' is invalid. Falling back to mode 'auto'."), n.mode = "auto"), "min" === n.mode ? n.monitorFunc = Z_ : "max" === n.mode || -1 !== n.monitor.indexOf("acc") ? n.monitorFunc = Q_ : n.monitorFunc = Z_, n.monitorFunc === Z_ && (n.minDelta *= -1), n
            }
            Vm(t, e);
            var n = t.prototype;
            return n.onTrainBegin = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                this.wait = 0, this.stoppedEpoch = 0, null != this.baseline ? this.best = this.baseline : this.best = this.monitorFunc === Z_ ? 1 / 0 : -1 / 0;
                            case 3:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), n.onEpochEnd = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t, n) {
                    var r;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, gR(n);
                            case 2:
                                if (null != (r = this.getMonitorValue(n))) {
                                    e.next = 5;
                                    break
                                }
                                return e.abrupt("return");
                            case 5:
                                this.monitorFunc(r - this.minDelta, this.best) ? (this.best = r, this.wait = 0) : (this.wait++, this.wait >= this.patience && (this.stoppedEpoch = t, this.model.stopTraining = !0));
                            case 6:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t, n) {
                    return e.apply(this, arguments)
                }
            }(), n.onTrainEnd = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                this.stoppedEpoch > 0 && this.verbose && console.log("Epoch " + this.stoppedEpoch + ": early stopping.");
                            case 1:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), n.getMonitorValue = function (e) {
                null == e && (e = {});
                var t = e[this.monitor];
                return null == t && console.warn("Metric for EarlyStopping " + this.monitor + " is not available. Available metrics are: " + Object.keys(e)), t
            }, t
        }(J_),
        nD = {
            earlyStopping: function (e) {
                return new tD(e)
            }
        };
    ! function (e) {
        e[e.DT_INVALID = 0] = "DT_INVALID", e[e.DT_FLOAT = 1] = "DT_FLOAT", e[e.DT_DOUBLE = 2] = "DT_DOUBLE", e[e.DT_INT32 = 3] = "DT_INT32", e[e.DT_UINT8 = 4] = "DT_UINT8", e[e.DT_INT16 = 5] = "DT_INT16", e[e.DT_INT8 = 6] = "DT_INT8", e[e.DT_STRING = 7] = "DT_STRING", e[e.DT_COMPLEX64 = 8] = "DT_COMPLEX64", e[e.DT_INT64 = 9] = "DT_INT64", e[e.DT_BOOL = 10] = "DT_BOOL", e[e.DT_QINT8 = 11] = "DT_QINT8", e[e.DT_QUINT8 = 12] = "DT_QUINT8", e[e.DT_QINT32 = 13] = "DT_QINT32", e[e.DT_BFLOAT16 = 14] = "DT_BFLOAT16", e[e.DT_FLOAT_REF = 101] = "DT_FLOAT_REF", e[e.DT_DOUBLE_REF = 102] = "DT_DOUBLE_REF", e[e.DT_INT32_REF = 103] = "DT_INT32_REF", e[e.DT_UINT8_REF = 104] = "DT_UINT8_REF", e[e.DT_INT16_REF = 105] = "DT_INT16_REF", e[e.DT_INT8_REF = 106] = "DT_INT8_REF", e[e.DT_STRING_REF = 107] = "DT_STRING_REF", e[e.DT_COMPLEX64_REF = 108] = "DT_COMPLEX64_REF", e[e.DT_INT64_REF = 109] = "DT_INT64_REF", e[e.DT_BOOL_REF = 110] = "DT_BOOL_REF", e[e.DT_QINT8_REF = 111] = "DT_QINT8_REF", e[e.DT_QUINT8_REF = 112] = "DT_QUINT8_REF", e[e.DT_QINT32_REF = 113] = "DT_QINT32_REF", e[e.DT_BFLOAT16_REF = 114] = "DT_BFLOAT16_REF"
    }($_ || ($_ = {})),
    function (e) {
        ! function (e) {
            e[e.LEGACY = 0] = "LEGACY", e[e.V1 = 1] = "V1", e[e.V2 = 2] = "V2"
        }(e.CheckpointFormatVersion || (e.CheckpointFormatVersion = {}))
    }(eD || (eD = {}));
    var rD = {};

    function aD(e) {
        return rD[e]
    }

    function iD(e, t, n, r, a) {
        var i = t.inputParams[e];
        if (i && void 0 !== i.inputIndexStart) {
            var o = i.inputIndexStart,
                s = 0 === i.inputIndexEnd ? void 0 : void 0 === i.inputIndexEnd ? o + 1 : i.inputIndexEnd;
            if ("tensor" === i.type) return oD(t.inputNames[i.inputIndexStart], n, r, a);
            if ("tensors" === i.type) return t.inputNames.slice(o, s).map(function (e) {
                return oD(e, n, r, a)
            });
            var u = oD(t.inputNames.slice(o)[0], n, r, a),
                l = u.dataSync();
            return "number" === i.type ? l[0] : Av(u.shape, l)
        }
        var c = t.attrParams[e];
        return c && c.value
    }

    function oD(e, t, n, r) {
        var a = lD(e),
            i = a[0],
            o = a[1];
        if (null != r) {
            var s = r.getHashTableHandleByName(i);
            if (null != s) return s
        }
        var u = n.currentContextIds.find(function (e) {
            return !!t[uD(i, e)]
        });
        return void 0 !== u ? t[uD(i, u)][o] : void 0
    }

    function sD(e, t) {
        var n = lD(e),
            r = n[0],
            a = n[1];
        return [uD(r, t && t.currentContextId), a]
    }

    function uD(e, t) {
        return t ? e + "-" + t : e
    }

    function lD(e) {
        var t = e.split(":");
        return 1 === t.length ? [e, 0] : [t[0], Number(t[t.length - 1])]
    }

    function cD(e, t, n) {
        var r = iD("pad", e, t, n);
        if ("explicit" === r) {
            r = iD("explicitPaddings", e, t, n);
            for (var a = [
                    [0, 0],
                    [0, 0],
                    [0, 0],
                    [0, 0]
                ], i = 0; i < 4; i++) a[i][0] = r[2 * i], a[i][1] = r[2 * i + 1];
            return a
        }
        return r
    }

    function pD(e) {
        return e.kept ? e : Xy(e)
    }
    var hD = {
            __proto__: null,
            json: [{
                tfOpName: "Add",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "AddV2",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "AddN",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    end: 0,
                    name: "tensors",
                    type: "tensors"
                }]
            }, {
                tfOpName: "BiasAdd",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Sub",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "RealDiv",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Div",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "DivNoNan",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "FloorDiv",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Mul",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Maximum",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Minimum",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Pow",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "SquaredDifference",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Mod",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "FloorMod",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }]
        },
        fD = {
            __proto__: null,
            json: [{
                tfOpName: "Abs",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Acos",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Asin",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Atan",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Atan2",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "y",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Ceil",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "ClipByValue",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "clipValueMin",
                    type: "number"
                }, {
                    start: 2,
                    name: "clipValueMax",
                    type: "number"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Complex",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "real",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "imag",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "ComplexAbs",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Cos",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Cosh",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Elu",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Exp",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Floor",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Log",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Imag",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "Tout",
                    name: "outputType",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Neg",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Real",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "Tout",
                    name: "outputType",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Prelu",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "alpha",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Relu",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Relu6",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Selu",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Sigmoid",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Sin",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Sinh",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Sqrt",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Rsqrt",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Square",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Tan",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Tanh",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Sign",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Round",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Expm1",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Log1p",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Reciprocal",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Softplus",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Asinh",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Acosh",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Atanh",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Erf",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Prod",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axes",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "keep_dims",
                    name: "keepDims",
                    type: "bool",
                    notSupported: !0
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LeakyRelu",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "alpha",
                    name: "alpha",
                    type: "number",
                    defaultValue: .2
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }]
        },
        dD = {
            __proto__: null,
            json: [{
                tfOpName: "EmptyTensorList",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "elementShape",
                    type: "shape"
                }, {
                    start: 1,
                    name: "maxNumElements",
                    type: "number"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "LoopCond",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "pred",
                    type: "tensor"
                }]
            }, {
                tfOpName: "Switch",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "data",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "pred",
                    type: "tensor"
                }]
            }, {
                tfOpName: "Merge",
                category: "control",
                inputs: [{
                    start: 0,
                    end: 0,
                    name: "tensors",
                    type: "tensors"
                }]
            }, {
                tfOpName: "Enter",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensor",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "frame_name",
                    name: "frameName",
                    type: "string"
                }, {
                    tfName: "is_constant",
                    name: "isConstant",
                    type: "bool"
                }]
            }, {
                tfOpName: "Exit",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensor",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "NextIteration",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensor",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "TensorArrayV3",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "size",
                    type: "number"
                }],
                attrs: [{
                    tfName: "dtype",
                    name: "dtype",
                    type: "dtype"
                }, {
                    tfName: "element_shape",
                    name: "elementShape",
                    type: "shape"
                }, {
                    tfName: "dynamic_size",
                    name: "dynamicSize",
                    type: "bool"
                }, {
                    tfName: "clear_after_read",
                    name: "clearAfterRead",
                    type: "bool"
                }, {
                    tfName: "identical_element_shapes",
                    name: "identicalElementShapes",
                    type: "bool"
                }, {
                    tfName: "tensor_array_name",
                    name: "name",
                    type: "string"
                }]
            }, {
                tfOpName: "TensorArrayWriteV3",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorArrayId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "index",
                    type: "number"
                }, {
                    start: 2,
                    name: "tensor",
                    type: "tensor"
                }, {
                    start: 3,
                    name: "flowIn",
                    type: "number"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "TensorArrayReadV3",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorArrayId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "index",
                    type: "number"
                }, {
                    start: 2,
                    name: "flowIn",
                    type: "number"
                }],
                attrs: [{
                    tfName: "dtype",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "TensorArrayGatherV3",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorArrayId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "indices",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "flowIn",
                    type: "number"
                }],
                attrs: [{
                    tfName: "dtype",
                    name: "dtype",
                    type: "dtype"
                }, {
                    tfName: "element_shape",
                    name: "elementShape",
                    type: "shape"
                }]
            }, {
                tfOpName: "TensorArrayScatterV3",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorArrayId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "indices",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "tensor",
                    type: "tensor"
                }, {
                    start: 3,
                    name: "flowIn",
                    type: "number"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorArrayConcatV3",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorArrayId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "flowIn",
                    type: "number"
                }],
                attrs: [{
                    tfName: "dtype",
                    name: "dtype",
                    type: "dtype"
                }, {
                    tfName: "element_shape_except0",
                    name: "elementShapeExcept0",
                    type: "shape",
                    notSupported: !0
                }]
            }, {
                tfOpName: "TensorArraySplitV3",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorArrayId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "tensor",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "lengths",
                    type: "number[]"
                }, {
                    start: 3,
                    name: "flowIn",
                    type: "number"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorArraySizeV3",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorArrayId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "flowIn",
                    type: "number"
                }]
            }, {
                tfOpName: "TensorArrayCloseV3",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorArrayId",
                    type: "tensor"
                }]
            }, {
                tfOpName: "StatelessIf",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "cond",
                    type: "tensor"
                }, {
                    start: 1,
                    end: 0,
                    name: "args",
                    type: "tensors"
                }],
                attrs: [{
                    tfName: "then_branch",
                    name: "thenBranch",
                    type: "func"
                }, {
                    tfName: "else_branch",
                    name: "elseBranch",
                    type: "func"
                }]
            }, {
                tfOpName: "If",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "cond",
                    type: "tensor"
                }, {
                    start: 1,
                    end: 0,
                    name: "args",
                    type: "tensors"
                }],
                attrs: [{
                    tfName: "then_branch",
                    name: "thenBranch",
                    type: "func"
                }, {
                    tfName: "else_branch",
                    name: "elseBranch",
                    type: "func"
                }]
            }, {
                tfOpName: "StatelessWhile",
                category: "control",
                inputs: [{
                    start: 0,
                    end: 0,
                    name: "args",
                    type: "tensors"
                }],
                attrs: [{
                    tfName: "cond",
                    name: "cond",
                    type: "func"
                }, {
                    tfName: "body",
                    name: "body",
                    type: "func"
                }]
            }, {
                tfOpName: "While",
                category: "control",
                inputs: [{
                    start: 0,
                    end: 0,
                    name: "args",
                    type: "tensors"
                }],
                attrs: [{
                    tfName: "cond",
                    name: "cond",
                    type: "func"
                }, {
                    tfName: "body",
                    name: "body",
                    type: "func"
                }]
            }, {
                tfOpName: "TensorListScatter",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensor",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "indices",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "elementShape",
                    type: "shape"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListScatterV2",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensor",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "indices",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "elementShape",
                    type: "shape"
                }, {
                    start: 3,
                    name: "numElements",
                    type: "number"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListGather",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorListId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "indices",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "elementShape",
                    type: "shape"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListGetItem",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorListId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "index",
                    type: "number"
                }, {
                    start: 2,
                    name: "elementShape",
                    type: "shape"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListSetItem",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorListId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "index",
                    type: "number"
                }, {
                    start: 2,
                    name: "tensor",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListReserve",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "elementShape",
                    type: "shape"
                }, {
                    start: 1,
                    name: "numElements",
                    type: "number"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListFromTensor",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensor",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "elementShape",
                    type: "shape"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListStack",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorListId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "elementShape",
                    type: "shape"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }, {
                    tfName: "num_elements",
                    name: "numElements",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListSplit",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensor",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "elementShape",
                    type: "shape"
                }, {
                    start: 2,
                    name: "lengths",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListConcat",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorListId",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "element_shape",
                    name: "elementShape",
                    type: "shape"
                }, {
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListPopBack",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorListId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "elementShape",
                    type: "shape"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListPushBack",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorListId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "tensor",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }]
        },
        mD = {
            __proto__: null,
            json: [{
                tfOpName: "AvgPool",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    notSupported: !0
                }, {
                    tfName: "ksize",
                    name: "kernelSize",
                    type: "number[]"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "MaxPool",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    notSupported: !0
                }, {
                    tfName: "ksize",
                    name: "kernelSize",
                    type: "number[]"
                }, {
                    tfName: "explicit_paddings",
                    name: "explicitPaddings",
                    type: "number[]",
                    defaultValue: [],
                    notSupported: !0
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "MaxPoolWithArgmax",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "ksize",
                    name: "kernelSize",
                    type: "number[]"
                }, {
                    tfName: "include_batch_in_index",
                    name: "includeBatchInIndex",
                    type: "bool"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "AvgPool3D",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    notSupported: !0
                }, {
                    tfName: "ksize",
                    name: "kernelSize",
                    type: "number[]"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "MaxPool3D",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    notSupported: !0
                }, {
                    tfName: "ksize",
                    name: "kernelSize",
                    type: "number[]"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Conv1D",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "filter",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "stride",
                    name: "stride",
                    type: "number"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    defaultValue: "NWC"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "dilation",
                    name: "dilation",
                    type: "number",
                    defaultValue: 1
                }]
            }, {
                tfOpName: "Conv2D",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "filter",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "useCudnnOnGpu",
                    name: "useCudnnOnGpu",
                    type: "bool"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    defaultValue: "NHWC"
                }, {
                    tfName: "explicit_paddings",
                    name: "explicitPaddings",
                    type: "number[]",
                    defaultValue: []
                }, {
                    tfName: "dilations",
                    name: "dilations",
                    type: "number[]"
                }]
            }, {
                tfOpName: "_FusedConv2D",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "filter",
                    type: "tensor"
                }, {
                    start: 2,
                    end: 0,
                    name: "args",
                    type: "tensors"
                }],
                attrs: [{
                    tfName: "num_args",
                    name: "numArgs",
                    type: "number"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "explicit_paddings",
                    name: "explicitPaddings",
                    type: "number[]",
                    defaultValue: []
                }, {
                    tfName: "use_cudnn_on_gpu",
                    name: "useCudnnOnGpu",
                    type: "bool",
                    defaultValue: !0
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    defaultValue: "NHWC"
                }, {
                    tfName: "dilations",
                    name: "dilations",
                    type: "number[]",
                    defaultValue: [1, 1, 1, 1]
                }, {
                    tfName: "fused_ops",
                    name: "fusedOps",
                    type: "string[]",
                    defaultValue: []
                }, {
                    tfName: "epsilon",
                    name: "epsilon",
                    type: "number",
                    defaultValue: 1e-4
                }, {
                    tfName: "leakyrelu_alpha",
                    name: "leakyreluAlpha",
                    type: "number"
                }]
            }, {
                tfOpName: "Conv2DBackpropInput",
                category: "convolution",
                inputs: [{
                    start: 2,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "filter",
                    type: "tensor"
                }, {
                    start: 0,
                    name: "outputShape",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    notSupported: !0
                }, {
                    tfName: "explicit_paddings",
                    name: "explicitPaddings",
                    type: "number[]",
                    defaultValue: []
                }, {
                    tfName: "dilations",
                    name: "dilations",
                    type: "number[]",
                    notSupported: !0
                }]
            }, {
                tfOpName: "DepthwiseConv2d",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "input",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "filter",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    defaultValue: "NHWC"
                }, {
                    tfName: "explicit_paddings",
                    name: "explicitPaddings",
                    type: "number[]",
                    defaultValue: []
                }, {
                    tfName: "dilations",
                    name: "dilations",
                    type: "number[]"
                }]
            }, {
                tfOpName: "DepthwiseConv2dNative",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "input",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "filter",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    defaultValue: "NHWC"
                }, {
                    tfName: "explicit_paddings",
                    name: "explicitPaddings",
                    type: "number[]",
                    defaultValue: []
                }, {
                    tfName: "dilations",
                    name: "dilations",
                    type: "number[]"
                }]
            }, {
                tfOpName: "FusedDepthwiseConv2dNative",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "filter",
                    type: "tensor"
                }, {
                    start: 2,
                    end: 0,
                    name: "args",
                    type: "tensors"
                }],
                attrs: [{
                    tfName: "num_args",
                    name: "numArgs",
                    type: "number"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    defaultValue: "NHWC"
                }, {
                    tfName: "dilations",
                    name: "dilations",
                    type: "number[]",
                    defaultValue: [1, 1, 1, 1]
                }, {
                    tfName: "fused_ops",
                    name: "fusedOps",
                    type: "string[]",
                    defaultValue: []
                }, {
                    tfName: "explicit_paddings",
                    name: "explicitPaddings",
                    type: "number[]",
                    defaultValue: []
                }]
            }, {
                tfOpName: "Conv3D",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "filter",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    defaultValue: "NHWC"
                }, {
                    tfName: "dilations",
                    name: "dilations",
                    type: "number[]"
                }]
            }, {
                tfOpName: "Dilation2D",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "filter",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "rates",
                    name: "dilations",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }]
            }]
        },
        vD = {
            __proto__: null,
            json: [{
                tfOpName: "Fill",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "shape",
                    type: "number[]"
                }, {
                    start: 1,
                    name: "value",
                    type: "number"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "LinSpace",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "start",
                    type: "number"
                }, {
                    start: 1,
                    name: "stop",
                    type: "number"
                }, {
                    start: 2,
                    name: "num",
                    type: "number"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "OneHot",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "indices",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "depth",
                    type: "number"
                }, {
                    start: 2,
                    name: "onValue",
                    type: "number",
                    defaultValue: 1
                }, {
                    start: 3,
                    name: "offValue",
                    type: "number",
                    defaultValue: 0
                }],
                attrs: [{
                    tfName: "axis",
                    name: "axis",
                    type: "number",
                    notSupported: !0
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Ones",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "shape",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "OnesLike",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "dtype",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "RandomUniform",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "shape",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "minval",
                    name: "minval",
                    type: "number",
                    defaultValue: 0
                }, {
                    tfName: "maxval",
                    name: "maxval",
                    type: "number",
                    defaultValue: 1
                }, {
                    tfName: "dtype",
                    name: "dtype",
                    type: "dtype"
                }, {
                    tfName: "seed",
                    name: "seed",
                    type: "number",
                    defaultValue: 0
                }, {
                    tfName: "seed2",
                    name: "seed2",
                    type: "number",
                    defaultValue: 0,
                    notSupported: !0
                }, {
                    tfName: "T",
                    name: "T",
                    type: "number",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Range",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "start",
                    type: "number"
                }, {
                    start: 1,
                    name: "stop",
                    type: "number"
                }, {
                    start: 2,
                    name: "step",
                    type: "number",
                    defaultValue: 0
                }],
                attrs: [{
                    tfName: "Tidx",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TruncatedNormal",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "shape",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "means",
                    name: "mean",
                    type: "number",
                    defaultValue: 0
                }, {
                    tfName: "stddev",
                    name: "stdDev",
                    type: "number",
                    defaultValue: 1
                }, {
                    tfName: "seed",
                    name: "seed",
                    type: "number"
                }, {
                    tfName: "seed2",
                    name: "seed2",
                    type: "number",
                    defaultValue: 0,
                    notSupported: !0
                }, {
                    tfName: "dtype",
                    name: "dtype",
                    type: "dtype"
                }, {
                    tfName: "T",
                    name: "T",
                    type: "number",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Zeros",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "shape",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "ZerosLike",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "Multinomial",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "logits",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "numSamples",
                    type: "number"
                }],
                attrs: [{
                    tfName: "seed",
                    name: "seed",
                    type: "number"
                }, {
                    tfName: "seed2",
                    name: "seed2",
                    type: "number"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype"
                }, {
                    tfName: "output_dtype",
                    name: "output_dtype",
                    type: "dtype"
                }]
            }]
        },
        gD = {
            __proto__: null,
            json: [{
                tfOpName: "NonMaxSuppressionV2",
                category: "dynamic",
                inputs: [{
                    start: 0,
                    name: "boxes",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "scores",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "maxOutputSize",
                    type: "number"
                }, {
                    start: 3,
                    name: "iouThreshold",
                    type: "number"
                }]
            }, {
                tfOpName: "NonMaxSuppressionV3",
                category: "dynamic",
                inputs: [{
                    start: 0,
                    name: "boxes",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "scores",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "maxOutputSize",
                    type: "number"
                }, {
                    start: 3,
                    name: "iouThreshold",
                    type: "number"
                }, {
                    start: 4,
                    name: "scoreThreshold",
                    type: "number"
                }]
            }, {
                tfOpName: "NonMaxSuppressionV4",
                category: "dynamic",
                inputs: [{
                    start: 0,
                    name: "boxes",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "scores",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "maxOutputSize",
                    type: "number"
                }, {
                    start: 3,
                    name: "iouThreshold",
                    type: "number"
                }, {
                    start: 4,
                    name: "scoreThreshold",
                    type: "number"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "T_threshold",
                    name: "threshold",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "pad_to_max_output_size",
                    name: "padToMaxOutputSize",
                    type: "bool"
                }]
            }, {
                tfOpName: "NonMaxSuppressionV5",
                category: "dynamic",
                inputs: [{
                    start: 0,
                    name: "boxes",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "scores",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "maxOutputSize",
                    type: "number"
                }, {
                    start: 3,
                    name: "iouThreshold",
                    type: "number"
                }, {
                    start: 4,
                    name: "scoreThreshold",
                    type: "number"
                }, {
                    start: 5,
                    name: "softNmsSigma",
                    type: "number"
                }]
            }, {
                tfOpName: "Where",
                category: "dynamic",
                inputs: [{
                    start: 0,
                    name: "condition",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "ListDiff",
                category: "dynamic",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "y",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }]
        },
        yD = {
            __proto__: null,
            json: [{
                tfOpName: "TopKV2",
                category: "evaluation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "k",
                    type: "number"
                }],
                attrs: [{
                    tfName: "sorted",
                    name: "sorted",
                    type: "bool"
                }]
            }, {
                tfOpName: "Unique",
                category: "evaluation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "UniqueV2",
                category: "evaluation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number"
                }]
            }]
        },
        bD = {
            __proto__: null,
            json: [{
                tfOpName: "PlaceholderWithDefault",
                category: "graph",
                inputs: [{
                    start: 0,
                    name: "default",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "shape",
                    name: "shape",
                    type: "shape"
                }, {
                    tfName: "dtype",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "Placeholder",
                category: "graph",
                attrs: [{
                    tfName: "shape",
                    name: "shape",
                    type: "shape"
                }, {
                    tfName: "dtype",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "Const",
                category: "graph"
            }, {
                tfOpName: "Identity",
                category: "graph",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "IdentityN",
                category: "graph",
                inputs: [{
                    start: 0,
                    end: 0,
                    name: "x",
                    type: "tensors"
                }]
            }, {
                tfOpName: "Snapshot",
                category: "graph",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "Rank",
                category: "graph",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "Size",
                category: "graph",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "Shape",
                category: "graph",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "ShapeN",
                category: "graph",
                inputs: [{
                    start: 0,
                    end: 0,
                    name: "x",
                    type: "tensors"
                }]
            }, {
                tfOpName: "Print",
                category: "graph",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "data",
                    type: "tensors"
                }],
                attrs: [{
                    tfName: "message",
                    name: "message",
                    type: "string"
                }, {
                    tfName: "first_n",
                    name: "firstN",
                    type: "number",
                    notSupported: !0
                }, {
                    tfName: "summarize",
                    name: "summarize",
                    type: "number",
                    defaultValue: 3
                }]
            }, {
                tfOpName: "NoOp",
                category: "graph",
                inputs: []
            }, {
                tfOpName: "StopGradient",
                category: "graph",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "FakeQuantWithMinMaxVars",
                category: "graph",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "min",
                    name: "min",
                    type: "number"
                }, {
                    tfName: "max",
                    name: "max",
                    type: "number"
                }]
            }]
        },
        xD = {
            __proto__: null,
            json: [{
                tfOpName: "HashTable",
                category: "hash_table",
                inputs: [],
                attrs: [{
                    tfName: "shared_name",
                    name: "sharedName",
                    type: "string"
                }, {
                    tfName: "use_node_name_sharing",
                    name: "useNodeNameSharing",
                    type: "bool"
                }, {
                    tfName: "key_dtype",
                    name: "keyDType",
                    type: "dtype"
                }, {
                    tfName: "value_dtype",
                    name: "valueDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "HashTableV2",
                category: "hash_table",
                inputs: [],
                attrs: [{
                    tfName: "shared_name",
                    name: "sharedName",
                    type: "string"
                }, {
                    tfName: "use_node_name_sharing",
                    name: "useNodeNameSharing",
                    type: "bool"
                }, {
                    tfName: "key_dtype",
                    name: "keyDType",
                    type: "dtype"
                }, {
                    tfName: "value_dtype",
                    name: "valueDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "LookupTableImport",
                category: "hash_table",
                inputs: [{
                    start: 0,
                    name: "tableHandle",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "keys",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "values",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "Tin",
                    name: "tIn",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "Tout",
                    name: "tOut",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LookupTableImportV2",
                category: "hash_table",
                inputs: [{
                    start: 0,
                    name: "tableHandle",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "keys",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "values",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "Tin",
                    name: "tIn",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "Tout",
                    name: "tOut",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LookupTableFind",
                category: "hash_table",
                inputs: [{
                    start: 0,
                    name: "tableHandle",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "keys",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "defaultValue",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "Tin",
                    name: "tIn",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "Tout",
                    name: "tOut",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LookupTableFindV2",
                category: "hash_table",
                inputs: [{
                    start: 0,
                    name: "tableHandle",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "keys",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "defaultValue",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "Tin",
                    name: "tIn",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "Tout",
                    name: "tOut",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LookupTableSize",
                category: "hash_table",
                inputs: [{
                    start: 0,
                    name: "tableHandle",
                    type: "tensor"
                }]
            }, {
                tfOpName: "LookupTableSizeV2",
                category: "hash_table",
                inputs: [{
                    start: 0,
                    name: "tableHandle",
                    type: "tensor"
                }]
            }]
        },
        wD = {
            __proto__: null,
            json: [{
                tfOpName: "ResizeBilinear",
                category: "image",
                inputs: [{
                    start: 0,
                    name: "images",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "size",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "align_corners",
                    name: "alignCorners",
                    type: "bool"
                }, {
                    tfName: "half_pixel_centers",
                    name: "halfPixelCenters",
                    type: "bool"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "ResizeNearestNeighbor",
                category: "image",
                inputs: [{
                    start: 0,
                    name: "images",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "size",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "align_corners",
                    name: "alignCorners",
                    type: "bool"
                }, {
                    tfName: "half_pixel_centers",
                    name: "halfPixelCenters",
                    type: "bool"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "CropAndResize",
                category: "image",
                inputs: [{
                    start: 0,
                    name: "image",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "boxes",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "boxInd",
                    type: "tensor"
                }, {
                    start: 3,
                    name: "cropSize",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "method",
                    name: "method",
                    type: "string"
                }, {
                    tfName: "extrapolation_value",
                    name: "extrapolationValue",
                    type: "number"
                }]
            }]
        },
        kD = {
            __proto__: null,
            json: [{
                tfOpName: "Equal",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "NotEqual",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Greater",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "GreaterEqual",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Less",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LessEqual",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LogicalAnd",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LogicalNot",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LogicalOr",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Select",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "condition",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "SelectV2",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "condition",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }]
        },
        ND = {
            __proto__: null,
            json: [{
                tfOpName: "_FusedMatMul",
                category: "matrices",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }, {
                    start: 2,
                    end: 0,
                    name: "args",
                    type: "tensors"
                }],
                attrs: [{
                    tfName: "num_args",
                    name: "numArgs",
                    type: "number"
                }, {
                    tfName: "fused_ops",
                    name: "fusedOps",
                    type: "string[]",
                    defaultValue: []
                }, {
                    tfName: "epsilon",
                    name: "epsilon",
                    type: "number",
                    defaultValue: 1e-4
                }, {
                    tfName: "transpose_a",
                    name: "transposeA",
                    type: "bool",
                    defaultValue: !1
                }, {
                    tfName: "transpose_b",
                    name: "transposeB",
                    type: "bool",
                    defaultValue: !1
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "MatMul",
                category: "matrices",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "transpose_a",
                    name: "transposeA",
                    type: "bool",
                    defaultValue: !1
                }, {
                    tfName: "transpose_b",
                    name: "transposeB",
                    type: "bool",
                    defaultValue: !1
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "BatchMatMul",
                category: "matrices",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "adj_x",
                    name: "transposeA",
                    type: "bool",
                    defaultValue: !1
                }, {
                    tfName: "adj_y",
                    name: "transposeB",
                    type: "bool",
                    defaultValue: !1
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "BatchMatMulV2",
                category: "matrices",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "adj_x",
                    name: "transposeA",
                    type: "bool",
                    defaultValue: !1
                }, {
                    tfName: "adj_y",
                    name: "transposeB",
                    type: "bool",
                    defaultValue: !1
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Transpose",
                category: "matrices",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "perm",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }]
        },
        ID = {
            __proto__: null,
            json: [{
                tfOpName: "FusedBatchNorm",
                category: "normalization",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "scale",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "offset",
                    type: "tensor"
                }, {
                    start: 3,
                    name: "mean",
                    type: "tensor"
                }, {
                    start: 4,
                    name: "variance",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "epsilon",
                    name: "epsilon",
                    type: "number",
                    defaultValue: .001
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    notSupported: !0
                }]
            }, {
                tfOpName: "FusedBatchNormV2",
                category: "normalization",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "scale",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "offset",
                    type: "tensor"
                }, {
                    start: 3,
                    name: "mean",
                    type: "tensor"
                }, {
                    start: 4,
                    name: "variance",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "epsilon",
                    name: "epsilon",
                    type: "number",
                    defaultValue: .001
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    notSupported: !0
                }]
            }, {
                tfOpName: "FusedBatchNormV3",
                category: "normalization",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "scale",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "offset",
                    type: "tensor"
                }, {
                    start: 3,
                    name: "mean",
                    type: "tensor"
                }, {
                    start: 4,
                    name: "variance",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "epsilon",
                    name: "epsilon",
                    type: "number",
                    defaultValue: .001
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LRN",
                category: "normalization",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "depth_radius",
                    name: "radius",
                    type: "number",
                    defaultValue: 5
                }, {
                    tfName: "bias",
                    name: "bias",
                    type: "number",
                    defaultValue: 1
                }, {
                    tfName: "alpha",
                    name: "alpha",
                    type: "number",
                    defaultValue: 1
                }, {
                    tfName: "beta",
                    name: "beta",
                    type: "number",
                    defaultValue: .5
                }]
            }, {
                tfOpName: "Softmax",
                category: "normalization",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "LogSoftmax",
                category: "normalization",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "SparseToDense",
                category: "normalization",
                inputs: [{
                    start: 0,
                    name: "sparseIndices",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "outputShape",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "sparseValues",
                    type: "tensor"
                }, {
                    start: 3,
                    name: "defaultValue",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "validate_indices",
                    name: "validateIndices",
                    type: "bool",
                    defaultValue: !0,
                    notSupported: !0
                }]
            }]
        },
        SD = {
            __proto__: null,
            json: [{
                tfOpName: "Bincount",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "size",
                    type: "number"
                }, {
                    start: 2,
                    name: "weights",
                    type: "tensor"
                }]
            }, {
                tfOpName: "DenseBincount",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "size",
                    type: "number"
                }, {
                    start: 2,
                    name: "weights",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "binary_output",
                    name: "binaryOutput",
                    type: "bool"
                }]
            }, {
                tfOpName: "Max",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "keep_dims",
                    name: "keepDims",
                    type: "bool"
                }]
            }, {
                tfOpName: "Mean",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "keep_dims",
                    name: "keepDims",
                    type: "bool"
                }]
            }, {
                tfOpName: "Min",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "keep_dims",
                    name: "keepDims",
                    type: "bool"
                }]
            }, {
                tfOpName: "Sum",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "keep_dims",
                    name: "keepDims",
                    type: "bool"
                }]
            }, {
                tfOpName: "All",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "keep_dims",
                    name: "keepDims",
                    type: "bool"
                }]
            }, {
                tfOpName: "Any",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "keep_dims",
                    name: "keepDims",
                    type: "bool"
                }]
            }, {
                tfOpName: "ArgMax",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number"
                }]
            }, {
                tfOpName: "ArgMin",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number"
                }]
            }, {
                tfOpName: "Prod",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "keep_dims",
                    name: "keepDims",
                    type: "bool"
                }]
            }, {
                tfOpName: "Cumsum",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number"
                }],
                attrs: [{
                    tfName: "exclusive",
                    name: "exclusive",
                    type: "bool"
                }, {
                    tfName: "reverse",
                    name: "reverse",
                    type: "bool"
                }]
            }]
        },
        TD = {
            __proto__: null,
            json: [{
                tfOpName: "ConcatV2",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    end: -1,
                    name: "tensors",
                    type: "tensors"
                }, {
                    start: -1,
                    name: "axis",
                    type: "number"
                }],
                attrs: [{
                    tfName: "N",
                    name: "n",
                    type: "number",
                    defaultValue: 2
                }]
            }, {
                tfOpName: "Concat",
                category: "slice_join",
                inputs: [{
                    start: 1,
                    end: 0,
                    name: "tensors",
                    type: "tensors"
                }, {
                    start: 0,
                    name: "axis",
                    type: "number"
                }],
                attrs: [{
                    tfName: "N",
                    name: "n",
                    type: "number",
                    defaultValue: 2
                }]
            }, {
                tfOpName: "GatherV2",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "indices",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "axis",
                    type: "number",
                    defaultValue: 0
                }],
                attrs: [{
                    tfName: "batch_dims",
                    name: "batchDims",
                    type: "number",
                    defaultValue: 0
                }]
            }, {
                tfOpName: "Gather",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "indices",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "validate_indices",
                    name: "validateIndices",
                    type: "bool",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Reverse",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "dims",
                    type: "bool[]"
                }]
            }, {
                tfOpName: "ReverseV2",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number[]"
                }]
            }, {
                tfOpName: "Slice",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "begin",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "size",
                    type: "number[]"
                }]
            }, {
                tfOpName: "StridedSlice",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "begin",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "end",
                    type: "number[]"
                }, {
                    start: 3,
                    name: "strides",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "begin_mask",
                    name: "beginMask",
                    type: "number",
                    defaultValue: 0
                }, {
                    tfName: "end_mask",
                    name: "endMask",
                    type: "number",
                    defaultValue: 0
                }, {
                    tfName: "new_axis_mask",
                    name: "newAxisMask",
                    type: "number",
                    defaultValue: 0
                }, {
                    tfName: "ellipsis_mask",
                    name: "ellipsisMask",
                    type: "number",
                    defaultValue: 0
                }, {
                    tfName: "shrink_axis_mask",
                    name: "shrinkAxisMask",
                    type: "number",
                    defaultValue: 0
                }]
            }, {
                tfOpName: "Pack",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    end: 0,
                    name: "tensors",
                    type: "tensors"
                }],
                attrs: [{
                    tfName: "axis",
                    name: "axis",
                    type: "number",
                    defaultValue: 0
                }]
            }, {
                tfOpName: "Unpack",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "tensor",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "axis",
                    name: "axis",
                    type: "number",
                    defaultValue: 0
                }, {
                    tfName: "num",
                    name: "num",
                    type: "number",
                    defaultValue: 0,
                    notSupported: !0
                }]
            }, {
                tfOpName: "Tile",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "reps",
                    type: "number[]"
                }]
            }, {
                tfOpName: "Split",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "axis",
                    type: "number",
                    defaultValue: 0
                }, {
                    start: 1,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "num_split",
                    name: "numOrSizeSplits",
                    type: "number",
                    defaultValue: 1
                }]
            }, {
                tfOpName: "SplitV",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "numOrSizeSplits",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "axis",
                    type: "number",
                    defaultValue: 0
                }]
            }, {
                tfOpName: "ScatterNd",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "indices",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "values",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "shape",
                    type: "number[]"
                }]
            }, {
                tfOpName: "GatherNd",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "indices",
                    type: "tensor"
                }]
            }, {
                tfOpName: "SparseToDense",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "sparseIndices",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "outputShape",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "sparseValues",
                    type: "tensor"
                }, {
                    start: 3,
                    name: "defaultValue",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "validate_indices",
                    name: "validateIndices",
                    type: "bool",
                    defaultValue: !1,
                    notSupported: !0
                }]
            }]
        },
        CD = {
            __proto__: null,
            json: [{
                tfOpName: "FFT",
                category: "spectral",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "IFFT",
                category: "spectral",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "RFFT",
                category: "spectral",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "fft_length",
                    type: "number",
                    notSupported: !0
                }]
            }, {
                tfOpName: "IRFFT",
                category: "spectral",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "fft_length",
                    type: "number",
                    notSupported: !0
                }]
            }]
        },
        ED = {
            __proto__: null,
            json: [{
                tfOpName: "Cast",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "SrcT",
                    name: "sdtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "DstT",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "ExpandDims",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number"
                }]
            }, {
                tfOpName: "MirrorPad",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "padding",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "mode",
                    name: "mode",
                    type: "string"
                }]
            }, {
                tfOpName: "Pad",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "padding",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "constant_value",
                    name: "constantValue",
                    type: "number",
                    defaultValue: 0
                }]
            }, {
                tfOpName: "PadV2",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "padding",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "constantValue",
                    type: "number",
                    defaultValue: 0
                }]
            }, {
                tfOpName: "Reshape",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "shape",
                    type: "number[]"
                }]
            }, {
                tfOpName: "Squeeze",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "axis",
                    tfDeprecatedName: "squeeze_dims",
                    name: "axis",
                    type: "number[]"
                }]
            }, {
                tfOpName: "SpaceToBatchND",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "blockShape",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "paddings",
                    type: "number[]"
                }]
            }, {
                tfOpName: "BatchToSpaceND",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "blockShape",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "crops",
                    type: "number[]"
                }]
            }, {
                tfOpName: "DepthToSpace",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "block_size",
                    name: "blockSize",
                    type: "number"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string"
                }]
            }, {
                tfOpName: "BroadcastTo",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "shape",
                    type: "number[]"
                }],
                attrs: []
            }]
        },
        RD = function () {
            function e() {
                var e, t = [hD, fD, dD, mD, vD, gD, yD, kD, wD, bD, ND, ID, SD, TD, CD, ED, xD],
                    n = (e = []).concat.apply(e, t.map(function (e) {
                        return e.json
                    }));
                this.opMappers = n.reduce(function (e, t) {
                    return e[t.tfOpName] = t, e
                }, {})
            }
            Wm(e, null, [{
                key: "Instance",
                get: function () {
                    return this._instance || (this._instance = new this)
                }
            }]);
            var t = e.prototype;
            return t.transformGraph = function (e, t) {
                var n = this;
                void 0 === t && (t = {});
                var r = e.node,
                    a = [],
                    i = [],
                    o = [],
                    s = r.reduce(function (e, t) {
                        return e[t.name] = n.mapNode(t), t.op.startsWith("Placeholder") ? a.push(e[t.name]) : "Const" === t.op ? i.push(e[t.name]) : null != t.input && 0 !== t.input.length || o.push(e[t.name]), e
                    }, {}),
                    u = [],
                    l = [],
                    c = {},
                    p = {};
                null != t && (c = this.mapSignatureEntries(t.inputs), p = this.mapSignatureEntries(t.outputs));
                var h = Object.keys(s);
                h.forEach(function (e) {
                    var t = s[e];
                    t.inputNames.forEach(function (e) {
                        var n = sD(e)[0];
                        t.inputs.push(s[n]), s[n].children.push(t)
                    })
                }), 0 === Object.keys(p).length ? h.forEach(function (e) {
                    var t = s[e];
                    0 === t.children.length && l.push(t)
                }) : Object.keys(p).forEach(function (e) {
                    var t = sD(e)[0],
                        n = s[t];
                    null != n && (n.signatureKey = p[e], l.push(n))
                }), Object.keys(c).length > 0 ? Object.keys(c).forEach(function (e) {
                    var t = sD(e)[0],
                        n = s[t];
                    n && (n.signatureKey = c[e], u.push(n))
                }) : u = a;
                var f = {};
                null != e.library && null != e.library.function && (f = e.library.function.reduce(function (e, t) {
                    return e[t.signature.name] = n.mapFunction(t), e
                }, {}));
                var d = {
                    nodes: s,
                    inputs: u,
                    outputs: l,
                    weights: i,
                    placeholders: a,
                    signature: t,
                    functions: f
                };
                return o.length > 0 && (d.initNodes = o), d
            }, t.mapSignatureEntries = function (e) {
                return Object.keys(e || {}).reduce(function (t, n) {
                    return t[e[n].name] = n, t
                }, {})
            }, t.mapNode = function (e) {
                var t = aD(e.op) || this.opMappers[e.op] || {};
                null == e.attr && (e.attr = {});
                var n = {
                    name: e.name,
                    op: e.op,
                    category: t.category,
                    inputNames: (e.input || []).map(function (e) {
                        return e.startsWith("^") ? e.substr(1) : e
                    }),
                    inputs: [],
                    children: [],
                    inputParams: {},
                    attrParams: {},
                    rawAttrs: e.attr
                };
                return null != t.inputs && (n.inputParams = t.inputs.reduce(function (e, t) {
                    return e[t.name] = {
                        type: t.type,
                        inputIndexStart: t.start,
                        inputIndexEnd: t.end
                    }, e
                }, {})), null != t.attrs && (n.attrParams = t.attrs.reduce(function (t, n) {
                    var r = n.type,
                        a = void 0;
                    switch (n.type) {
                        case "string":
                            void 0 === (a = FD(e.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (a = FD(e.attr, n.tfDeprecatedName, n.defaultValue));
                            break;
                        case "string[]":
                            void 0 === (a = VD(e.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (a = VD(e.attr, n.tfDeprecatedName, n.defaultValue));
                            break;
                        case "number":
                            void 0 === (a = DD(e.attr, n.tfName, n.defaultValue || 0)) && n.tfDeprecatedName && (a = DD(e.attr, n.tfDeprecatedName, n.defaultValue));
                            break;
                        case "number[]":
                            void 0 === (a = WD(e.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (a = WD(e.attr, n.tfDeprecatedName, n.defaultValue));
                            break;
                        case "bool":
                            void 0 === (a = _D(e.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (a = _D(e.attr, n.tfDeprecatedName, n.defaultValue));
                            break;
                        case "bool[]":
                            void 0 === (a = GD(e.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (a = GD(e.attr, n.tfDeprecatedName, n.defaultValue));
                            break;
                        case "shape":
                            void 0 === (a = BD(e.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (a = BD(e.attr, n.tfDeprecatedName, n.defaultValue));
                            break;
                        case "shape[]":
                            void 0 === (a = UD(e.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (a = UD(e.attr, n.tfDeprecatedName, n.defaultValue));
                            break;
                        case "dtype":
                            void 0 === (a = LD(e.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (a = LD(e.attr, n.tfDeprecatedName, n.defaultValue));
                            break;
                        case "dtype[]":
                            void 0 === (a = zD(e.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (a = zD(e.attr, n.tfDeprecatedName, n.defaultValue));
                            break;
                        case "func":
                            void 0 === (a = MD(e.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (a = MD(e.attr, n.tfDeprecatedName, n.defaultValue));
                            break;
                        case "tensor":
                        case "tensors":
                            break;
                        default:
                            throw new Error("Unsupported param type: " + n.type + " for op: " + e.op)
                    }
                    return t[n.name] = {
                        value: a,
                        type: r
                    }, t
                }, {})), n
            }, t.mapFunction = function (e) {
                var t = this,
                    n = e.nodeDef,
                    r = [],
                    a = {};
                null != n && (a = n.reduce(function (e, n) {
                    return e[n.name] = t.mapNode(n), "Const" === n.op && r.push(e[n.name]), e
                }, {}));
                var i = [],
                    o = [];
                e.signature.inputArg.forEach(function (e) {
                    var t = sD(e.name)[0],
                        n = {
                            name: t,
                            op: "Placeholder",
                            inputs: [],
                            inputNames: [],
                            category: "graph",
                            inputParams: {},
                            attrParams: {
                                dtype: {
                                    value: OD(e.type),
                                    type: "dtype"
                                }
                            },
                            children: []
                        };
                    n.signatureKey = e.name, i.push(n), a[t] = n
                }), Object.keys(a).forEach(function (e) {
                    var t = a[e];
                    t.inputNames.forEach(function (e) {
                        var n = sD(e)[0];
                        t.inputs.push(a[n]), a[n].children.push(t)
                    })
                });
                var s = e.ret;
                e.signature.outputArg.forEach(function (e) {
                    var t = sD(s[e.name]),
                        n = t[0],
                        r = t[1],
                        i = a[n];
                    null != i && (i.defaultOutput = r, o.push(i))
                });
                var u = this.mapArgsToSignature(e);
                return {
                    nodes: a,
                    inputs: i,
                    outputs: o,
                    weights: r,
                    placeholders: [],
                    signature: u
                }
            }, t.mapArgsToSignature = function (e) {
                var t = this;
                return {
                    methodName: e.signature.name,
                    inputs: e.signature.inputArg.reduce(function (e, n) {
                        return e[n.name] = t.mapArgToTensorInfo(n), e
                    }, {}),
                    outputs: e.signature.outputArg.reduce(function (n, r) {
                        return n[r.name] = t.mapArgToTensorInfo(r, e.ret), n
                    }, {})
                }
            }, t.mapArgToTensorInfo = function (e, t) {
                var n = e.name;
                return null != t && (n = t[n]), {
                    name: n,
                    dtype: e.type
                }
            }, e
        }();

    function AD(e, t) {
        var n = Array.isArray(e) ? String.fromCharCode.apply(null, e) : function (e) {
            var t = Wv().global;
            if (void 0 !== t.atob) return t.atob(e);
            if ("undefined" != typeof Buffer) return new Buffer(e, "base64").toString();
            throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")
        }(e);
        return t ? n : n.toLowerCase()
    }

    function FD(e, t, n, r) {
        void 0 === r && (r = !1);
        var a = e[t];
        return null != a ? AD(a.s, r) : n
    }

    function _D(e, t, n) {
        var r = e[t];
        return r ? r.b : n
    }

    function DD(e, t, n) {
        var r = e[t] || {},
            a = null != r.i ? r.i : null != r.f ? r.f : n;
        return "number" == typeof a ? a : parseInt(a, 10)
    }

    function OD(e) {
        switch ("string" == typeof e && (e = $_[e]), e) {
            case $_.DT_FLOAT:
                return "float32";
            case $_.DT_INT32:
            case $_.DT_INT64:
            case $_.DT_INT8:
            case $_.DT_UINT8:
                return "int32";
            case $_.DT_BOOL:
                return "bool";
            case $_.DT_DOUBLE:
                return "float32";
            case $_.DT_STRING:
                return "string";
            default:
                return null
        }
    }

    function MD(e, t, n) {
        var r = e[t];
        return r && r.func ? r.func.name : n
    }

    function LD(e, t, n) {
        var r = e[t];
        return r && r.type ? OD(r.type) : n
    }

    function zD(e, t, n) {
        var r = e[t];
        return r && r.list && r.list.type ? r.list.type.map(function (e) {
            return OD(e)
        }) : n
    }

    function PD(e) {
        if (!e.unknownRank) return null != e.dim ? e.dim.map(function (e) {
            return "number" == typeof e.size ? e.size : parseInt(e.size, 10)
        }) : []
    }

    function BD(e, t, n) {
        var r = e[t];
        return r && r.shape ? PD(r.shape) : n
    }

    function WD(e, t, n) {
        var r = e[t];
        return r ? ((r.list.f && r.list.f.length ? r.list.f : r.list.i) || []).map(function (e) {
            return "number" == typeof e ? e : parseInt(e, 10)
        }) : n
    }

    function VD(e, t, n, r) {
        void 0 === r && (r = !1);
        var a = e[t];
        return a && a.list && a.list.s ? a.list.s.map(function (e) {
            return AD(e, r)
        }) : n
    }

    function UD(e, t, n) {
        var r = e[t];
        return r && r.list && r.list.shape ? r.list.shape.map(function (e) {
            return PD(e)
        }) : n
    }

    function GD(e, t, n) {
        var r = e[t];
        return r && r.list && r.list.b ? r.list.b : n
    }
    var jD = function () {
        function e(e, t, n) {
            var r = this;
            this.node = e, this.tensorMap = t, this.context = n, this.inputs = [], this.attrs = {}, this.inputs = e.inputNames.map(function (e) {
                return r.getInput(e)
            }), null != e.rawAttrs && (this.attrs = Object.keys(e.rawAttrs).reduce(function (e, t) {
                return e[t] = r.getAttr(t), e
            }, {}))
        }
        var t = e.prototype;
        return t.getInput = function (e) {
            return oD(e, this.tensorMap, this.context)
        }, t.getAttr = function (e, t) {
            var n = this.node.rawAttrs[e];
            if (null != n.tensor) return oD(e, this.tensorMap, this.context);
            if (null != n.i || null != n.f) return DD(this.node.rawAttrs, e, t);
            if (null != n.s) return FD(this.node.rawAttrs, e, t);
            if (null != n.b) return _D(this.node.rawAttrs, e, t);
            if (null != n.shape) return BD(this.node.rawAttrs, e, t);
            if (null != n.type) return LD(this.node.rawAttrs, e, t);
            if (null != n.list) {
                if (null != n.list.i || null != n.list.f) return WD(this.node.rawAttrs, e, t);
                if (null != n.list.s) return VD(this.node.rawAttrs, e, t);
                if (null != n.list.shape) return UD(this.node.rawAttrs, e, t);
                if (null != n.list.b) return GD(this.node.rawAttrs, e, t);
                if (null != n.list.type) return zD(this.node.rawAttrs, e, t)
            }
            return t
        }, e
    }();

    function HD(e, t, n) {
        if (void 0 === n && (n = ""), "number" != typeof e && "number" != typeof t) {
            nv(e.length === t.length, function () {
                return n + " Shapes " + e + " and " + t + " must match"
            });
            for (var r = 0; r < e.length; r++) {
                var a = e[r],
                    i = t[r];
                nv(a < 0 || i < 0 || a === i, function () {
                    return n + " Shapes " + e + " and " + t + " must match"
                })
            }
        }
    }

    function qD(e) {
        return "number" != typeof e && !e.some(function (e) {
            return e < 0
        })
    }

    function KD(e, t, n) {
        var r = XD(e, n),
            a = !qD(r);
        if (a && 0 === t.length) throw new Error("Tried to calculate elements of an empty list with non-fully-defined elementShape: " + r);
        if (a && t.forEach(function (e) {
                r = XD(e.shape, r)
            }), !qD(r)) throw new Error("Non-fully-defined elementShape: " + r);
        return r
    }

    function XD(e, t) {
        if ("number" == typeof e) return t;
        if ("number" == typeof t) return e;
        if (e.length !== t.length) throw new Error("Incompatible ranks during merge: " + e + " vs. " + t);
        for (var n = [], r = 0; r < e.length; ++r) {
            var a = e[r],
                i = t[r];
            if (a >= 0 && i >= 0 && a !== i) throw new Error("Incompatible shape during merge: " + e + " vs. " + t);
            n[r] = a >= 0 ? a : i
        }
        return n
    }
    var YD = function () {
            function e(e, t, n, r, a, i, o) {
                this.name = e, this.dtype = t, this.maxSize = n, this.elementShape = r, this.identicalElementShapes = a, this.dynamicSize = i, this.clearAfterRead = o, this.tensors = [], this.closed_ = !1, this.idTensor = wN(0), ix(this.idTensor)
            }
            var t = e.prototype;
            return t.clearAndClose = function (e) {
                this.tensors.forEach(function (t) {
                    null != e && e.has(t.tensor.id) || t.tensor.dispose()
                }), this.tensors = [], this.closed_ = !0, this.idTensor.dispose()
            }, t.size = function () {
                return this.tensors.length
            }, t.read = function (e) {
                if (this.closed_) throw new Error("TensorArray " + this.name + " has already been closed.");
                if (e < 0 || e >= this.size()) throw new Error("Tried to read from index " + e + ", but array size is: " + this.size());
                var t = this.tensors[e];
                if (t.cleared) throw new Error("TensorArray " + this.name + ": Could not read index " + e + " twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).");
                return this.clearAfterRead && (t.cleared = !0), t.read = !0, t.tensor
            }, t.readMany = function (e) {
                var t = this;
                return e.map(function (e) {
                    return t.read(e)
                })
            }, t.write = function (e, t) {
                if (this.closed_) throw new Error("TensorArray " + this.name + " has already been closed.");
                if (e < 0 || !this.dynamicSize && e >= this.maxSize) throw new Error("Tried to write to index " + e + ", but array is not resizeable and size is: " + this.maxSize);
                var n = this.tensors[e] || {};
                if (t.dtype !== this.dtype) throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + e + ",\n          because the value dtype is " + t.dtype + ", but TensorArray dtype is " + this.dtype + ".");
                if (0 !== this.size() || null != this.elementShape && 0 !== this.elementShape.length || (this.elementShape = t.shape), HD(this.elementShape, t.shape, "TensorArray " + this.name + ": Could not write to TensorArray index " + e + "."), n.read) throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + e + ", because it has already been read.");
                if (n.written) throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + e + ", because it has already been written.");
                n.tensor = t, ix(t), n.written = !0, this.tensors[e] = n
            }, t.writeMany = function (e, t) {
                var n = this;
                if (e.length !== t.length) throw new Error("TensorArray " + this.name + ": could not write multiple tensors,because the index size: " + e.length + " is not the same as tensors size: " + t.length + ".");
                e.forEach(function (e, r) {
                    return n.write(e, t[r])
                })
            }, t.gather = function (e, t) {
                if (t && t !== this.dtype) throw new Error("TensorArray dtype is " + this.dtype + " but gather requested dtype " + t);
                if (e) e = e.slice(0, this.size());
                else {
                    e = [];
                    for (var n = 0; n < this.size(); n++) e.push(n)
                }
                if (0 === e.length) return ny([], [0].concat(this.elementShape));
                var r = this.readMany(e);
                return HD(this.elementShape, r[0].shape, "TensorArray shape mismatch: "), UN(r, 0)
            }, t.concat = function (e) {
                if (e && e !== this.dtype) throw new Error("TensorArray dtype is " + this.dtype + " but concat requested dtype " + e);
                if (0 === this.size()) return ny([], [0].concat(this.elementShape));
                for (var t = [], n = 0; n < this.size(); n++) t.push(n);
                var r = this.readMany(t);
                return HD(this.elementShape, r[0].shape, "TensorArray shape mismatch: tensor array shape (" + this.elementShape + ") vs first tensor shape (" + r[0].shape + ")"), Vx(r, 0)
            }, t.scatter = function (e, t) {
                if (t.dtype !== this.dtype) throw new Error("TensorArray dtype is " + this.dtype + " but tensor has dtype " + t.dtype);
                if (e.length !== t.shape[0]) throw new Error("Expected len(indices) == tensor.shape[0], but saw: " + e.length + " vs. " + t.shape[0]);
                var n = Math.max.apply(Math, e);
                if (!this.dynamicSize && n >= this.maxSize) throw new Error("Max index must be < array size (" + n + "  vs. " + this.maxSize + ")");
                this.writeMany(e, QN(t, 0))
            }, t.split = function (e, t) {
                var n = this;
                if (t.dtype !== this.dtype) throw new Error("TensorArray dtype is " + this.dtype + " but tensor has dtype " + t.dtype);
                var r = 0,
                    a = e.map(function (e) {
                        return r += e
                    });
                if (r !== t.shape[0]) throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        " + r + ", and tensor's shape is: " + t.shape);
                if (!this.dynamicSize && e.length !== this.maxSize) throw new Error("TensorArray's size is not equal to the size of lengths (" + this.maxSize + " vs. " + e.length + "), and the TensorArray is not marked as dynamically resizeable");
                var i = 0 === r ? 0 : t.size / r,
                    o = [];
                rx(function () {
                    t = Px(t, [1, r, i]);
                    for (var s = 0; s < e.length; ++s) {
                        var u = [0, 0 === s ? 0 : a[s - 1], 0],
                            l = [1, e[s], i];
                        o[s] = Px(Gx(t, u, l), n.elementShape)
                    }
                    return o
                });
                for (var s = [], u = 0; u < e.length; u++) s[u] = u;
                this.writeMany(s, o)
            }, Wm(e, [{
                key: "id",
                get: function () {
                    return this.idTensor.id
                }
            }, {
                key: "closed",
                get: function () {
                    return this.closed_
                }
            }]), e
        }(),
        JD = function () {
            function e(e, t, n, r) {
                void 0 === r && (r = -1), this.tensors = e, this.elementShape = t, this.elementDtype = n, null != e && e.forEach(function (e) {
                    if (n !== e.dtype) throw new Error("Invalid data types; op elements " + n + ", but list elements " + e.dtype);
                    HD(t, e.shape, "TensorList shape mismatch: "), ix(e)
                }), this.idTensor = wN(0), this.maxNumElements = r, ix(this.idTensor)
            }
            var t = e.prototype;
            return t.copy = function () {
                return new e([].concat(this.tensors), this.elementShape, this.elementDtype)
            }, t.clearAndClose = function (e) {
                this.tensors.forEach(function (t) {
                    null != e && e.has(t.id) || t.dispose()
                }), this.tensors.length = 0, this.idTensor.dispose()
            }, t.size = function () {
                return this.tensors.length
            }, t.stack = function (e, t, n) {
                var r = this;
                if (void 0 === n && (n = -1), t !== this.elementDtype) throw new Error("Invalid data types; op elements " + t + ", but list elements " + this.elementDtype);
                if (-1 !== n && this.tensors.length !== n) throw new Error("Operation expected a list with " + n + " elements but got a list with " + this.tensors.length + " elements.");
                HD(e, this.elementShape, "TensorList shape mismatch: ");
                var a = KD(this.elementShape, this.tensors, e);
                return rx(function () {
                    var e = r.tensors.map(function (e) {
                        return Px(e, a)
                    });
                    return UN(e, 0)
                })
            }, t.popBack = function (e, t) {
                if (t !== this.elementDtype) throw new Error("Invalid data types; op elements " + t + ", but list elements " + this.elementDtype);
                if (0 === this.size()) throw new Error("Trying to pop from an empty list.");
                var n = KD(this.elementShape, this.tensors, e),
                    r = this.tensors.pop();
                return HD(r.shape, e, "TensorList shape mismatch: "), Px(r, n)
            }, t.pushBack = function (e) {
                if (e.dtype !== this.elementDtype) throw new Error("Invalid data types; op elements " + e.dtype + ", but list elements " + this.elementDtype);
                if (HD(e.shape, this.elementShape, "TensorList shape mismatch: "), this.maxNumElements === this.size()) throw new Error("Trying to push element into a full list.");
                ix(e), this.tensors.push(e)
            }, t.resize = function (e) {
                if (e < 0) throw new Error("TensorListResize expects size to be non-negative. Got: " + e);
                if (-1 !== this.maxNumElements && e > this.maxNumElements) throw new Error("TensorListResize input size " + e + " is greater maxNumElement " + this.maxNumElements + ".");
                this.tensors.length = e
            }, t.getItem = function (e, t, n) {
                if (n !== this.elementDtype) throw new Error("Invalid data types; op elements " + n + ", but list elements " + this.elementDtype);
                if (e < 0 || e > this.tensors.length) throw new Error("Trying to access element " + e + " in a list with " + this.tensors.length + " elements.");
                if (null == this.tensors[e]) throw new Error("element at index " + e + " is null.");
                HD(this.tensors[e].shape, t, "TensorList shape mismatch: ");
                var r = KD(this.elementShape, this.tensors, t);
                return Px(this.tensors[e], r)
            }, t.setItem = function (e, t) {
                if (t.dtype !== this.elementDtype) throw new Error("Invalid data types; op elements " + t.dtype + ", but list elements " + this.elementDtype);
                if (e < 0 || -1 !== this.maxNumElements && e >= this.maxNumElements) throw new Error("Trying to set element " + e + " in a list with max " + this.maxNumElements + " elements.");
                HD(this.elementShape, t.shape, "TensorList shape mismatch: "), ix(t), this.tensors[e] = t
            }, t.gather = function (e, t, n) {
                var r = this;
                if (t !== this.elementDtype) throw new Error("Invalid data types; op elements " + t + ", but list elements " + this.elementDtype);
                HD(this.elementShape, n, "TensorList shape mismatch: "), e = e.slice(0, this.size());
                var a = KD(this.elementShape, this.tensors, n);
                return 0 === e.length ? ny([], [0].concat(a)) : rx(function () {
                    var t = e.map(function (e) {
                        return Px(r.tensors[e], a)
                    });
                    return UN(t, 0)
                })
            }, t.concat = function (e, t) {
                var n = this;
                if (e && e !== this.elementDtype) throw new Error("TensorList dtype is " + this.elementDtype + " but concat requested dtype " + e);
                HD(this.elementShape, t, "TensorList shape mismatch: ");
                var r = KD(this.elementShape, this.tensors, t);
                return 0 === this.size() ? ny([], [0].concat(r)) : rx(function () {
                    var e = n.tensors.map(function (e) {
                        return Px(e, r)
                    });
                    return Vx(e, 0)
                })
            }, Wm(e, [{
                key: "id",
                get: function () {
                    return this.idTensor.id
                }
            }]), e
        }();

    function ZD(e, t, n) {
        var r = e.dtype;
        if (e.shape.length < 1) throw new Error("Tensor must be at least a vector, but saw shape: " + e.shape);
        if (e.dtype !== n) throw new Error("Invalid data types; op elements " + e.dtype + ", but list elements " + n);
        HD(e.shape.slice(1), t, "TensorList shape mismatch: ");
        var a = QN(e);
        return new JD(a, t, r)
    }

    function QD(e, t, n) {
        return new JD([], e, t, n)
    }

    function $D(e, t, n, r) {
        if (t.length !== e.shape[0]) throw new Error("Expected len(indices) == tensor.shape[0], but saw: " + t.length + " vs. " + e.shape[0]);
        var a = Math.max.apply(Math, t);
        if (null != r && -1 !== r && a >= r) throw new Error("Max index must be < array size (" + a + "  vs. " + r + ")");
        var i = new JD([], n, e.dtype, r),
            o = QN(e, 0);
        return t.forEach(function (e, t) {
            i.setItem(e, o[t])
        }), i
    }

    function eO(e, t, n) {
        var r = 0,
            a = t.map(function (e) {
                return r += e
            });
        if (r !== e.shape[0]) throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        " + r + ", and tensor's shape is: " + e.shape);
        for (var i = XD(e.shape.slice(1), n), o = 0 === r ? 0 : e.size / r, s = rx(function () {
                var n = [];
                e = Px(e, [1, r, o]);
                for (var s = 0; s < t.length; ++s) {
                    var u = [0, 0 === s ? 0 : a[s - 1], 0],
                        l = [1, t[s], o];
                    n[s] = Px(Gx(e, u, l), i)
                }
                return e.dispose(), n
            }), u = new JD([], n, e.dtype, t.length), l = 0; l < s.length; l++) u.setItem(l, s[l]);
        return u
    }
    var tO = function () {
        var e = Pm(regeneratorRuntime.mark(function e(t, n, r) {
            var a, i, o, s, u, l, c, p, h, f, d, m, v, g, y, b, x, w, k, N, I, S, T, C, E, R, A, F, _, D, O, M, L, z, P, B, W, V, U, G, j, H, q, K, X, Y, J, Z, Q, $, ee, te, ne, re, ae, ie, oe, se, ue, le, ce, pe, he, fe, de, me, ve, ge, ye, be, xe, we, ke, Ne, Ie, Se, Te, Ce, Ee, Re, Ae, Fe, _e, De, Oe, Me, Le, ze, Pe, Be, We, Ve, Ue, Ge, je, He;
            return regeneratorRuntime.wrap(function (e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        e.t0 = t.op, e.next = "If" === e.t0 || "StatelessIf" === e.t0 ? 3 : "While" === e.t0 || "StatelessWhile" === e.t0 ? 15 : "LoopCond" === e.t0 ? 19 : "Switch" === e.t0 ? 21 : "Merge" === e.t0 ? 32 : "Enter" === e.t0 ? 37 : "Exit" === e.t0 ? 41 : "NextIteration" === e.t0 ? 44 : "TensorArrayV3" === e.t0 ? 47 : "TensorArrayWriteV3" === e.t0 ? 57 : "TensorArrayReadV3" === e.t0 ? 63 : "TensorArrayGatherV3" === e.t0 ? 67 : "TensorArrayScatterV3" === e.t0 ? 72 : "TensorArrayConcatV3" === e.t0 ? 78 : "TensorArraySplitV3" === e.t0 ? 82 : "TensorArraySizeV3" === e.t0 ? 88 : "TensorArrayCloseV3" === e.t0 ? 91 : "TensorListSetItem" === e.t0 ? 95 : "TensorListGetItem" === e.t0 ? 101 : "TensorListScatterV2" === e.t0 || "TensorListScatter" === e.t0 ? 107 : "TensorListReserve" === e.t0 || "EmptyTensorList" === e.t0 ? 114 : "TensorListGather" === e.t0 ? 121 : "TensorListStack" === e.t0 ? 127 : "TensorListFromTensor" === e.t0 ? 133 : "TensorListConcat" === e.t0 ? 139 : "TensorListPushBack" === e.t0 ? 144 : "TensorListPopBack" === e.t0 ? 149 : "TensorListSplit" === e.t0 ? 154 : 160;
                        break;
                    case 3:
                        return a = iD("thenBranch", t, n, r), i = iD("elseBranch", t, n, r), o = iD("cond", t, n, r), s = iD("args", t, n, r), e.next = 9, o.data();
                    case 9:
                        if (!e.sent[0]) {
                            e.next = 14;
                            break
                        }
                        return e.abrupt("return", r.functionMap[a].executeFunctionAsync(s, r.tensorArrayMap, r.tensorListMap));
                    case 14:
                        return e.abrupt("return", r.functionMap[i].executeFunctionAsync(s, r.tensorArrayMap, r.tensorListMap));
                    case 15:
                        return e.delegateYield(regeneratorRuntime.mark(function e() {
                            var a, i, o, s, u, l, c, p;
                            return regeneratorRuntime.wrap(function (e) {
                                for (;;) switch (e.prev = e.next) {
                                    case 0:
                                        return a = iD("body", t, n, r), i = iD("cond", t, n, r), o = iD("args", t, n, r), e.next = 5, r.functionMap[i].executeFunctionAsync(o, r.tensorArrayMap, r.tensorListMap);
                                    case 5:
                                        return s = e.sent, u = o.map(function (e) {
                                            return e.id
                                        }), e.next = 9, s[0].data();
                                    case 9:
                                        l = e.sent, s.forEach(function (e) {
                                            e.kept || -1 !== u.indexOf(e.id) || e.dispose()
                                        }), c = o, p = regeneratorRuntime.mark(function e() {
                                            var t, n, o;
                                            return regeneratorRuntime.wrap(function (e) {
                                                for (;;) switch (e.prev = e.next) {
                                                    case 0:
                                                        return t = c, e.next = 3, r.functionMap[a].executeFunctionAsync(c, r.tensorArrayMap, r.tensorListMap);
                                                    case 3:
                                                        return c = e.sent, n = c.map(function (e) {
                                                            return e.id
                                                        }), t.forEach(function (e) {
                                                            e.kept || -1 !== u.indexOf(e.id) || -1 !== n.indexOf(e.id) || e.dispose()
                                                        }), e.next = 8, r.functionMap[i].executeFunctionAsync(c, r.tensorArrayMap, r.tensorListMap);
                                                    case 8:
                                                        return o = e.sent, e.next = 11, o[0].data();
                                                    case 11:
                                                        l = e.sent, o.forEach(function (e) {
                                                            e.kept || -1 !== u.indexOf(e.id) || -1 !== n.indexOf(e.id) || e.dispose()
                                                        });
                                                    case 13:
                                                    case "end":
                                                        return e.stop()
                                                }
                                            }, e)
                                        });
                                    case 13:
                                        if (!l[0]) {
                                            e.next = 17;
                                            break
                                        }
                                        return e.delegateYield(p(), "t0", 15);
                                    case 15:
                                        e.next = 13;
                                        break;
                                    case 17:
                                        return e.abrupt("return", {
                                            v: c
                                        });
                                    case 18:
                                    case "end":
                                        return e.stop()
                                }
                            }, e)
                        })(), "t1", 16);
                    case 16:
                        if ("object" != typeof (u = e.t1)) {
                            e.next = 19;
                            break
                        }
                        return e.abrupt("return", u.v);
                    case 19:
                        return l = iD("pred", t, n, r), e.abrupt("return", [pD(l)]);
                    case 21:
                        return c = iD("pred", t, n, r), (p = iD("data", t, n, r)).kept || (p = pD(p)), e.next = 26, c.data();
                    case 26:
                        if (!e.sent[0]) {
                            e.next = 30;
                            break
                        }
                        e.t2 = [void 0, p], e.next = 31;
                        break;
                    case 30:
                        e.t2 = [p, void 0];
                    case 31:
                        return e.abrupt("return", e.t2);
                    case 32:
                        if (!(h = t.inputNames.find(function (e) {
                                return void 0 !== oD(e, n, r)
                            }))) {
                            e.next = 36;
                            break
                        }
                        return f = oD(h, n, r), e.abrupt("return", [pD(f)]);
                    case 36:
                        return e.abrupt("return", void 0);
                    case 37:
                        return d = iD("frameName", t, n, r), m = iD("tensor", t, n, r), r.enterFrame(d), e.abrupt("return", [pD(m)]);
                    case 41:
                        return v = iD("tensor", t, n, r), r.exitFrame(), e.abrupt("return", [pD(v)]);
                    case 44:
                        return g = iD("tensor", t, n, r), r.nextIteration(), e.abrupt("return", [pD(g)]);
                    case 47:
                        return y = iD("size", t, n, r), b = iD("dtype", t, n, r), x = iD("elementShape", t, n, r), w = iD("dynamicSize", t, n, r), k = iD("clearAfterRead", t, n, r), N = iD("identicalElementShapes", t, n, r), I = iD("name", t, n, r), S = new YD(I, b, y, x, N, w, k), r.addTensorArray(S), e.abrupt("return", [S.idTensor, wN(1)]);
                    case 57:
                        return T = iD("tensorArrayId", t, n, r), C = iD("index", t, n, r), E = iD("tensor", t, n, r), (R = r.getTensorArray(T.id)).write(C, E), e.abrupt("return", [R.idTensor]);
                    case 63:
                        return A = iD("tensorArrayId", t, n, r), F = iD("index", t, n, r), _ = r.getTensorArray(A.id), e.abrupt("return", [_.read(F)]);
                    case 67:
                        return D = iD("tensorArrayId", t, n, r), O = iD("indices", t, n, r), M = iD("dtype", t, n, r), L = r.getTensorArray(D.id), e.abrupt("return", [L.gather(O, M)]);
                    case 72:
                        return z = iD("tensorArrayId", t, n, r), P = iD("indices", t, n, r), B = iD("tensor", t, n, r), (W = r.getTensorArray(z.id)).scatter(P, B), e.abrupt("return", [W.idTensor]);
                    case 78:
                        return V = iD("tensorArrayId", t, n, r), U = r.getTensorArray(V.id), G = iD("dtype", t, n, r), e.abrupt("return", [U.concat(G)]);
                    case 82:
                        return j = iD("tensorArrayId", t, n, r), H = iD("tensor", t, n, r), q = iD("lengths", t, n, r), (K = r.getTensorArray(j.id)).split(q, H), e.abrupt("return", [K.idTensor]);
                    case 88:
                        return X = iD("tensorArrayId", t, n, r), Y = r.getTensorArray(X.id), e.abrupt("return", [wN(Y.size(), "int32")]);
                    case 91:
                        return J = iD("tensorArrayId", t, n, r), (Z = r.getTensorArray(J.id)).clearAndClose(), e.abrupt("return", [Z.idTensor]);
                    case 95:
                        return Q = iD("tensorListId", t, n, r), $ = iD("index", t, n, r), ee = iD("tensor", t, n, r), (te = r.getTensorList(Q.id)).setItem($, ee), e.abrupt("return", [te.idTensor]);
                    case 101:
                        return ne = iD("tensorListId", t, n, r), re = iD("index", t, n, r), ae = iD("elementShape", t, n, r), ie = iD("elementDType", t, n, r), oe = r.getTensorList(ne.id), e.abrupt("return", [oe.getItem(re, ae, ie)]);
                    case 107:
                        return se = iD("indices", t, n, r), ue = iD("tensor", t, n, r), le = iD("elementShape", t, n, r), ce = iD("numElements", t, n, r), pe = $D(ue, se, le, ce), r.addTensorList(pe), e.abrupt("return", [pe.idTensor]);
                    case 114:
                        return he = iD("elementShape", t, n, r), fe = iD("elementDType", t, n, r), de = "TensorListReserve" === t.op ? "numElements" : "maxNumElements", me = iD(de, t, n, r), ve = QD(he, fe, me), r.addTensorList(ve), e.abrupt("return", [ve.idTensor]);
                    case 121:
                        return ge = iD("tensorListId", t, n, r), ye = iD("indices", t, n, r), be = iD("elementShape", t, n, r), xe = iD("elementDType", t, n, r), we = r.getTensorList(ge.id), e.abrupt("return", [we.gather(ye, xe, be)]);
                    case 127:
                        return ke = iD("tensorListId", t, n, r), Ne = iD("elementShape", t, n, r), Ie = iD("elementDType", t, n, r), Se = iD("numElements", t, n, r), Te = r.getTensorList(ke.id), e.abrupt("return", [Te.stack(Ne, Ie, Se)]);
                    case 133:
                        return Ce = iD("tensor", t, n, r), Ee = iD("elementShape", t, n, r), Re = iD("elementDType", t, n, r), Ae = ZD(Ce, Ee, Re), r.addTensorList(Ae), e.abrupt("return", [Ae.idTensor]);
                    case 139:
                        return Fe = iD("tensorListId", t, n, r), _e = r.getTensorList(Fe.id), De = iD("dtype", t, n, r), Oe = iD("elementShape", t, n, r), e.abrupt("return", [_e.concat(De, Oe)]);
                    case 144:
                        return Me = iD("tensorListId", t, n, r), Le = iD("tensor", t, n, r), (ze = r.getTensorList(Me.id)).pushBack(Le), e.abrupt("return", [ze.idTensor]);
                    case 149:
                        return Pe = iD("tensorListId", t, n, r), Be = iD("elementShape", t, n, r), We = iD("elementDType", t, n, r), Ve = r.getTensorList(Pe.id), e.abrupt("return", [Ve.popBack(Be, We)]);
                    case 154:
                        return Ue = iD("tensor", t, n, r), Ge = iD("elementShape", t, n, r), je = iD("lengths", t, n, r), He = eO(Ue, je, Ge), r.addTensorList(He), e.abrupt("return", [He.idTensor]);
                    case 160:
                        throw TypeError("Node type " + t.op + " is not implemented");
                    case 161:
                    case "end":
                        return e.stop()
                }
            }, e)
        }));
        return function (t, n, r) {
            return e.apply(this, arguments)
        }
    }();

    function nO(e, t, n) {
        var r = iD("fusedOps", e, t, n),
            a = r[0],
            i = r[1],
            o = "biasadd" === a,
            s = "prelu" === i,
            u = "fusedbatchnorm" === a,
            l = iD("numArgs", e, t, n);
        if (o) {
            if (s && 2 !== l) throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
            if (!s && 1 !== l) throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")
        }
        if (u) throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.");
        var c = iD("strides", e, t, n),
            p = cD(e, t, n),
            h = iD("dataFormat", e, t, n).toUpperCase(),
            f = iD("dilations", e, t, n),
            d = iD("args", e, t, n);
        return {
            stride: c,
            pad: p,
            dataFormat: h,
            dilations: f,
            biasArg: d[0],
            preluArg: d[1],
            activationFunc: i,
            leakyreluAlpha: iD("leakyreluAlpha", e, t, n)
        }
    }

    function rO(e, t, n) {
        return {
            boxes: iD("boxes", e, t, n),
            scores: iD("scores", e, t, n),
            maxOutputSize: iD("maxOutputSize", e, t, n),
            iouThreshold: iD("iouThreshold", e, t, n),
            scoreThreshold: iD("scoreThreshold", e, t, n),
            softNmsSigma: iD("softNmsSigma", e, t, n)
        }
    }
    var aO = function () {
            var e = Pm(regeneratorRuntime.mark(function e(t, n, r) {
                var a, i, o, s, u, l, c, p, h, f, d, m, v, g, y, b, x, w, k, N, I, S, T, C;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            e.t0 = t.op, e.next = "NonMaxSuppressionV5" === e.t0 ? 3 : "NonMaxSuppressionV4" === e.t0 ? 8 : "NonMaxSuppressionV3" === e.t0 || "NonMaxSuppressionV2" === e.t0 ? 14 : "Where" === e.t0 ? 19 : "ListDiff" === e.t0 ? 26 : 27;
                            break;
                        case 3:
                            return a = rO(t, n, r), i = a.boxes, o = a.scores, s = a.maxOutputSize, u = a.iouThreshold, l = a.scoreThreshold, c = a.softNmsSigma, e.next = 6, hS.nonMaxSuppressionWithScoreAsync(i, o, s, u, l, c);
                        case 6:
                            return p = e.sent, e.abrupt("return", [p.selectedIndices, p.selectedScores]);
                        case 8:
                            return h = rO(t, n, r), f = h.boxes, d = h.scores, m = h.maxOutputSize, v = h.iouThreshold, g = h.scoreThreshold, y = iD("padToMaxOutputSize", t, n, r), e.next = 12, hS.nonMaxSuppressionPaddedAsync(f, d, m, v, g, y);
                        case 12:
                            return b = e.sent, e.abrupt("return", [b.selectedIndices, b.validOutputs]);
                        case 14:
                            return x = rO(t, n, r), w = x.boxes, k = x.scores, N = x.maxOutputSize, I = x.iouThreshold, S = x.scoreThreshold, e.next = 17, hS.nonMaxSuppressionAsync(w, k, N, I, S);
                        case 17:
                            return e.t1 = e.sent, e.abrupt("return", [e.t1]);
                        case 19:
                            return T = Ky(iD("condition", t, n, r), "bool"), e.next = 22, nI(T);
                        case 22:
                            return e.t2 = e.sent, C = [e.t2], T.dispose(), e.abrupt("return", C);
                        case 26:
                            return e.abrupt("return", SN(iD("x", t, n, r), iD("y", t, n, r)));
                        case 27:
                            throw TypeError("Node type " + t.op + " is not implemented");
                        case 28:
                        case "end":
                            return e.stop()
                    }
                }, e)
            }));
            return function (t, n, r) {
                return e.apply(this, arguments)
            }
        }(),
        iO = function () {
            function e(e, t) {
                this.keyDType = e, this.valueDType = t, this.handle = wN(0), this.tensorMap = new Map, ix(this.handle)
            }
            var t = e.prototype;
            return t.clearAndClose = function () {
                this.tensorMap.forEach(function (e) {
                    return e.dispose()
                }), this.tensorMap.clear(), this.handle.dispose()
            }, t.size = function () {
                return this.tensorMap.size
            }, t.tensorSize = function () {
                return wN(this.size(), "int32")
            }, t.import = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t, n) {
                    var r, a = this;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return this.checkKeyAndValueTensor(t, n), e.next = 3, t.data();
                            case 3:
                                return r = e.sent, this.tensorMap.forEach(function (e) {
                                    return e.dispose()
                                }), this.tensorMap.clear(), e.abrupt("return", rx(function () {
                                    var e = QN(n),
                                        t = r.length,
                                        i = e.length;
                                    nv(t === i, function () {
                                        return "The number of elements doesn't match, keys has " + t + " elements, the values has " + i + " elements."
                                    });
                                    for (var o = 0; o < t; o++) {
                                        var s = r[o],
                                            u = e[o];
                                        ix(u), a.tensorMap.set(s, u)
                                    }
                                    return a.handle
                                }));
                            case 7:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t, n) {
                    return e.apply(this, arguments)
                }
            }(), t.find = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t, n) {
                    var r, a = this;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return this.checkKeyAndValueTensor(t, n), e.next = 3, t.data();
                            case 3:
                                return r = e.sent, e.abrupt("return", rx(function () {
                                    for (var e = [], t = 0; t < r.length; t++) {
                                        var i = r[t],
                                            o = a.findWithDefault(i, n);
                                        e.push(o)
                                    }
                                    return UN(e)
                                }));
                            case 5:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t, n) {
                    return e.apply(this, arguments)
                }
            }(), t.findWithDefault = function (e, t) {
                var n = this.tensorMap.get(e);
                return null != n ? n : t
            }, t.checkKeyAndValueTensor = function (e, t) {
                if (e.dtype !== this.keyDType) throw new Error("Expect key dtype " + this.keyDType + ", but got " + e.dtype);
                if (t.dtype !== this.valueDType) throw new Error("Expect value dtype " + this.valueDType + ", but got " + t.dtype)
            }, Wm(e, [{
                key: "id",
                get: function () {
                    return this.handle.id
                }
            }]), e
        }(),
        oO = function () {
            var e = Pm(regeneratorRuntime.mark(function e(t, n, r, a) {
                var i, o, s, u, l, c, p, h, f, d, m, v, g;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            e.t0 = t.op, e.next = "HashTable" === e.t0 || "HashTableV2" === e.t0 ? 3 : "LookupTableImport" === e.t0 || "LookupTableImportV2" === e.t0 ? 8 : "LookupTableFind" === e.t0 || "LookupTableFindV2" === e.t0 ? 16 : "LookupTableSize" === e.t0 || "LookupTableSizeV2" === e.t0 ? 24 : 27;
                            break;
                        case 3:
                            return i = iD("keyDType", t, n, r), o = iD("valueDType", t, n, r), s = new iO(i, o), a.addHashTable(t.name, s), e.abrupt("return", [s.handle]);
                        case 8:
                            return u = iD("tableHandle", t, n, r, a), l = iD("keys", t, n, r), c = iD("values", t, n, r), p = a.getHashTableById(u.id), e.next = 14, p.import(l, c);
                        case 14:
                            return e.t1 = e.sent, e.abrupt("return", [e.t1]);
                        case 16:
                            return h = iD("tableHandle", t, n, r, a), f = iD("keys", t, n, r), d = iD("defaultValue", t, n, r), m = a.getHashTableById(h.id), e.next = 22, m.find(f, d);
                        case 22:
                            return e.t2 = e.sent, e.abrupt("return", [e.t2]);
                        case 24:
                            return v = iD("tableHandle", t, n, r, a), g = a.getHashTableById(v.id), e.abrupt("return", [g.tensorSize()]);
                        case 27:
                            throw TypeError("Node type " + t.op + " is not implemented");
                        case 28:
                        case "end":
                            return e.stop()
                    }
                }, e)
            }));
            return function (t, n, r, a) {
                return e.apply(this, arguments)
            }
        }();

    function sO(e, t, n, r) {
        var a = function (e, t, n) {
            switch (e.category) {
                case "arithmetic":
                    return rx(function () {
                        return function (e, t, n) {
                            switch (e.op) {
                                case "BiasAdd":
                                case "AddV2":
                                case "Add":
                                    return [ux(iD("a", e, t, n), iD("b", e, t, n))];
                                case "AddN":
                                    return [mx(iD("tensors", e, t, n))];
                                case "FloorMod":
                                case "Mod":
                                    return [Ek(iD("a", e, t, n), iD("b", e, t, n))];
                                case "Mul":
                                    return [px(iD("a", e, t, n), iD("b", e, t, n))];
                                case "RealDiv":
                                case "Div":
                                    return [cx(iD("a", e, t, n), iD("b", e, t, n))];
                                case "DivNoNan":
                                    return [Tw(iD("a", e, t, n), iD("b", e, t, n))];
                                case "FloorDiv":
                                    return [lx(iD("a", e, t, n), iD("b", e, t, n))];
                                case "Sub":
                                    return [ak(iD("a", e, t, n), iD("b", e, t, n))];
                                case "Minimum":
                                    return [Tk(iD("a", e, t, n), iD("b", e, t, n))];
                                case "Maximum":
                                    return [Nk(iD("a", e, t, n), iD("b", e, t, n))];
                                case "Pow":
                                    return [Hk(iD("a", e, t, n), iD("b", e, t, n))];
                                case "SquaredDifference":
                                    return [WN(iD("a", e, t, n), iD("b", e, t, n))];
                                default:
                                    throw TypeError("Node type " + e.op + " is not implemented")
                            }
                        }(e, t, n)
                    });
                case "basic_math":
                    return rx(function () {
                        return function (e, t, n) {
                            switch (e.op) {
                                case "Abs":
                                case "ComplexAbs":
                                    return [hx(iD("x", e, t, n))];
                                case "Acos":
                                    return [fx(iD("x", e, t, n))];
                                case "Acosh":
                                    return [dx(iD("x", e, t, n))];
                                case "Asin":
                                    return [xx(iD("x", e, t, n))];
                                case "Asinh":
                                    return [wx(iD("x", e, t, n))];
                                case "Atan":
                                    return [kx(iD("x", e, t, n))];
                                case "Atan2":
                                    return [Nx(iD("x", e, t, n), iD("y", e, t, n))];
                                case "Atanh":
                                    return [Ix(iD("x", e, t, n))];
                                case "Ceil":
                                    return [$x(iD("x", e, t, n))];
                                case "Complex":
                                    return [ey(iD("real", e, t, n), iD("imag", e, t, n))];
                                case "Cos":
                                    return [hw(iD("x", e, t, n))];
                                case "Cosh":
                                    return [fw(iD("x", e, t, n))];
                                case "Elu":
                                    return [Ew(iD("x", e, t, n))];
                                case "Erf":
                                    return [Rw(iD("x", e, t, n))];
                                case "Exp":
                                    return [Aw(iD("x", e, t, n))];
                                case "Expm1":
                                    return [_w(iD("x", e, t, n))];
                                case "Floor":
                                    return [Lw(iD("x", e, t, n))];
                                case "Log":
                                    return [Yw(iD("x", e, t, n))];
                                case "Log1p":
                                    return [Jw(iD("x", e, t, n))];
                                case "Imag":
                                    return [Ww(iD("x", e, t, n))];
                                case "Neg":
                                    return [ek(iD("x", e, t, n))];
                                case "Reciprocal":
                                    return [pN(iD("x", e, t, n))];
                                case "Real":
                                    return [cN(iD("x", e, t, n))];
                                case "Relu":
                                    return [hN(iD("x", e, t, n))];
                                case "Round":
                                    return [bN(iD("x", e, t, n))];
                                case "Selu":
                                    return [kN(iD("x", e, t, n))];
                                case "Sigmoid":
                                    return [Ux(iD("x", e, t, n))];
                                case "Sin":
                                    return [CN(iD("x", e, t, n))];
                                case "Sign":
                                    return [TN(iD("x", e, t, n))];
                                case "Sinh":
                                    return [EN(iD("x", e, t, n))];
                                case "Softplus":
                                    return [tk(iD("x", e, t, n))];
                                case "Sqrt":
                                    return [BN(iD("x", e, t, n))];
                                case "Square":
                                    return [Rk(iD("x", e, t, n))];
                                case "Tanh":
                                    return [jx(iD("x", e, t, n))];
                                case "Tan":
                                    return [HN(iD("x", e, t, n))];
                                case "ClipByValue":
                                    return [ew(iD("x", e, t, n), iD("clipValueMin", e, t, n), iD("clipValueMax", e, t, n))];
                                case "Relu6":
                                    return [fN(iD("x", e, t, n))];
                                case "Rsqrt":
                                    return [xN(oD(e.inputNames[0], t, n))];
                                case "Prod":
                                    return [Kk(iD("x", e, t, n), iD("axes", e, t, n))];
                                case "LeakyRelu":
                                    return [jw(iD("x", e, t, n), iD("alpha", e, t, n))];
                                case "Prelu":
                                    return [qk(iD("x", e, t, n), iD("alpha", e, t, n))];
                                default:
                                    throw TypeError("Node type " + e.op + " is not implemented")
                            }
                        }(e, t, n)
                    });
                case "control":
                    return tO(e, t, n);
                case "convolution":
                    return rx(function () {
                        return function (e, t, n) {
                            switch (e.op) {
                                case "Conv1D":
                                    var r = iD("stride", e, t, n),
                                        a = iD("pad", e, t, n),
                                        i = iD("dataFormat", e, t, n).toUpperCase(),
                                        o = iD("dilation", e, t, n);
                                    return [ow(iD("x", e, t, n), iD("filter", e, t, n), r, a, i, o)];
                                case "Conv2D":
                                    var s = iD("strides", e, t, n),
                                        u = cD(e, t, n),
                                        l = iD("dataFormat", e, t, n).toUpperCase(),
                                        c = iD("dilations", e, t, n);
                                    return [iw(iD("x", e, t, n), iD("filter", e, t, n), [s[1], s[2]], u, l, [c[1], c[2]])];
                                case "_FusedConv2D":
                                    var p = nO(e, t, n),
                                        h = p.stride,
                                        f = p.pad,
                                        d = p.dataFormat,
                                        m = p.dilations,
                                        v = p.biasArg,
                                        g = p.preluArg,
                                        y = p.activationFunc,
                                        b = p.leakyreluAlpha;
                                    return [yI({
                                        x: iD("x", e, t, n),
                                        filter: iD("filter", e, t, n),
                                        strides: [h[1], h[2]],
                                        pad: f,
                                        dataFormat: d,
                                        dilations: [m[1], m[2]],
                                        bias: v,
                                        activation: y,
                                        preluActivationWeights: g,
                                        leakyreluAlpha: b
                                    })];
                                case "FusedDepthwiseConv2dNative":
                                    var x = nO(e, t, n),
                                        w = x.stride,
                                        k = x.pad,
                                        N = x.dataFormat,
                                        I = x.dilations,
                                        S = x.biasArg,
                                        T = x.preluArg,
                                        C = x.activationFunc,
                                        E = x.leakyreluAlpha;
                                    return [wI({
                                        x: iD("x", e, t, n),
                                        filter: iD("filter", e, t, n),
                                        strides: [w[1], w[2]],
                                        pad: k,
                                        dataFormat: N,
                                        dilations: [I[1], I[2]],
                                        bias: S,
                                        activation: C,
                                        preluActivationWeights: T,
                                        leakyreluAlpha: E
                                    })];
                                case "Conv2DBackpropInput":
                                case "Conv2dTranspose":
                                    var R = iD("outputShape", e, t, n),
                                        A = iD("strides", e, t, n),
                                        F = cD(e, t, n);
                                    return [uw(iD("x", e, t, n), iD("filter", e, t, n), R, [A[1], A[2]], F)];
                                case "DepthwiseConv2dNative":
                                case "DepthwiseConv2d":
                                    var _ = iD("strides", e, t, n),
                                        D = cD(e, t, n),
                                        O = iD("dilations", e, t, n),
                                        M = iD("dataFormat", e, t, n).toUpperCase();
                                    return [gw(iD("input", e, t, n), iD("filter", e, t, n), [_[1], _[2]], D, M, [O[1], O[2]])];
                                case "Conv3D":
                                    var L = iD("strides", e, t, n),
                                        z = iD("pad", e, t, n),
                                        P = iD("dataFormat", e, t, n).toUpperCase(),
                                        B = iD("dilations", e, t, n);
                                    return [lw(iD("x", e, t, n), iD("filter", e, t, n), [L[1], L[2], L[3]], z, P, [B[1], B[2], B[3]])];
                                case "AvgPool":
                                    var W = iD("strides", e, t, n),
                                        V = iD("pad", e, t, n),
                                        U = iD("kernelSize", e, t, n);
                                    return [Bx(iD("x", e, t, n), [U[1], U[2]], [W[1], W[2]], V)];
                                case "MaxPool":
                                    var G = iD("strides", e, t, n),
                                        j = iD("pad", e, t, n),
                                        H = iD("kernelSize", e, t, n);
                                    return [xk(iD("x", e, t, n), [H[1], H[2]], [G[1], G[2]], j)];
                                case "MaxPoolWithArgmax":
                                    var q = iD("strides", e, t, n),
                                        K = iD("pad", e, t, n),
                                        X = iD("kernelSize", e, t, n),
                                        Y = iD("includeBatchInIndex", e, t, n),
                                        J = kk(iD("x", e, t, n), [X[1], X[2]], [q[1], q[2]], K, Y);
                                    return [J.result, J.indexes];
                                case "AvgPool3D":
                                    var Z = iD("strides", e, t, n),
                                        Q = iD("pad", e, t, n),
                                        $ = iD("kernelSize", e, t, n);
                                    return [Wx(iD("x", e, t, n), [$[1], $[2], $[3]], [Z[1], Z[2], Z[3]], Q)];
                                case "MaxPool3D":
                                    var ee = iD("strides", e, t, n),
                                        te = iD("pad", e, t, n),
                                        ne = iD("kernelSize", e, t, n);
                                    return [wk(iD("x", e, t, n), [ne[1], ne[2], ne[3]], [ee[1], ee[2], ee[3]], te)];
                                case "Dilation2D":
                                    var re = iD("strides", e, t, n),
                                        ae = iD("pad", e, t, n),
                                        ie = iD("dilations", e, t, n),
                                        oe = re[1],
                                        se = re[2],
                                        ue = ie[1],
                                        le = ie[2];
                                    return [bw(iD("x", e, t, n), iD("filter", e, t, n), [oe, se], ae, [ue, le], "NHWC")];
                                default:
                                    throw TypeError("Node type " + e.op + " is not implemented")
                            }
                        }(e, t, n)
                    });
                case "creation":
                    return rx(function () {
                        return function (e, t, n) {
                            switch (e.op) {
                                case "Fill":
                                    var r = iD("shape", e, t, n),
                                        a = iD("dtype", e, t, n);
                                    return [Mw(r, iD("value", e, t, n), a)];
                                case "LinSpace":
                                    return [Kw(iD("start", e, t, n), iD("stop", e, t, n), iD("num", e, t, n))];
                                case "Multinomial":
                                    var i = iD("logits", e, t, n),
                                        o = iD("numSamples", e, t, n),
                                        s = iD("seed", e, t, n);
                                    return [_k(i, o, s)];
                                case "OneHot":
                                    var u = iD("indices", e, t, n),
                                        l = iD("depth", e, t, n),
                                        c = iD("onValue", e, t, n),
                                        p = iD("offValue", e, t, n);
                                    return [db(u, l, c, p)];
                                case "Ones":
                                    return [Mk(iD("shape", e, t, n), iD("dtype", e, t, n))];
                                case "OnesLike":
                                    return [Lk(iD("x", e, t, n))];
                                case "RandomUniform":
                                    return [uN(iD("shape", e, t, n), iD("minval", e, t, n), iD("maxval", e, t, n), iD("dtype", e, t, n))];
                                case "Range":
                                    return [lN(iD("start", e, t, n), iD("stop", e, t, n), iD("step", e, t, n), iD("dtype", e, t, n))];
                                case "TruncatedNormal":
                                    var h = iD("shape", e, t, n),
                                        f = iD("mean", e, t, n),
                                        d = iD("stdDev", e, t, n),
                                        m = iD("seed", e, t, n);
                                    return [YN(h, f, d, iD("dtype", e, t, n), m)];
                                case "Zeros":
                                    return [Ok(iD("shape", e, t, n), iD("dtype", e, t, n))];
                                case "ZerosLike":
                                    return [Sw(iD("x", e, t, n))];
                                default:
                                    throw TypeError("Node type " + e.op + " is not implemented")
                            }
                        }(e, t, n)
                    });
                case "dynamic":
                    return aO(e, t, n);
                case "evaluation":
                    return rx(function () {
                        return function (e, t, n) {
                            switch (e.op) {
                                case "TopKV2":
                                    var r = iD("x", e, t, n),
                                        a = iD("k", e, t, n),
                                        i = iD("sorted", e, t, n),
                                        o = XN(r, a, i);
                                    return [o.values, o.indices];
                                case "Unique":
                                    var s = iD("x", e, t, n),
                                        u = JN(s);
                                    return [u.values, u.indices];
                                case "UniqueV2":
                                    var l = iD("x", e, t, n),
                                        c = iD("axis", e, t, n),
                                        p = JN(l, c);
                                    return [p.values, p.indices];
                                default:
                                    throw TypeError("Node type " + e.op + " is not implemented")
                            }
                        }(e, t, n)
                    });
                case "image":
                    return rx(function () {
                        return function (e, t, n) {
                            switch (e.op) {
                                case "ResizeBilinear":
                                    var r = iD("images", e, t, n),
                                        a = iD("size", e, t, n),
                                        i = iD("alignCorners", e, t, n),
                                        o = iD("halfPixelCenters", e, t, n);
                                    return [hS.resizeBilinear(r, [a[0], a[1]], i, o)];
                                case "ResizeNearestNeighbor":
                                    var s = iD("images", e, t, n),
                                        u = iD("size", e, t, n),
                                        l = iD("alignCorners", e, t, n),
                                        c = iD("halfPixelCenters", e, t, n);
                                    return [hS.resizeNearestNeighbor(s, [u[0], u[1]], l, c)];
                                case "CropAndResize":
                                    var p = iD("image", e, t, n),
                                        h = iD("boxes", e, t, n),
                                        f = iD("boxInd", e, t, n),
                                        d = iD("cropSize", e, t, n),
                                        m = iD("method", e, t, n),
                                        v = iD("extrapolationValue", e, t, n);
                                    return [hS.cropAndResize(p, h, f, d, m, v)];
                                default:
                                    throw TypeError("Node type " + e.op + " is not implemented")
                            }
                        }(e, t, n)
                    });
                case "graph":
                    return rx(function () {
                        return function (e, t, n) {
                            switch (e.op) {
                                case "Const":
                                    return t[e.name];
                                case "PlaceholderWithDefault":
                                    var r = iD("default", e, t, n);
                                    return [oD(e.name, t, n) || r];
                                case "Placeholder":
                                    return [oD(e.name, t, n)];
                                case "Identity":
                                case "StopGradient":
                                case "FakeQuantWithMinMaxVars":
                                    return [pD(iD("x", e, t, n))];
                                case "IdentityN":
                                    return iD("x", e, t, n).map(function (e) {
                                        return pD(e)
                                    });
                                case "Snapshot":
                                    return [pD(iD("x", e, t, n))];
                                case "Shape":
                                    return [qN(iD("x", e, t, n).shape, "int32")];
                                case "ShapeN":
                                    return iD("x", e, t, n).map(function (e) {
                                        return qN(e.shape)
                                    });
                                case "Size":
                                    return [wN(iD("x", e, t, n).size, "int32")];
                                case "Rank":
                                    return [wN(iD("x", e, t, n).rank, "int32")];
                                case "NoOp":
                                    return [wN(1)];
                                case "Print":
                                    var a = iD("x", e, t, n),
                                        i = iD("data", e, t, n),
                                        o = iD("message", e, t, n),
                                        s = iD("summarize", e, t, n);
                                    console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."), console.log(o);
                                    for (var u = 0; u < i.length; u++) console.log(Array.prototype.slice.call(i[u].dataSync()).slice(0, s));
                                    return [a];
                                default:
                                    throw TypeError("Node type " + e.op + " is not implemented")
                            }
                        }(e, t, n)
                    });
                case "logical":
                    return rx(function () {
                        return function (e, t, n) {
                            switch (e.op) {
                                case "Equal":
                                    return [Nw(iD("a", e, t, n), iD("b", e, t, n))];
                                case "NotEqual":
                                    return [Dk(iD("a", e, t, n), iD("b", e, t, n))];
                                case "Greater":
                                    return [Pw(iD("a", e, t, n), iD("b", e, t, n))];
                                case "GreaterEqual":
                                    return [Bw(iD("a", e, t, n), iD("b", e, t, n))];
                                case "Less":
                                    return [Hw(iD("a", e, t, n), iD("b", e, t, n))];
                                case "LessEqual":
                                    return [qw(iD("a", e, t, n), iD("b", e, t, n))];
                                case "LogicalAnd":
                                    return [vk(iD("a", e, t, n), iD("b", e, t, n))];
                                case "LogicalNot":
                                    return [gk(iD("a", e, t, n))];
                                case "LogicalOr":
                                    return [yk(iD("a", e, t, n), iD("b", e, t, n))];
                                case "Select":
                                case "SelectV2":
                                    return [Iw(iD("condition", e, t, n), iD("a", e, t, n), iD("b", e, t, n))];
                                default:
                                    throw TypeError("Node type " + e.op + " is not implemented")
                            }
                        }(e, t, n)
                    });
                case "matrices":
                    return rx(function () {
                        return function (e, t, n) {
                            switch (e.op) {
                                case "BatchMatMul":
                                case "BatchMatMulV2":
                                case "MatMul":
                                    return [fb(iD("a", e, t, n), iD("b", e, t, n), iD("transposeA", e, t, n), iD("transposeB", e, t, n))];
                                case "Transpose":
                                    return [mb(iD("x", e, t, n), iD("perm", e, t, n))];
                                case "_FusedMatMul":
                                    var r = iD("fusedOps", e, t, n),
                                        a = r[0],
                                        i = r[1],
                                        o = "biasadd" === a,
                                        s = "prelu" === i,
                                        u = iD("numArgs", e, t, n),
                                        l = iD("leakyreluAlpha", e, t, n);
                                    if (o) {
                                        if (s && 2 !== u) throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
                                        if (!s && 1 !== u) throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")
                                    }
                                    var c = iD("args", e, t, n),
                                        p = c[0],
                                        h = c[1];
                                    return [kI({
                                        a: iD("a", e, t, n),
                                        b: iD("b", e, t, n),
                                        transposeA: iD("transposeA", e, t, n),
                                        transposeB: iD("transposeB", e, t, n),
                                        bias: p,
                                        activation: i,
                                        preluActivationWeights: h,
                                        leakyreluAlpha: l
                                    })];
                                default:
                                    throw TypeError("Node type " + e.op + " is not implemented")
                            }
                        }(e, t, n)
                    });
                case "normalization":
                    return rx(function () {
                        return function (e, t, n) {
                            switch (e.op) {
                                case "FusedBatchNorm":
                                case "FusedBatchNormV2":
                                case "FusedBatchNormV3":
                                    return [Kx(iD("x", e, t, n), iD("mean", e, t, n), iD("variance", e, t, n), iD("offset", e, t, n), iD("scale", e, t, n), iD("epsilon", e, t, n))];
                                case "LRN":
                                    return [Xw(iD("x", e, t, n), iD("radius", e, t, n), iD("bias", e, t, n), iD("alpha", e, t, n), iD("beta", e, t, n))];
                                case "Softmax":
                                    return [DN(iD("x", e, t, n))];
                                case "LogSoftmax":
                                    return [ok(iD("x", e, t, n))];
                                case "SparseToDense":
                                    return [sI(iD("sparseIndices", e, t, n), iD("outputShape", e, t, n), iD("sparseValues", e, t, n), iD("defaultValue", e, t, n))];
                                default:
                                    throw TypeError("Node type " + e.op + " is not implemented")
                            }
                        }(e, t, n)
                    });
                case "reduction":
                    return rx(function () {
                        return function (e, t, n) {
                            switch (e.op) {
                                case "Max":
                                    var r = iD("axis", e, t, n),
                                        a = iD("keepDims", e, t, n);
                                    return [rk(iD("x", e, t, n), r, a)];
                                case "Mean":
                                    var i = iD("axis", e, t, n),
                                        o = iD("keepDims", e, t, n);
                                    return [Ik(iD("x", e, t, n), i, o)];
                                case "Min":
                                    var s = iD("axis", e, t, n),
                                        u = iD("keepDims", e, t, n);
                                    return [Sk(iD("x", e, t, n), s, u)];
                                case "Sum":
                                    var l = iD("axis", e, t, n),
                                        c = iD("keepDims", e, t, n);
                                    return [ik(iD("x", e, t, n), l, c)];
                                case "All":
                                    var p = iD("axis", e, t, n),
                                        h = iD("keepDims", e, t, n);
                                    return [vx(iD("x", e, t, n), p, h)];
                                case "Any":
                                    var f = iD("axis", e, t, n),
                                        d = iD("keepDims", e, t, n);
                                    return [gx(iD("x", e, t, n), f, d)];
                                case "ArgMax":
                                    var m = iD("axis", e, t, n);
                                    return [yx(iD("x", e, t, n), m)];
                                case "ArgMin":
                                    var v = iD("axis", e, t, n);
                                    return [bx(iD("x", e, t, n), v)];
                                case "Prod":
                                    var g = iD("axis", e, t, n),
                                        y = iD("keepDims", e, t, n);
                                    return [Kk(iD("x", e, t, n), g, y)];
                                case "Cumsum":
                                    var b = iD("axis", e, t, n),
                                        x = iD("exclusive", e, t, n),
                                        w = iD("reverse", e, t, n);
                                    return [dw(iD("x", e, t, n), b, x, w)];
                                case "Bincount":
                                    var k = iD("x", e, t, n),
                                        N = iD("weights", e, t, n),
                                        I = iD("size", e, t, n);
                                    return [Zx(k, N, I)];
                                case "DenseBincount":
                                    var S = iD("x", e, t, n),
                                        T = iD("weights", e, t, n),
                                        C = iD("size", e, t, n),
                                        E = iD("binaryOutput", e, t, n);
                                    return [mw(S, T, C, E)];
                                default:
                                    throw TypeError("Node type " + e.op + " is not implemented")
                            }
                        }(e, t, n)
                    });
                case "slice_join":
                    return rx(function () {
                        return function (e, t, n) {
                            switch (e.op) {
                                case "ConcatV2":
                                case "Concat":
                                    var r = iD("n", e, t, n),
                                        a = iD("axis", e, t, n),
                                        i = iD("tensors", e, t, n);
                                    return i = i.slice(0, r), [Vx(i, a)];
                                case "Gather":
                                    var o = iD("x", e, t, n),
                                        s = iD("indices", e, t, n);
                                    return [zw(o, Ky(s, "int32"), 0)];
                                case "GatherV2":
                                    var u = iD("axis", e, t, n),
                                        l = iD("batchDims", e, t, n),
                                        c = iD("x", e, t, n),
                                        p = iD("indices", e, t, n);
                                    return [zw(c, Ky(p, "int32"), u, l)];
                                case "Reverse":
                                    for (var h = iD("dims", e, t, n), f = [], d = 0; d < h.length; d++) h[d] && f.push(d);
                                    var m = iD("x", e, t, n);
                                    return [dN(m, f)];
                                case "ReverseV2":
                                    var v = iD("axis", e, t, n),
                                        g = iD("x", e, t, n);
                                    return [dN(g, v)];
                                case "Slice":
                                    var y = iD("begin", e, t, n),
                                        b = iD("size", e, t, n);
                                    return [Gx(iD("x", e, t, n), y, b)];
                                case "StridedSlice":
                                    var x = iD("begin", e, t, n),
                                        w = iD("end", e, t, n),
                                        k = iD("strides", e, t, n),
                                        N = iD("beginMask", e, t, n),
                                        I = iD("endMask", e, t, n),
                                        S = iD("ellipsisMask", e, t, n),
                                        T = iD("newAxisMask", e, t, n),
                                        C = iD("shrinkAxisMask", e, t, n),
                                        E = iD("x", e, t, n);
                                    return [jN(E, x, w, k, N, I, S, T, C)];
                                case "Pack":
                                    return rx(function () {
                                        var r = iD("axis", e, t, n),
                                            a = iD("tensors", e, t, n),
                                            i = a[0].shape,
                                            o = VN(a[0]).shape,
                                            s = a.map(function (e) {
                                                var t = sv(e.shape, i);
                                                if (!t && !sv(VN(e).shape, o)) throw new Error("the input tensors shape does not match");
                                                return t ? e : Px(e, i)
                                            });
                                        return [UN(s, r)]
                                    });
                                case "Unpack":
                                    var R = iD("axis", e, t, n),
                                        A = iD("tensor", e, t, n);
                                    return QN(A, R);
                                case "Tile":
                                    var F = iD("reps", e, t, n);
                                    return [Dw(iD("x", e, t, n), F)];
                                case "Split":
                                case "SplitV":
                                    var _ = iD("axis", e, t, n),
                                        D = iD("numOrSizeSplits", e, t, n),
                                        O = iD("x", e, t, n);
                                    return zN(O, D, _);
                                case "ScatterNd":
                                    var M = iD("indices", e, t, n),
                                        L = iD("values", e, t, n),
                                        z = iD("shape", e, t, n);
                                    return [oI(M, L, z)];
                                case "GatherNd":
                                    var P = iD("x", e, t, n),
                                        B = iD("indices", e, t, n);
                                    return [uI(P, B)];
                                case "SparseToDense":
                                    var W = iD("sparseIndices", e, t, n),
                                        V = iD("outputShape", e, t, n),
                                        U = iD("sparseValues", e, t, n),
                                        G = iD("defaultValue", e, t, n);
                                    return [sI(W, U, V, U.dtype === G.dtype ? G : Ky(G, U.dtype))];
                                default:
                                    throw TypeError("Node type " + e.op + " is not implemented")
                            }
                        }(e, t, n)
                    });
                case "spectral":
                    return rx(function () {
                        return function (e, t, n) {
                            switch (e.op) {
                                case "FFT":
                                    return [ON(iD("x", e, t, n))];
                                case "IFFT":
                                    return [MN(iD("x", e, t, n))];
                                case "RFFT":
                                    return [PN(iD("x", e, t, n))];
                                case "IRFFT":
                                    return [LN(iD("x", e, t, n))];
                                default:
                                    throw TypeError("Node type " + e.op + " is not implemented")
                            }
                        }(e, t, n)
                    });
                case "transformation":
                    return rx(function () {
                        return function (e, t, n) {
                            switch (e.op) {
                                case "Cast":
                                    return [Ky(iD("x", e, t, n), iD("dtype", e, t, n))];
                                case "ExpandDims":
                                    var r = iD("axis", e, t, n);
                                    return [Fw(iD("x", e, t, n), r)];
                                case "Squeeze":
                                    var a = iD("axis", e, t, n);
                                    return [VN(iD("x", e, t, n), a)];
                                case "Reshape":
                                    return [Px(iD("x", e, t, n), iD("shape", e, t, n))];
                                case "MirrorPad":
                                    return [Ck(iD("x", e, t, n), iD("padding", e, t, n), iD("mode", e, t, n))];
                                case "PadV2":
                                case "Pad":
                                    return [Pk(iD("x", e, t, n), iD("padding", e, t, n), iD("constantValue", e, t, n))];
                                case "SpaceToBatchND":
                                    var i = iD("blockShape", e, t, n),
                                        o = iD("paddings", e, t, n);
                                    return [Gk(iD("x", e, t, n), i, o)];
                                case "BatchToSpaceND":
                                    var s = iD("blockShape", e, t, n),
                                        u = iD("crops", e, t, n);
                                    return [qx(iD("x", e, t, n), s, u)];
                                case "DepthToSpace":
                                    var l = iD("blockSize", e, t, n),
                                        c = iD("dataFormat", e, t, n).toUpperCase();
                                    return [vw(iD("x", e, t, n), l, c)];
                                case "BroadcastTo":
                                    return [Qx(iD("x", e, t, n), iD("shape", e, t, n))];
                                default:
                                    throw TypeError("Node type " + e.op + " is not implemented")
                            }
                        }(e, t, n)
                    });
                case "hash_table":
                    return oO(e, t, n, r);
                case "custom":
                    var a = aD(e.op);
                    if (a && a.customExecutor) return a.customExecutor(new jD(e, t, n));
                    throw TypeError("Custom op " + e.op + " is not registered.");
                default:
                    throw TypeError("Unknown op '" + e.op + "'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()")
            }
        }(e, t, n);
        return zv(a) ? a.then(function (e) {
            return [].concat(e)
        }) : [].concat(a)
    }
    var uO = function () {
        function e(e, t, n, r) {
            void 0 === e && (e = {}), void 0 === t && (t = {}), void 0 === n && (n = {}), void 0 === r && (r = {}), this.weightMap = e, this.tensorArrayMap = t, this.tensorListMap = n, this.functionMap = r, this.rootContext = {
                id: 0,
                frameName: "",
                iterationId: 0
            }, this.contexts = [this.rootContext], this.lastId = 0, this.generateCurrentContextIds()
        }
        var t = e.prototype;
        return t.newFrame = function (e, t) {
            return {
                id: e,
                frameName: t,
                iterationId: 0
            }
        }, t.generateCurrentContextIds = function () {
            for (var e = [], t = 0; t < this.contexts.length - 1; t++) {
                var n = this.contexts.slice(0, this.contexts.length - t);
                e.push(this.contextIdforContexts(n))
            }
            e.push(""), this._currentContextIds = e
        }, t.contextIdforContexts = function (e) {
            return e ? e.map(function (e) {
                return 0 === e.id && 0 === e.iterationId ? "" : e.frameName + "-" + e.iterationId
            }).join("/") : ""
        }, t.enterFrame = function (e) {
            this.contexts && (this.lastId++, this.contexts = this.contexts.slice(), this.contexts.push(this.newFrame(this.lastId, e)), this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))
        }, t.exitFrame = function () {
            if (!(this.contexts && this.contexts.length > 1)) throw new Error("Cannot exit frame, the context is empty");
            this.contexts = this.contexts.slice(), this.contexts.splice(-1), this.currentContextIds.shift()
        }, t.nextIteration = function () {
            if (!(this.contexts && this.contexts.length > 0)) throw new Error("Cannot increase frame iteration, the context is empty");
            this.contexts = this.contexts.slice(), this.lastId++;
            var e = Object.assign({}, this.contexts[this.contexts.length - 1]);
            e.iterationId += 1, e.id = this.lastId, this.contexts.splice(-1, 1, e), this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts))
        }, t.getWeight = function (e) {
            return this.weightMap[e]
        }, t.addTensorArray = function (e) {
            this.tensorArrayMap[e.id] = e
        }, t.getTensorArray = function (e) {
            return this.tensorArrayMap[e]
        }, t.addTensorList = function (e) {
            this.tensorListMap[e.id] = e
        }, t.getTensorList = function (e) {
            return this.tensorListMap[e]
        }, t.dispose = function (e) {
            for (var t in this.tensorArrayMap) this.tensorArrayMap[t].clearAndClose(e);
            for (var n in this.tensorListMap) this.tensorListMap[n].clearAndClose(e)
        }, Wm(e, [{
            key: "currentContext",
            set: function (e) {
                this.contexts !== e && (this.contexts = e, this.generateCurrentContextIds())
            },
            get: function () {
                return this.contexts
            }
        }, {
            key: "currentContextId",
            get: function () {
                return this._currentContextIds[0]
            }
        }, {
            key: "currentContextIds",
            get: function () {
                return this._currentContextIds
            }
        }]), e
    }();

    function lO(e, t, n, r) {
        var a = new Set,
            i = [],
            o = null,
            s = null,
            u = new Set,
            l = Object.keys(e).map(function (e) {
                return lD(e)[0]
            }),
            c = [];
        null != r && (c = r.map(function (e) {
            return lD(e.name)[0]
        }));
        for (var p = [].concat(t); p.length > 0;) {
            var h = p.pop();
            (fO(h) || dO(h) || mO(h)) && null == o && (s = (o = h).children.map(function (e) {
                return e.name
            }).filter(function (e) {
                return a.has(e)
            })), a.add(h.name), null == n[h.name] && -1 === l.indexOf(h.name) && -1 === c.indexOf(h.name) && (0 !== h.inputs.length ? h.inputs.forEach(function (e) {
                u.has(e.name) || (u.add(e.name), p.push(e))
            }) : i.push(h.name))
        }
        return {
            inputs: e,
            outputs: t,
            usedNodes: a,
            missingInputs: i,
            dynamicNode: o,
            syncInputs: s
        }
    }
    var cO = ["Switch", "Merge", "Enter", "Exit", "NextIteration", "StatelessIf", "StatelessWhile", "if", "While"],
        pO = ["NonMaxSuppressionV2", "NonMaxSuppressionV3", "NonMaxSuppressionV5", "Where"],
        hO = ["HashTable", "HashTableV2", "LookupTableImport", "LookupTableImportV2", "LookupTableFind", "LookupTableFindV2", "LookupTableSize", "LookupTableSizeV2"];

    function fO(e) {
        return cO.indexOf(e.op) >= 0
    }

    function dO(e) {
        return pO.indexOf(e.op) >= 0
    }

    function mO(e) {
        return hO.indexOf(e.op) >= 0
    }
    var vO = function () {
            function e(t, n) {
                var r = this;
                this.graph = t, this.parent = n, this.compiledMap = new Map, this._weightMap = {}, this.SEPERATOR = ",", this._functions = {}, this._functionExecutorMap = {}, this._outputs = t.outputs, this._inputs = t.inputs, this._initNodes = t.initNodes, this._signature = t.signature, this._functions = t.functions, null != t.functions && Object.keys(t.functions).forEach(function (n) {
                    r._functionExecutorMap[n] = new e(t.functions[n], r)
                })
            }
            var t = e.prototype;
            return t.getCompilationKey = function (e, t) {
                var n = e.map(function (e) {
                        return e.name
                    }).sort(),
                    r = t.map(function (e) {
                        return e.name
                    }).sort();
                return n.join(this.SEPERATOR) + "--" + r.join(this.SEPERATOR)
            }, t.compile = function (e, t) {
                var n = lO(e, t, this.weightMap, this._initNodes),
                    r = n.missingInputs,
                    a = n.dynamicNode,
                    i = n.syncInputs;
                if (null != a) throw new Error("This execution contains the node '" + a.name + "', which has the dynamic op '" + a.op + "'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [" + i + "]");
                if (r.length > 0) {
                    var o = t.map(function (e) {
                            return e.name
                        }),
                        s = Object.keys(e);
                    throw new Error("Cannot compute the outputs [" + o + "] from the provided inputs [" + s + "]. Missing the following inputs: [" + r + "]")
                }
                return function (e, t, n) {
                    var r = n.usedNodes,
                        a = n.inputs,
                        i = [],
                        o = Object.keys(a).map(function (e) {
                            return lD(e)[0]
                        }).map(function (t) {
                            return e.nodes[t]
                        }),
                        s = e.initNodes;
                    o.forEach(function (e) {
                        r.has(e.name) && i.push(e)
                    }), e.weights.forEach(function (e) {
                        r.has(e.name) && i.push(e)
                    }), null != s && s.forEach(function (e) {
                        r.has(e.name) && i.push(e)
                    });
                    for (var u = new Set, l = []; i.length > 0;) {
                        var c = i.pop();
                        u.add(c.name), t[c.name] || l.push(c), c.children.forEach(function (e) {
                            !u.has(e.name) && r.has(e.name) && e.inputs.every(function (e) {
                                return u.has(e.name)
                            }) && i.push(e)
                        })
                    }
                    return l
                }(this.graph, this.weightMap, n)
            }, t.execute = function (e, t) {
                var n = this;
                e = this.mapInputs(e);
                var r = Object.keys(e).sort();
                this.checkInputs(e), this.checkInputShapeAndType(e), t = this.mapOutputs(t), this.checkOutputs(t);
                var a = r.map(function (e) {
                        return n.graph.nodes[lD(e)[0]]
                    }),
                    i = t.map(function (e) {
                        return lD(e)[0]
                    }),
                    o = i.map(function (e) {
                        return n.graph.nodes[e]
                    });
                0 === o.length && (o = this._outputs);
                var s = this.getCompilationKey(a, o),
                    u = this.compiledMap.get(s);
                null == u && (u = this.compile(e, o), this.compiledMap.set(s, u));
                var l = {},
                    c = {};
                return rx(function () {
                    var r = new uO(n.weightMap, l, c, n.functionExecutorMap),
                        a = Object.assign({}, n.weightMap);
                    Object.keys(e).forEach(function (t) {
                        var n = lD(t),
                            r = n[0],
                            i = [];
                        i[n[1]] = e[t], a[r] = i
                    });
                    for (var o = n.getFrozenTensorIds(a), s = {}, p = 0; p < u.length; p++) {
                        var h = u[p];
                        if (!a[h.name]) {
                            var f = sO(h, a, r, n._resourceManager);
                            if (zv(f)) throw new Error("The execution of the op '" + h.op + "' returned a promise. Please use model.executeAsync() instead.");
                            a[h.name] = f, n.checkTensorForDisposal(h.name, h, a, r, o, i, s)
                        }
                    }
                    return null == n.parent && r.dispose(o), t.map(function (e) {
                        return oD(e, a, r)
                    })
                })
            }, t.getFrozenTensorIds = function (e) {
                var t = [].concat.apply([], Object.keys(e).map(function (t) {
                    return e[t]
                }).map(function (e) {
                    return e.map(function (e) {
                        return e.id
                    })
                }));
                return new Set(t)
            }, t.checkTensorForDisposal = function (e, t, n, r, a, i, o) {
                "control" !== t.category && -1 === i.indexOf(e) && (n[e].forEach(function (e) {
                    null != e && (o[e.id] = (o[e.id] || 0) + t.children.length)
                }), t.inputs.forEach(function (e) {
                    if ("control" !== e.category) {
                        var t = function (e, t, n) {
                            return t[uD(e, r.currentContextId)]
                        }(e.name, n);
                        null != t && t.forEach(function (e) {
                            if (e && !a.has(e.id)) {
                                var t = o[e.id];
                                1 === t ? (e.dispose(), delete o[e.id]) : null != t && o[e.id]--
                            }
                        })
                    }
                }))
            }, t.executeAsync = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t, n) {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.abrupt("return", this._executeAsync(t, n));
                            case 1:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t, n) {
                    return e.apply(this, arguments)
                }
            }(), t._executeAsync = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t, n, r, a, i) {
                    var o, s, u, l, c, p;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return void 0 === r && (r = !1), void 0 === a && (a = {}), void 0 === i && (i = {}), r || (t = this.mapInputs(t), this.checkInputs(t), this.checkInputShapeAndType(t), n = this.mapOutputs(n), this.checkOutputs(n)), o = new uO(this.weightMap, a, i, this.functionExecutorMap), e.next = 7, this.executeWithControlFlow(t, o, n, r);
                            case 7:
                                return s = e.sent, u = n.map(function (e) {
                                    return oD(e, s, o)
                                }), l = u.map(function (e) {
                                    return e.id
                                }), c = Object.keys(t).map(function (e) {
                                    return t[e].id
                                }), p = new Set([].concat(l, c, this.weightIds)), Object.keys(s).forEach(function (e) {
                                    s[e].forEach(function (e) {
                                        !e || e.isDisposed || p.has(e.id) || e.dispose()
                                    })
                                }), null == this.parent && o.dispose(p), e.abrupt("return", u);
                            case 15:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t, n, r, a, i) {
                    return e.apply(this, arguments)
                }
            }(), t.executeFunctionAsync = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t, n, r) {
                    var a, i = this;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return a = t.reduce(function (e, t, n) {
                                    return e[i.inputs[n].name] = t, e
                                }, {}), e.abrupt("return", this._executeAsync(a, this.outputNodes, !0, n, r));
                            case 2:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t, n, r) {
                    return e.apply(this, arguments)
                }
            }(), t.executeWithControlFlow = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t, n, r, a) {
                    var i, o, s, u, l, c, p, h, f, d, m, v, g, y, b, x, w, k = this;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                i = Object.keys(t), o = i.map(function (e) {
                                    return k.graph.nodes[lD(e)[0]]
                                }), s = r.map(function (e) {
                                    return lD(e)[0]
                                }), 0 === (u = s.map(function (e) {
                                    return k.graph.nodes[e]
                                })).length && (u = this._outputs), l = lO(t, u, this.weightMap, this._initNodes), c = l.usedNodes, p = l.missingInputs, h = l.dynamicNode, f = l.syncInputs, d = [].concat(o, this.graph.weights, this._initNodes || []).map(function (e) {
                                    return {
                                        node: e,
                                        contexts: n.currentContext
                                    }
                                }), m = Object.assign({}, this.weightMap), Object.keys(t).forEach(function (e) {
                                    var n = lD(e),
                                        r = n[0],
                                        a = [];
                                    a[n[1]] = t[e], m[r] = a
                                }), v = {}, g = this.getFrozenTensorIds(m), y = {};
                            case 12:
                                if (!(d.length > 0)) {
                                    e.next = 18;
                                    break
                                }
                                return b = this.processStack(o, d, n, m, y, g, s, v, c), e.next = 16, Promise.all(b);
                            case 16:
                                e.next = 12;
                                break;
                            case 18:
                                if (null != h || a || console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead."), !((x = u.filter(function (e) {
                                        return !fO(e) && !oD(e.name, m, n)
                                    }).map(function (e) {
                                        return e.name
                                    })).length > 0)) {
                                    e.next = 24;
                                    break
                                }
                                throw w = "", null != h && (w = "Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [" + f + "]"), new Error("Cannot compute the outputs [" + x + "] from the provided inputs [" + i + "]. Consider providing the following inputs: [" + p + "]. " + w);
                            case 24:
                                return e.abrupt("return", m);
                            case 25:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t, n, r, a) {
                    return e.apply(this, arguments)
                }
            }(), t.processStack = function (e, t, n, r, a, i, o, s, u) {
                for (var l = this, c = [], p = function () {
                        var e = t.pop();
                        n.currentContext = e.contexts;
                        var p = "";
                        if ("Enter" === e.node.op && iD("isConstant", e.node, r, n)) {
                            var h = sD(e.node.name, n);
                            p = h[0]
                        }
                        if (null == r[e.node.name]) {
                            var f = sO(e.node, r, n, l._resourceManager);
                            if (!p) {
                                var d = sD(e.node.name, n);
                                p = d[0]
                            }
                            var m = n.currentContext;
                            zv(f) ? c.push(f.then(function (c) {
                                return r[p] = c, n.currentContext = m, l.checkTensorForDisposal(p, e.node, r, n, i, o, s), l.processChildNodes(e.node, t, n, r, a, u), c
                            })) : (r[p] = f, l.checkTensorForDisposal(p, e.node, r, n, i, o, s), l.processChildNodes(e.node, t, n, r, a, u))
                        } else l.processChildNodes(e.node, t, n, r, a, u)
                    }; t.length > 0;) p();
                return c
            }, t.processChildNodes = function (e, t, n, r, a, i) {
                e.children.forEach(function (e) {
                    var o = sD(e.name, n)[0];
                    !a[o] && i.has(e.name) && ("Merge" === e.op ? e.inputNames.some(function (e) {
                        return !!oD(e, r, n)
                    }) && (a[o] = !0, t.push({
                        contexts: n.currentContext,
                        node: e
                    })) : e.inputNames.every(function (e) {
                        return !!oD(e, r, n)
                    }) && (a[o] = !0, t.push({
                        contexts: n.currentContext,
                        node: e
                    })))
                })
            }, t.dispose = function () {
                var e = this;
                Object.keys(this.weightMap).forEach(function (t) {
                    return e.weightMap[t].forEach(function (e) {
                        return e.dispose()
                    })
                })
            }, t.checkInputShapeAndType = function (e) {
                var t = this;
                Object.keys(e).forEach(function (n) {
                    var r = e[n],
                        a = lD(n)[0],
                        i = t.graph.nodes[a];
                    if (i.attrParams.shape && i.attrParams.shape.value) {
                        var o = i.attrParams.shape.value;
                        nv(o.length === r.shape.length && r.shape.every(function (e, t) {
                            return -1 === o[t] || o[t] === e
                        }), function () {
                            return "The shape of dict['" + i.name + "'] provided in model.execute(dict) must be [" + o + "], but was [" + r.shape + "]"
                        })
                    }
                    i.attrParams.dtype && i.attrParams.dtype.value && nv(r.dtype === i.attrParams.dtype.value, function () {
                        return "The dtype of dict['" + i.name + "'] provided in model.execute(dict) must be " + i.attrParams.dtype.value + ", but was " + r.dtype
                    })
                })
            }, t.mapInputs = function (e) {
                var t = {};
                for (var n in e) null != this._signature && null != this._signature.inputs && null != this._signature.inputs[n] ? t[this._signature.inputs[n].name] = e[n] : t[n] = e[n];
                return t
            }, t.checkInputs = function (e) {
                var t = this,
                    n = Object.keys(e).filter(function (e) {
                        var n = lD(e)[0];
                        return null == t.graph.nodes[n]
                    });
                if (n.length > 0) throw new Error("The dict provided in model.execute(dict) has keys: [" + n + "] that are not part of graph")
            }, t.mapOutputs = function (e) {
                var t = this;
                return e.map(function (e) {
                    return null != t._signature && null != t._signature.outputs && null != t._signature.outputs[e] ? t._signature.outputs[e].name : e
                }, {})
            }, t.checkOutputs = function (e) {
                var t = this;
                e.forEach(function (e) {
                    var n = lD(e)[0];
                    if (!t.graph.nodes[n]) throw new Error("The output '" + e + "' is not found in the graph")
                })
            }, Wm(e, [{
                key: "weightIds",
                get: function () {
                    return this.parent ? this.parent.weightIds : this._weightIds
                }
            }, {
                key: "functionExecutorMap",
                get: function () {
                    return this.parent ? this.parent.functionExecutorMap : this._functionExecutorMap
                }
            }, {
                key: "weightMap",
                get: function () {
                    return this.parent ? this.parent.weightMap : this._weightMap
                },
                set: function (e) {
                    var t, n = Object.keys(e).map(function (t) {
                        return e[t].map(function (e) {
                            return e.id
                        })
                    });
                    this._weightIds = (t = []).concat.apply(t, n), this._weightMap = e
                }
            }, {
                key: "resourceManager",
                set: function (e) {
                    this._resourceManager = e
                }
            }, {
                key: "inputs",
                get: function () {
                    return this._inputs.map(function (e) {
                        return {
                            name: e.name,
                            shape: e.attrParams.shape ? e.attrParams.shape.value : void 0,
                            dtype: e.attrParams.dtype ? e.attrParams.dtype.value : void 0
                        }
                    })
                }
            }, {
                key: "outputs",
                get: function () {
                    return this._outputs.map(function (e) {
                        return {
                            name: e.name,
                            shape: e.attrParams.shape ? e.attrParams.shape.value : void 0,
                            dtype: e.attrParams.dtype ? e.attrParams.dtype.value : void 0
                        }
                    })
                }
            }, {
                key: "inputNodes",
                get: function () {
                    return this._inputs.map(function (e) {
                        return e.signatureKey || e.name
                    })
                }
            }, {
                key: "outputNodes",
                get: function () {
                    return this._outputs.map(function (e) {
                        var t = e.signatureKey || e.name;
                        return e.defaultOutput ? t + ":" + e.defaultOutput : t
                    })
                }
            }, {
                key: "functions",
                get: function () {
                    var e = this;
                    return Object.keys(this._functions).reduce(function (t, n) {
                        return t[n] = e._functions[n].signature, t
                    }, {})
                }
            }]), e
        }(),
        gO = function () {
            function e(e, t) {
                void 0 === e && (e = {}), void 0 === t && (t = {}), this.hashTableNameToHandle = e, this.hashTableMap = t
            }
            var t = e.prototype;
            return t.addHashTable = function (e, t) {
                this.hashTableNameToHandle[e] = t.handle, this.hashTableMap[t.id] = t
            }, t.getHashTableHandleByName = function (e) {
                return this.hashTableNameToHandle[e]
            }, t.getHashTableById = function (e) {
                return this.hashTableMap[e]
            }, t.dispose = function () {
                for (var e in this.hashTableMap) this.hashTableMap[e].clearAndClose(), delete this.hashTableMap[e];
                for (var t in this.hashTableNameToHandle) this.hashTableNameToHandle[t].dispose(), delete this.hashTableNameToHandle[t]
            }, e
        }(),
        yO = function () {
            function e(e, t) {
                void 0 === t && (t = {}), this.modelUrl = e, this.loadOptions = t, this.version = "n/a", null == t && (this.loadOptions = {}), this.resourceManager = new gO
            }
            var t = e.prototype;
            return t.findIOHandler = function () {
                var e = this.modelUrl;
                if (null != e.load) this.handler = e;
                else if (null != this.loadOptions.requestInit) this.handler = ub(e, this.loadOptions);
                else {
                    var t = gy(e, this.loadOptions);
                    if (0 === t.length) t.push(ub(e, this.loadOptions));
                    else if (t.length > 1) throw new Error("Found more than one (" + t.length + ") load handlers for URL '" + [e] + "'");
                    this.handler = t[0]
                }
            }, t.load = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (this.findIOHandler(), null != this.handler.load) {
                                    e.next = 3;
                                    break
                                }
                                throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
                            case 3:
                                return e.next = 5, this.handler.load();
                            case 5:
                                return t = e.sent, e.abrupt("return", this.loadSync(t));
                            case 7:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t.loadSync = function (e) {
                this.artifacts = e;
                var t, n = this.artifacts.modelTopology;
                t = null != this.artifacts.userDefinedMetadata && null != this.artifacts.userDefinedMetadata.signature ? this.artifacts.userDefinedMetadata.signature : this.artifacts.signature, this.signature = t, this.version = n.versions.producer + "." + n.versions.minConsumer;
                var r = iy(this.artifacts.weightData, this.artifacts.weightSpecs);
                if (this.executor = new vO(RD.Instance.transformGraph(n, this.signature)), this.executor.weightMap = this.convertTensorMapToTensorsMap(r), this.executor.resourceManager = this.resourceManager, null != e.modelInitializer && null != e.modelInitializer.node) {
                    var a = RD.Instance.transformGraph(e.modelInitializer);
                    this.initializer = new vO(a), this.initializer.weightMap = this.executor.weightMap, this.initializer.resourceManager = this.resourceManager, this.initializer.executeAsync({}, [])
                }
                return !0
            }, t.save = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t, n) {
                    var r;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if ("string" != typeof t) {
                                    e.next = 9;
                                    break
                                }
                                if (0 !== (r = vy(t)).length) {
                                    e.next = 6;
                                    break
                                }
                                throw new Error("Cannot find any save handlers for URL '" + t + "'");
                            case 6:
                                if (!(r.length > 1)) {
                                    e.next = 8;
                                    break
                                }
                                throw new Error("Found more than one (" + r.length + ") save handlers for URL '" + t + "'");
                            case 8:
                                t = r[0];
                            case 9:
                                if (null != t.save) {
                                    e.next = 11;
                                    break
                                }
                                throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
                            case 11:
                                return e.abrupt("return", t.save(this.artifacts));
                            case 12:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t, n) {
                    return e.apply(this, arguments)
                }
            }(), t.predict = function (e, t) {
                return this.execute(e, this.outputNodes)
            }, t.normalizeInputs = function (e) {
                if (!(e instanceof Ng || Array.isArray(e))) return e;
                if ((e = Array.isArray(e) ? e : [e]).length !== this.inputNodes.length) throw new Error("Input tensor count mismatch,the graph model has " + this.inputNodes.length + " placeholders, while there are " + e.length + " input tensors.");
                return this.inputNodes.reduce(function (t, n, r) {
                    return t[n] = e[r], t
                }, {})
            }, t.normalizeOutputs = function (e) {
                return e = e || this.outputNodes, Array.isArray(e) ? e : [e]
            }, t.execute = function (e, t) {
                e = this.normalizeInputs(e), t = this.normalizeOutputs(t);
                var n = this.executor.execute(e, t);
                return n.length > 1 ? n : n[0]
            }, t.executeAsync = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t, n) {
                    var r;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return t = this.normalizeInputs(t), n = this.normalizeOutputs(n), e.next = 4, this.executor.executeAsync(t, n);
                            case 4:
                                return r = e.sent, e.abrupt("return", r.length > 1 ? r : r[0]);
                            case 6:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t, n) {
                    return e.apply(this, arguments)
                }
            }(), t.convertTensorMapToTensorsMap = function (e) {
                return Object.keys(e).reduce(function (t, n) {
                    return t[n] = [e[n]], t
                }, {})
            }, t.dispose = function () {
                this.executor.dispose(), this.initializer && this.initializer.dispose(), this.resourceManager.dispose()
            }, Wm(e, [{
                key: "modelVersion",
                get: function () {
                    return this.version
                }
            }, {
                key: "inputNodes",
                get: function () {
                    return this.executor.inputNodes
                }
            }, {
                key: "outputNodes",
                get: function () {
                    return this.executor.outputNodes
                }
            }, {
                key: "inputs",
                get: function () {
                    return this.executor.inputs
                }
            }, {
                key: "outputs",
                get: function () {
                    return this.executor.outputs
                }
            }, {
                key: "weights",
                get: function () {
                    return this.executor.weightMap
                }
            }, {
                key: "metadata",
                get: function () {
                    return this.artifacts.userDefinedMetadata
                }
            }, {
                key: "modelSignature",
                get: function () {
                    return this.signature
                }
            }]), e
        }();

    function bO() {
        return (bO = Pm(regeneratorRuntime.mark(function e(t, n) {
            var r;
            return regeneratorRuntime.wrap(function (e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        if (void 0 === n && (n = {}), null != t) {
                            e.next = 3;
                            break
                        }
                        throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");
                    case 3:
                        return null == n && (n = {}), n.fromTFHub && null == t.load && (t.endsWith("/") || (t += "/"), t += "model.json?tfjs-format=file"), r = new yO(t, n), e.next = 8, r.load();
                    case 8:
                        return e.abrupt("return", r);
                    case 9:
                    case "end":
                        return e.stop()
                }
            }, e)
        }))).apply(this, arguments)
    }

    function xO(e, t, n, r) {
        if (void 0 === n && (n = new Map), void 0 === r && (r = new Set), null == e) return null;
        if (r.has(e)) throw new Error("Circular references are not supported.");
        if (n.has(e)) return n.get(e);
        var a = t(e);
        if (a.recurse && null !== a.value) throw new Error("A deep map function may not return both a value and recurse=true.");
        if (a.recurse) {
            if (NO(e)) {
                var i = Array.isArray(e) ? [] : {};
                for (var o in r.add(e), e) {
                    var s = xO(e[o], t, n, r);
                    i[o] = s
                }
                return r.delete(e), i
            }
            throw new Error("Can't recurse into non-iterable type: " + e)
        }
        return n.set(e, a.value), a.value
    }

    function wO(e) {
        return null === e ? null : NO(e[0]) ? {
            value: null,
            recurse: !0
        } : {
            value: e,
            recurse: !1
        }
    }

    function kO(e, t) {
        return function () {
            return Pm(regeneratorRuntime.mark(function e(t, n) {
                var r, a, i, o, s, u, l;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            r = new Map, xO(t, n, r), a = 0, i = Array.from(r.keys());
                        case 3:
                            if (!(a < i.length)) {
                                e.next = 14;
                                break
                            }
                            if (o = i[a], !zv(s = r.get(o))) {
                                e.next = 11;
                                break
                            }
                            return e.next = 9, s;
                        case 9:
                            u = e.sent, r.set(o, u);
                        case 11:
                            a++, e.next = 3;
                            break;
                        case 14:
                            return l = xO(t, n, r), e.abrupt("return", l);
                        case 16:
                        case "end":
                            return e.stop()
                    }
                }, e)
            })).apply(this, arguments)
        }.apply(this, arguments)
    }

    function NO(e) {
        return null != e && !ArrayBuffer.isView(e) && (Array.isArray(e) || "object" == typeof e && !(e instanceof Ng))
    }

    function IO(e) {
        return function (e, t) {
            return xO(e, SO)
        }(e)
    }

    function SO(e) {
        return e instanceof Ng ? {
            value: e.clone(),
            recurse: !1
        } : NO(e) ? {
            value: null,
            recurse: !0
        } : {
            value: e,
            recurse: !1
        }
    }
    var TO = function () {
            function e(e) {
                if (this.capacity = e, this.begin = 0, this.end = 0, null == e) throw new RangeError("Can't create a ring buffer of unknown capacity.");
                if (e < 1) throw new RangeError("Can't create ring buffer of capacity < 1.");
                this.data = new Array(e), this.doubledCapacity = 2 * e
            }
            var t = e.prototype;
            return t.wrap = function (e) {
                for (; e < 0;) e += this.doubledCapacity;
                return e % this.doubledCapacity
            }, t.get = function (e) {
                if (e < 0) throw new RangeError("Can't get item at a negative index.");
                return this.data[e % this.capacity]
            }, t.set = function (e, t) {
                if (e < 0) throw new RangeError("Can't set item at a negative index.");
                this.data[e % this.capacity] = t
            }, t.length = function () {
                var e = this.end - this.begin;
                return e < 0 && (e = this.doubledCapacity + e), e
            }, t.isFull = function () {
                return this.length() === this.capacity
            }, t.isEmpty = function () {
                return 0 === this.length()
            }, t.push = function (e) {
                if (this.isFull()) throw new RangeError("Ring buffer is full.");
                this.set(this.end, e), this.end = this.wrap(this.end + 1)
            }, t.pushAll = function (e) {
                for (var t, n = Xm(e); !(t = n()).done;) {
                    var r = t.value;
                    this.push(r)
                }
            }, t.pop = function () {
                if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
                this.end = this.wrap(this.end - 1);
                var e = this.get(this.end);
                return this.set(this.end, void 0), e
            }, t.unshift = function (e) {
                if (this.isFull()) throw new RangeError("Ring buffer is full.");
                this.begin = this.wrap(this.begin - 1), this.set(this.begin, e)
            }, t.shift = function () {
                if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
                var e = this.get(this.begin);
                return this.set(this.begin, void 0), this.begin = this.wrap(this.begin + 1), e
            }, t.shuffleExcise = function (e) {
                if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
                var t = this.wrap(this.begin + e),
                    n = this.get(t);
                return this.set(t, this.pop()), n
            }, e
        }(),
        CO = function (e) {
            function t() {
                return e.call(this, t.INITIAL_CAPACITY) || this
            }
            Vm(t, e);
            var n = t.prototype;
            return n.isFull = function () {
                return !1
            }, n.push = function (t) {
                e.prototype.isFull.call(this) && this.expand(), e.prototype.push.call(this, t)
            }, n.unshift = function (t) {
                e.prototype.isFull.call(this) && this.expand(), e.prototype.unshift.call(this, t)
            }, n.expand = function () {
                for (var e = 2 * this.capacity, t = new Array(e), n = this.length(), r = 0; r < n; r++) t[r] = this.get(this.wrap(this.begin + r));
                this.data = t, this.capacity = e, this.doubledCapacity = 2 * this.capacity, this.begin = 0, this.end = n
            }, t
        }(TO);

    function EO(e) {
        return new OO(e)
    }

    function RO(e) {
        return new MO(e)
    }

    function AO(e, t) {
        return new qO(e, t)
    }

    function FO(e, t) {
        return void 0 === t && (t = _O.FAIL), new KO(e, t)
    }
    CO.INITIAL_CAPACITY = 32;
    var _O, DO = function () {
            function e() {}
            var t = e.prototype;
            return t.toArray = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t, n;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return t = [], e.next = 3, this.next();
                            case 3:
                                n = e.sent;
                            case 4:
                                if (n.done) {
                                    e.next = 11;
                                    break
                                }
                                return t.push(n.value), e.next = 8, this.next();
                            case 8:
                                n = e.sent, e.next = 4;
                                break;
                            case 11:
                                return e.abrupt("return", t);
                            case 12:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t.toArrayForTest = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t, n, r;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return t = this.prefetch(100), n = [], e.next = 4, t.next();
                            case 4:
                                r = e.sent;
                            case 5:
                                if (r.done) {
                                    e.next = 12;
                                    break
                                }
                                return n.push(r.value), e.next = 9, t.next();
                            case 9:
                                r = e.sent, e.next = 5;
                                break;
                            case 12:
                                return e.abrupt("return", n);
                            case 13:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t.resolveFully = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.next();
                            case 2:
                                t = e.sent;
                            case 3:
                                if (t.done) {
                                    e.next = 9;
                                    break
                                }
                                return e.next = 6, this.next();
                            case 6:
                                t = e.sent, e.next = 3;
                                break;
                            case 9:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t.resolveWhile = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    var n, r;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.next();
                            case 2:
                                n = e.sent, r = t(n.value);
                            case 4:
                                if (n.done || !r) {
                                    e.next = 11;
                                    break
                                }
                                return e.next = 7, this.next();
                            case 7:
                                n = e.sent, r = t(n.value), e.next = 4;
                                break;
                            case 11:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), t.handleErrors = function (e) {
                return new UO(this, e)
            }, t.filter = function (e) {
                return new WO(this, e)
            }, t.map = function (e) {
                return new VO(this, e)
            }, t.mapAsync = function (e) {
                return new GO(this, e)
            }, t.serialMapAsync = function (e) {
                return new GO(this, e).serial()
            }, t.flatmap = function (e) {
                return new HO(this, e)
            }, t.forEachAsync = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.abrupt("return", this.map(t).resolveFully());
                            case 1:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), t.serialForEach = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.abrupt("return", this.serialMapAsync(t).resolveWhile(function (e) {
                                    return !0 === e
                                }));
                            case 1:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), t.rowMajorBatch = function (e, t) {
                return void 0 === t && (t = !0), new BO(this, e, t)
            }, t.columnMajorBatch = function (e, t, n) {
                return void 0 === t && (t = !0), void 0 === n && (n = wO), this.rowMajorBatch(e, t).map(function (e) {
                    return function (e, t) {
                        return void 0 === t && (t = wO),
                            function e(t, n, r) {
                                void 0 === r && (r = new Set);
                                var a = t[0];
                                if (r.has(a)) throw new Error("Circular references are not supported.");
                                var i = n(t);
                                if (i.recurse && null !== i.value) throw new Error("A deep zip function may not return both a value and recurse=true.");
                                if (i.recurse) {
                                    if (NO(a)) {
                                        var o = Array.isArray(a) ? [] : {};
                                        r.add(a);
                                        var s = function (a) {
                                            var i = t.map(function (e) {
                                                    return e[a]
                                                }),
                                                s = e(i, n, r);
                                            o[a] = s
                                        };
                                        for (var u in a) s(u);
                                        return r.delete(a), o
                                    }
                                    throw new Error("Can't recurse into non-iterable type: " + a)
                                }
                                return i.value
                            }(e, t)
                    }(e, n)
                })
            }, t.concatenate = function (e, t) {
                return new qO(EO([this, e]), t)
            }, t.take = function (e) {
                return e < 0 || null == e ? this : new PO(this, e)
            }, t.skip = function (e) {
                return e < 0 || null == e ? this : new zO(this, e)
            }, t.prefetch = function (e) {
                return new XO(this, e)
            }, t.shuffle = function (e, t) {
                return new YO(this, e, t)
            }, t.serial = function () {
                return new LO(this)
            }, e
        }(),
        OO = function (e) {
            function t(t) {
                var n;
                return (n = e.call(this) || this).items = t, n.trav = 0, n
            }
            Vm(t, e);
            var n = t.prototype;
            return n.summary = function () {
                return "Array of " + this.items.length + " items"
            }, n.next = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (!(this.trav >= this.items.length)) {
                                    e.next = 2;
                                    break
                                }
                                return e.abrupt("return", {
                                    value: null,
                                    done: !0
                                });
                            case 2:
                                return t = this.items[this.trav], this.trav++, e.abrupt("return", {
                                    value: IO(t),
                                    done: !1
                                });
                            case 5:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t
        }(DO),
        MO = function (e) {
            function t(t) {
                var n;
                return (n = e.call(this) || this).nextFn = t, n
            }
            Vm(t, e);
            var n = t.prototype;
            return n.summary = function () {
                return "Function call"
            }, n.next = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.prev = 0, e.abrupt("return", this.nextFn());
                            case 4:
                                throw e.prev = 4, e.t0 = e.catch(0), e.t0.message = "Error thrown while iterating through a dataset: " + e.t0.message, e.t0;
                            case 8:
                            case "end":
                                return e.stop()
                        }
                    }, e, this, [
                        [0, 4]
                    ])
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t
        }(DO),
        LO = function (e) {
            function t(t) {
                var n;
                return (n = e.call(this) || this).upstream = t, n.lastRead = Promise.resolve({
                    value: null,
                    done: !1
                }), n
            }
            Vm(t, e);
            var n = t.prototype;
            return n.summary = function () {
                return this.upstream.summary() + " -> Serial"
            }, n.next = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t = this;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return this.lastRead = this.lastRead.then(function () {
                                    return t.serialNext()
                                }), e.abrupt("return", this.lastRead);
                            case 2:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), n.serialNext = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.abrupt("return", this.upstream.next());
                            case 1:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t
        }(DO),
        zO = function (e) {
            function t(t, n) {
                var r;
                return (r = e.call(this) || this).upstream = t, r.maxCount = n, r.count = 0, r.lastRead = Promise.resolve({
                    value: null,
                    done: !1
                }), r
            }
            Vm(t, e);
            var n = t.prototype;
            return n.summary = function () {
                return this.upstream.summary() + " -> Skip"
            }, n.next = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t = this;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return this.lastRead = this.lastRead.then(function () {
                                    return t.serialNext()
                                }), e.abrupt("return", this.lastRead);
                            case 2:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), n.serialNext = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (!(this.count++ < this.maxCount)) {
                                    e.next = 9;
                                    break
                                }
                                return e.next = 3, this.upstream.next();
                            case 3:
                                if (!(t = e.sent).done) {
                                    e.next = 6;
                                    break
                                }
                                return e.abrupt("return", t);
                            case 6:
                                ax(t.value), e.next = 0;
                                break;
                            case 9:
                                return e.abrupt("return", this.upstream.next());
                            case 10:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t
        }(DO),
        PO = function (e) {
            function t(t, n) {
                var r;
                return (r = e.call(this) || this).upstream = t, r.maxCount = n, r.count = 0, r
            }
            Vm(t, e);
            var n = t.prototype;
            return n.summary = function () {
                return this.upstream.summary() + " -> Take"
            }, n.next = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (!(this.count++ >= this.maxCount)) {
                                    e.next = 2;
                                    break
                                }
                                return e.abrupt("return", {
                                    value: null,
                                    done: !0
                                });
                            case 2:
                                return e.abrupt("return", this.upstream.next());
                            case 3:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t
        }(DO),
        BO = function (e) {
            function t(t, n, r) {
                var a;
                return void 0 === r && (r = !0), (a = e.call(this) || this).upstream = t, a.batchSize = n, a.enableSmallLastBatch = r, a.lastRead = Promise.resolve({
                    value: null,
                    done: !1
                }), a
            }
            Vm(t, e);
            var n = t.prototype;
            return n.summary = function () {
                return this.upstream.summary() + " -> RowMajorBatch"
            }, n.next = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t = this;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return this.lastRead = this.lastRead.then(function () {
                                    return t.serialNext()
                                }), e.abrupt("return", this.lastRead);
                            case 2:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), n.serialNext = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t, n;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                t = [];
                            case 1:
                                if (!(t.length < this.batchSize)) {
                                    e.next = 12;
                                    break
                                }
                                return e.next = 4, this.upstream.next();
                            case 4:
                                if (!(n = e.sent).done) {
                                    e.next = 9;
                                    break
                                }
                                if (!(this.enableSmallLastBatch && t.length > 0)) {
                                    e.next = 8;
                                    break
                                }
                                return e.abrupt("return", {
                                    value: t,
                                    done: !1
                                });
                            case 8:
                                return e.abrupt("return", {
                                    value: null,
                                    done: !0
                                });
                            case 9:
                                t.push(n.value), e.next = 1;
                                break;
                            case 12:
                                return e.abrupt("return", {
                                    value: t,
                                    done: !1
                                });
                            case 13:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t
        }(DO),
        WO = function (e) {
            function t(t, n) {
                var r;
                return (r = e.call(this) || this).upstream = t, r.predicate = n, r.lastRead = Promise.resolve({
                    value: null,
                    done: !1
                }), r
            }
            Vm(t, e);
            var n = t.prototype;
            return n.summary = function () {
                return this.upstream.summary() + " -> Filter"
            }, n.next = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t = this;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return this.lastRead = this.lastRead.then(function () {
                                    return t.serialNext()
                                }), e.abrupt("return", this.lastRead);
                            case 2:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), n.serialNext = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 3, this.upstream.next();
                            case 3:
                                if (!(t = e.sent).done && !this.predicate(t.value)) {
                                    e.next = 6;
                                    break
                                }
                                return e.abrupt("return", t);
                            case 6:
                                ax(t.value), e.next = 0;
                                break;
                            case 9:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t
        }(DO),
        VO = function (e) {
            function t(t, n) {
                var r;
                return (r = e.call(this) || this).upstream = t, r.transform = n, r
            }
            Vm(t, e);
            var n = t.prototype;
            return n.summary = function () {
                return this.upstream.summary() + " -> Map"
            }, n.next = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t, n, r, a, i, o, s;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.upstream.next();
                            case 2:
                                if (!(t = e.sent).done) {
                                    e.next = 5;
                                    break
                                }
                                return e.abrupt("return", {
                                    value: null,
                                    done: !0
                                });
                            case 5:
                                for (n = zg(t.value), r = this.transform(t.value), a = zg(r), i = Xm(n); !(o = i()).done;) Lg(s = o.value, a) || s.dispose();
                                return e.abrupt("return", {
                                    value: r,
                                    done: !1
                                });
                            case 10:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t
        }(DO),
        UO = function (e) {
            function t(t, n) {
                var r;
                return (r = e.call(this) || this).upstream = t, r.handler = n, r.count = 0, r.lastRead = Promise.resolve({
                    value: null,
                    done: !1
                }), r
            }
            Vm(t, e);
            var n = t.prototype;
            return n.summary = function () {
                return this.upstream.summary() + " -> handleErrors"
            }, n.next = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t = this;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return this.lastRead = this.lastRead.then(function () {
                                    return t.serialNext()
                                }), e.abrupt("return", this.lastRead);
                            case 2:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), n.serialNext = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.prev = 1, e.next = 4, this.upstream.next();
                            case 4:
                                return e.abrupt("return", e.sent);
                            case 7:
                                if (e.prev = 7, e.t0 = e.catch(1), this.handler(e.t0)) {
                                    e.next = 11;
                                    break
                                }
                                return e.abrupt("return", {
                                    value: null,
                                    done: !0
                                });
                            case 11:
                                e.next = 0;
                                break;
                            case 13:
                            case "end":
                                return e.stop()
                        }
                    }, e, this, [
                        [1, 7]
                    ])
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t
        }(DO),
        GO = function (e) {
            function t(t, n) {
                var r;
                return (r = e.call(this) || this).upstream = t, r.transform = n, r
            }
            Vm(t, e);
            var n = t.prototype;
            return n.summary = function () {
                return this.upstream.summary() + " -> AsyncMap"
            }, n.next = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t, n, r, a, i, o, s;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.upstream.next();
                            case 2:
                                if (!(t = e.sent).done) {
                                    e.next = 5;
                                    break
                                }
                                return e.abrupt("return", {
                                    value: null,
                                    done: !0
                                });
                            case 5:
                                return n = zg(t.value), e.next = 8, this.transform(t.value);
                            case 8:
                                for (r = e.sent, a = zg(r), i = Xm(n); !(o = i()).done;) Lg(s = o.value, a) || s.dispose();
                                return e.abrupt("return", {
                                    value: r,
                                    done: !1
                                });
                            case 12:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t
        }(DO),
        jO = function (e) {
            function t() {
                var t;
                return (t = e.call(this) || this).outputQueue = new CO, t.lastRead = Promise.resolve({
                    value: null,
                    done: !1
                }), t
            }
            Vm(t, e);
            var n = t.prototype;
            return n.next = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t = this;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return this.lastRead = this.lastRead.then(function () {
                                    return t.serialNext()
                                }), e.abrupt("return", this.lastRead);
                            case 2:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), n.serialNext = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (0 !== this.outputQueue.length()) {
                                    e.next = 7;
                                    break
                                }
                                return e.next = 3, this.pump();
                            case 3:
                                if (e.sent) {
                                    e.next = 5;
                                    break
                                }
                                return e.abrupt("return", {
                                    value: null,
                                    done: !0
                                });
                            case 5:
                                e.next = 0;
                                break;
                            case 7:
                                return e.abrupt("return", {
                                    value: this.outputQueue.shift(),
                                    done: !1
                                });
                            case 8:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t
        }(DO),
        HO = function (e) {
            function t(t, n) {
                var r;
                return (r = e.call(this) || this).upstream = t, r.transform = n, r
            }
            Vm(t, e);
            var n = t.prototype;
            return n.summary = function () {
                return this.upstream.summary() + " -> Flatmap"
            }, n.pump = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t, n, r, a, i, o, s;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.upstream.next();
                            case 2:
                                if (!(t = e.sent).done) {
                                    e.next = 5;
                                    break
                                }
                                return e.abrupt("return", !1);
                            case 5:
                                for (n = zg(t.value), r = this.transform(t.value), a = zg(r), this.outputQueue.pushAll(r), i = Xm(n); !(o = i()).done;) Lg(s = o.value, a) || s.dispose();
                                return e.abrupt("return", !0);
                            case 11:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t
        }(jO),
        qO = function (e) {
            function t(t, n) {
                var r;
                return (r = e.call(this) || this).baseErrorHandler = n, r.lastRead = null, r.iterator = null, r.moreIterators = t, r
            }
            Vm(t, e);
            var n = t.prototype;
            return n.summary = function () {
                return "TODO: fill in upstream of chained summaries -> Chained"
            }, n.next = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return this.lastRead = this.readFromChain(this.lastRead), e.abrupt("return", this.lastRead);
                            case 2:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), n.readFromChain = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    var n, r;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, t;
                            case 2:
                                if (null != this.iterator) {
                                    e.next = 10;
                                    break
                                }
                                return e.next = 5, this.moreIterators.next();
                            case 5:
                                if (!(n = e.sent).done) {
                                    e.next = 8;
                                    break
                                }
                                return e.abrupt("return", {
                                    value: null,
                                    done: !0
                                });
                            case 8:
                                this.iterator = n.value, null != this.baseErrorHandler && (this.iterator = this.iterator.handleErrors(this.baseErrorHandler));
                            case 10:
                                return e.next = 12, this.iterator.next();
                            case 12:
                                if (!(r = e.sent).done) {
                                    e.next = 16;
                                    break
                                }
                                return this.iterator = null, e.abrupt("return", this.readFromChain(t));
                            case 16:
                                return e.abrupt("return", r);
                            case 17:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), t
        }(DO);
    ! function (e) {
        e[e.FAIL = 0] = "FAIL", e[e.SHORTEST = 1] = "SHORTEST", e[e.LONGEST = 2] = "LONGEST"
    }(_O || (_O = {}));
    var KO = function (e) {
            function t(t, n) {
                var r;
                return void 0 === n && (n = _O.FAIL), (r = e.call(this) || this).iterators = t, r.mismatchMode = n, r.count = 0, r.currentPromise = null, r
            }
            Vm(t, e);
            var n = t.prototype;
            return n.summary = function () {
                return "{TODO: fill in upstream of zip summaries} -> Zip"
            }, n.nextState = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    var n, r, a, i;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return a = function (e) {
                                    return e instanceof DO ? {
                                        value: e.next().then(function (e) {
                                            return n++, e.done && r++, e.value
                                        }),
                                        recurse: !1
                                    } : {
                                        value: null,
                                        recurse: !0
                                    }
                                }, e.next = 3, t;
                            case 3:
                                return n = 0, r = 0, e.next = 7, kO(this.iterators, a);
                            case 7:
                                if (i = e.sent, n !== r) {
                                    e.next = 10;
                                    break
                                }
                                return e.abrupt("return", {
                                    value: null,
                                    done: !0
                                });
                            case 10:
                                if (!(r > 0)) {
                                    e.next = 16;
                                    break
                                }
                                e.t0 = this.mismatchMode, e.next = e.t0 === _O.FAIL ? 14 : e.t0 === _O.SHORTEST ? 15 : (e.t0, _O.LONGEST, 16);
                                break;
                            case 14:
                                throw new Error("Zipped streams should have the same length. Mismatched at element " + this.count + ".");
                            case 15:
                                return e.abrupt("return", {
                                    value: null,
                                    done: !0
                                });
                            case 16:
                                return this.count++, e.abrupt("return", {
                                    value: i,
                                    done: !1
                                });
                            case 18:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), n.next = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return this.currentPromise = this.nextState(this.currentPromise), e.abrupt("return", this.currentPromise);
                            case 2:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t
        }(DO),
        XO = function (e) {
            function t(t, n) {
                var r;
                return (r = e.call(this) || this).upstream = t, r.bufferSize = n, r.buffer = new TO(n), r
            }
            Vm(t, e);
            var n = t.prototype;
            return n.summary = function () {
                return this.upstream.summary() + " -> Prefetch"
            }, n.refill = function () {
                for (; !this.buffer.isFull();) {
                    var e = this.upstream.next();
                    this.buffer.push(e)
                }
            }, n.next = function () {
                return this.refill(), this.buffer.shift()
            }, t
        }(DO),
        YO = function (e) {
            function t(t, n, r) {
                var a;
                return (a = e.call(this, t, n) || this).upstream = t, a.windowSize = n, a.upstreamExhausted = !1, a.random = nN(r || cg().toString()), a.lastRead = Promise.resolve({
                    value: null,
                    done: !1
                }), a
            }
            Vm(t, e);
            var n = t.prototype;
            return n.next = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t = this;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return this.lastRead = this.lastRead.then(function () {
                                    return t.serialNext()
                                }), e.abrupt("return", this.lastRead);
                            case 2:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), n.randomInt = function (e) {
                return Math.floor(this.random() * e)
            }, n.chooseIndex = function () {
                return this.randomInt(this.buffer.length())
            }, n.serialNext = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t, n;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                this.upstreamExhausted || this.refill();
                            case 1:
                                if (this.buffer.isEmpty()) {
                                    e.next = 14;
                                    break
                                }
                                return t = this.chooseIndex(), e.next = 5, this.buffer.shuffleExcise(t);
                            case 5:
                                if (!(n = e.sent).done) {
                                    e.next = 10;
                                    break
                                }
                                this.upstreamExhausted = !0, e.next = 12;
                                break;
                            case 10:
                                return this.refill(), e.abrupt("return", n);
                            case 12:
                                e.next = 1;
                                break;
                            case 14:
                                return e.abrupt("return", {
                                    value: null,
                                    done: !0
                                });
                            case 15:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t
        }(XO),
        JO = function () {
            function e() {
                this.size = null
            }
            var t = e.prototype;
            return t.batch = function (e, t) {
                void 0 === t && (t = !0);
                var n, r = this;
                return nv(e > 0, function () {
                    return "batchSize needs to be positive, but it is\n      " + e
                }), n = this.size === 1 / 0 || null == this.size ? this.size : t ? Math.ceil(this.size / e) : Math.floor(this.size / e), ZO(Pm(regeneratorRuntime.mark(function n() {
                    return regeneratorRuntime.wrap(function (n) {
                        for (;;) switch (n.prev = n.next) {
                            case 0:
                                return n.next = 2, r.iterator();
                            case 2:
                                return n.abrupt("return", n.sent.columnMajorBatch(e, t, QO));
                            case 3:
                            case "end":
                                return n.stop()
                        }
                    }, n)
                })), n)
            }, t.concatenate = function (e) {
                var t, n = this;
                return t = this.size === 1 / 0 || e.size === 1 / 0 ? 1 / 0 : null != this.size && null != e.size ? this.size + e.size : null, ZO(Pm(regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) switch (t.prev = t.next) {
                            case 0:
                                return t.next = 2, n.iterator();
                            case 2:
                                return t.t0 = t.sent, t.next = 5, e.iterator();
                            case 5:
                                return t.t1 = t.sent, t.abrupt("return", t.t0.concatenate.call(t.t0, t.t1));
                            case 7:
                            case "end":
                                return t.stop()
                        }
                    }, t)
                })), t)
            }, t.filter = function (e) {
                var t, n = this;
                return t = this.size === 1 / 0 ? 1 / 0 : null, ZO(Pm(regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) switch (t.prev = t.next) {
                            case 0:
                                return t.next = 2, n.iterator();
                            case 2:
                                return t.abrupt("return", t.sent.filter(function (t) {
                                    return rx(function () {
                                        return e(t)
                                    })
                                }));
                            case 3:
                            case "end":
                                return t.stop()
                        }
                    }, t)
                })), t)
            }, t.forEachAsync = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.iterator();
                            case 2:
                                return e.abrupt("return", e.sent.forEachAsync(t));
                            case 3:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), t.map = function (e) {
                var t = this;
                return ZO(Pm(regeneratorRuntime.mark(function n() {
                    return regeneratorRuntime.wrap(function (n) {
                        for (;;) switch (n.prev = n.next) {
                            case 0:
                                return n.next = 2, t.iterator();
                            case 2:
                                return n.abrupt("return", n.sent.map(function (t) {
                                    return rx(function () {
                                        return e(t)
                                    })
                                }));
                            case 3:
                            case "end":
                                return n.stop()
                        }
                    }, n)
                })), this.size)
            }, t.mapAsync = function (e) {
                var t = this;
                return ZO(Pm(regeneratorRuntime.mark(function n() {
                    return regeneratorRuntime.wrap(function (n) {
                        for (;;) switch (n.prev = n.next) {
                            case 0:
                                return n.next = 2, t.iterator();
                            case 2:
                                return n.abrupt("return", n.sent.mapAsync(e));
                            case 3:
                            case "end":
                                return n.stop()
                        }
                    }, n)
                })), this.size)
            }, t.prefetch = function (e) {
                if (null == e) throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");
                var t = this;
                return ZO(Pm(regeneratorRuntime.mark(function n() {
                    return regeneratorRuntime.wrap(function (n) {
                        for (;;) switch (n.prev = n.next) {
                            case 0:
                                return n.next = 2, t.iterator();
                            case 2:
                                return n.abrupt("return", n.sent.prefetch(e));
                            case 3:
                            case "end":
                                return n.stop()
                        }
                    }, n)
                })), this.size)
            }, t.repeat = function (e) {
                var t, n = this;
                return t = null != this.size && e > 0 ? this.size * e : 0 === e ? 0 : null != this.size && (void 0 === e || e < 0) ? 1 / 0 : null, ZO(Pm(regeneratorRuntime.mark(function t() {
                    var r;
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) switch (t.prev = t.next) {
                            case 0:
                                return r = RO(Pm(regeneratorRuntime.mark(function e() {
                                    return regeneratorRuntime.wrap(function (e) {
                                        for (;;) switch (e.prev = e.next) {
                                            case 0:
                                                return e.next = 2, n.iterator();
                                            case 2:
                                                return e.t0 = e.sent, e.abrupt("return", {
                                                    value: e.t0,
                                                    done: !1
                                                });
                                            case 4:
                                            case "end":
                                                return e.stop()
                                        }
                                    }, e)
                                }))), t.abrupt("return", AO(r.take(e)));
                            case 2:
                            case "end":
                                return t.stop()
                        }
                    }, t)
                })), t)
            }, t.skip = function (e) {
                var t, n = this;
                return t = null != this.size && e >= 0 && this.size >= e ? this.size - e : null != this.size && (this.size < e || void 0 === e || e < 0) ? 0 : null, ZO(Pm(regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) switch (t.prev = t.next) {
                            case 0:
                                return t.next = 2, n.iterator();
                            case 2:
                                return t.abrupt("return", t.sent.skip(e));
                            case 3:
                            case "end":
                                return t.stop()
                        }
                    }, t)
                })), t)
            }, t.shuffle = function (e, t, n) {
                if (void 0 === n && (n = !0), null == e || e < 0) throw null == this.size ? new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.") : new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting bufferSize to the dataset size (" + this.size + " elements)");
                var r = this,
                    a = nN(t || cg().toString());
                return ZO(Pm(regeneratorRuntime.mark(function t() {
                    var i;
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) switch (t.prev = t.next) {
                            case 0:
                                return i = a.int32(), n && (i += a.int32()), t.next = 4, r.iterator();
                            case 4:
                                return t.abrupt("return", t.sent.shuffle(e, i.toString()));
                            case 5:
                            case "end":
                                return t.stop()
                        }
                    }, t)
                })), this.size)
            }, t.take = function (e) {
                var t, n = this;
                return t = null != this.size && this.size > e ? e : null != this.size && this.size <= e ? this.size : null, ZO(Pm(regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) switch (t.prev = t.next) {
                            case 0:
                                return t.next = 2, n.iterator();
                            case 2:
                                return t.abrupt("return", t.sent.take(e));
                            case 3:
                            case "end":
                                return t.stop()
                        }
                    }, t)
                })), t)
            }, t.toArray = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (this.size !== 1 / 0) {
                                    e.next = 2;
                                    break
                                }
                                throw new Error("Can not convert infinite data stream to array.");
                            case 2:
                                return e.next = 4, this.iterator();
                            case 4:
                                return e.abrupt("return", e.sent.toArray());
                            case 5:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t.toArrayForTest = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (this.size !== 1 / 0) {
                                    e.next = 2;
                                    break
                                }
                                throw new Error("Can not convert infinite data stream to array.");
                            case 2:
                                return e.next = 4, this.iterator();
                            case 4:
                                return e.abrupt("return", e.sent.toArrayForTest());
                            case 5:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), e
        }();

    function ZO(e, t) {
        return void 0 === t && (t = null), new(function (n) {
            function r() {
                var e;
                return (e = n.apply(this, arguments) || this).size = t, e
            }
            return Vm(r, n), r.prototype.iterator = function () {
                var t = Pm(regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) switch (t.prev = t.next) {
                            case 0:
                                return t.abrupt("return", e());
                            case 1:
                            case "end":
                                return t.stop()
                        }
                    }, t)
                }));
                return function () {
                    return t.apply(this, arguments)
                }
            }(), r
        }(JO))
    }

    function QO(e) {
        return null === e ? null : function (e) {
            return null == e || null === (t = e) || "object" != typeof t && "function" != typeof t || Array.isArray(e) || "object" == typeof e && e instanceof Ng || xv(e);
            var t
        }(e[0]) ? {
            value: function (e) {
                if (0 === e.length) throw new Error("Can't make a batch of zero elements.");
                return e[0] instanceof Ng ? UN(e) : ny(e)
            }(e),
            recurse: !1
        } : {
            value: null,
            recurse: !0
        }
    }
    JO.MAX_BUFFER_SIZE = 1e4;
    var $O = function (e) {
            function t(t) {
                var n;
                return (n = e.call(this) || this).input = t, n
            }
            return Vm(t, e), t.prototype.iterator = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t, n, r;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.input.iterator();
                            case 2:
                                return t = e.sent, n = t.decodeUTF8(), r = n.split("\n").map(function (e) {
                                    return e.endsWith("\r") && (e = e.slice(0, -1)), e
                                }), e.abrupt("return", r);
                            case 6:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t
        }(JO),
        eM = Symbol("out"),
        tM = Symbol("field"),
        nM = Symbol("quote"),
        rM = Symbol("quoteafterquote"),
        aM = Symbol("quoteinquote"),
        iM = function (e) {
            function t(t, n) {
                var r;
                return (r = e.call(this) || this).input = t, r.hasHeader = !0, r.fullColumnNames = null, r.columnNamesValidated = !1, r.columnConfigs = null, r.configuredColumnsOnly = !1, r.delimiter = ",", r.delimWhitespace = !1, r.base = new $O(t), n || (n = {}), r.hasHeader = !1 !== n.hasHeader, r.fullColumnNames = n.columnNames, r.columnConfigs = n.columnConfigs, r.configuredColumnsOnly = n.configuredColumnsOnly, n.delimWhitespace ? (nv(null == n.delimiter, function () {
                    return "Delimiter should not be provided when delimWhitespace is true."
                }), r.delimWhitespace = !0, r.delimiter = " ") : r.delimiter = n.delimiter ? n.delimiter : ",", r
            }
            Vm(t, e);
            var n = t.prototype;
            return n.columnNames = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (this.columnNamesValidated) {
                                    e.next = 3;
                                    break
                                }
                                return e.next = 3, this.setColumnNames();
                            case 3:
                                return e.abrupt("return", this.configuredColumnsOnly ? Object.keys(this.columnConfigs) : this.fullColumnNames);
                            case 4:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), n.setColumnNames = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t, n, r, a, i, o, s = this;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.maybeReadHeaderLine();
                            case 2:
                                if (t = e.sent, this.fullColumnNames || t) {
                                    e.next = 7;
                                    break
                                }
                                throw new Error("Column names must be provided if there is no header line.");
                            case 7:
                                this.fullColumnNames && t && nv(t.length === this.fullColumnNames.length, function () {
                                    return "The length of provided columnNames (" + s.fullColumnNames.length.toString() + ") does not match the length of the header line read from file (" + t.length.toString() + ")."
                                });
                            case 8:
                                if (this.fullColumnNames || (this.fullColumnNames = t), n = this.fullColumnNames.reduce(function (e, t) {
                                        return e[t] = e[t] + 1 || 1, e
                                    }, {}), nv(0 === (r = Object.keys(n).filter(function (e) {
                                        return n[e] > 1
                                    })).length, function () {
                                        return "Duplicate column names found: " + r.toString()
                                    }), !this.columnConfigs) {
                                    e.next = 22;
                                    break
                                }
                                a = 0, i = Object.keys(this.columnConfigs);
                            case 14:
                                if (!(a < i.length)) {
                                    e.next = 22;
                                    break
                                }
                                if (o = i[a], -1 !== this.fullColumnNames.indexOf(o)) {
                                    e.next = 19;
                                    break
                                }
                                throw new Error('The key "' + o + '" provided in columnConfigs does not match any of the column names (' + this.fullColumnNames.toString() + ").");
                            case 19:
                                a++, e.next = 14;
                                break;
                            case 22:
                                this.columnNamesValidated = !0;
                            case 23:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), n.maybeReadHeaderLine = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t, n, r, a;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (!this.hasHeader) {
                                    e.next = 14;
                                    break
                                }
                                return e.next = 3, this.base.iterator();
                            case 3:
                                return t = e.sent, e.next = 6, t.next();
                            case 6:
                                if (!(n = e.sent).done) {
                                    e.next = 9;
                                    break
                                }
                                throw new Error("No data was found for CSV parsing.");
                            case 9:
                                return r = n.value, a = this.parseRow(r, !1), e.abrupt("return", a);
                            case 14:
                                return e.abrupt("return", null);
                            case 15:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), n.iterator = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t, n = this;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (this.columnNamesValidated) {
                                    e.next = 3;
                                    break
                                }
                                return e.next = 3, this.setColumnNames();
                            case 3:
                                return e.next = 5, this.base.iterator();
                            case 5:
                                return t = e.sent, this.hasHeader && (t = t.skip(1)), e.abrupt("return", t.map(function (e) {
                                    return n.makeDataElement(e)
                                }));
                            case 8:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), n.makeDataElement = function (e) {
                for (var t = this.parseRow(e), n = {}, r = {}, a = 0; a < this.fullColumnNames.length; a++) {
                    var i = this.fullColumnNames[a],
                        o = this.columnConfigs ? this.columnConfigs[i] : null;
                    if (!this.configuredColumnsOnly || o) {
                        var s = t[a],
                            u = null;
                        if ("" === s)
                            if (o && void 0 !== o.default) u = o.default;
                            else {
                                if (o && (o.required || o.isLabel)) throw new Error("Required column " + i + " is empty in this line: " + e);
                                u = void 0
                            }
                        else {
                            var l = Number(s);
                            if (isNaN(l)) u = o && "bool" === o.dtype ? this.getBoolean(s) : s;
                            else if (o && o.dtype) switch (o.dtype) {
                                case "float32":
                                    u = l;
                                    break;
                                case "int32":
                                    u = Math.floor(l);
                                    break;
                                case "bool":
                                    u = this.getBoolean(s);
                                    break;
                                default:
                                    u = l
                            } else u = l
                        }
                        o && o.isLabel ? r[i] = u : n[i] = u
                    }
                }
                return 0 === Object.keys(r).length ? n : {
                    xs: n,
                    ys: r
                }
            }, n.getBoolean = function (e) {
                return "1" === e || "true" === e.toLowerCase() ? 1 : 0
            }, n.parseRow = function (e, t) {
                void 0 === t && (t = !0);
                for (var n = [], r = 0, a = e.length, i = eM, o = 0; o < a; o++) switch (i) {
                    case eM:
                        switch (e.charAt(o)) {
                            case '"':
                                r = o + 1, i = nM;
                                break;
                            case this.delimiter:
                                if (r = o + 1, " " === this.delimiter && this.delimWhitespace) break;
                                n.push(""), i = eM;
                                break;
                            default:
                                i = tM, r = o
                        }
                        break;
                    case tM:
                        switch (e.charAt(o)) {
                            case this.delimiter:
                                n.push(e.substring(r, o)), i = eM, r = o + 1
                        }
                        break;
                    case nM:
                        switch (e.charAt(o)) {
                            case '"':
                                i = rM
                        }
                        break;
                    case rM:
                        switch (e.charAt(o)) {
                            case this.delimiter:
                                n.push(e.substring(r, o - 1)), i = eM, r = o + 1;
                                break;
                            case '"':
                                i = nM;
                                break;
                            default:
                                i = aM
                        }
                        break;
                    case aM:
                        switch (e.charAt(o)) {
                            case '"':
                                i = nM
                        }
                }
                if (i === rM ? n.push(e.substring(r, a - 1)) : n.push(e.substring(r)), t && n.length !== this.fullColumnNames.length) throw new Error("Invalid row in csv file. Should have " + this.fullColumnNames.length + " elements in a row, but got " + n);
                return n
            }, t
        }(JO),
        oM = function (e) {
            function t(t) {
                var n;
                (n = e.call(this) || this).microphoneConfig = t, n.isClosed = !1, n.fftSize = t.fftSize || 1024;
                var r = Math.log2(n.fftSize);
                if (n.fftSize < 0 || r < 4 || r > 14 || !Number.isInteger(r)) throw new Error("Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got " + n.fftSize);
                if (n.numFrames = t.numFramesPerSpectrogram || 43, n.sampleRateHz = t.sampleRateHz, n.columnTruncateLength = t.columnTruncateLength || n.fftSize, n.audioTrackConstraints = t.audioTrackConstraints, n.smoothingTimeConstant = t.smoothingTimeConstant || 0, n.includeSpectrogram = !1 !== t.includeSpectrogram, n.includeWaveform = !0 === t.includeWaveform, !n.includeSpectrogram && !n.includeWaveform) throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.");
                return n
            }
            Vm(t, e);
            var n = t.prototype;
            return n.summary = function () {
                return "microphone"
            }, t.create = function () {
                var e = Pm(regeneratorRuntime.mark(function e(n) {
                    var r;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (void 0 === n && (n = {}), !Wv().get("IS_NODE")) {
                                    e.next = 3;
                                    break
                                }
                                throw new Error("microphone API is only supported in browser environment.");
                            case 3:
                                return r = new t(n), e.next = 6, r.start();
                            case 6:
                                return e.abrupt("return", r);
                            case 7:
                            case "end":
                                return e.stop()
                        }
                    }, e)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), n.start = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t, n;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.prev = 0, e.next = 3, navigator.mediaDevices.getUserMedia({
                                    audio: null == this.audioTrackConstraints || this.audioTrackConstraints,
                                    video: !1
                                });
                            case 3:
                                this.stream = e.sent, e.next = 9;
                                break;
                            case 6:
                                throw e.prev = 6, e.t0 = e.catch(0), new Error("Error thrown while initializing video stream: " + e.t0.message);
                            case 9:
                                if (this.stream) {
                                    e.next = 11;
                                    break
                                }
                                throw new Error("Could not obtain audio from microphone.");
                            case 11:
                                if (t = window.AudioContext || window.webkitAudioContext, this.audioContext = new t, this.sampleRateHz) {
                                    e.next = 17;
                                    break
                                }
                                this.sampleRateHz = this.audioContext.sampleRate, e.next = 19;
                                break;
                            case 17:
                                if (this.audioContext.sampleRate === this.sampleRateHz) {
                                    e.next = 19;
                                    break
                                }
                                throw new Error("Mismatch in sampling rate: Expected: " + this.sampleRateHz + "; Actual: " + this.audioContext.sampleRate);
                            case 19:
                                return n = this.audioContext.createMediaStreamSource(this.stream), this.analyser = this.audioContext.createAnalyser(), this.analyser.fftSize = 2 * this.fftSize, this.analyser.smoothingTimeConstant = this.smoothingTimeConstant, n.connect(this.analyser), this.freqData = new Float32Array(this.fftSize), this.timeData = new Float32Array(this.fftSize), e.abrupt("return");
                            case 27:
                            case "end":
                                return e.stop()
                        }
                    }, e, this, [
                        [0, 6]
                    ])
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), n.next = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t, n, r, a, i;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (!this.isClosed) {
                                    e.next = 2;
                                    break
                                }
                                return e.abrupt("return", {
                                    value: null,
                                    done: !0
                                });
                            case 2:
                                return e.next = 4, this.getAudioData();
                            case 4:
                                return r = e.sent, this.includeSpectrogram && (a = this.flattenQueue(r.freqDataQueue), t = this.getTensorFromAudioDataArray(a, [this.numFrames, this.columnTruncateLength, 1])), this.includeWaveform && (i = this.flattenQueue(r.timeDataQueue), n = this.getTensorFromAudioDataArray(i, [this.numFrames * this.fftSize, 1])), e.abrupt("return", {
                                    value: {
                                        spectrogram: t,
                                        waveform: n
                                    },
                                    done: !1
                                });
                            case 8:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), n.capture = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.next();
                            case 2:
                                return e.abrupt("return", e.sent.value);
                            case 3:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), n.getAudioData = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t, n, r, a = this;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return t = [], n = [], r = 0, e.abrupt("return", new Promise(function (e) {
                                    var i = setInterval(function () {
                                        a.includeSpectrogram && (a.analyser.getFloatFrequencyData(a.freqData), a.freqData[0] === -1 / 0 && e({
                                            freqDataQueue: t,
                                            timeDataQueue: n
                                        }), t.push(a.freqData.slice(0, a.columnTruncateLength))), a.includeWaveform && (a.analyser.getFloatTimeDomainData(a.timeData), n.push(a.timeData.slice())), ++r === a.numFrames && (clearInterval(i), e({
                                            freqDataQueue: t,
                                            timeDataQueue: n
                                        }))
                                    }, a.fftSize / a.sampleRateHz * 1e3)
                                }));
                            case 4:
                            case "end":
                                return e.stop()
                        }
                    }, e)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), n.stop = function () {
                this.isClosed || (this.isClosed = !0, this.analyser.disconnect(), this.audioContext.close(), null != this.stream && this.stream.getTracks().length > 0 && this.stream.getTracks()[0].stop())
            }, n.toArray = function () {
                throw new Error("Can not convert infinite audio stream to array.")
            }, n.getSampleRate = function () {
                return this.sampleRateHz
            }, n.flattenQueue = function (e) {
                var t = e[0].length,
                    n = new Float32Array(e.length * t);
                return e.forEach(function (e, r) {
                    return n.set(e, r * t)
                }), n
            }, n.getTensorFromAudioDataArray = function (e, t) {
                var n = new Float32Array(ov(t));
                return n.set(e, n.length - e.length), ny(n, t)
            }, t
        }(DO),
        sM = function (e) {
            function t(t, n) {
                var r;
                if ((r = e.call(this) || this).webcamVideoElement = t, r.webcamConfig = n, r.isClosed = !0, r.resize = !1, r.needToResize())
                    if (r.resize = !0, r.cropSize = [r.webcamConfig.resizeHeight, r.webcamConfig.resizeWidth], r.cropBoxInd = qN([0], "int32"), r.webcamConfig.centerCrop) {
                        var a = 1 * r.webcamConfig.resizeWidth / r.webcamVideoElement.width,
                            i = 1 * r.webcamConfig.resizeHeight / r.webcamVideoElement.height,
                            o = (1 - a) / 2,
                            s = (1 - i) / 2,
                            u = o + a,
                            l = i + s;
                        r.cropBox = KN([s, o, l, u], [1, 4])
                    } else r.cropBox = KN([0, 0, 1, 1], [1, 4]);
                return r
            }
            Vm(t, e);
            var n = t.prototype;
            return n.summary = function () {
                return "webcam"
            }, t.create = function () {
                var e = Pm(regeneratorRuntime.mark(function e(n, r) {
                    var a;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (void 0 === r && (r = {}), !Wv().get("IS_NODE")) {
                                    e.next = 3;
                                    break
                                }
                                throw new Error("tf.data.webcam is only supported in browser environment.");
                            case 3:
                                if (n) {
                                    e.next = 9;
                                    break
                                }
                                if (n = document.createElement("video"), r.resizeWidth && r.resizeHeight) {
                                    e.next = 7;
                                    break
                                }
                                throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");
                            case 7:
                                n.width = r.resizeWidth, n.height = r.resizeHeight;
                            case 9:
                                return a = new t(n, r), e.next = 12, a.start();
                            case 12:
                                return e.abrupt("return", a);
                            case 13:
                            case "end":
                                return e.stop()
                        }
                    }, e)
                }));
                return function (t, n) {
                    return e.apply(this, arguments)
                }
            }(), n.start = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t = this;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return this.webcamConfig.facingMode && nv("user" === this.webcamConfig.facingMode || "environment" === this.webcamConfig.facingMode, function () {
                                    return "Invalid webcam facing mode: " + t.webcamConfig.facingMode + ". Please provide 'user' or 'environment'"
                                }), e.prev = 1, e.next = 4, navigator.mediaDevices.getUserMedia({
                                    video: {
                                        deviceId: this.webcamConfig.deviceId,
                                        facingMode: this.webcamConfig.facingMode ? this.webcamConfig.facingMode : "user",
                                        width: this.webcamVideoElement.width,
                                        height: this.webcamVideoElement.height
                                    }
                                });
                            case 4:
                                this.stream = e.sent, e.next = 11;
                                break;
                            case 7:
                                throw e.prev = 7, e.t0 = e.catch(1), e.t0.message = "Error thrown while initializing video stream: " + e.t0.message, e.t0;
                            case 11:
                                if (this.stream) {
                                    e.next = 13;
                                    break
                                }
                                throw new Error("Could not obtain video from webcam.");
                            case 13:
                                try {
                                    this.webcamVideoElement.srcObject = this.stream
                                } catch (e) {
                                    console.log(e), this.webcamVideoElement.src = window.URL.createObjectURL(this.stream)
                                }
                                return this.webcamVideoElement.play(), this.isClosed = !1, e.abrupt("return", new Promise(function (e) {
                                    t.webcamVideoElement.onloadedmetadata = function () {
                                        e()
                                    }
                                }));
                            case 17:
                            case "end":
                                return e.stop()
                        }
                    }, e, this, [
                        [1, 7]
                    ])
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), n.next = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (!this.isClosed) {
                                    e.next = 2;
                                    break
                                }
                                return e.abrupt("return", {
                                    value: null,
                                    done: !0
                                });
                            case 2:
                                e.prev = 2, t = kb(this.webcamVideoElement), e.next = 9;
                                break;
                            case 6:
                                throw e.prev = 6, e.t0 = e.catch(2), new Error("Error thrown converting video to pixels: " + JSON.stringify(e.t0));
                            case 9:
                                if (!this.resize) {
                                    e.next = 22;
                                    break
                                }
                                return e.prev = 10, e.abrupt("return", {
                                    value: this.cropAndResizeFrame(t),
                                    done: !1
                                });
                            case 14:
                                throw e.prev = 14, e.t1 = e.catch(10), new Error("Error thrown cropping the video: " + e.t1.message);
                            case 17:
                                return e.prev = 17, t.dispose(), e.finish(17);
                            case 20:
                                e.next = 23;
                                break;
                            case 22:
                                return e.abrupt("return", {
                                    value: t,
                                    done: !1
                                });
                            case 23:
                            case "end":
                                return e.stop()
                        }
                    }, e, this, [
                        [2, 6],
                        [10, 14, 17, 20]
                    ])
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), n.needToResize = function () {
                return !(!this.webcamConfig.resizeWidth || !this.webcamConfig.resizeHeight || this.webcamVideoElement.width === this.webcamConfig.resizeWidth && this.webcamVideoElement.height === this.webcamConfig.resizeHeight)
            }, n.cropAndResizeFrame = function (e) {
                var t = this;
                return rx(function () {
                    var n, r = Fw(Ky(e, "float32"), 0),
                        a = (n = hS.cropAndResize(r, t.cropBox, t.cropBoxInd, t.cropSize, "bilinear")).shape;
                    return Px(n, a.slice(1))
                })
            }, n.capture = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.next();
                            case 2:
                                return e.abrupt("return", e.sent.value);
                            case 3:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), n.stop = function () {
                this.stream.getTracks().forEach(function (e) {
                    return e.stop()
                });
                try {
                    this.webcamVideoElement.srcObject = null
                } catch (e) {
                    console.log(e), this.webcamVideoElement.src = null
                }
                this.isClosed = !0
            }, n.toArray = function () {
                throw new Error("Can not convert infinite video stream to array.")
            }, t
        }(DO),
        uM = function () {},
        lM = function (e) {
            function t() {
                return e.apply(this, arguments) || this
            }
            return Vm(t, e), t.prototype.split = function (e) {
                return new cM(this, e)
            }, t
        }(DO),
        cM = function (e) {
            function t(t, n) {
                var r;
                return (r = e.call(this) || this).upstream = t, r.impl = new pM(t, n), r
            }
            Vm(t, e);
            var n = t.prototype;
            return n.summary = function () {
                return this.impl.summary()
            }, n.next = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.abrupt("return", this.impl.next());
                            case 1:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t
        }(lM),
        pM = function (e) {
            function t(t, n) {
                var r;
                return (r = e.call(this) || this).upstream = t, r.separator = n, r.carryover = "", r
            }
            Vm(t, e);
            var n = t.prototype;
            return n.summary = function () {
                return this.upstream.summary() + " -> Split('" + this.separator + "')"
            }, n.pump = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t, n, r, a, i;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.upstream.next();
                            case 2:
                                if (!(t = e.sent).done) {
                                    e.next = 9;
                                    break
                                }
                                if ("" !== this.carryover) {
                                    e.next = 6;
                                    break
                                }
                                return e.abrupt("return", !1);
                            case 6:
                                return this.outputQueue.push(this.carryover), this.carryover = "", e.abrupt("return", !0);
                            case 9:
                                for ((n = t.value.split(this.separator))[0] = this.carryover + n[0], r = Xm(n.slice(0, -1)); !(a = r()).done;) i = a.value, this.outputQueue.push(i);
                                return this.carryover = n[n.length - 1], e.abrupt("return", !0);
                            case 14:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t
        }(jO),
        hM = function (e) {
            function t() {
                return e.apply(this, arguments) || this
            }
            return Vm(t, e), t.prototype.decodeUTF8 = function () {
                return new fM(this)
            }, t
        }(DO),
        fM = function (e) {
            function t(t) {
                var n;
                return (n = e.call(this) || this).upstream = t, n.impl = new dM(t), n
            }
            Vm(t, e);
            var n = t.prototype;
            return n.summary = function () {
                return this.impl.summary()
            }, n.next = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.abrupt("return", this.impl.next());
                            case 1:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t
        }(lM),
        dM = function (e) {
            function t(t) {
                var n;
                if ((n = e.call(this) || this).upstream = t, Wv().get("IS_BROWSER")) n.decoder = new TextDecoder("utf-8");
                else {
                    var r = require("string_decoder").StringDecoder;
                    n.decoder = new r("utf8")
                }
                return n
            }
            Vm(t, e);
            var n = t.prototype;
            return n.summary = function () {
                return this.upstream.summary() + " -> Utf8"
            }, n.pump = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t, n, r;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.upstream.next();
                            case 2:
                                if (!(t = e.sent).done) {
                                    e.next = 7;
                                    break
                                }
                                return e.abrupt("return", !1);
                            case 7:
                                n = t.value;
                            case 8:
                                return r = Wv().get("IS_BROWSER") ? this.decoder.decode(n, {
                                    stream: !0
                                }) : this.decoder.write(Buffer.from(n.buffer)), this.outputQueue.push(r), e.abrupt("return", !0);
                            case 11:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t
        }(jO),
        mM = function (e) {
            function t(t, n) {
                var r;
                return void 0 === n && (n = {}), (r = e.call(this) || this).file = t, r.options = n, nv(t instanceof Uint8Array || !!Wv().get("IS_BROWSER") && (t instanceof File || t instanceof Blob), function () {
                    return "FileChunkIterator only supports File, Blob and Uint8Array right now."
                }), r.offset = n.offset || 0, r.chunkSize = n.chunkSize || 1048576, r
            }
            Vm(t, e);
            var n = t.prototype;
            return n.summary = function () {
                return "FileChunks " + this.file
            }, n.next = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t, n = this;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (!(this.offset >= (this.file instanceof Uint8Array ? this.file.byteLength : this.file.size))) {
                                    e.next = 2;
                                    break
                                }
                                return e.abrupt("return", {
                                    value: null,
                                    done: !0
                                });
                            case 2:
                                return t = new Promise(function (e, t) {
                                    var r = n.offset + n.chunkSize;
                                    if (n.file instanceof Uint8Array) e(new Uint8Array(n.file.slice(n.offset, r)));
                                    else {
                                        var a = new FileReader;
                                        a.onload = function (n) {
                                            var r = a.result;
                                            if (r instanceof ArrayBuffer && (r = new Uint8Array(r)), !(r instanceof Uint8Array)) return t(new TypeError("FileReader returned unknown type."));
                                            e(r)
                                        }, a.onabort = function (e) {
                                            return t(new Error("Aborted"))
                                        }, a.onerror = function (e) {
                                            return t(new Error(e.type))
                                        };
                                        var i = n.file.slice(n.offset, r);
                                        a.readAsArrayBuffer(i)
                                    }
                                    n.offset = r
                                }), e.next = 5, t;
                            case 5:
                                return e.t0 = e.sent, e.abrupt("return", {
                                    value: e.t0,
                                    done: !1
                                });
                            case 7:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t
        }(hM);

    function vM(e, t) {
        return function () {
            return Pm(regeneratorRuntime.mark(function e(t, n) {
                var r, a, i, o;
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return void 0 === n && (n = {}), "string" == typeof t ? r = t : (r = t.url, a = gM(t)), e.next = 4, pg(r, a);
                        case 4:
                            if (!(i = e.sent).ok) {
                                e.next = 14;
                                break
                            }
                            return e.t0 = Uint8Array, e.next = 9, i.arrayBuffer();
                        case 9:
                            return e.t1 = e.sent, o = new e.t0(e.t1), e.abrupt("return", new mM(o, n));
                        case 14:
                            throw new Error(i.statusText);
                        case 15:
                        case "end":
                            return e.stop()
                    }
                }, e)
            })).apply(this, arguments)
        }.apply(this, arguments)
    }
    var gM = function (e) {
        return {
            method: e.method,
            headers: e.headers,
            body: e.body,
            mode: e.mode,
            credentials: e.credentials,
            cache: e.cache,
            redirect: e.redirect,
            referrer: e.referrer,
            integrity: e.integrity
        }
    };

    function yM(e) {
        return "string" == typeof e && "file://" === e.substr(0, 7)
    }
    var bM = function (e) {
            function t(t, n) {
                var r;
                return void 0 === n && (n = {}), (r = e.call(this) || this).input = t, r.options = n, r
            }
            return Vm(t, e), t.prototype.iterator = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    var t;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return yM(this.input) && Wv().get("IS_NODE") && (t = require("fs"), this.input = t.readFileSync(this.input.substr(7))), e.abrupt("return", new mM(this.input, this.options));
                            case 2:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t
        }(uM),
        xM = function (e) {
            function t(t, n) {
                var r;
                return void 0 === n && (n = {}), (r = e.call(this) || this).url = t, r.fileOptions = n, r
            }
            return Vm(t, e), t.prototype.iterator = function () {
                var e = Pm(regeneratorRuntime.mark(function e() {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (!yM(this.url)) {
                                    e.next = 4;
                                    break
                                }
                                return e.abrupt("return", new bM(this.url, this.fileOptions).iterator());
                            case 4:
                                return e.abrupt("return", vM(this.url, this.fileOptions));
                            case 5:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }(), t
        }(uM);

    function wM() {
        return (wM = Pm(regeneratorRuntime.mark(function e(t, n) {
            return regeneratorRuntime.wrap(function (e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return e.abrupt("return", sM.create(t, n));
                    case 1:
                    case "end":
                        return e.stop()
                }
            }, e)
        }))).apply(this, arguments)
    }

    function kM() {
        return (kM = Pm(regeneratorRuntime.mark(function e(t) {
            return regeneratorRuntime.wrap(function (e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return e.abrupt("return", oM.create(t));
                    case 1:
                    case "end":
                        return e.stop()
                }
            }, e)
        }))).apply(this, arguments)
    }
    var NM = {
        __proto__: null,
        array: function (e) {
            return ZO(Pm(regeneratorRuntime.mark(function t() {
                return regeneratorRuntime.wrap(function (t) {
                    for (;;) switch (t.prev = t.next) {
                        case 0:
                            return t.abrupt("return", EO(e));
                        case 1:
                        case "end":
                            return t.stop()
                    }
                }, t)
            })), e.length)
        },
        Dataset: JO,
        zip: function (e) {
            if (!NO(e)) throw new Error("The argument to zip() must be an object or array.");
            var t;
            if (Array.isArray(e))
                for (var n = 0; n < e.length; n++) t = null == t ? e[n].size : Math.min(t, e[n].size);
            else if (e instanceof Object)
                for (var r in e) t = null == t ? e[r].size : Math.min(t, e[r].size);
            return ZO(Pm(regeneratorRuntime.mark(function t() {
                var n;
                return regeneratorRuntime.wrap(function (t) {
                    for (;;) switch (t.prev = t.next) {
                        case 0:
                            return t.next = 2, kO(e, function (e) {
                                if (e instanceof JO) return {
                                    value: e.iterator(),
                                    recurse: !1
                                };
                                if (NO(e)) return {
                                    value: null,
                                    recurse: !0
                                };
                                throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")
                            });
                        case 2:
                            return n = t.sent, t.abrupt("return", FO(n, _O.SHORTEST));
                        case 4:
                        case "end":
                            return t.stop()
                    }
                }, t)
            })), t)
        },
        CSVDataset: iM,
        TextLineDataset: $O,
        csv: function (e, t) {
            return void 0 === t && (t = {}), new iM(new xM(e), t)
        },
        func: function (e) {
            var t = RO(e);
            return ZO(Pm(regeneratorRuntime.mark(function e() {
                return regeneratorRuntime.wrap(function (e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return e.abrupt("return", t);
                        case 1:
                        case "end":
                            return e.stop()
                    }
                }, e)
            })))
        },
        generator: function (e) {
            return ZO(Pm(regeneratorRuntime.mark(function t() {
                var n;
                return regeneratorRuntime.wrap(function (t) {
                    for (;;) switch (t.prev = t.next) {
                        case 0:
                            return t.next = 2, e();
                        case 2:
                            return n = t.sent, t.abrupt("return", RO(function () {
                                return n.next()
                            }));
                        case 4:
                        case "end":
                            return t.stop()
                    }
                }, t)
            })))
        },
        microphone: function (e) {
            return kM.apply(this, arguments)
        },
        webcam: function (e, t) {
            return wM.apply(this, arguments)
        },
        FileDataSource: bM,
        URLDataSource: xM,
        version_data: "3.3.0"
    };

    function IM(e, t) {
        Array.isArray(e) || (e = [e]), e.forEach(function (e) {
            null != e && nv("complex64" !== e.dtype, function () {
                return t + " does not support complex64 tensors in the CPU backend."
            })
        })
    }
    var SM = eI,
        TM = function (e) {
            function t() {
                var t;
                return (t = e.call(this) || this).blockSize = 48, t.firstUse = !0, t.data = new Ym(qm(t), tx()), t
            }
            Vm(t, e);
            var n = t.prototype;
            return n.nextDataId = function () {
                return t.nextDataId++
            }, n.write = function (e, t, n) {
                this.firstUse && (this.firstUse = !1, Wv().get("IS_NODE") && zS("\n============================\nHi there ð. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));
                var r = {
                    id: this.nextDataId()
                };
                return this.data.set(r, {
                    values: e,
                    dtype: n,
                    refCount: 1
                }), r
            }, n.makeTensorInfo = function (e, t, n) {
                var r;
                if ("string" === t && null != n && n.length > 0 && Nv(n[0])) {
                    var a = n.map(function (e) {
                        return hg(e)
                    });
                    r = this.write(a, e, t)
                } else r = this.write(n, e, t);
                return {
                    dataId: r,
                    shape: e,
                    dtype: t
                }
            }, n.refCount = function (e) {
                return this.data.has(e) ? this.data.get(e).refCount : 0
            }, n.incRef = function (e) {
                this.data.get(e).refCount++
            }, n.decRef = function (e) {
                this.data.has(e) && this.data.get(e).refCount--
            }, n.move = function (e, t, n, r, a) {
                this.data.set(e, {
                    values: t,
                    dtype: r,
                    refCount: a
                })
            }, n.numDataIds = function () {
                return this.data.numDataIds()
            }, n.read = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.abrupt("return", this.readSync(t));
                            case 1:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), n.readSync = function (e) {
                var t = this.data.get(e),
                    n = t.dtype,
                    r = t.complexTensorInfos;
                return "complex64" === n ? PS(this.readSync(r.real.dataId), this.readSync(r.imag.dataId)) : this.data.get(e).values
            }, n.bufferSync = function (e) {
                var t = this.readSync(e.dataId),
                    n = t;
                if ("string" === e.dtype) try {
                    n = t.map(function (e) {
                        return fg(e)
                    })
                } catch (e) {
                    throw new Error("Failed to decode encoded string bytes into utf-8")
                }
                return qy(e.shape, e.dtype, n)
            }, n.makeOutput = function (e, t, n) {
                var r = this.write(e, t, n);
                return tx().makeTensorFromDataId(r, t, n, this)
            }, n.disposeData = function (e, t) {
                if (void 0 === t && (t = !1), this.data.has(e)) {
                    if (this.data.get(e).refCount--, !t && this.data.get(e).refCount > 0) return !1;
                    var n = this.data.get(e).complexTensorInfos;
                    null != n && (this.disposeData(n.real.dataId, !0), this.disposeData(n.imag.dataId, !0)), this.data.delete(e)
                }
                return !0
            }, n.disposeIntermediateTensorInfo = function (e) {
                this.disposeData(e.dataId)
            }, n.time = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    var n, r;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return n = cg(), t(), r = cg() - n, e.abrupt("return", {
                                    kernelMs: r
                                });
                            case 4:
                            case "end":
                                return e.stop()
                        }
                    }, e)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), n.memory = function () {
                return {
                    unreliable: !0,
                    reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]
                }
            }, n.where = function (e) {
                IM([e], "where");
                var t = this.readSync(e.dataId);
                return SM(e.shape, t)
            }, n.dispose = function () {}, n.floatPrecision = function () {
                return 32
            }, n.epsilon = function () {
                return e.prototype.epsilon.call(this)
            }, t
        }(Jm);

    function CM(e) {
        for (var t = new Float32Array(e.length), n = 0; n < e.length; ++n) t[n] = Math.abs(e[n]);
        return t
    }
    TM.nextDataId = 0;
    var EM = {
        kernelName: "Abs",
        backendName: "cpu",
        kernelFunc: function (e) {
            var t = e.inputs.x,
                n = e.backend;
            IM(t, "abs");
            var r = new Float32Array(ov(t.shape));
            return r = CM(n.data.get(t.dataId).values), n.makeOutput(r, t.shape, "float32")
        }
    };

    function RM(e) {
        return function (t, n, r, a, i) {
            var o = kw(t, n),
                s = o.length,
                u = Rv(o),
                l = mv(i, ov(o)),
                c = t.length,
                p = n.length,
                h = Rv(t),
                f = Rv(n),
                d = xw(t, o),
                m = xw(n, o);
            if (d.length + m.length === 0)
                for (var v = 0; v < l.length; ++v) l[v] = e(r[v % r.length], a[v % a.length]);
            else
                for (var g = function (t) {
                        var n = Lv(t, s, u),
                            i = n.slice(-c);
                        d.forEach(function (e) {
                            return i[e] = 0
                        });
                        var o = Mv(i, c, h),
                            v = n.slice(-p);
                        m.forEach(function (e) {
                            return v[e] = 0
                        });
                        var g = Mv(v, p, f);
                        l[t] = e(r[o], a[g])
                    }, y = 0; y < l.length; ++y) g(y);
            return [l, o]
        }
    }

    function AM(e) {
        var t = e.inputs,
            n = e.backend,
            r = t.real,
            a = t.imag,
            i = n.data.get(r.dataId).values,
            o = n.data.get(a.dataId).values,
            s = n.makeTensorInfo(r.shape, "complex64");
        return n.data.get(s.dataId).complexTensorInfos = {
            real: n.makeTensorInfo(r.shape, "float32", i),
            imag: n.makeTensorInfo(a.shape, "float32", o)
        }, s
    }
    var FM = {
        kernelName: "Complex",
        backendName: "cpu",
        kernelFunc: AM
    };

    function _M(e, t, n) {
        if (void 0 === n && (n = "float32"), "complex64" === n) return AM({
            inputs: {
                real: _M(e, t, "float32"),
                imag: _M(e, t, "float32")
            },
            backend: e
        });
        var r = _v(ov(t), n);
        return e.makeTensorInfo(t, n, r)
    }

    function DM(e) {
        var t = e.inputs,
            n = e.backend,
            r = t.x;
        return n.incRef(r.dataId), {
            dataId: r.dataId,
            shape: r.shape,
            dtype: r.dtype
        }
    }
    var OM = {
        kernelName: "Identity",
        backendName: "cpu",
        kernelFunc: DM
    };

    function MM(e) {
        var t = e.inputs,
            n = e.backend,
            r = t.input,
            a = n.data.get(r.dataId).complexTensorInfos.real,
            i = n.data.get(a.dataId).values;
        return n.makeTensorInfo(a.shape, a.dtype, i)
    }
    var LM = {
        kernelName: "Real",
        backendName: "cpu",
        kernelFunc: MM
    };

    function zM(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.x,
            i = r.dtype;
        if ("complex64" === i) {
            if ("complex64" === a.dtype) return DM({
                inputs: {
                    x: a
                },
                backend: n
            });
            var o = _M(n, a.shape, a.dtype),
                s = zM({
                    inputs: {
                        x: a
                    },
                    backend: n,
                    attrs: {
                        dtype: "float32"
                    }
                }),
                u = AM({
                    inputs: {
                        real: s,
                        imag: o
                    },
                    backend: n
                });
            return n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(s), u
        }
        if ("complex64" === a.dtype) {
            var l = MM({
                    inputs: {
                        input: a
                    },
                    backend: n
                }),
                c = zM({
                    inputs: {
                        x: l
                    },
                    backend: n,
                    attrs: {
                        dtype: i
                    }
                });
            return n.disposeIntermediateTensorInfo(l), c
        }
        if (!bv(a.dtype, i)) {
            var p = DM({
                inputs: {
                    x: a
                },
                backend: n
            });
            return {
                dataId: p.dataId,
                shape: p.shape,
                dtype: i
            }
        }
        if ("int32" === i) {
            var h = n.data.get(a.dataId).values,
                f = Int32Array.from(h);
            return n.makeTensorInfo(a.shape, "int32", f)
        }
        if ("bool" === i) {
            var d = n.data.get(a.dataId).values,
                m = lg([0], a.dtype),
                v = RM(function (e, t) {
                    return e !== t ? 1 : 0
                })(a.shape, [], d, m, "bool"),
                g = v[0],
                y = v[1];
            return n.makeTensorInfo(y, "bool", g)
        }
        throw new Error("Error in Cast: failed to cast " + a.dtype + " to " + i)
    }
    var PM = {
        kernelName: "Cast",
        backendName: "cpu",
        kernelFunc: zM
    };

    function BM(e, t, n, r) {
        return null == n ? function (n) {
            var a = n.inputs,
                i = n.backend,
                o = a.a,
                s = a.b,
                u = i;
            IM([o, s], e);
            var l = u.data.get(o.dataId).values,
                c = u.data.get(s.dataId).values,
                p = r || o.dtype,
                h = t(o.shape, s.shape, l, c, p),
                f = h[0],
                d = h[1];
            return u.makeTensorInfo(d, p, f)
        } : function (e) {
            var a = e.inputs,
                i = e.backend,
                o = a.a,
                s = a.b,
                u = i;
            if ("complex64" === o.dtype || "complex64" === s.dtype) {
                var l = zM({
                        inputs: {
                            x: o
                        },
                        backend: u,
                        attrs: {
                            dtype: "complex64"
                        }
                    }),
                    c = u.data.get(l.dataId),
                    p = c.complexTensorInfos.real,
                    h = c.complexTensorInfos.imag,
                    f = u.data.get(p.dataId).values,
                    d = u.data.get(h.dataId).values,
                    m = zM({
                        inputs: {
                            x: s
                        },
                        backend: u,
                        attrs: {
                            dtype: "complex64"
                        }
                    }),
                    v = u.data.get(m.dataId),
                    g = v.complexTensorInfos.real,
                    y = v.complexTensorInfos.imag,
                    b = u.data.get(g.dataId).values,
                    x = u.data.get(y.dataId).values,
                    w = n(o.shape, s.shape, f, d, b, x),
                    k = w[0],
                    N = w[1],
                    I = w[2],
                    S = u.makeTensorInfo(I, "float32", k),
                    T = u.makeTensorInfo(I, "float32", N),
                    C = AM({
                        inputs: {
                            real: S,
                            imag: T
                        },
                        backend: u
                    });
                return u.disposeIntermediateTensorInfo(l), u.disposeIntermediateTensorInfo(m), u.disposeIntermediateTensorInfo(S), u.disposeIntermediateTensorInfo(T), C
            }
            var E = u.data.get(o.dataId).values,
                R = u.data.get(s.dataId).values,
                A = r || o.dtype,
                F = t(o.shape, s.shape, E, R, A),
                _ = F[0],
                D = F[1];
            return u.makeTensorInfo(D, A, _)
        }
    }

    function WM(e) {
        return function (t, n, r, a, i, o) {
            var s = kw(t, n),
                u = ov(s),
                l = s.length,
                c = Rv(s),
                p = mv("float32", u),
                h = mv("float32", u),
                f = xw(t, s),
                d = xw(n, s),
                m = PS(r, a),
                v = PS(i, o),
                g = t.length,
                y = Rv(t),
                b = n.length,
                x = Rv(n);
            if (f.length + d.length === 0)
                for (var w = 0; w < p.length; w++) {
                    var k = w % m.length,
                        N = w % v.length,
                        I = e(m[2 * k], m[2 * k + 1], v[2 * N], v[2 * N + 1]);
                    p[w] = I.real, h[w] = I.imag
                } else
                    for (var S = function (t) {
                            var n = Lv(t, l, c),
                                r = n.slice(-g);
                            f.forEach(function (e) {
                                return r[e] = 0
                            });
                            var a = Mv(r, g, y),
                                i = n.slice(-b);
                            d.forEach(function (e) {
                                return i[e] = 0
                            });
                            var o = Mv(i, b, x),
                                s = e(m[2 * a], m[2 * a + 1], v[2 * o], v[2 * o + 1]);
                            p[t] = s.real, h[t] = s.imag
                        }, T = 0; T < p.length; T++) S(T);
            return [p, h, s]
        }
    }
    var VM = RM(function (e, t) {
            return e + t
        }),
        UM = WM(function (e, t, n, r) {
            return {
                real: e + n,
                imag: t + r
            }
        }),
        GM = BM(Gv, VM, UM),
        jM = {
            kernelName: Gv,
            backendName: "cpu",
            kernelFunc: GM
        };

    function HM(e, t, n, r, a) {
        for (var i = ov(r), o = _v(a, n), s = 0; s < e.length; s++) {
            var u = e[s];
            if (u < 0) throw new Error("Input x must be non-negative!");
            u >= a || (o[u] += i > 0 ? t[s] : 1)
        }
        return o
    }

    function qM(e, t, n, r) {
        void 0 === r && (r = !1);
        for (var a = e.shape[0], i = e.shape[1], o = qy([a, n], t.dtype), s = 0; s < a; s++)
            for (var u = 0; u < i; u++) {
                var l = e.get(s, u);
                if (l < 0) throw new Error("Input x must be non-negative!");
                l >= n || (r ? o.set(1, s, l) : t.size > 0 ? o.set(o.get(s, l) + t.get(s, u), s, l) : o.set(o.get(s, l) + 1, s, l))
            }
        return o
    }

    function KM(e) {
        return function (t, n, r) {
            for (var a = mv(n, t.length), i = 0; i < t.length; ++i) a[i] = e(t[i], r);
            return a
        }
    }

    function XM(e, t, n) {
        return function (r) {
            var a = r.inputs,
                i = r.attrs,
                o = r.backend,
                s = a.x;
            if (IM(s, e), "string" === s.dtype || "string" === n) throw new Error("unaryKernelFunc does not support string input/output");
            for (var u = o, l = u.data.get(s.dataId).values, c = ov(s.shape), p = n || s.dtype, h = vv(p, c), f = 0; f < c; ++f) h[f] = t(l[f], i);
            return u.makeTensorInfo(s.shape, p, h)
        }
    }

    function YM(e, t, n) {
        return function (r) {
            var a = r.inputs,
                i = r.attrs,
                o = r.backend,
                s = a.x;
            if (IM(s, e), "string" === s.dtype || "string" === n) throw new Error("unaryKernelFunc does not support string input/output");
            var u = o,
                l = u.data.get(s.dataId).values,
                c = n || s.dtype,
                p = t(l, c, i);
            return u.makeTensorInfo(s.shape, c, p)
        }
    }
    var JM = KM(function (e) {
            return Math.ceil(e)
        }),
        ZM = {
            kernelName: "Ceil",
            backendName: "cpu",
            kernelFunc: YM("Ceil", JM)
        };

    function QM(e, t, n, r) {
        var a = vv(n, ov(t));
        if (r && "string" !== n) {
            var i = 0;
            e.forEach(function (e) {
                var t = ov(e.shape);
                a.set(e.vals, i), i += t
            })
        } else {
            var o = 0;
            e.forEach(function (e) {
                for (var r = "string" === n ? JS(e.vals) : e.vals, i = 0, s = 0; s < e.shape[0]; ++s)
                    for (var u = s * t[1] + o, l = 0; l < e.shape[1]; ++l) a[u + l] = r[i++];
                o += e.shape[1]
            })
        }
        return a
    }
    var $M = KM(function (e) {
            return Math.exp(e)
        }),
        eL = YM(Kv, $M),
        tL = {
            kernelName: Kv,
            backendName: "cpu",
            kernelFunc: eL
        },
        nL = KM(function (e) {
            return Math.expm1(e)
        }),
        rL = {
            kernelName: "Expm1",
            backendName: "cpu",
            kernelFunc: YM("Expm1", nL)
        },
        aL = KM(function (e) {
            return Math.floor(e)
        }),
        iL = {
            kernelName: "Floor",
            backendName: "cpu",
            kernelFunc: YM("Floor", aL)
        };

    function oL(e, t, n) {
        for (var r = qy(n, e.dtype), a = 0; a < r.size; ++a) {
            var i = r.indexToLoc(a).slice(),
                o = i[0],
                s = i[2],
                u = t.locToIndex([o, s]);
            i[2] = t.values[u];
            var l = e.locToIndex(i);
            r.values[a] = e.values[l]
        }
        return r
    }
    var sL = RM(function (e, t) {
            return e > t ? 1 : 0
        }),
        uL = {
            kernelName: "Greater",
            backendName: "cpu",
            kernelFunc: BM("Greater", sL, null, "bool")
        },
        lL = RM(function (e, t) {
            return e < t ? 1 : 0
        }),
        cL = {
            kernelName: "Less",
            backendName: "cpu",
            kernelFunc: BM("Less", lL, null, "bool")
        };

    function pL(e, t, n) {
        var r = (t - e) / (n - 1),
            a = _v(n, "float32");
        a[0] = e;
        for (var i = 1; i < a.length; i++) a[i] = a[i - 1] + r;
        return a
    }
    var hL = KM(function (e) {
            return Math.log(e)
        }),
        fL = YM(Xv, hL),
        dL = {
            kernelName: Xv,
            backendName: "cpu",
            kernelFunc: fL
        };

    function mL(e, t, n, r) {
        for (var a = mv(r, ov(n)), i = 0; i < a.length; ++i) {
            for (var o = i * t, s = e[o], u = 0; u < t; ++u) {
                var l = e[o + u];
                l > s && (s = l)
            }
            a[i] = s
        }
        return a
    }
    var vL = RM(function (e, t) {
            return Math.max(e, t)
        }),
        gL = {
            kernelName: "Maximum",
            backendName: "cpu",
            kernelFunc: BM("Maximum", vL)
        },
        yL = RM(function (e, t) {
            return Math.min(e, t)
        }),
        bL = {
            kernelName: "Minimum",
            backendName: "cpu",
            kernelFunc: BM("Minimum", yL)
        },
        xL = RM(function (e, t) {
            return e * t
        }),
        wL = WM(function (e, t, n, r) {
            return {
                real: e * n - t * r,
                imag: e * r + t * n
            }
        }),
        kL = BM("Multiply", xL, wL),
        NL = {
            kernelName: "Multiply",
            backendName: "cpu",
            kernelFunc: kL
        };

    function IL(e, t, n) {
        var r = ug(-1, n);
        return xL([], t, r, e, n)
    }
    var SL = {
            kernelName: "Neg",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = t.x;
                IM(r, "neg");
                var a = IL(n.data.get(r.dataId).values, r.shape, r.dtype),
                    i = a[0],
                    o = a[1];
                return n.makeTensorInfo(o, r.dtype, i)
            }
        },
        TL = {
            kernelName: "NotEqual",
            backendName: "cpu",
            kernelFunc: BM("NotEqual", RM(function (e, t) {
                return e !== t ? 1 : 0
            }), null, "bool")
        };

    function CL(e, t, n, r, a) {
        for (var i = t.length, o = ov(t), s = Rv(t), u = Rv(a), l = mv(n, ov(a)), c = 0; c < o; ++c) {
            for (var p = Lv(c, i, s), h = new Array(p.length), f = 0; f < h.length; f++) h[f] = p[r[f]];
            l[Mv(h, i, u)] = e[c]
        }
        return l
    }

    function EL(e) {
        var t = e.inputs,
            n = e.attrs,
            r = e.backend,
            a = t.x,
            i = n.perm;
        IM(a, "transpose");
        for (var o = a.shape.length, s = new Array(o), u = 0; u < s.length; u++) s[u] = a.shape[i[u]];
        var l = CL(r.data.get(a.dataId).values, a.shape, a.dtype, i, s);
        return {
            dataId: r.write(l, s, a.dtype),
            shape: s,
            dtype: a.dtype
        }
    }
    var RL = {
        kernelName: "Transpose",
        backendName: "cpu",
        kernelFunc: EL
    };

    function AL(e, t, n, r) {
        for (var a = lk(e, r), i = a[0], o = a[1], s = _g(t, "int32"), u = _v(ov(i), s), l = ov(o), c = 0; c < u.length; ++c) {
            for (var p = c * l, h = 1, f = 0; f < l; ++f) h *= n[p + f];
            u[c] = h
        }
        return {
            outVals: u,
            outShape: i,
            outDtype: s
        }
    }
    var FL = {
        kernelName: "Prod",
        backendName: "cpu",
        kernelFunc: function (e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = r.axis,
                o = r.keepDims;
            IM(a, "prod");
            var s = a.shape.length,
                u = fv(i, a.shape),
                l = hk(u, s),
                c = u,
                p = a,
                h = [];
            null != l && (p = EL({
                inputs: {
                    x: a
                },
                backend: n,
                attrs: {
                    perm: l
                }
            }), h.push(p), c = dk(c.length, s));
            var f = n.data.get(p.dataId).values,
                d = AL(p.shape, p.dtype, f, c),
                m = d.outVals,
                v = d.outShape,
                g = d.outDtype,
                y = v;
            return o && (y = ck(v, u)), h.forEach(function (e) {
                return n.disposeIntermediateTensorInfo(e)
            }), n.makeTensorInfo(y, g, m)
        }
    };

    function _L(e, t, n, r) {
        if (e === t || e < t && n < 0 || t < e && n > 1) return _v(0, r);
        var a = _v(Math.abs(Math.ceil((t - e) / n)), r);
        t < e && 1 === n && (n = -1), a[0] = e;
        for (var i = 1; i < a.length; i++) a[i] = a[i - 1] + n;
        return a
    }
    var DL = KM(function (e) {
            return 1 / Math.sqrt(e)
        }),
        OL = {
            kernelName: "Rsqrt",
            backendName: "cpu",
            kernelFunc: YM("Rsqrt", DL)
        };

    function ML(e, t, n, r, a) {
        var i = Ub(r, t, n),
            o = ov(n),
            s = Rv(r);
        if (i) {
            var u = Gb(t, s);
            return "string" === a ? e.slice(u, u + o) : e.subarray(u, u + o)
        }
        for (var l = qy(r, a, "string" === a ? JS(e) : e), c = qy(n, a), p = 0; p < c.size; ++p) {
            var h = c.indexToLoc(p),
                f = h.map(function (e, n) {
                    return e + t[n]
                });
            c.set.apply(c, [l.get.apply(l, f)].concat(h))
        }
        return "string" === a ? ZS(c.values) : c.values
    }

    function LL(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.x,
            i = r.begin,
            o = r.size;
        IM(a, "slice");
        var s = jb(a, i, o),
            u = s[0],
            l = s[1];
        Ab(a, u, l);
        var c = ML(n.data.get(a.dataId).values, u, l, a.shape, a.dtype);
        return n.makeTensorInfo(l, a.dtype, c)
    }
    var zL = {
            kernelName: "Slice",
            backendName: "cpu",
            kernelFunc: LL
        },
        PL = {
            kernelName: "SquaredDifference",
            backendName: "cpu",
            kernelFunc: BM("SquaredDifference", RM(function (e, t) {
                var n = e - t;
                return n * n
            }))
        };

    function BL(e, t, n, r) {
        for (var a = qy(e, t.dtype), i = 0; i < a.size; i++) {
            for (var o = a.indexToLoc(i), s = new Array(o.length), u = 0; u < s.length; u++) s[u] = o[u] * n[u] + r[u];
            a.set.apply(a, [t.get.apply(t, s)].concat(o))
        }
        return a
    }
    var WL = RM(function (e, t) {
            return e - t
        }),
        VL = WM(function (e, t, n, r) {
            return {
                real: e - n,
                imag: t - r
            }
        }),
        UL = BM(Qv, WL, VL),
        GL = {
            kernelName: Qv,
            backendName: "cpu",
            kernelFunc: UL
        };

    function jL(e, t) {
        for (var n = new Array(e.rank), r = 0; r < n.length; r++) n[r] = e.shape[r] * t[r];
        for (var a = qy(n, e.dtype), i = 0; i < a.values.length; ++i) {
            for (var o = a.indexToLoc(i), s = new Array(e.rank), u = 0; u < s.length; u++) s[u] = o[u] % e.shape[u];
            var l = e.locToIndex(s);
            a.values[i] = e.values[l]
        }
        return a
    }

    function HL(e, t, n, r, a) {
        for (var i = t[t.length - 1], o = e.length / i, s = i, u = mv(n, o * r), l = mv("int32", o * r), c = 0; c < o; c++) {
            for (var p = c * s, h = e.subarray(p, p + s), f = [], d = 0; d < h.length; d++) f.push({
                value: h[d],
                index: d
            });
            f.sort(function (e, t) {
                return t.value - e.value
            });
            for (var m = c * r, v = u.subarray(m, m + r), g = l.subarray(m, m + r), y = 0; y < r; y++) v[y] = f[y].value, g[y] = f[y].index
        }
        var b = t.slice();
        return b[b.length - 1] = r, [qy(b, n, u), qy(b, "int32", l)]
    }

    function qL(e, t, n, r) {
        for (var a = fv(t, n)[0], i = [1, n[0], 1], o = 0; o < a; o++) i[0] *= n[o];
        i[1] = n[a];
        for (var s = a + 1; s < n.length; s++) i[2] *= n[s];
        for (var u = {}, l = new Int32Array(n[a]), c = new xg(i, r, e), p = [], h = 1 === i[0] && 1 === i[2], f = 0; f < n[a]; f++) {
            var d = void 0;
            if (h) d = e[f].toString();
            else {
                for (var m = [], v = 0; v < i[0]; v++)
                    for (var g = 0; g < i[2]; g++) m.push(c.get(v, f, g));
                d = m.join(",")
            }
            if (void 0 !== u[d]) l[f] = u[d];
            else {
                var y = Object.keys(u).length;
                u[d] = y, l[f] = y, p.push(f)
            }
        }
        var b = i.slice();
        b[1] = Object.keys(u).length;
        var x = new xg(b, r);
        p.forEach(function (e, t) {
            for (var n = 0; n < i[0]; n++)
                for (var r = 0; r < i[2]; r++) x.set(c.get(n, e, r), n, t, r)
        });
        var w = n.slice();
        return w[a] = b[1], {
            outputValues: x.values,
            outputShape: w,
            indices: l
        }
    }
    ox("cpu", function () {
        return new TM
    }, 1);
    var KL = XM(Hv, function (e) {
            return e >= 0 ? e : Math.exp(e) - 1
        }),
        XL = {
            kernelName: Hv,
            backendName: "cpu",
            kernelFunc: KL
        };

    function YL(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.x,
            i = r.alpha;
        IM([a], "leakyRelu");
        for (var o = ov(a.shape), s = n.data.get(a.dataId).values, u = mv("float32", o), l = 0; l < s.length; l++) u[l] = s[l] < 0 ? i * s[l] : s[l];
        return n.makeTensorInfo(a.shape, "float32", u)
    }
    var JL = {
            kernelName: "LeakyRelu",
            backendName: "cpu",
            kernelFunc: YL
        },
        ZL = RM(function (e, t) {
            return e < 0 ? t * e : e
        });

    function QL(e) {
        var t = e.inputs,
            n = e.backend,
            r = t.x,
            a = t.alpha;
        IM([r, a], "prelu");
        var i = n.data.get(r.dataId).values,
            o = n.data.get(a.dataId).values,
            s = ZL(r.shape, a.shape, i, o, r.dtype),
            u = s[0],
            l = s[1];
        return n.makeTensorInfo(l, r.dtype, u)
    }
    var $L = {
            kernelName: "Prelu",
            backendName: "cpu",
            kernelFunc: QL
        },
        ez = XM("Relu", function (e) {
            return Math.max(0, e)
        }),
        tz = {
            kernelName: "Relu",
            backendName: "cpu",
            kernelFunc: ez
        },
        nz = XM("Relu6", function (e) {
            return Math.min(Math.max(0, e), 6)
        }),
        rz = {
            kernelName: "Relu6",
            backendName: "cpu",
            kernelFunc: nz
        };

    function az(e, t, n, r, a) {
        if ("linear" === n) return DM({
            inputs: {
                x: t
            },
            backend: e
        });
        if ("relu" === n) return ez({
            inputs: {
                x: t
            },
            backend: e
        });
        if ("elu" === n) return KL({
            inputs: {
                x: t
            },
            backend: e
        });
        if ("relu6" === n) return nz({
            inputs: {
                x: t
            },
            backend: e
        });
        if ("prelu" === n) return QL({
            inputs: {
                x: t,
                alpha: r
            },
            backend: e
        });
        if ("leakyrelu" === n) return YL({
            inputs: {
                x: t
            },
            backend: e,
            attrs: {
                alpha: a
            }
        });
        throw new Error("Activation " + n + " has not been implemented for the CPU backend.")
    }

    function iz(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.x,
            i = r.shape,
            o = ov(a.shape),
            s = hv(i, o),
            u = ov(s);
        nv(o === u, function () {
            return "The new shape (" + s + ") has " + u + " elements and the old shape (" + a.shape + ") has " + o + " elements. The new shape and old shape must have the same number of elements."
        }), n.incRef(a.dataId);
        var l = n.data.get(a.dataId);
        if (null != l.complexTensorInfos) {
            var c = l.complexTensorInfos.real,
                p = l.complexTensorInfos.imag;
            c.shape = s, p.shape = s
        }
        return {
            dataId: a.dataId,
            shape: s,
            dtype: a.dtype
        }
    }
    var oz = {
        kernelName: "Reshape",
        backendName: "cpu",
        kernelFunc: iz
    };

    function sz(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.a,
            i = t.b,
            o = r.transposeA,
            s = r.transposeB;
        IM([a, i], "matMul");
        var u = a.shape.length,
            l = i.shape.length,
            c = o ? a.shape[u - 2] : a.shape[u - 1],
            p = s ? i.shape[l - 1] : i.shape[l - 2],
            h = o ? a.shape[u - 1] : a.shape[u - 2],
            f = s ? i.shape[l - 2] : i.shape[l - 1],
            d = a.shape.slice(0, -2),
            m = i.shape.slice(0, -2),
            v = ov(d),
            g = ov(m);
        nv(u >= 2 && l >= 2 && (v === g || 1 === v || 1 === g), function () {
            return "Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (" + d + ") and (" + m + ")."
        });
        var y = (v > g ? a.shape.slice(0, -2) : i.shape.slice(0, -2)).concat([h, f]);
        nv(c === p, function () {
            return "Error in matMul: inner shapes (" + c + ") and (" + p + ") of Tensors with shapes " + a.shape + " and " + i.shape + " and transposeA=" + o + " and transposeB=" + s + " must match."
        });
        for (var b = s ? [g, f, p] : [g, p, f], x = iz({
                inputs: {
                    x: a
                },
                backend: n,
                attrs: {
                    shape: o ? [v, c, h] : [v, h, c]
                }
            }), w = iz({
                inputs: {
                    x: i
                },
                backend: n,
                attrs: {
                    shape: b
                }
            }), k = o ? x.shape[1] : x.shape[2], N = o ? x.shape[2] : x.shape[1], I = s ? w.shape[1] : w.shape[2], S = Math.max(v, g), T = n.data.get(x.dataId).values, C = n.data.get(w.dataId).values, E = Rv(x.shape), R = Rv(w.shape), A = o ? [E[0], 1, E[1]] : [E[0], E[1], 1], F = A[0], _ = A[1], D = A[2], O = s ? [1, R[1], R[0]] : [R[1], 1, R[0]], M = O[0], L = O[1], z = O[2], P = N * I, B = qy([S, N, I], x.dtype), W = B.values, V = n.blockSize, U = 0; U < S; U++)
            for (var G = 0; G < N; G += V)
                for (var j = 0; j < I; j += V)
                    for (var H = 0; H < k; H += V)
                        for (var q = Math.min(G + V, N), K = Math.min(j + V, I), X = Math.min(H + V, k), Y = G; Y < q; Y++)
                            for (var J = j; J < K; J++) {
                                for (var Z = 0, Q = H; Q < X; Q++) {
                                    var $ = Math.min(U, v - 1) * F,
                                        ee = Math.min(U, g - 1) * z;
                                    Z += T[$ + Y * _ + Q * D] * C[Q * M + J * L + ee]
                                }
                                W[U * P + (Y * I + J)] += Z
                            }
        return n.disposeIntermediateTensorInfo(x), n.disposeIntermediateTensorInfo(w), n.makeTensorInfo(y, B.dtype, B.values)
    }
    var uz = {
            kernelName: "BatchMatMul",
            backendName: "cpu",
            kernelFunc: sz
        },
        lz = {
            kernelName: "_FusedMatMul",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t, n, r, a = e.inputs,
                    i = e.backend,
                    o = e.attrs,
                    s = a.a,
                    u = a.b,
                    l = a.bias,
                    c = a.preluActivationWeights,
                    p = o.transposeA,
                    h = o.transposeB,
                    f = o.activation,
                    d = o.leakyreluAlpha,
                    m = [];
                t = sz({
                    inputs: {
                        a: s,
                        b: u
                    },
                    attrs: {
                        transposeA: p,
                        transposeB: h
                    },
                    backend: i
                }), l && (n = GM({
                    inputs: {
                        a: t,
                        b: l
                    },
                    backend: i
                }), m.push(t), t = n), f && (r = az(i, t, f, c, d), m.push(t), t = r);
                for (var v = 0, g = m; v < g.length; v++) {
                    var y = g[v];
                    i.disposeIntermediateTensorInfo(y)
                }
                return t
            }
        },
        cz = {
            kernelName: "Acos",
            backendName: "cpu",
            kernelFunc: XM("Acos", function (e) {
                return Math.acos(e)
            })
        },
        pz = {
            kernelName: "Acosh",
            backendName: "cpu",
            kernelFunc: XM("Acosh", function (e) {
                return Math.acosh(e)
            })
        },
        hz = {
            kernelName: "AddN",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = t;
                IM(t, "addN");
                for (var a = r.map(function (e) {
                        return n.data.get(e.dataId).values
                    }), i = qy(r[0].shape, r[0].dtype), o = i.values, s = 0; s < r.length; s++)
                    for (var u = a[s], l = 0; l < o.length; l++) o[l] += u[l];
                return n.makeTensorInfo(i.shape, i.dtype, i.values)
            }
        },
        fz = {
            kernelName: "All",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.axis,
                    o = r.keepDims;
                IM(a, "all");
                var s = fv(i, a.shape),
                    u = s,
                    l = hk(u, a.shape.length),
                    c = a;
                null != l && (c = EL({
                    inputs: {
                        x: a
                    },
                    backend: n,
                    attrs: {
                        perm: l
                    }
                }), u = dk(u.length, a.shape.length)), pk("all", u, c.shape.length);
                for (var p = lk(c.shape, u), h = p[0], f = ov(p[1]), d = _v(ov(h), c.dtype), m = n.data.get(c.dataId).values, v = 0; v < d.length; ++v) {
                    for (var g = v * f, y = m[g], b = 0; b < f; ++b) {
                        var x = m[g + b];
                        y = y && x
                    }
                    d[v] = y
                }
                null != l && n.disposeIntermediateTensorInfo(c);
                var w = n.makeTensorInfo(h, c.dtype, d);
                if (o) {
                    var k = iz({
                        inputs: {
                            x: w
                        },
                        backend: n,
                        attrs: {
                            shape: ck(h, s)
                        }
                    });
                    return n.disposeIntermediateTensorInfo(w), k
                }
                return w
            }
        },
        dz = {
            kernelName: "Any",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.axis,
                    o = r.keepDims;
                IM(a, "any");
                var s = fv(i, a.shape),
                    u = s,
                    l = hk(u, a.shape.length),
                    c = a;
                null != l && (c = EL({
                    inputs: {
                        x: a
                    },
                    backend: n,
                    attrs: {
                        perm: l
                    }
                }), u = dk(u.length, a.shape.length)), pk("any", u, c.shape.length);
                for (var p = lk(c.shape, u), h = p[0], f = ov(p[1]), d = _v(ov(h), c.dtype), m = n.data.get(c.dataId).values, v = 0; v < d.length; ++v) {
                    for (var g = v * f, y = m[g], b = 0; b < f; ++b) {
                        var x = m[g + b];
                        y = y || x
                    }
                    d[v] = y
                }
                null != l && n.disposeIntermediateTensorInfo(c);
                var w = n.makeTensorInfo(h, c.dtype, d);
                if (o) {
                    var k = iz({
                        inputs: {
                            x: w
                        },
                        backend: n,
                        attrs: {
                            shape: ck(h, s)
                        }
                    });
                    return n.disposeIntermediateTensorInfo(w), k
                }
                return w
            }
        },
        mz = {
            kernelName: "ArgMax",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.axis;
                IM(a, "argMax");
                var o = fv(i, a.shape),
                    s = hk(o, a.shape.length),
                    u = a,
                    l = [];
                null != s && (u = EL({
                    inputs: {
                        x: a
                    },
                    backend: n,
                    attrs: {
                        perm: s
                    }
                }), l.push(u), o = dk(o.length, u.shape.length)), pk("argMax", o = [o[0]], u.shape.length);
                for (var c = lk(u.shape, o), p = c[0], h = c[1], f = _v(ov(p), "int32"), d = ov(h), m = n.data.get(u.dataId).values, v = 0; v < f.length; ++v) {
                    for (var g = v * d, y = m[g], b = 0, x = 0; x < d; ++x) {
                        var w = m[g + x];
                        w > y && (y = w, b = x)
                    }
                    f[v] = b
                }
                return l.forEach(function (e) {
                    return n.disposeIntermediateTensorInfo(e)
                }), n.makeTensorInfo(p, "int32", f)
            }
        },
        vz = {
            kernelName: "ArgMin",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.axis;
                IM(a, "argMin");
                var o = fv(i, a.shape),
                    s = hk(o, a.shape.length),
                    u = a,
                    l = [];
                null != s && (u = EL({
                    inputs: {
                        x: a
                    },
                    backend: n,
                    attrs: {
                        perm: s
                    }
                }), l.push(u), o = dk(o.length, u.shape.length)), pk("argMin", o = [o[0]], u.shape.length);
                for (var c = lk(u.shape, o), p = c[0], h = c[1], f = _v(ov(p), "int32"), d = ov(h), m = n.data.get(u.dataId).values, v = 0; v < f.length; ++v) {
                    for (var g = v * d, y = m[g], b = 0, x = 0; x < d; ++x) {
                        var w = m[g + x];
                        w < y && (y = w, b = x)
                    }
                    f[v] = b
                }
                return l.forEach(function (e) {
                    return n.disposeIntermediateTensorInfo(e)
                }), n.makeTensorInfo(p, "int32", f)
            }
        },
        gz = {
            kernelName: "Asin",
            backendName: "cpu",
            kernelFunc: XM("Asin", function (e) {
                return Math.asin(e)
            })
        },
        yz = {
            kernelName: "Asinh",
            backendName: "cpu",
            kernelFunc: XM("Asinh", function (e) {
                return Math.asinh(e)
            })
        },
        bz = {
            kernelName: "Atan",
            backendName: "cpu",
            kernelFunc: XM("Atan", function (e) {
                return Math.atan(e)
            })
        },
        xz = {
            kernelName: "Atan2",
            backendName: "cpu",
            kernelFunc: BM("Atan2", RM(function (e, t) {
                return Math.atan2(e, t)
            }))
        },
        wz = {
            kernelName: "Atanh",
            backendName: "cpu",
            kernelFunc: XM("Atanh", function (e) {
                return Math.atanh(e)
            })
        };

    function kz(e, t, n, r, a, i) {
        for (var o = a.strideHeight, s = a.strideWidth, u = a.dilationHeight, l = a.dilationWidth, c = a.effectiveFilterHeight, p = a.effectiveFilterWidth, h = a.padInfo.top, f = a.padInfo.left, d = "max" === i ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, m = qy(a.outShape, n), v = m.values, g = a.outShape[1] * a.outShape[2] * a.outShape[3], y = a.outShape[2] * a.outShape[3], b = a.outShape[3], x = 0; x < a.batchSize; ++x)
            for (var w = x * g, k = x * r[0], N = 0; N < a.inChannels; ++N)
                for (var I = 0; I < a.outHeight; ++I)
                    for (var S = I * o - h, T = Math.max(0, S), C = Math.min(a.inHeight, c + S), E = w + I * y, R = 0; R < a.outWidth; ++R) {
                        for (var A = R * s - f, F = Math.max(0, A), _ = Math.min(a.inWidth, p + A), D = d, O = 0, M = 0, L = T; L < C; L += u) {
                            for (var z = k + L * r[1], P = F; P < _; P += l) {
                                var B = e[z + P * r[2] + N];
                                "max" === i && B > D ? D = B : "avg" === i && (O += B, M++)
                            }
                            if (isNaN(D)) break
                        }
                        v[E + R * b + N] = "avg" === i ? O / M : D
                    }
        return m
    }

    function Nz(e, t, n, r, a, i) {
        void 0 === a && (a = !1), void 0 === i && (i = !1);
        for (var o = qy(r.outShape, "int32"), s = r.strideHeight, u = r.strideWidth, l = r.dilationHeight, c = r.dilationWidth, p = r.effectiveFilterHeight, h = r.effectiveFilterWidth, f = r.padInfo.top, d = r.padInfo.left, m = qy(t, n, e), v = 0; v < r.batchSize; ++v)
            for (var g = 0; g < r.inChannels; ++g)
                for (var y = 0; y < r.outHeight; ++y) {
                    for (var b = y * s - f, x = b; x < 0;) x += l;
                    for (var w = Math.min(r.inHeight, p + b), k = 0; k < r.outWidth; ++k) {
                        for (var N = k * u - d, I = N; I < 0;) I += c;
                        for (var S = Math.min(r.inWidth, h + N), T = Number.NEGATIVE_INFINITY, C = -1, E = x; E < w; E += l)
                            for (var R = E - b, A = I; A < S; A += c) {
                                var F = A - N,
                                    _ = m.get(v, E, A, g);
                                _ > T && (T = _, C = a ? i ? ((v * r.inHeight + E) * r.inWidth + A) * r.inChannels + g : (E * r.inWidth + A) * r.inChannels + g : R * h + F)
                            }
                        o.set(C, v, y, k, g)
                    }
                }
        return o
    }

    function Iz(e, t, n, r, a, i) {
        for (var o = a.strideDepth, s = a.strideHeight, u = a.strideWidth, l = a.dilationDepth, c = a.dilationHeight, p = a.dilationWidth, h = a.effectiveFilterDepth, f = a.effectiveFilterHeight, d = a.effectiveFilterWidth, m = a.padInfo.front, v = a.padInfo.top, g = a.padInfo.left, y = "max" === i ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, b = qy(a.outShape, n), x = b.values, w = a.outShape[1] * a.outShape[2] * a.outShape[3] * a.outShape[4], k = a.outShape[2] * a.outShape[3] * a.outShape[4], N = a.outShape[3] * a.outShape[4], I = a.outShape[4], S = 0; S < a.batchSize; ++S)
            for (var T = S * w, C = S * r[0], E = 0; E < a.inChannels; ++E)
                for (var R = 0; R < a.outDepth; ++R) {
                    for (var A = R * o - m, F = A; F < 0;) F += l;
                    for (var _ = Math.min(a.inDepth, h + A), D = T + R * k, O = 0; O < a.outHeight; ++O) {
                        for (var M = O * s - v, L = M; L < 0;) L += c;
                        for (var z = Math.min(a.inHeight, f + M), P = D + O * N, B = 0; B < a.outWidth; ++B) {
                            for (var W = B * u - g, V = W; V < 0;) V += p;
                            for (var U = Math.min(a.inWidth, d + W), G = P + B * I, j = y, H = 0, q = 0, K = F; K < _; K += l) {
                                for (var X = C + K * r[1], Y = L; Y < z; Y += c) {
                                    for (var J = X + Y * r[2], Z = V; Z < U; Z += p) {
                                        var Q = e[J + Z * r[3] + E];
                                        if ("max" === i && Q > j ? j = Q : "avg" === i && (H += Q, q++), isNaN(j)) break
                                    }
                                    if (isNaN(j)) break
                                }
                                if (isNaN(j)) break
                            }
                            x[G + E] = "avg" === i ? H / q : j
                        }
                    }
                }
        return b
    }
    var Sz = {
            kernelName: "AvgPool",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x;
                IM(a, "avgPool");
                var i = r.filterSize,
                    o = r.strides,
                    s = r.pad,
                    u = r.dimRoundingMode;
                nv(Lx(o, 1), function () {
                    return "Error in avgPool: Either strides or dilations must be 1. Got strides " + o + " and dilations '1'"
                });
                var l, c = Tx(a.shape, i, o, 1, s, u);
                if (1 === c.filterWidth && 1 === c.filterHeight && sv(c.inShape, c.outShape)) l = DM({
                    inputs: {
                        x: a
                    },
                    backend: n
                });
                else {
                    var p = n.data.get(a.dataId).values,
                        h = Rv(a.shape),
                        f = kz(p, a.shape, a.dtype, h, c, "avg");
                    l = n.makeTensorInfo(c.outShape, a.dtype, f.values)
                }
                return l
            }
        },
        Tz = {
            kernelName: "AvgPool3D",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.filterSize,
                    o = r.strides,
                    s = r.pad,
                    u = r.dimRoundingMode,
                    l = r.dataFormat;
                IM(a, "avgPool3d");
                var c = Cx(a.shape, i, o, 1, s, u, l),
                    p = Iz(n.data.get(a.dataId).values, a.shape, a.dtype, Rv(a.shape), c, "avg");
                return n.makeTensorInfo(p.shape, "float32", p.values)
            }
        },
        Cz = {
            kernelName: "AvgPool3DGrad",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.dy,
                    i = t.input,
                    o = r.filterSize,
                    s = r.strides,
                    u = r.pad,
                    l = r.dimRoundingMode;
                IM([a, i], "avgPool3DGrad");
                for (var c = Cx(i.shape, o, s, 1, u, l), p = c.strideDepth, h = c.strideHeight, f = c.strideWidth, d = c.filterDepth, m = c.filterHeight, v = c.filterWidth, g = c.dilationDepth, y = c.dilationHeight, b = c.dilationWidth, x = c.effectiveFilterDepth, w = c.effectiveFilterHeight, k = c.effectiveFilterWidth, N = x - 1 - c.padInfo.front, I = k - 1 - c.padInfo.left, S = w - 1 - c.padInfo.top, T = qy(i.shape, "float32"), C = 1 / (d * m * v), E = n.bufferSync(a), R = 0; R < c.batchSize; ++R)
                    for (var A = 0; A < c.inChannels; ++A)
                        for (var F = 0; F < c.inDepth; ++F)
                            for (var _ = 0; _ < c.inHeight; ++_)
                                for (var D = 0; D < c.inWidth; ++D) {
                                    for (var O = F - N, M = _ - S, L = D - I, z = 0, P = 0; P < x; P += g) {
                                        var B = (O + P) / p;
                                        if (!(B < 0 || B >= c.outDepth || Math.floor(B) !== B))
                                            for (var W = 0; W < w; W += y) {
                                                var V = (M + W) / h;
                                                if (!(V < 0 || V >= c.outHeight || Math.floor(V) !== V))
                                                    for (var U = 0; U < k; U += b) {
                                                        var G = (L + U) / f;
                                                        G < 0 || G >= c.outWidth || Math.floor(G) !== G || (z += E.get(R, B, V, G, A))
                                                    }
                                            }
                                    }
                                    T.set(z * C, R, F, _, D, A)
                                }
                return n.makeTensorInfo(T.shape, T.dtype, T.values)
            }
        },
        Ez = {
            kernelName: "AvgPoolGrad",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.dy,
                    i = t.input,
                    o = i;
                IM([a, i], "avgPoolGrad");
                for (var s = r.filterSize, u = r.strides, l = r.pad, c = Tx(o.shape, s, u, 1, l), p = c.strideHeight, h = c.strideWidth, f = c.filterHeight, d = c.filterWidth, m = c.dilationHeight, v = c.dilationWidth, g = c.effectiveFilterHeight, y = c.effectiveFilterWidth, b = y - 1 - c.padInfo.left, x = g - 1 - c.padInfo.top, w = qy(o.shape, "float32"), k = 1 / (f * d), N = n.data.get(a.dataId).values, I = qy(a.shape, "float32", N), S = 0; S < c.batchSize; ++S)
                    for (var T = 0; T < c.inChannels; ++T)
                        for (var C = 0; C < c.inHeight; ++C)
                            for (var E = 0; E < c.inWidth; ++E) {
                                for (var R = C - x, A = E - b, F = 0, _ = 0; _ < g; _ += m) {
                                    var D = (R + _) / p;
                                    if (!(D < 0 || D >= c.outHeight || Math.floor(D) !== D))
                                        for (var O = 0; O < y; O += v) {
                                            var M = (A + O) / h;
                                            M < 0 || M >= c.outWidth || Math.floor(M) !== M || (F += I.get(S, D, M, T))
                                        }
                                }
                                w.set(F * k, S, C, E, T)
                            }
                return n.makeTensorInfo(w.shape, w.dtype, w.values)
            }
        },
        Rz = {
            kernelName: "FusedBatchNorm",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.scale,
                    o = t.offset,
                    s = t.mean,
                    u = t.variance;
                nv(s.shape.length === u.shape.length, function () {
                    return "Batch normalization gradient requires mean and variance to have equal ranks."
                }), nv(null == o || s.shape.length === o.shape.length, function () {
                    return "Batch normalization gradient requires mean and offset to have equal ranks."
                }), nv(null == i || s.shape.length === i.shape.length, function () {
                    return "Batch normalization gradient requires mean and scale to have equal ranks."
                }), IM([a, s, u, i, o], "batchNorm");
                var l = r.varianceEpsilon;
                null == l && (l = .001);
                for (var c = n.data.get(a.dataId).values, p = n.data.get(s.dataId).values, h = n.data.get(u.dataId).values, f = i ? n.data.get(i.dataId).values : new Float32Array([1]), d = o ? n.data.get(o.dataId).values : new Float32Array([0]), m = new Float32Array(c.length), v = d.length, g = f.length, y = h.length, b = p.length, x = 0, w = 0, k = 0, N = 0, I = 0; I < c.length; ++I) m[I] = d[x++] + (c[I] - p[w++]) * f[k++] / Math.sqrt(h[N++] + l), x >= v && (x = 0), w >= b && (w = 0), k >= g && (k = 0), N >= y && (N = 0);
                return n.makeTensorInfo(a.shape, a.dtype, m)
            }
        },
        Az = {
            kernelName: "BatchToSpaceND",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.blockShape,
                    o = r.crops;
                IM([a], "batchToSpaceND");
                var s = i.reduce(function (e, t) {
                        return e * t
                    }),
                    u = FS(a.shape, i, s),
                    l = _S(u.length, i.length),
                    c = DS(a.shape, i, s),
                    p = OS(o, i.length),
                    h = MS(c, o, i.length),
                    f = iz({
                        inputs: {
                            x: a
                        },
                        backend: n,
                        attrs: {
                            shape: u
                        }
                    }),
                    d = EL({
                        inputs: {
                            x: f
                        },
                        backend: n,
                        attrs: {
                            perm: l
                        }
                    }),
                    m = iz({
                        inputs: {
                            x: d
                        },
                        backend: n,
                        attrs: {
                            shape: c
                        }
                    }),
                    v = LL({
                        inputs: {
                            x: m
                        },
                        backend: n,
                        attrs: {
                            begin: p,
                            size: h
                        }
                    });
                return n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(m), v
            }
        },
        Fz = {
            kernelName: "Bincount",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.weights,
                    o = r.size,
                    s = HM(n.data.get(a.dataId).values, n.data.get(i.dataId).values, i.dtype, i.shape, o);
                return n.makeTensorInfo([o], i.dtype, s)
            }
        },
        _z = {
            kernelName: "ClipByValue",
            backendName: "cpu",
            kernelFunc: XM("ClipByValue", function (e, t) {
                var n = t;
                return e > n.clipValueMax ? n.clipValueMax : e < n.clipValueMin ? n.clipValueMin : e
            })
        },
        Dz = {
            kernelName: "ComplexAbs",
            backendName: "cpu",
            kernelFunc: function (e) {
                for (var t = e.inputs.x, n = e.backend, r = new Float32Array(ov(t.shape)), a = n.data.get(t.dataId), i = a.complexTensorInfos.real, o = a.complexTensorInfos.imag, s = n.data.get(i.dataId).values, u = n.data.get(o.dataId).values, l = 0; l < s.length; l++) {
                    var c = s[l],
                        p = u[l];
                    r[l] = Math.hypot(c, p)
                }
                return n.makeOutput(r, t.shape, "float32")
            }
        };

    function Oz(e) {
        var t = e.inputs,
            n = e.backend,
            r = t.input,
            a = n.data.get(r.dataId).complexTensorInfos.imag,
            i = n.data.get(a.dataId).values;
        return n.makeTensorInfo(a.shape, a.dtype, i)
    }
    var Mz = {
        kernelName: "Imag",
        backendName: "cpu",
        kernelFunc: Oz
    };

    function Lz(e) {
        var t = e.inputs,
            n = e.backend,
            r = fv(e.attrs.axis, t[0].shape)[0],
            a = ES(t.map(function (e) {
                return e.shape
            }), r);
        if (0 === ov(a)) return n.makeTensorInfo(a, t[0].dtype, []);
        var i = t.filter(function (e) {
            return ov(e.shape) > 0
        });
        if (1 === i.length) return DM({
            inputs: {
                x: i[0]
            },
            backend: n
        });
        if (CS(i.map(function (e) {
                return e.shape
            }), r), "complex64" === i[0].dtype) {
            var o = i.map(function (e) {
                    return MM({
                        inputs: {
                            input: e
                        },
                        backend: n
                    })
                }),
                s = i.map(function (e) {
                    return Oz({
                        inputs: {
                            input: e
                        },
                        backend: n
                    })
                }),
                u = Lz({
                    inputs: o,
                    backend: n,
                    attrs: {
                        axis: r
                    }
                }),
                l = Lz({
                    inputs: s,
                    backend: n,
                    attrs: {
                        axis: r
                    }
                }),
                c = AM({
                    inputs: {
                        real: u,
                        imag: l
                    },
                    backend: n
                });
            return o.forEach(function (e) {
                return n.disposeIntermediateTensorInfo(e)
            }), s.forEach(function (e) {
                return n.disposeIntermediateTensorInfo(e)
            }), n.disposeIntermediateTensorInfo(u), n.disposeIntermediateTensorInfo(l), c
        }
        var p = i.map(function (e) {
                var t = ov(e.shape.slice(r));
                return iz({
                    inputs: {
                        x: e
                    },
                    backend: n,
                    attrs: {
                        shape: [-1, t]
                    }
                })
            }),
            h = p.map(function (e) {
                return {
                    vals: n.data.get(e.dataId).values,
                    shape: e.shape
                }
            });
        a = ES(p.map(function (e) {
            return e.shape
        }), 1);
        var f = 1 === p[0].shape[0],
            d = QM(h, a, t[0].dtype, f),
            m = ES(i.map(function (e) {
                return e.shape
            }), r),
            v = n.makeTensorInfo(m, t[0].dtype, d);
        return p.forEach(function (e) {
            return n.disposeIntermediateTensorInfo(e)
        }), v
    }
    var zz = {
        kernelName: "Concat",
        backendName: "cpu",
        kernelFunc: Lz
    };

    function Pz(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.x,
            i = t.filter,
            o = r.strides,
            s = r.pad,
            u = r.dataFormat,
            l = r.dilations,
            c = r.dimRoundingMode;
        IM([a, i], "conv2d");
        for (var p = zx(u), h = Ex(a.shape, i.shape, o, l, s, c, !1, p), f = h.filterHeight, d = h.filterWidth, m = h.dilationHeight, v = h.dilationWidth, g = h.padInfo.left, y = h.padInfo.top, b = "channelsLast" === h.dataFormat, x = new xg(h.outShape, a.dtype), w = Rv(a.shape), k = Rv(i.shape), N = w[0], I = b ? w[1] : w[2], S = b ? w[2] : 1, T = b ? 1 : w[1], C = x.strides[0], E = b ? x.strides[1] : x.strides[2], R = b ? x.strides[2] : 1, A = b ? 1 : x.strides[1], F = n.data.get(a.dataId).values, _ = n.data.get(i.dataId).values, D = x.values, O = 0; O < h.batchSize; ++O)
            for (var M = O * N, L = O * C, z = 0; z < h.outHeight; ++z)
                for (var P = L + z * E, B = z * h.strideHeight - y, W = 0; W < f; ++W) {
                    var V = B + W * m;
                    if (!(V < 0 || V >= h.inHeight))
                        for (var U = W * k[0], G = M + V * I, j = 0; j < h.outWidth; ++j)
                            for (var H = P + j * R, q = j * h.strideWidth - g, K = 0; K < d; ++K) {
                                var X = q + K * v;
                                if (!(X < 0 || X >= h.inWidth))
                                    for (var Y = G + X * S, J = U + K * k[1], Z = 0; Z < h.inChannels; ++Z) {
                                        for (var Q = F[Y + Z * T], $ = 0; $ < h.outChannels; ++$) D[H + $ * A] += Q * _[J + $];
                                        J += h.outChannels
                                    }
                            }
                }
        return n.makeTensorInfo(x.shape, x.dtype, D)
    }
    var Bz = {
            kernelName: "Conv2D",
            backendName: "cpu",
            kernelFunc: Pz
        },
        Wz = {
            kernelName: "Conv2DBackpropFilter",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.dy,
                    o = r.strides,
                    s = r.pad,
                    u = r.dataFormat,
                    l = r.dimRoundingMode,
                    c = r.filterShape;
                IM([a, i], "conv2dBackpropFilter");
                for (var p = zx(u), h = Ex(a.shape, c, o, 1, s, l, !1, p), f = h.strideHeight, d = h.strideWidth, m = h.filterHeight, v = h.filterWidth, g = "channelsLast" === h.dataFormat, y = new xg(h.filterShape, "float32"), b = h.padInfo.left, x = h.padInfo.top, w = n.data.get(a.dataId).values, k = n.data.get(i.dataId).values, N = new xg(a.shape, a.dtype, w), I = new xg(i.shape, i.dtype, k), S = 0; S < m; ++S)
                    for (var T = Math.max(0, Math.ceil((x - S) / f)), C = Math.min(h.outHeight, (h.inHeight + x - S) / f), E = 0; E < v; ++E)
                        for (var R = Math.max(0, Math.ceil((b - E) / d)), A = Math.min(h.outWidth, (h.inWidth + b - E) / d), F = 0; F < h.inChannels; ++F)
                            for (var _ = 0; _ < h.outChannels; ++_) {
                                for (var D = 0, O = 0; O < h.batchSize; ++O)
                                    for (var M = T; M < C; ++M)
                                        for (var L = S + M * f - x, z = R; z < A; ++z) {
                                            var P = E + z * d - b;
                                            D += g ? N.get(O, L, P, F) * I.get(O, M, z, _) : N.get(O, F, L, P) * I.get(O, _, M, z)
                                        }
                                y.set(D, S, E, F, _)
                            }
                return n.makeTensorInfo(y.shape, y.dtype, y.values)
            }
        },
        Vz = {
            kernelName: "Conv2DBackpropInput",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.dy,
                    i = t.filter,
                    o = r.inputShape,
                    s = r.strides,
                    u = r.pad,
                    l = r.dataFormat,
                    c = r.dimRoundingMode;
                IM([a, i], "conv2dBackpropInput");
                var p = Rv(i.shape),
                    h = Rv(a.shape),
                    f = zx(l),
                    d = Ex(o, i.shape, s, 1, u, c, !1, f),
                    m = new xg(d.inShape, "float32"),
                    v = m.values,
                    g = n.data.get(a.dataId).values,
                    y = n.data.get(i.dataId).values,
                    b = p[0],
                    x = p[1],
                    w = p[2],
                    k = d.batchSize,
                    N = d.filterHeight,
                    I = d.filterWidth,
                    S = d.inChannels,
                    T = d.inHeight,
                    C = d.inWidth,
                    E = d.outChannels,
                    R = d.outHeight,
                    A = d.outWidth,
                    F = d.strideHeight,
                    _ = d.strideWidth;
                f = d.dataFormat;
                for (var D = N - 1 - d.padInfo.top, O = I - 1 - d.padInfo.left, M = "channelsLast" === f, L = m.strides[0], z = M ? m.strides[1] : m.strides[2], P = M ? m.strides[2] : 1, B = M ? 1 : m.strides[1], W = h[0], V = M ? h[1] : h[2], U = M ? h[2] : 1, G = M ? 1 : h[1], j = 0; j < k; ++j)
                    for (var H = 0; H < S; ++H)
                        for (var q = 0; q < T; ++q)
                            for (var K = q - D, X = Math.max(0, Math.ceil(K / F)), Y = Math.min(R, (N + K) / F), J = 0; J < C; ++J) {
                                for (var Z = J - O, Q = Math.max(0, Math.ceil(Z / _)), $ = Math.min(A, (I + Z) / _), ee = 0, te = X; te < Y; ++te)
                                    for (var ne = te * F - K, re = Q; re < $; ++re)
                                        for (var ae = W * j + V * te + U * re, ie = b * (N - 1 - ne) + x * (I - 1 - (re * _ - Z)) + w * H, oe = 0; oe < E; ++oe) ee += g[ae + G * oe] * y[ie + oe];
                                v[L * j + z * q + P * J + B * H] = ee
                            }
                return n.makeTensorInfo(m.shape, m.dtype, m.values)
            }
        },
        Uz = {
            kernelName: "Conv3D",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.filter,
                    o = r.strides,
                    s = r.pad,
                    u = r.dilations;
                IM([a, i], "conv3d");
                for (var l = Rx(a.shape, i.shape, o, u, s), c = l.filterDepth, p = l.filterHeight, h = l.filterWidth, f = l.dilationDepth, d = l.dilationHeight, m = l.dilationWidth, v = l.padInfo, g = v.front, y = v.left, b = v.top, x = new xg(l.outShape, a.dtype), w = n.data.get(a.dataId).values, k = n.data.get(i.dataId).values, N = x.values, I = Rv(a.shape), S = Rv(i.shape), T = 0; T < l.batchSize; ++T)
                    for (var C = T * I[0], E = T * x.strides[0], R = 0; R < l.outDepth; ++R)
                        for (var A = E + R * x.strides[1], F = R * l.strideDepth - g, _ = 0; _ < c; ++_) {
                            var D = F + _ * f;
                            if (!(D < 0 || D >= l.inDepth))
                                for (var O = _ * S[0], M = C + D * I[1], L = 0; L < l.outHeight; ++L)
                                    for (var z = A + L * x.strides[2], P = L * l.strideHeight - b, B = 0; B < p; ++B) {
                                        var W = P + B * d;
                                        if (!(W < 0 || W >= l.inHeight))
                                            for (var V = O + B * S[1], U = M + W * I[2], G = 0; G < l.outWidth; ++G)
                                                for (var j = z + G * l.outChannels, H = G * l.strideWidth - y, q = 0; q < h; ++q) {
                                                    var K = H + q * m;
                                                    if (!(K < 0 || K >= l.inWidth))
                                                        for (var X = V + q * S[2], Y = U + K * l.inChannels, J = X, Z = 0; Z < l.inChannels; ++Z) {
                                                            for (var Q = w[Y + Z], $ = 0; $ < l.outChannels; ++$) N[j + $] += Q * k[J + $];
                                                            J += l.outChannels
                                                        }
                                                }
                                    }
                        }
                return n.makeTensorInfo(x.shape, x.dtype, x.values)
            }
        },
        Gz = {
            kernelName: "Conv3DBackpropFilterV2",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.dy,
                    o = r.strides,
                    s = r.pad,
                    u = r.filterShape;
                IM([a, i], "conv3dBackpropFilterV2");
                for (var l = Rv(a.shape), c = Rv(i.shape), p = Rx(a.shape, u, o, 1, s), h = p.strideDepth, f = p.strideHeight, d = p.strideWidth, m = p.filterDepth, v = p.filterHeight, g = p.filterWidth, y = new xg(p.filterShape, "float32"), b = y.values, x = y.strides, w = x[0], k = x[1], N = x[2], I = x[3], S = n.data.get(i.dataId).values, T = c[0], C = c[1], E = c[2], R = c[3], A = n.data.get(a.dataId).values, F = l[0], _ = l[1], D = l[2], O = l[3], M = p.padInfo.front, L = p.padInfo.left, z = p.padInfo.top, P = 0; P < m; ++P)
                    for (var B = Math.max(0, Math.ceil((M - P) / h)), W = Math.min(p.outDepth, (p.inDepth + M - P) / h), V = P * w, U = 0; U < v; ++U)
                        for (var G = Math.max(0, Math.ceil((z - U) / f)), j = Math.min(p.outHeight, (p.inHeight + z - U) / f), H = U * k + V, q = 0; q < g; ++q)
                            for (var K = Math.max(0, Math.ceil((L - q) / d)), X = Math.min(p.outWidth, (p.inWidth + L - q) / d), Y = q * N + H, J = 0; J < p.inChannels; ++J)
                                for (var Z = J * I + Y, Q = 0; Q < p.outChannels; ++Q) {
                                    for (var $ = 0, ee = 0; ee < p.batchSize; ++ee)
                                        for (var te = ee * F, ne = ee * T, re = B; re < W; ++re)
                                            for (var ae = (P + re * h - M) * _ + te, ie = re * C + ne, oe = G; oe < j; ++oe)
                                                for (var se = (U + oe * f - z) * D + ae, ue = oe * E + ie, le = K; le < X; ++le) {
                                                    var ce = le * R + ue;
                                                    $ += A[(q + le * d - L) * O + se + J] * S[ce + Q]
                                                }
                                    b[Z + Q] = $
                                }
                return n.makeTensorInfo(y.shape, y.dtype, y.values)
            }
        },
        jz = {
            kernelName: "Conv3DBackpropInputV2",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.dy,
                    i = t.filter,
                    o = r.pad,
                    s = r.strides,
                    u = r.inputShape;
                IM([a], "conv3dBackpropInputV2");
                for (var l = Rv(a.shape), c = Rv(i.shape), p = Rx(u, i.shape, s, 1, o), h = new xg(p.inShape, "float32"), f = h.values, d = h.strides, m = d[0], v = d[1], g = d[2], y = d[3], b = n.data.get(a.dataId).values, x = l[0], w = l[1], k = l[2], N = l[3], I = n.data.get(i.dataId).values, S = c[0], T = c[1], C = c[2], E = c[3], R = p.batchSize, A = p.filterDepth, F = p.filterHeight, _ = p.filterWidth, D = p.inChannels, O = p.inDepth, M = p.inHeight, L = p.inWidth, z = p.outChannels, P = p.outDepth, B = p.outHeight, W = p.outWidth, V = p.strideDepth, U = p.strideHeight, G = p.strideWidth, j = A - 1 - p.padInfo.front, H = F - 1 - p.padInfo.top, q = _ - 1 - p.padInfo.left, K = 0; K < R; ++K)
                    for (var X = 0; X < D; ++X)
                        for (var Y = 0; Y < O; ++Y)
                            for (var J = Y - j, Z = Math.max(0, Math.ceil(J / V)), Q = Math.min(P, (A + J) / V), $ = 0; $ < M; ++$)
                                for (var ee = $ - H, te = Math.max(0, Math.ceil(ee / U)), ne = Math.min(B, (F + ee) / U), re = 0; re < L; ++re) {
                                    for (var ae = re - q, ie = Math.max(0, Math.ceil(ae / G)), oe = Math.min(W, (_ + ae) / G), se = 0, ue = Z; ue < Q; ++ue)
                                        for (var le = ue * V - J, ce = te; ce < ne; ++ce)
                                            for (var pe = ce * U - ee, he = ie; he < oe; ++he)
                                                for (var fe = x * K + w * ue + k * ce + N * he, de = S * (A - 1 - le) + T * (F - 1 - pe) + C * (_ - 1 - (he * G - ae)) + E * X, me = 0; me < z; ++me) se += b[fe + me] * I[de + me];
                                    f[m * K + v * Y + g * $ + y * re + X] = se
                                }
                return n.makeTensorInfo(h.shape, h.dtype, h.values)
            }
        },
        Hz = XM(jv, function (e) {
            return Math.cos(e)
        }),
        qz = {
            kernelName: jv,
            backendName: "cpu",
            kernelFunc: Hz
        },
        Kz = {
            kernelName: "Cosh",
            backendName: "cpu",
            kernelFunc: XM("Cosh", function (e) {
                return Math.cosh(e)
            })
        },
        Xz = {
            kernelName: "CropAndResize",
            backendName: "cpu",
            kernelFunc: function (e) {
                for (var t = e.inputs, n = e.backend, r = e.attrs, a = t.image, i = t.boxes, o = t.boxInd, s = r.cropSize, u = r.method, l = r.extrapolationValue, c = a.shape, p = c[0], h = c[1], f = c[2], d = c[3], m = i.shape[0], v = s[0], g = s[1], y = qy([m, v, g, d], "float32"), b = n.data.get(i.dataId).values, x = n.data.get(o.dataId).values, w = n.data.get(a.dataId).values, k = Rv(a.shape), N = Rv(y.shape), I = 0; I < m; I++) {
                    var S = 4 * I,
                        T = b[S],
                        C = b[S + 1],
                        E = b[S + 2],
                        R = b[S + 3],
                        A = x[I];
                    if (!(A >= p))
                        for (var F = v > 1 ? (E - T) * (h - 1) / (v - 1) : 0, _ = g > 1 ? (R - C) * (f - 1) / (g - 1) : 0, D = 0; D < v; D++) {
                            var O = v > 1 ? T * (h - 1) + D * F : .5 * (T + E) * (h - 1);
                            if (O < 0 || O > h - 1)
                                for (var M = 0; M < g; M++)
                                    for (var L = 0; L < d; L++) {
                                        var z = L + M * N[2] + D * N[1] + I * N[0];
                                        y.values[z] = l
                                    } else if ("bilinear" === u)
                                        for (var P = Math.floor(O), B = Math.ceil(O), W = O - P, V = 0; V < g; V++) {
                                            var U = g > 1 ? C * (f - 1) + V * _ : .5 * (C + R) * (f - 1);
                                            if (U < 0 || U > f - 1)
                                                for (var G = 0; G < d; G++) {
                                                    var j = G + V * N[2] + D * N[1] + I * N[0];
                                                    y.values[j] = l
                                                } else
                                                    for (var H = Math.floor(U), q = Math.ceil(U), K = U - H, X = 0; X < d; X++) {
                                                        var Y = X + H * k[2] + P * k[1] + A * k[0],
                                                            J = w[Y],
                                                            Z = w[Y = X + q * k[2] + P * k[1] + A * k[0]],
                                                            Q = w[Y = X + H * k[2] + B * k[1] + A * k[0]],
                                                            $ = J + (Z - J) * K,
                                                            ee = Q + (w[Y = X + q * k[2] + B * k[1] + A * k[0]] - Q) * K;
                                                        Y = X + V * N[2] + D * N[1] + I * N[0], y.values[Y] = $ + (ee - $) * W
                                                    }
                                        } else
                                            for (var te = 0; te < g; ++te) {
                                                var ne = g > 1 ? C * (f - 1) + te * _ : .5 * (C + R) * (f - 1);
                                                if (ne < 0 || ne > f - 1)
                                                    for (var re = 0; re < d; re++) {
                                                        var ae = re + te * N[2] + D * N[1] + I * N[0];
                                                        y.values[ae] = l
                                                    } else
                                                        for (var ie = Math.round(ne), oe = Math.round(O), se = 0; se < d; se++) {
                                                            var ue = se + ie * k[2] + oe * k[1] + A * k[0],
                                                                le = se + te * N[2] + D * N[1] + I * N[0];
                                                            y.values[le] = w[ue]
                                                        }
                                            }
                        }
                }
                return n.makeTensorInfo(y.shape, y.dtype, y.values)
            }
        },
        Yz = {
            kernelName: "Cumsum",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.axis,
                    o = r.exclusive,
                    s = r.reverse;
                IM(a, "cumsum");
                var u = hk([i], a.shape.length),
                    l = a;
                null != u && (l = EL({
                    inputs: {
                        x: a
                    },
                    backend: n,
                    attrs: {
                        perm: u
                    }
                }));
                var c = dk(1, a.shape.length)[0];
                if (c !== l.shape.length - 1) throw new Error("backend.cumsum in CPU expects an inner-most axis=" + (l.shape.length - 1) + " but got axis=" + c);
                for (var p = _g(l.dtype, "int32"), h = _v(ov(l.shape), p), f = n.data.get(l.dataId).values, d = l.shape[l.shape.length - 1], m = s ? function (e, t) {
                        return e + d - t - 1
                    } : function (e, t) {
                        return e + t
                    }, v = 0; v < f.length; v += d)
                    for (var g = 0; g < d; g++) {
                        var y = m(v, g);
                        if (0 === g) h[y] = o ? 0 : f[y];
                        else {
                            var b = m(v, g - 1);
                            h[y] = o ? f[b] + h[b] : f[y] + h[b]
                        }
                    }
                var x = n.makeTensorInfo(l.shape, p, h);
                if (null != u) {
                    var w = EL({
                        inputs: {
                            x: x
                        },
                        backend: n,
                        attrs: {
                            perm: fk(u)
                        }
                    });
                    return n.disposeIntermediateTensorInfo(x), n.disposeIntermediateTensorInfo(l), w
                }
                return x
            }
        },
        Jz = {
            kernelName: "DenseBincount",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.weights,
                    o = r.size,
                    s = r.binaryOutput;
                if (1 === a.shape.length) {
                    var u = HM(n.data.get(a.dataId).values, n.data.get(i.dataId).values, i.dtype, i.shape, o);
                    return n.makeTensorInfo([o], i.dtype, u)
                }
                if (2 === a.shape.length) {
                    var l = qM(n.bufferSync(a), n.bufferSync(i), o, s);
                    return n.makeTensorInfo(l.shape, i.dtype, l.values)
                }
                throw new Error("Error in denseBincount: input must be at most rank 2, but got rank" + a.shape.length + ".")
            }
        },
        Zz = {
            kernelName: "DepthToSpace",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.blockSize,
                    o = r.dataFormat;
                nv("NHWC" === o, function () {
                    return "Only NHWC dataFormat supported on CPU for depthToSpace. Got " + o
                }), nv(i > 1, function () {
                    return "blockSize should be > 1 for depthToSpace, but was: " + i
                });
                for (var s = a.shape[0], u = a.shape[1], l = a.shape[2], c = a.shape[3], p = u * i, h = l * i, f = c / (i * i), d = n.data.get(a.dataId).values, m = new Float32Array(s * p * h * f), v = 0, g = 0; g < s; ++g)
                    for (var y = 0; y < p; ++y)
                        for (var b = Math.floor(y / i), x = y % i, w = 0; w < h; ++w)
                            for (var k = Math.floor(w / i), N = (x * i + w % i) * f, I = 0; I < f; ++I) {
                                var S = I + N + c * (k + l * (b + u * g));
                                m[v++] = d[S]
                            }
                return n.makeTensorInfo([s, p, h, f], a.dtype, m)
            }
        };

    function Qz(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.x,
            i = t.filter,
            o = r.strides,
            s = r.pad,
            u = r.dilations,
            l = r.dimRoundingMode;
        IM([a, i], "depthwiseConv2DNative");
        var c = Rv(a.shape),
            p = Rv(i.shape),
            h = u;
        null == h && (h = [1, 1]), nv(Lx(o, h), function () {
            return "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides " + o + " and dilations '" + h + "'"
        });
        for (var f = Ex(a.shape, i.shape, o, h, s, l, !0), d = f.filterHeight, m = f.filterWidth, v = f.dilationHeight, g = f.dilationWidth, y = f.padInfo, b = y.left, x = y.top, w = f.outChannels / f.inChannels, k = new xg(f.outShape, a.dtype), N = n.data.get(a.dataId).values, I = n.data.get(i.dataId).values, S = k.values, T = 0; T < f.batchSize; ++T)
            for (var C = T * c[0], E = T * k.strides[0], R = 0; R < f.outHeight; ++R)
                for (var A = E + R * k.strides[1], F = R * f.strideHeight - b, _ = 0; _ < d; ++_) {
                    var D = F + _ * v;
                    if (!(D < 0 || D >= f.inHeight))
                        for (var O = _ * p[0], M = C + D * c[1], L = 0; L < f.outWidth; ++L)
                            for (var z = A + L * k.strides[2], P = L * f.strideWidth - x, B = 0; B < m; ++B) {
                                var W = P + B * g;
                                if (!(W < 0 || W >= f.inWidth))
                                    for (var V = O + B * p[1], U = M + W * f.inChannels, G = z, j = V, H = 0; H < f.inChannels; ++H) {
                                        for (var q = N[U + H], K = 0; K < w; ++K) S[G + K] += q * I[j + K];
                                        G += w, j += w
                                    }
                            }
                }
        return n.makeTensorInfo(k.shape, k.dtype, k.values)
    }
    var $z = {
            kernelName: "DepthwiseConv2dNative",
            backendName: "cpu",
            kernelFunc: Qz
        },
        eP = {
            kernelName: "DepthwiseConv2dNativeBackpropFilter",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.dy,
                    o = r.strides,
                    s = r.dilations,
                    u = r.pad,
                    l = r.dimRoundingMode,
                    c = r.filterShape;
                IM([a, i], "depthwiseConv2dNativeBackpropFilter");
                for (var p = Ex(a.shape, c, o, s, u, l, !0), h = p.strideHeight, f = p.strideWidth, d = p.filterHeight, m = p.filterWidth, v = new xg(p.filterShape, "float32"), g = p.padInfo.left, y = p.padInfo.top, b = p.outChannels / p.inChannels, x = n.data.get(a.dataId).values, w = new xg(a.shape, a.dtype, x), k = n.data.get(i.dataId).values, N = new xg(i.shape, i.dtype, k), I = 0; I < d; ++I)
                    for (var S = Math.max(0, Math.ceil((y - I) / h)), T = Math.min(p.outHeight, (p.inHeight + y - I) / h), C = 0; C < m; ++C)
                        for (var E = Math.max(0, Math.ceil((g - C) / f)), R = Math.min(p.outWidth, (p.inWidth + g - C) / f), A = 0; A < p.outChannels; ++A) {
                            for (var F = Math.trunc(A / b), _ = A % b, D = 0, O = 0; O < p.batchSize; ++O)
                                for (var M = S; M < T; ++M)
                                    for (var L = I + M * h - y, z = E; z < R; ++z) {
                                        var P = C + z * f - g;
                                        D += w.get(O, L, P, F) * N.get(O, M, z, A)
                                    }
                            v.set(D, I, C, F, _)
                        }
                return n.makeTensorInfo(v.shape, v.dtype, v.values)
            }
        },
        tP = {
            kernelName: "DepthwiseConv2dNativeBackpropInput",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.dy,
                    i = t.filter,
                    o = r.strides,
                    s = r.dilations,
                    u = r.pad,
                    l = r.dimRoundingMode,
                    c = r.inputShape;
                IM([a, i], "depthwiseConv2DNativeBackpropInput");
                for (var p = Rv(a.shape), h = Rv(i.shape), f = Ex(c, i.shape, o, s, u, l, !0), d = new xg(f.inShape, "float32"), m = d.values, v = d.strides, g = v[0], y = v[1], b = v[2], x = n.data.get(a.dataId).values, w = p[0], k = p[1], N = p[2], I = n.data.get(i.dataId).values, S = h[0], T = h[1], C = h[2], E = f.batchSize, R = f.filterHeight, A = f.filterWidth, F = f.inChannels, _ = f.inHeight, D = f.inWidth, O = f.outChannels, M = f.outHeight, L = f.outWidth, z = f.strideHeight, P = f.strideWidth, B = R - 1 - f.padInfo.top, W = A - 1 - f.padInfo.left, V = O / F, U = 0; U < E; ++U)
                    for (var G = 0; G < F; ++G)
                        for (var j = 0; j < _; ++j)
                            for (var H = j - B, q = Math.max(0, Math.ceil(H / z)), K = Math.min(M, (R + H) / z), X = 0; X < D; ++X) {
                                for (var Y = X - W, J = Math.max(0, Math.ceil(Y / P)), Z = Math.min(L, (A + Y) / P), Q = 0, $ = q; $ < K; ++$)
                                    for (var ee = $ * z - H, te = J; te < Z; ++te)
                                        for (var ne = w * U + k * $ + N * te, re = S * (R - 1 - ee) + T * (A - 1 - (te * P - Y)) + C * G, ae = 0; ae < V; ++ae) Q += x[ne + (G * V + ae)] * I[re + ae];
                                m[g * U + y * j + b * X + G] = Q
                            }
                return n.makeTensorInfo(d.shape, d.dtype, d.values)
            }
        },
        nP = {
            kernelName: "Diag",
            backendName: "cpu",
            kernelFunc: function (e) {
                for (var t = e.inputs, n = e.backend, r = t.x, a = ov(r.shape), i = n.data.get(r.dataId).values, o = qy([a, a], r.dtype), s = o.values, u = 0; u < i.length; u++) s[u * a + u] = i[u];
                var l = [].concat(r.shape, r.shape);
                return n.makeTensorInfo(l, o.dtype, o.values)
            }
        },
        rP = {
            kernelName: "Dilation2D",
            backendName: "cpu",
            kernelFunc: function (e) {
                for (var t = e.inputs, n = e.backend, r = e.attrs, a = t.x, i = t.filter, o = r.strides, s = r.pad, u = r.dilations, l = n, c = l.data.get(a.dataId).values, p = a.shape.length, h = l.data.get(i.dataId).values, f = i.shape.length, d = Sx(a.shape, i.shape, o, s, "NHWC", u), m = d.batchSize, v = d.inHeight, g = d.inWidth, y = d.inChannels, b = d.outHeight, x = d.outWidth, w = d.padInfo, k = d.strideHeight, N = d.strideWidth, I = d.filterHeight, S = d.filterWidth, T = d.dilationHeight, C = d.dilationWidth, E = d.outShape, R = ov(E), A = E.length, F = vv(a.dtype, R), _ = 0; _ < m; ++_)
                    for (var D = 0; D < b; ++D)
                        for (var O = D * k - w.top, M = 0; M < x; ++M)
                            for (var L = M * N - w.left, z = 0; z < y; ++z) {
                                for (var P = Number.MIN_SAFE_INTEGER, B = 0; B < I; ++B) {
                                    var W = O + B * T;
                                    if (W >= 0 && W < v)
                                        for (var V = 0; V < S; ++V) {
                                            var U = L + V * C;
                                            if (U >= 0 && U < g) {
                                                var G = Mv([_, W, U, z], p, Rv(a.shape)),
                                                    j = Mv([B, V, z], f, Rv(i.shape)),
                                                    H = c[G] + h[j];
                                                H > P && (P = H)
                                            }
                                        }
                                }
                                F[Mv([_, D, M, z], A, Rv(E))] = P
                            }
                return {
                    dataId: l.write(lg(F, a.dtype), E, a.dtype),
                    shape: E,
                    dtype: a.dtype
                }
            }
        },
        aP = {
            kernelName: "Dilation2DBackpropFilter",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.filter,
                    o = t.dy,
                    s = r.strides,
                    u = r.pad,
                    l = r.dilations,
                    c = n,
                    p = Av(a.shape, c.data.get(a.dataId).values),
                    h = Av(i.shape, c.data.get(i.dataId).values),
                    f = Sx(a.shape, i.shape, s, u, "NHWC", l),
                    d = f.batchSize,
                    m = f.inHeight,
                    v = f.inWidth,
                    g = f.inChannels,
                    y = f.outHeight,
                    b = f.outWidth,
                    x = f.padInfo,
                    w = f.strideHeight,
                    k = f.strideWidth,
                    N = f.filterHeight,
                    I = f.filterWidth,
                    S = f.dilationHeight,
                    T = f.dilationWidth,
                    C = f.outShape;
                nv(o.rank === C.length, function () {
                    return "Error in Dilation2DBackpropFilter, dy must have the same rank as output " + C.length + ", but got " + o.rank
                });
                for (var E = Av(C, c.data.get(o.dataId).values), R = Dv(i.shape, i.dtype), A = 0; A < d; ++A)
                    for (var F = 0; F < y; ++F)
                        for (var _ = F * w - x.top, D = 0; D < b; ++D)
                            for (var O = D * k - x.left, M = 0; M < g; ++M) {
                                for (var L = Number.MIN_SAFE_INTEGER, z = 0, P = 0, B = 0; B < N; ++B) {
                                    var W = _ + B * S;
                                    if (W >= 0 && W < m)
                                        for (var V = 0; V < I; ++V) {
                                            var U = O + V * T;
                                            if (U >= 0 && U < v) {
                                                var G = p[A][W][U][M] + h[B][V][M];
                                                G > L && (L = G, z = B, P = V)
                                            }
                                        }
                                }
                                R[z][P][M] += E[A][F][D][M]
                            }
                return {
                    dataId: c.write(lg(R, a.dtype), i.shape, i.dtype),
                    shape: i.shape,
                    dtype: i.dtype
                }
            }
        },
        iP = {
            kernelName: "Dilation2DBackpropInput",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.filter,
                    o = t.dy,
                    s = r.strides,
                    u = r.pad,
                    l = r.dilations,
                    c = n,
                    p = Av(a.shape, c.data.get(a.dataId).values),
                    h = Av(i.shape, c.data.get(i.dataId).values),
                    f = Sx(a.shape, i.shape, s, u, "NHWC", l),
                    d = f.batchSize,
                    m = f.inHeight,
                    v = f.inWidth,
                    g = f.inChannels,
                    y = f.outHeight,
                    b = f.outWidth,
                    x = f.padInfo,
                    w = f.strideHeight,
                    k = f.strideWidth,
                    N = f.filterHeight,
                    I = f.filterWidth,
                    S = f.dilationHeight,
                    T = f.dilationWidth,
                    C = f.outShape;
                nv(o.rank === C.length, function () {
                    return "Error in Dilation2DBackpropInput, dy must have the same rank as output " + C.length + ", but got " + o.rank
                });
                for (var E = Av(C, c.data.get(o.dataId).values), R = Dv(a.shape, a.dtype), A = 0; A < d; ++A)
                    for (var F = 0; F < y; ++F)
                        for (var _ = F * w - x.top, D = 0; D < b; ++D)
                            for (var O = D * k - x.left, M = 0; M < g; ++M) {
                                for (var L = Number.MIN_SAFE_INTEGER, z = _ < 0 ? 0 : _, P = O < 0 ? 0 : O, B = 0; B < N; ++B) {
                                    var W = _ + B * S;
                                    if (W >= 0 && W < m)
                                        for (var V = 0; V < I; ++V) {
                                            var U = O + V * T;
                                            if (U >= 0 && U < v) {
                                                var G = p[A][W][U][M] + h[B][V][M];
                                                G > L && (L = G, z = W, P = U)
                                            }
                                        }
                                }
                                R[A][z][P][M] += E[A][F][D][M]
                            }
                return {
                    dataId: c.write(lg(R, a.dtype), a.shape, a.dtype),
                    shape: a.shape,
                    dtype: a.dtype
                }
            }
        },
        oP = {
            kernelName: "EluGrad",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = t.dy,
                    a = t.y;
                IM([r, a], "eluGrad");
                for (var i = new Float32Array(ov(a.shape)), o = n.data.get(a.dataId).values, s = n.data.get(r.dataId).values, u = 0; u < o.length; ++u) {
                    var l = o[u];
                    i[u] = l >= 1 ? s[u] : s[u] * (l + 1)
                }
                return n.makeTensorInfo(a.shape, "float32", i)
            }
        },
        sP = BM("Equal", RM(function (e, t) {
            return e === t ? 1 : 0
        }), null, "bool"),
        uP = {
            kernelName: "Equal",
            backendName: "cpu",
            kernelFunc: sP
        },
        lP = XM(qv, function (e) {
            var t = Math.sign(e),
                n = Math.abs(e),
                r = 1 / (1 + .3275911 * n);
            return t * (1 - ((((1.061405429 * r - 1.453152027) * r + 1.421413741) * r - .284496736) * r + .254829592) * r * Math.exp(-n * n))
        }),
        cP = {
            kernelName: qv,
            backendName: "cpu",
            kernelFunc: lP
        };

    function pP(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.input,
            i = r.dim,
            o = a.shape.length,
            s = a.shape.slice(),
            u = i;
        return i < 0 && (nv(-(o + 1) <= i, function () {
            return "Axis must be in the interval [" + -(o + 1) + ", " + o + "]"
        }), u = o + i + 1), s.splice(u, 0, 1), iz({
            inputs: {
                x: a
            },
            backend: n,
            attrs: {
                shape: s
            }
        })
    }
    var hP = {
            kernelName: "ExpandDims",
            backendName: "cpu",
            kernelFunc: pP
        },
        fP = BM("RealDiv", RM(function (e, t) {
            return e / t
        })),
        dP = {
            kernelName: "RealDiv",
            backendName: "cpu",
            kernelFunc: fP
        };

    function mP(e, t, n) {
        for (var r = e.shape, a = r[0], i = r[1], o = n.data.get(e.dataId), s = o.complexTensorInfos.real, u = o.complexTensorInfos.imag, l = [a, i], c = ov(l), p = mv("float32", c), h = mv("float32", c), f = 0; f < a; f++) {
            for (var d = LL({
                    inputs: {
                        x: s
                    },
                    backend: n,
                    attrs: {
                        begin: [f, 0],
                        size: [1, i]
                    }
                }), m = LL({
                    inputs: {
                        x: u
                    },
                    backend: n,
                    attrs: {
                        begin: [f, 0],
                        size: [1, i]
                    }
                }), v = AM({
                    inputs: {
                        real: d,
                        imag: m
                    },
                    backend: n
                }), g = vP(v, t, n), y = PS(g.real, g.imag), b = 0; b < i; b++) {
                var x = US(y, b);
                p[f * i + b] = x.real, h[f * i + b] = x.imag
            }
            n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(m), n.disposeIntermediateTensorInfo(v)
        }
        var w = n.makeTensorInfo(l, "float32", p),
            k = n.makeTensorInfo(l, "float32", h),
            N = AM({
                inputs: {
                    real: w,
                    imag: k
                },
                backend: n
            });
        return n.disposeIntermediateTensorInfo(w), n.disposeIntermediateTensorInfo(k), N
    }

    function vP(e, t, n) {
        var r, a = ov(e.shape),
            i = n.data.get(e.dataId),
            o = n.data.get(i.complexTensorInfos.real.dataId).values,
            s = n.data.get(i.complexTensorInfos.imag.dataId).values;
        if (0 == ((r = a) & r - 1)) {
            var u = function e(t, n, r, a, i) {
                    if (1 === r) return {
                        real: t,
                        imag: n
                    };
                    var o = PS(t, n),
                        s = r / 2,
                        u = WS(o),
                        l = u.real,
                        c = u.imag,
                        p = [l.length],
                        h = i.makeTensorInfo(p, "float32", l),
                        f = i.makeTensorInfo(p, "float32", c),
                        d = AM({
                            inputs: {
                                real: h,
                                imag: f
                            },
                            backend: i
                        }),
                        m = VS(o),
                        v = m.real,
                        g = m.imag,
                        y = [v.length],
                        b = i.makeTensorInfo(y, "float32", v),
                        x = i.makeTensorInfo(y, "float32", g),
                        w = AM({
                            inputs: {
                                real: b,
                                imag: x
                            },
                            backend: i
                        }),
                        k = e(l, c, s, a, i),
                        N = k.real,
                        I = k.imag,
                        S = [N.length],
                        T = i.makeTensorInfo(S, "float32", N),
                        C = i.makeTensorInfo(S, "float32", I),
                        E = AM({
                            inputs: {
                                real: T,
                                imag: C
                            },
                            backend: i
                        }),
                        R = e(v, g, s, a, i),
                        A = R.real,
                        F = R.imag,
                        _ = [A.length],
                        D = i.makeTensorInfo(_, "float32", A),
                        O = i.makeTensorInfo(_, "float32", F),
                        M = AM({
                            inputs: {
                                real: D,
                                imag: O
                            },
                            backend: i
                        }),
                        L = jS(r, a),
                        z = [L.real.length],
                        P = i.makeTensorInfo(z, "float32", L.real),
                        B = i.makeTensorInfo(z, "float32", L.imag),
                        W = AM({
                            inputs: {
                                real: P,
                                imag: B
                            },
                            backend: i
                        }),
                        V = kL({
                            inputs: {
                                a: W,
                                b: M
                            },
                            backend: i
                        }),
                        U = GM({
                            inputs: {
                                a: E,
                                b: V
                            },
                            backend: i
                        }),
                        G = UL({
                            inputs: {
                                a: E,
                                b: V
                            },
                            backend: i
                        }),
                        j = MM({
                            inputs: {
                                input: U
                            },
                            backend: i
                        }),
                        H = MM({
                            inputs: {
                                input: G
                            },
                            backend: i
                        }),
                        q = Oz({
                            inputs: {
                                input: U
                            },
                            backend: i
                        }),
                        K = Oz({
                            inputs: {
                                input: G
                            },
                            backend: i
                        }),
                        X = Lz({
                            inputs: [j, H],
                            backend: i,
                            attrs: {
                                axis: 0
                            }
                        }),
                        Y = Lz({
                            inputs: [q, K],
                            backend: i,
                            attrs: {
                                axis: 0
                            }
                        }),
                        J = i.data.get(X.dataId).values,
                        Z = i.data.get(Y.dataId).values;
                    return i.disposeIntermediateTensorInfo(h), i.disposeIntermediateTensorInfo(f), i.disposeIntermediateTensorInfo(d), i.disposeIntermediateTensorInfo(b), i.disposeIntermediateTensorInfo(x), i.disposeIntermediateTensorInfo(w), i.disposeIntermediateTensorInfo(T), i.disposeIntermediateTensorInfo(C), i.disposeIntermediateTensorInfo(E), i.disposeIntermediateTensorInfo(D), i.disposeIntermediateTensorInfo(O), i.disposeIntermediateTensorInfo(M), i.disposeIntermediateTensorInfo(P), i.disposeIntermediateTensorInfo(B), i.disposeIntermediateTensorInfo(W), i.disposeIntermediateTensorInfo(V), i.disposeIntermediateTensorInfo(U), i.disposeIntermediateTensorInfo(G), i.disposeIntermediateTensorInfo(j), i.disposeIntermediateTensorInfo(q), i.disposeIntermediateTensorInfo(H), i.disposeIntermediateTensorInfo(K), i.disposeIntermediateTensorInfo(X), i.disposeIntermediateTensorInfo(Y), {
                        real: J,
                        imag: Z
                    }
                }(o, s, a, t, n),
                l = [e.shape[0], e.shape[1]];
            if (t) {
                var c = n.makeTensorInfo(l, "float32", u.real),
                    p = n.makeTensorInfo(l, "float32", u.imag),
                    h = n.makeTensorInfo([], "float32", ug(a, "float32")),
                    f = DM({
                        inputs: {
                            x: h
                        },
                        backend: n
                    }),
                    d = dP.kernelFunc({
                        inputs: {
                            a: c,
                            b: h
                        },
                        backend: n
                    }),
                    m = dP.kernelFunc({
                        inputs: {
                            a: p,
                            b: f
                        },
                        backend: n
                    }),
                    v = n.data.get(d.dataId).values,
                    g = n.data.get(m.dataId).values;
                return n.disposeIntermediateTensorInfo(c), n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(m), {
                    real: v,
                    imag: g
                }
            }
            return u
        }
        return BS(function (e, t, n) {
            for (var r = new Float32Array(2 * t), a = 0; a < t; a++) {
                for (var i = 0, o = 0, s = 0; s < t; s++) {
                    var u = HS(a * s, t, n),
                        l = US(e, s);
                    i += l.real * u.real - l.imag * u.imag, o += l.real * u.imag + l.imag * u.real
                }
                n && (i /= t, o /= t), GS(r, i, o, a)
            }
            return r
        }(PS(o, s), a, t))
    }
    var gP = {
        kernelName: "FFT",
        backendName: "cpu",
        kernelFunc: function (e) {
            var t = e.inputs,
                n = e.backend,
                r = t.input,
                a = ov(r.shape),
                i = r.shape[r.shape.length - 1],
                o = iz({
                    inputs: {
                        x: r
                    },
                    backend: n,
                    attrs: {
                        shape: [a / i, i]
                    }
                }),
                s = mP(o, !1, n),
                u = iz({
                    inputs: {
                        x: s
                    },
                    backend: n,
                    attrs: {
                        shape: r.shape
                    }
                });
            return n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(s), u
        }
    };

    function yP(e) {
        var t = e.backend,
            n = e.attrs,
            r = n.shape,
            a = n.value,
            i = n.dtype || Tv(a),
            o = vv(i, ov(r));
        return function (e, t, n) {
            o.fill(t)
        }(0, a), t.makeTensorInfo(r, i, o)
    }
    var bP = {
            kernelName: "Fill",
            backendName: "cpu",
            kernelFunc: yP
        },
        xP = {
            kernelName: "FlipLeftRight",
            backendName: "cpu",
            kernelFunc: function (e) {
                for (var t = e.inputs, n = (e.attrs, e.backend), r = t.image, a = n, i = mv(r.dtype, ov(r.shape)), o = r.shape, s = o[0], u = o[1], l = o[2], c = o[3], p = a.data.get(r.dataId).values, h = 0; h < s; h++)
                    for (var f = h * l * u * c, d = 0; d < u; d++)
                        for (var m = d * (l * c), v = 0; v < l; v++)
                            for (var g = v * c, y = 0; y < c; y++) {
                                var b = [s, d, v, y][2],
                                    x = Math.round(l - b),
                                    w = f + m + g + y,
                                    k = p[w];
                                x >= 0 && x < l && (k = p[f + m + x * c + y]), i[w] = k
                            }
                return {
                    dataId: a.write(i, r.shape, r.dtype),
                    shape: r.shape,
                    dtype: r.dtype
                }
            }
        },
        wP = {
            kernelName: "FloorDiv",
            backendName: "cpu",
            kernelFunc: BM("FloorDiv", RM(function (e, t) {
                return Math.floor(e / t)
            }), null, "int32")
        },
        kP = {
            kernelName: "FusedConv2D",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.filter,
                    o = t.bias,
                    s = t.preluActivationWeights,
                    u = r.strides,
                    l = r.pad,
                    c = r.dataFormat,
                    p = r.dilations,
                    h = r.dimRoundingMode,
                    f = r.activation,
                    d = r.leakyreluAlpha,
                    m = Pz({
                        inputs: {
                            x: a,
                            filter: i
                        },
                        backend: n,
                        attrs: {
                            strides: u,
                            pad: l,
                            dataFormat: c,
                            dilations: p,
                            dimRoundingMode: h
                        }
                    });
                if (o) {
                    var v = m;
                    m = GM({
                        inputs: {
                            a: m,
                            b: o
                        },
                        backend: n
                    }), n.disposeIntermediateTensorInfo(v)
                }
                if (f) {
                    var g = m;
                    m = az(n, m, f, s, d), n.disposeIntermediateTensorInfo(g)
                }
                return m
            }
        },
        NP = {
            kernelName: "FusedDepthwiseConv2D",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.filter,
                    o = t.bias,
                    s = t.preluActivationWeights,
                    u = r.strides,
                    l = r.pad,
                    c = r.dataFormat,
                    p = r.dilations,
                    h = r.dimRoundingMode,
                    f = r.activation,
                    d = r.leakyreluAlpha,
                    m = Qz({
                        inputs: {
                            x: a,
                            filter: i
                        },
                        backend: n,
                        attrs: {
                            strides: u,
                            pad: l,
                            dataFormat: c,
                            dilations: p,
                            dimRoundingMode: h
                        }
                    });
                if (o) {
                    var v = m;
                    m = GM({
                        inputs: {
                            a: m,
                            b: o
                        },
                        backend: n
                    }), n.disposeIntermediateTensorInfo(v)
                }
                if (f) {
                    var g = m;
                    m = az(n, m, f, s, d), n.disposeIntermediateTensorInfo(g)
                }
                return m
            }
        },
        IP = {
            kernelName: "GatherNd",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = t.params,
                    a = t.indices,
                    i = ov(r.shape),
                    o = a.shape,
                    s = o[o.length - 1],
                    u = Ib(r, a),
                    l = u[0],
                    c = u[1],
                    p = u[2],
                    h = u[3];
                if (0 === c) return n.makeTensorInfo(l, r.dtype, []);
                for (var f = qy([c, p], r.dtype), d = n.data.get(a.dataId).values, m = n.data.get(r.dataId).values, v = 0; v < c; v++) {
                    for (var g = [], y = 0, b = 0; b < s; b++) {
                        var x = d[v * s + b];
                        y += x * h[b], g.push(x)
                    }
                    if (y < 0 || y >= i / p) throw new Error("Invalid indices: " + g + " does not index into " + r.shape);
                    for (var w = 0; w < p; w++) f.values[v * p + w] = m[y * p + w]
                }
                return n.makeTensorInfo(l, f.dtype, f.values)
            }
        },
        SP = {
            kernelName: "GatherV2",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.indices,
                    o = r.axis,
                    s = r.batchDims;
                IM([a, i], "gatherV2");
                var u = s;
                null == s && (u = 0);
                var l = ov(i.shape),
                    c = YS(a, i, fv(o, a.shape)[0], u),
                    p = iz({
                        inputs: {
                            x: a
                        },
                        backend: n,
                        attrs: {
                            shape: [c.batchSize, c.outerSize, c.dimSize, c.sliceSize]
                        }
                    }),
                    h = iz({
                        inputs: {
                            x: i
                        },
                        backend: n,
                        attrs: {
                            shape: [c.batchSize, l / c.batchSize]
                        }
                    }),
                    f = [c.batchSize, c.outerSize, l / c.batchSize, c.sliceSize],
                    d = n.bufferSync(h),
                    m = oL(n.bufferSync(p), d, f);
                return n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(h), n.makeTensorInfo(c.outputShape, m.dtype, m.values)
            }
        },
        TP = {
            kernelName: "GreaterEqual",
            backendName: "cpu",
            kernelFunc: BM("GreaterEqual", RM(function (e, t) {
                return e >= t ? 1 : 0
            }), null, "bool")
        },
        CP = {
            kernelName: "IFFT",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = t.input,
                    a = ov(r.shape),
                    i = r.shape[r.shape.length - 1],
                    o = iz({
                        inputs: {
                            x: r
                        },
                        backend: n,
                        attrs: {
                            shape: [a / i, i]
                        }
                    }),
                    s = mP(o, !0, n),
                    u = iz({
                        inputs: {
                            x: s
                        },
                        backend: n,
                        attrs: {
                            shape: r.shape
                        }
                    });
                return n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(s), u
            }
        },
        EP = {
            kernelName: "IsFinite",
            backendName: "cpu",
            kernelFunc: XM("IsFinite", function (e) {
                return Number.isFinite(e) ? 1 : 0
            }, "bool")
        },
        RP = {
            kernelName: "IsInf",
            backendName: "cpu",
            kernelFunc: XM("IsInf", function (e) {
                return Math.abs(e) === 1 / 0 ? 1 : 0
            }, "bool")
        },
        AP = {
            kernelName: "IsNan",
            backendName: "cpu",
            kernelFunc: XM("IsNan", function (e) {
                return Number.isNaN(e) ? 1 : 0
            }, "bool")
        },
        FP = {
            kernelName: "LessEqual",
            backendName: "cpu",
            kernelFunc: BM("LessEqual", RM(function (e, t) {
                return e <= t ? 1 : 0
            }), null, "bool")
        },
        _P = {
            kernelName: "LinSpace",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.backend,
                    n = e.attrs,
                    r = pL(n.start, n.stop, n.num);
                return t.makeTensorInfo([r.length], "float32", r)
            }
        },
        DP = {
            kernelName: "Log1p",
            backendName: "cpu",
            kernelFunc: XM("Log1p", function (e) {
                return Math.log1p(e)
            })
        },
        OP = {
            kernelName: "LogicalAnd",
            backendName: "cpu",
            kernelFunc: BM("LogicalAnd", RM(function (e, t) {
                return e && t
            }), null, "bool")
        },
        MP = {
            kernelName: "LogicalNot",
            backendName: "cpu",
            kernelFunc: XM("LogicalNot", function (e) {
                return e ? 0 : 1
            }, "bool")
        },
        LP = {
            kernelName: "LogicalOr",
            backendName: "cpu",
            kernelFunc: BM("LogicalOr", RM(function (e, t) {
                return e || t
            }), null, "bool")
        },
        zP = {
            kernelName: "LRN",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.depthRadius,
                    o = r.bias,
                    s = r.alpha,
                    u = r.beta;
                IM(a, "LRN");
                var l = a.shape[3],
                    c = l - 1,
                    p = n.data.get(a.dataId).values,
                    h = ov(a.shape),
                    f = new Float32Array(h);

                function d(e) {
                    for (var t = e % l, n = e - t + Math.max(0, t - i), r = e - t + Math.min(t + i, c), a = 0; n <= r; n++) {
                        var o = p[n];
                        a += o * o
                    }
                    return a
                }
                for (var m = 0; m < h; m++) {
                    var v = d(m),
                        g = p[m] * Math.pow(o + s * v, -u);
                    f[m] = g
                }
                return n.makeTensorInfo(a.shape, a.dtype, f)
            }
        },
        PP = {
            kernelName: "LRNGrad",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.y,
                    o = t.dy,
                    s = r.depthRadius,
                    u = r.bias,
                    l = r.alpha,
                    c = r.beta;
                IM(o, "LRNGrad");
                for (var p = ov(o.shape), h = o.shape[3], f = n.data.get(o.dataId).values, d = n.data.get(a.dataId).values, m = n.data.get(i.dataId).values, v = new Float32Array(p), g = p, y = 0; y < g; y++) {
                    for (var b = y % h, x = y - b + Math.max(0, b - s), w = y - b + Math.min(h, b + s + 1), k = 0, N = x; N < w; N++) k += Math.pow(d[N], 2);
                    k = l * k + u;
                    for (var I = x; I < w; I++) {
                        var S = -2 * l * c * d[I] * m[y] / k;
                        y === I && (S += Math.pow(k, -c)), S *= f[y], v[I] += S
                    }
                }
                return n.makeTensorInfo(o.shape, a.dtype, v)
            }
        };

    function BP(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.x,
            i = r.reductionIndices,
            o = r.keepDims,
            s = n,
            u = a.shape,
            l = u.length,
            c = fv(i, u),
            p = c,
            h = hk(p, l),
            f = s.data.get(a.dataId).values;
        if (null != h) {
            for (var d = new Array(l), m = 0; m < d.length; m++) d[m] = u[h[m]];
            f = CL(f, u, a.dtype, h, d), p = dk(p.length, l), u = d
        }
        IM(a, "max"), pk("max", p, l);
        var v = lk(u, p),
            g = v[0],
            y = mL(f, ov(v[1]), g, a.dtype),
            b = s.write(y, g, a.dtype),
            x = g;
        return o && (x = ck(g, c)), {
            dataId: b,
            shape: x,
            dtype: a.dtype
        }
    }
    var WP = {
            kernelName: "Max",
            backendName: "cpu",
            kernelFunc: BP
        },
        VP = {
            kernelName: "MaxPool",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x;
                IM(a, "maxPool");
                var i = r.filterSize,
                    o = r.strides,
                    s = r.pad,
                    u = r.dimRoundingMode;
                nv(Lx(o, 1), function () {
                    return "Error in maxPool: Either strides or dilations must be 1. Got strides " + o + " and dilations '1'"
                });
                var l, c = Tx(a.shape, i, o, 1, s, u);
                if (1 === c.filterWidth && 1 === c.filterHeight && sv(c.inShape, c.outShape)) l = DM({
                    inputs: {
                        x: a
                    },
                    backend: n
                });
                else {
                    var p = n.data.get(a.dataId).values,
                        h = Rv(a.shape),
                        f = kz(p, a.shape, a.dtype, h, c, "max");
                    l = n.makeTensorInfo(c.outShape, a.dtype, f.values)
                }
                return l
            }
        },
        UP = {
            kernelName: "MaxPool3D",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.filterSize,
                    o = r.strides,
                    s = r.pad,
                    u = r.dimRoundingMode,
                    l = r.dataFormat;
                IM(a, "maxPool3d");
                var c = Cx(a.shape, i, o, 1, s, u, l),
                    p = Iz(n.data.get(a.dataId).values, a.shape, a.dtype, Rv(a.shape), c, "max");
                return n.makeTensorInfo(p.shape, "float32", p.values)
            }
        },
        GP = {
            kernelName: "MaxPool3DGrad",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.dy,
                    i = t.input,
                    o = r.filterSize,
                    s = r.strides,
                    u = r.pad,
                    l = r.dimRoundingMode;
                IM([a, i], "maxPool3DGrad");
                for (var c = Cx(i.shape, o, s, 1, u, l), p = function (e, t) {
                        for (var n = qy(t.outShape, "int32"), r = t.strideDepth, a = t.strideHeight, i = t.strideWidth, o = t.dilationDepth, s = t.dilationHeight, u = t.dilationWidth, l = t.effectiveFilterDepth, c = t.effectiveFilterHeight, p = t.effectiveFilterWidth, h = t.padInfo.front, f = t.padInfo.top, d = t.padInfo.left, m = 0; m < t.batchSize; ++m)
                            for (var v = 0; v < t.inChannels; ++v)
                                for (var g = 0; g < t.outDepth; ++g) {
                                    for (var y = g * r - h, b = y; b < 0;) b += o;
                                    for (var x = Math.min(t.inDepth, l + y), w = 0; w < t.outHeight; ++w) {
                                        for (var k = w * a - f, N = k; N < 0;) N += s;
                                        for (var I = Math.min(t.inHeight, c + k), S = 0; S < t.outWidth; ++S) {
                                            for (var T = S * i - d, C = T; C < 0;) C += u;
                                            for (var E = Math.min(t.inWidth, p + T), R = Number.NEGATIVE_INFINITY, A = -1, F = b; F < x; F += o)
                                                for (var _ = F - y, D = N; D < I; D += s)
                                                    for (var O = D - k, M = C; M < E; M += u) {
                                                        var L = M - T,
                                                            z = e.get(m, F, D, M, v);
                                                        z >= R && (R = z, A = _ * c * p + O * c + L)
                                                    }
                                            n.set(A, m, g, w, S, v)
                                        }
                                    }
                                }
                        return n
                    }(n.bufferSync(i), c), h = c.strideDepth, f = c.strideHeight, d = c.strideWidth, m = c.dilationDepth, v = c.dilationHeight, g = c.dilationWidth, y = c.effectiveFilterDepth, b = c.effectiveFilterHeight, x = c.effectiveFilterWidth, w = y - 1 - c.padInfo.front, k = x - 1 - c.padInfo.left, N = b - 1 - c.padInfo.top, I = qy(i.shape, "float32"), S = n.bufferSync(a), T = 0; T < c.batchSize; ++T)
                    for (var C = 0; C < c.inChannels; ++C)
                        for (var E = 0; E < c.inDepth; ++E)
                            for (var R = 0; R < c.inHeight; ++R)
                                for (var A = 0; A < c.inWidth; ++A) {
                                    for (var F = E - w, _ = R - N, D = A - k, O = 0, M = 0; M < y; M += m) {
                                        var L = (F + M) / h;
                                        if (!(L < 0 || L >= c.outDepth || Math.floor(L) !== L))
                                            for (var z = 0; z < b; z += v) {
                                                var P = (_ + z) / f;
                                                if (!(P < 0 || P >= c.outHeight || Math.floor(P) !== P))
                                                    for (var B = 0; B < x; B += g) {
                                                        var W = (D + B) / d;
                                                        if (!(W < 0 || W >= c.outWidth || Math.floor(W) !== W)) {
                                                            var V = y * b * x - 1 - p.get(T, L, P, W, C) === M * b * x + z * x + B ? 1 : 0;
                                                            0 !== V && (O += S.get(T, L, P, W, C) * V)
                                                        }
                                                    }
                                            }
                                    }
                                    I.set(O, T, E, R, A, C)
                                }
                return n.makeTensorInfo(I.shape, I.dtype, I.values)
            }
        },
        jP = {
            kernelName: "MaxPoolGrad",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.dy,
                    i = t.input,
                    o = i;
                IM([i, t.output], "maxPoolGrad");
                for (var s = r.filterSize, u = r.strides, l = r.pad, c = r.dimRoundingMode, p = Tx(o.shape, s, u, 1, l, c), h = n.data.get(o.dataId).values, f = qy(p.outShape, o.dtype, Nz(h, o.shape, o.dtype, p).values), d = p.strideHeight, m = p.strideWidth, v = p.dilationHeight, g = p.dilationWidth, y = p.effectiveFilterHeight, b = p.effectiveFilterWidth, x = b - 1 - p.padInfo.left, w = y - 1 - p.padInfo.top, k = qy(o.shape, "float32"), N = n.data.get(a.dataId).values, I = qy(a.shape, "float32", N), S = 0; S < p.batchSize; ++S)
                    for (var T = 0; T < p.inChannels; ++T)
                        for (var C = 0; C < p.inHeight; ++C)
                            for (var E = 0; E < p.inWidth; ++E) {
                                for (var R = C - w, A = E - x, F = 0, _ = 0; _ < y; _ += v) {
                                    var D = (R + _) / d;
                                    if (!(D < 0 || D >= p.outHeight || Math.floor(D) !== D))
                                        for (var O = 0; O < b; O += g) {
                                            var M = (A + O) / m;
                                            if (!(M < 0 || M >= p.outWidth || Math.floor(M) !== M)) {
                                                var L = y * b - 1 - f.get(S, D, M, T) === _ * b + O ? 1 : 0;
                                                0 !== L && (F += I.get(S, D, M, T) * L)
                                            }
                                        }
                                }
                                k.set(F, S, C, E, T)
                            }
                return n.makeTensorInfo(k.shape, k.dtype, k.values)
            }
        },
        HP = {
            kernelName: "MaxPoolWithArgmax",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.attrs,
                    r = e.backend,
                    a = t.x,
                    i = n.filterSize,
                    o = n.strides,
                    s = n.pad,
                    u = n.includeBatchInIndex,
                    l = r;
                IM(a, "MaxPoolWithArgmax");
                var c = l.data.get(a.dataId).values,
                    p = Tx(a.shape, i, o, [1, 1], s),
                    h = function (e, t, n, r, a) {
                        var i = kz(e, 0, n, Rv(t), a, "max"),
                            o = Nz(e, t, n, a, !0, r);
                        return [i.values, o.values]
                    }(c, a.shape, a.dtype, u, p),
                    f = h[0],
                    d = h[1],
                    m = l.write(f, p.outShape, a.dtype),
                    v = l.write(d, p.outShape, a.dtype);
                return [{
                    dataId: m,
                    shape: p.outShape,
                    dtype: a.dtype
                }, {
                    dataId: v,
                    shape: p.outShape,
                    dtype: "int32"
                }]
            }
        };

    function qP(e) {
        var t, n = e.inputs,
            r = e.backend,
            a = e.attrs,
            i = n.x,
            o = a.axis,
            s = a.keepDims;
        IM(i, "sum");
        var u = (t = "bool" === i.dtype ? zM({
                inputs: {
                    x: i
                },
                backend: r,
                attrs: {
                    dtype: "int32"
                }
            }) : DM({
                inputs: {
                    x: i
                },
                backend: r
            })).shape.length,
            l = fv(o, t.shape),
            c = hk(l, u),
            p = l,
            h = t;
        null != c && (h = EL({
            inputs: {
                x: t
            },
            backend: r,
            attrs: {
                perm: c
            }
        }), p = dk(p.length, u)), pk("sum", p, h.shape.length);
        for (var f = lk(h.shape, p), d = f[0], m = f[1], v = _M(r, d, _g(h.dtype, "int32")), g = ov(m), y = r.data.get(v.dataId).values, b = r.data.get(h.dataId).values, x = 0; x < y.length; ++x) {
            for (var w = x * g, k = 0, N = 0; N < g; ++N) k += b[w + N];
            y[x] = k
        }
        if (s) {
            var I = v;
            v = iz({
                inputs: {
                    x: v
                },
                backend: r,
                attrs: {
                    shape: ck(v.shape, l)
                }
            }), r.disposeIntermediateTensorInfo(I)
        }
        return r.disposeIntermediateTensorInfo(t), null != c && r.disposeIntermediateTensorInfo(h), v
    }
    var KP = {
            kernelName: "Sum",
            backendName: "cpu",
            kernelFunc: qP
        },
        XP = {
            kernelName: "Mean",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.axis,
                    o = r.keepDims,
                    s = fv(i, a.shape),
                    u = ov(lk(a.shape, s)[1]),
                    l = [],
                    c = n.makeTensorInfo([], "float32", new Float32Array([u]));
                l.push(c);
                var p = zM({
                    inputs: {
                        x: a
                    },
                    backend: n,
                    attrs: {
                        dtype: "float32"
                    }
                });
                l.push(p);
                var h = fP({
                    inputs: {
                        a: p,
                        b: c
                    },
                    backend: n
                });
                l.push(h);
                var f = qP({
                    inputs: {
                        x: h
                    },
                    backend: n,
                    attrs: {
                        axis: i,
                        keepDims: o
                    }
                });
                return l.forEach(function (e) {
                    return n.disposeIntermediateTensorInfo(e)
                }), f
            }
        },
        YP = {
            kernelName: "Min",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.axis,
                    o = r.keepDims;
                IM(a, "min");
                var s = fv(i, a.shape),
                    u = s,
                    l = hk(u, a.shape.length),
                    c = a;
                null != l && (c = EL({
                    inputs: {
                        x: a
                    },
                    backend: n,
                    attrs: {
                        perm: l
                    }
                }), u = dk(u.length, a.shape.length)), pk("min", u, c.shape.length);
                for (var p = lk(c.shape, u), h = p[0], f = ov(p[1]), d = _v(ov(h), c.dtype), m = n.data.get(c.dataId).values, v = 0; v < d.length; ++v) {
                    for (var g = v * f, y = m[g], b = 0; b < f; ++b) {
                        var x = m[g + b];
                        x < y && (y = x)
                    }
                    d[v] = y
                }
                null != l && n.disposeIntermediateTensorInfo(c);
                var w = n.makeTensorInfo(h, c.dtype, d);
                if (o) {
                    var k = iz({
                        inputs: {
                            x: w
                        },
                        backend: n,
                        attrs: {
                            shape: ck(h, s)
                        }
                    });
                    return n.disposeIntermediateTensorInfo(w), k
                }
                return w
            }
        },
        JP = {
            kernelName: "MirrorPad",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.paddings,
                    o = r.mode;
                IM(a, "mirrorPad");
                for (var s = i.map(function (e, t) {
                        return e[0] + a.shape[t] + e[1]
                    }), u = i.map(function (e) {
                        return e[0]
                    }), l = i.map(function (e, t) {
                        return e[0] + a.shape[t]
                    }), c = "reflect" === o ? 0 : 1, p = n.data.get(a.dataId).values, h = a.shape.length, f = Rv(a.shape), d = ov(s), m = s.length, v = Rv(s), g = mv(a.dtype, d), y = 0; y < d; y++) {
                    for (var b = Lv(y, m, v), x = 0; x < m; x++) b[x] < u[x] ? b[x] = 2 * u[x] - b[x] - c : b[x] >= l[x] && (b[x] = 2 * (l[x] - 1) - b[x] + c);
                    var w = Mv(b = b.map(function (e, t) {
                        return e - u[t]
                    }), h, f);
                    g[y] = p[w]
                }
                return {
                    dataId: n.write(g, s, a.dtype),
                    shape: s,
                    dtype: a.dtype
                }
            }
        },
        ZP = RM(function (e, t) {
            var n = e % t;
            return e < 0 && t < 0 || e >= 0 && t >= 0 ? n : (n + t) % t
        }),
        QP = BM(Yv, ZP),
        $P = {
            kernelName: Yv,
            backendName: "cpu",
            kernelFunc: QP
        };

    function eB(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.logits,
            i = r.dim,
            o = a.shape.length,
            s = i;
        if (-1 === s && (s = o - 1), s !== o - 1) throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank " + o + " and dim was " + s);
        var u = fv([s], a.shape),
            l = BP({
                inputs: {
                    x: a
                },
                backend: n,
                attrs: {
                    reductionIndices: u,
                    keepDims: !1
                }
            }),
            c = ck(l.shape, u),
            p = iz({
                inputs: {
                    x: l
                },
                backend: n,
                attrs: {
                    shape: c
                }
            }),
            h = UL({
                inputs: {
                    a: a,
                    b: p
                },
                backend: n
            }),
            f = eL({
                inputs: {
                    x: h
                },
                backend: n
            }),
            d = qP({
                inputs: {
                    x: f
                },
                backend: n,
                attrs: {
                    axis: u,
                    keepDims: !1
                }
            }),
            m = iz({
                inputs: {
                    x: d
                },
                backend: n,
                attrs: {
                    shape: c
                }
            }),
            v = fP({
                inputs: {
                    a: f,
                    b: m
                },
                backend: n
            });
        return n.disposeIntermediateTensorInfo(l), n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(m), v
    }
    var tB = {
            kernelName: "Softmax",
            backendName: "cpu",
            kernelFunc: eB
        },
        nB = {
            kernelName: "Multinomial",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.logits,
                    i = r.numSamples,
                    o = r.seed,
                    s = r.normalized;
                IM(a, "multinomial");
                for (var u = s ? a : eB({
                        inputs: {
                            logits: a
                        },
                        backend: n,
                        attrs: {
                            dim: -1
                        }
                    }), l = u.shape[0], c = u.shape[1], p = n.data.get(u.dataId).values, h = [l, i], f = _v(ov(h), "int32"), d = 0; d < l; ++d) {
                    var m = d * c,
                        v = new Float32Array(c - 1);
                    v[0] = p[m];
                    for (var g = 1; g < v.length; ++g) v[g] = v[g - 1] + p[m + g];
                    for (var y = nN(o.toString()), b = d * i, x = 0; x < i; ++x) {
                        var w = y();
                        f[b + x] = v.length;
                        for (var k = 0; k < v.length; k++)
                            if (w < v[k]) {
                                f[b + x] = k;
                                break
                            }
                    }
                }
                return s || n.disposeIntermediateTensorInfo(u), n.makeTensorInfo(h, "int32", f)
            }
        },
        rB = MI,
        aB = {
            kernelName: "NonMaxSuppressionV3",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.boxes,
                    i = t.scores,
                    o = r.maxOutputSize,
                    s = r.iouThreshold,
                    u = r.scoreThreshold;
                IM(a, "NonMaxSuppression");
                var l = n.data.get(a.dataId).values,
                    c = n.data.get(i.dataId).values,
                    p = rB(l, c, o, s, u).selectedIndices;
                return n.makeTensorInfo([p.length], "int32", new Int32Array(p))
            }
        },
        iB = LI,
        oB = {
            kernelName: "NonMaxSuppressionV4",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.boxes,
                    i = t.scores,
                    o = r.maxOutputSize,
                    s = r.iouThreshold,
                    u = r.scoreThreshold,
                    l = r.padToMaxOutputSize;
                IM(a, "NonMaxSuppressionPadded");
                var c = n.data.get(a.dataId).values,
                    p = n.data.get(i.dataId).values,
                    h = iB(c, p, o, s, u, l),
                    f = h.selectedIndices,
                    d = h.validOutputs;
                return [n.makeTensorInfo([f.length], "int32", new Int32Array(f)), n.makeTensorInfo([], "int32", new Int32Array([d]))]
            }
        },
        sB = zI,
        uB = {
            kernelName: "NonMaxSuppressionV5",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.boxes,
                    i = t.scores,
                    o = r.maxOutputSize,
                    s = r.iouThreshold,
                    u = r.scoreThreshold,
                    l = r.softNmsSigma;
                IM(a, "NonMaxSuppressionWithScore");
                var c = n.data.get(a.dataId).values,
                    p = n.data.get(i.dataId).values,
                    h = sB(c, p, o, s, u, l),
                    f = h.selectedIndices,
                    d = h.selectedScores;
                return [n.makeTensorInfo([f.length], "int32", new Int32Array(f)), n.makeTensorInfo([d.length], "float32", new Float32Array(d))]
            }
        },
        lB = {
            kernelName: "OneHot",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.indices,
                    i = r.depth,
                    o = r.onValue,
                    s = r.offValue;
                IM(a, "oneHot");
                var u = ov(a.shape),
                    l = new Float32Array(u * i);
                l.fill(s);
                for (var c = n.data.get(a.dataId).values, p = 0; p < u; ++p) c[p] >= 0 && c[p] < i && (l[p * i + c[p]] = o);
                return n.makeTensorInfo([].concat(a.shape, [i]), "int32", l)
            }
        };

    function cB(e) {
        var t = e.inputs,
            n = e.backend,
            r = t.x;
        if ("string" === r.dtype) throw new Error("zerosLike is not supported for string tensors");
        if ("complex64" === r.dtype) {
            var a = MM({
                    inputs: {
                        input: r
                    },
                    backend: n
                }),
                i = cB({
                    inputs: {
                        x: a
                    },
                    backend: n
                }),
                o = Oz({
                    inputs: {
                        input: r
                    },
                    backend: n
                }),
                s = cB({
                    inputs: {
                        x: o
                    },
                    backend: n
                }),
                u = AM({
                    inputs: {
                        real: i,
                        imag: s
                    },
                    backend: n
                });
            return n.disposeIntermediateTensorInfo(a), n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(s), u
        }
        return yP({
            backend: n,
            attrs: {
                shape: r.shape,
                value: 0,
                dtype: r.dtype
            }
        })
    }
    var pB = {
            kernelName: "ZerosLike",
            backendName: "cpu",
            kernelFunc: cB
        },
        hB = {
            kernelName: "OnesLike",
            backendName: "cpu",
            kernelFunc: function e(t) {
                var n = t.inputs,
                    r = t.backend,
                    a = n.x;
                if ("string" === a.dtype) throw new Error("onesLike is not supported for string tensors");
                if ("complex64" === a.dtype) {
                    var i = MM({
                            inputs: {
                                input: a
                            },
                            backend: r
                        }),
                        o = e({
                            inputs: {
                                x: i
                            },
                            backend: r
                        }),
                        s = Oz({
                            inputs: {
                                input: a
                            },
                            backend: r
                        }),
                        u = cB({
                            inputs: {
                                x: s
                            },
                            backend: r
                        }),
                        l = AM({
                            inputs: {
                                real: o,
                                imag: u
                            },
                            backend: r
                        });
                    return r.disposeIntermediateTensorInfo(i), r.disposeIntermediateTensorInfo(o), r.disposeIntermediateTensorInfo(s), r.disposeIntermediateTensorInfo(u), l
                }
                return yP({
                    backend: r,
                    attrs: {
                        shape: a.shape,
                        value: 1,
                        dtype: a.dtype
                    }
                })
            }
        };

    function fB(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs.axis;
        if (1 === t.length) return pP({
            inputs: {
                input: t[0]
            },
            backend: n,
            attrs: {
                dim: r
            }
        });
        var a = t[0].shape,
            i = t[0].dtype;
        t.forEach(function (e) {
            rv(a, e.shape, "All tensors passed to stack must have matching shapes"), nv(i === e.dtype, function () {
                return "All tensors passed to stack must have matching dtypes"
            })
        });
        var o = [],
            s = Lz({
                inputs: t.map(function (e) {
                    var t = pP({
                        inputs: {
                            input: e
                        },
                        backend: n,
                        attrs: {
                            dim: r
                        }
                    });
                    return o.push(t), t
                }),
                backend: n,
                attrs: {
                    axis: r
                }
            });
        return o.forEach(function (e) {
            return n.disposeIntermediateTensorInfo(e)
        }), s
    }
    var dB = {
            kernelName: "Pack",
            backendName: "cpu",
            kernelFunc: fB
        },
        mB = {
            kernelName: "PadV2",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.paddings,
                    o = r.constantValue;
                IM(a, "pad");
                var s = i.map(function (e, t) {
                        return e[0] + a.shape[t] + e[1]
                    }),
                    u = i.map(function (e) {
                        return e[0]
                    }),
                    l = n.data.get(a.dataId).values,
                    c = ov(a.shape),
                    p = a.shape.length,
                    h = Rv(a.shape),
                    f = ov(s),
                    d = s.length,
                    m = Rv(s),
                    v = mv(a.dtype, f);
                0 !== o && v.fill(o);
                for (var g = 0; g < c; g++) v[Mv(Lv(g, p, h).map(function (e, t) {
                    return e + u[t]
                }), d, m)] = l[g];
                return {
                    dataId: n.write(v, s, a.dtype),
                    shape: s,
                    dtype: a.dtype
                }
            }
        },
        vB = RM(function (e, t) {
            return Math.pow(e, t)
        }),
        gB = BM(Jv, vB),
        yB = {
            kernelName: Jv,
            backendName: "cpu",
            kernelFunc: gB
        },
        bB = {
            kernelName: "Range",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.backend,
                    n = e.attrs,
                    r = n.start,
                    a = n.stop,
                    i = n.dtype,
                    o = _L(r, a, n.step, i);
                return t.makeTensorInfo([o.length], i, o)
            }
        },
        xB = {
            kernelName: "Reciprocal",
            backendName: "cpu",
            kernelFunc: XM("Reciprocal", function (e) {
                return 1 / e
            })
        },
        wB = {
            kernelName: "ResizeBilinear",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.images,
                    i = r.alignCorners,
                    o = r.halfPixelCenters,
                    s = r.size;
                IM(a, "resizeBilinear");
                for (var u = Rv(a.shape), l = s[0], c = s[1], p = a.shape, h = p[0], f = p[1], d = p[2], m = p[3], v = n.data.get(a.dataId).values, g = new Float32Array(ov([h, l, c, m])), y = [i && l > 1 ? f - 1 : f, i && c > 1 ? d - 1 : d], b = [i && l > 1 ? l - 1 : l, i && c > 1 ? c - 1 : c], x = 0, w = y[0] / b[0], k = y[1] / b[1], N = 0; N < h; N++)
                    for (var I = 0; I < l; I++) {
                        var S;
                        S = o ? w * (I + .5) - .5 : w * I;
                        for (var T = Math.max(0, Math.floor(S)), C = S - T, E = Math.min(f - 1, Math.ceil(S)), R = N * u[0] + T * u[1], A = N * u[0] + E * u[1], F = 0; F < c; F++) {
                            var _;
                            _ = o ? k * (F + .5) - .5 : k * F;
                            for (var D = Math.max(0, Math.floor(_)), O = _ - D, M = Math.min(d - 1, Math.ceil(_)), L = R + D * u[2], z = A + D * u[2], P = R + M * u[2], B = A + M * u[2], W = 0; W < m; W++) {
                                var V = v[L + W],
                                    U = v[z + W],
                                    G = V + (v[P + W] - V) * O,
                                    j = G + (U + (v[B + W] - U) * O - G) * C;
                                g[x++] = j
                            }
                        }
                    }
                return n.makeTensorInfo([h, l, c, m], "float32", g)
            }
        },
        kB = {
            kernelName: "ResizeBilinearGrad",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.images,
                    i = t.dy,
                    o = r.alignCorners;
                IM([i, a], "resizeBilinearGrad");
                for (var s = Rv(a.shape), u = a.shape, l = u[0], c = u[1], p = u[2], h = u[3], f = i.shape, d = f[1], m = f[2], v = new Float32Array(l * c * p * h), g = [o && d > 1 ? c - 1 : c, o && m > 1 ? p - 1 : p], y = [o && d > 1 ? d - 1 : d, o && m > 1 ? m - 1 : m], b = g[0] / y[0], x = g[1] / y[1], w = n.data.get(i.dataId).values, k = 0, N = 0; N < l; N++)
                    for (var I = N * s[0], S = 0; S < d; S++)
                        for (var T = S * b, C = Math.floor(T), E = Math.min(Math.ceil(T), c - 1), R = I + C * s[1], A = I + E * s[1], F = T - C, _ = 1 - F, D = 0; D < m; D++)
                            for (var O = D * x, M = Math.floor(O), L = Math.min(Math.ceil(O), p - 1), z = O - M, P = 1 - z, B = R + M * s[2], W = R + L * s[2], V = A + M * s[2], U = A + L * s[2], G = _ * P, j = _ * z, H = F * P, q = F * z, K = 0; K < h; K++) {
                                var X = w[k++];
                                v[B + K] += X * G, v[W + K] += X * j, v[V + K] += X * H, v[U + K] += X * q
                            }
                return n.makeTensorInfo([l, p, c, h], "float32", v)
            }
        },
        NB = {
            kernelName: "ResizeNearestNeighbor",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.images,
                    i = r.alignCorners,
                    o = r.halfPixelCenters,
                    s = r.size;
                IM(a, "resizeNearestNeighbor");
                for (var u = Rv(a.shape), l = s[0], c = s[1], p = a.shape, h = p[0], f = p[1], d = p[2], m = p[3], v = n.data.get(a.dataId).values, g = new Float32Array(h * l * c * m), y = [i && l > 1 ? f - 1 : f, i && c > 1 ? d - 1 : d], b = [i && l > 1 ? l - 1 : l, i && c > 1 ? c - 1 : c], x = y[0] / b[0], w = y[1] / b[1], k = 0, N = 0; N < h; N++)
                    for (var I = N * u[0], S = 0; S < l; S++) {
                        var T = o ? x * (S + .5) : x * S,
                            C = Math.min(f - 1, i ? Math.round(T) : Math.floor(T));
                        o && (C = Math.max(0, C));
                        for (var E = I + C * u[1], R = 0; R < c; R++) {
                            var A = o ? w * (R + .5) : w * R,
                                F = Math.min(d - 1, i ? Math.round(A) : Math.floor(A));
                            o && (F = Math.max(0, F));
                            for (var _ = E + F * u[2], D = 0; D < m; D++) {
                                var O = v[_ + D];
                                g[k++] = O
                            }
                        }
                    }
                return n.makeTensorInfo([h, l, c, m], a.dtype, g)
            }
        },
        IB = {
            kernelName: "ResizeNearestNeighborGrad",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.images,
                    i = t.dy,
                    o = r.alignCorners;
                IM([i, a], "resizeNearestNeighborGrad");
                for (var s = Rv(a.shape), u = Rv(i.shape), l = a.shape, c = l[0], p = l[1], h = l[2], f = l[3], d = i.shape, m = d[1], v = d[2], g = new Float32Array(c * p * h * f), y = n.data.get(i.dataId).values, b = [o && m > 1 ? p - 1 : p, o && v > 1 ? h - 1 : h], x = [o && m > 1 ? m - 1 : m, o && v > 1 ? v - 1 : v], w = b[0] / x[0], k = b[1] / x[1], N = 1 / w, I = 1 / k, S = 2 * Math.ceil(N) + 2, T = 2 * Math.ceil(I) + 2, C = 0; C < c; C++)
                    for (var E = C * s[0], R = 0; R < p; R++)
                        for (var A = E + R * s[1], F = Math.floor(R * N), _ = Math.floor(F - S / 2), D = 0; D < h; D++)
                            for (var O = A + D * s[2], M = Math.floor(D * I), L = Math.floor(M - T / 2), z = 0; z < f; z++) {
                                for (var P = 0, B = 0; B < S; B++) {
                                    var W = B + _;
                                    if (!(W < 0 || W >= m)) {
                                        var V = E + W * u[1],
                                            U = W * w;
                                        if (R === Math.min(p - 1, o ? Math.round(U) : Math.floor(U)))
                                            for (var G = 0; G < T; G++) {
                                                var j = G + L;
                                                if (!(j < 0 || j >= v)) {
                                                    var H = V + j * u[2],
                                                        q = j * k;
                                                    D === Math.min(h - 1, o ? Math.round(q) : Math.floor(q)) && (P += y[H + z])
                                                }
                                            }
                                    }
                                }
                                g[O + z] = P
                            }
                return n.makeTensorInfo(a.shape, a.dtype, g)
            }
        },
        SB = {
            kernelName: "Reverse",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.dims;
                IM(a, "reverse");
                var o = a.shape.length,
                    s = fv(i, a.shape);
                if (0 === o) return DM({
                    inputs: {
                        x: a
                    },
                    backend: n
                });
                for (var u = new xg(a.shape, a.dtype), l = n.bufferSync(a), c = function (e) {
                        var t = u.indexToLoc(e),
                            n = t.slice();
                        s.forEach(function (e) {
                            return n[e] = a.shape[e] - 1 - n[e]
                        }), u.set.apply(u, [l.get.apply(l, n)].concat(t))
                    }, p = 0; p < u.size; p++) c(p);
                return n.makeTensorInfo(u.shape, u.dtype, u.values)
            }
        },
        TB = {
            kernelName: "RotateWithOffset",
            backendName: "cpu",
            kernelFunc: function (e) {
                for (var t = e.inputs, n = e.attrs, r = e.backend, a = t.image, i = n.radians, o = n.fillValue, s = n.center, u = r, l = mv(a.dtype, ov(a.shape)), c = a.shape, p = c[0], h = c[1], f = c[2], d = c[3], m = AS(s, h, f), v = m[0], g = m[1], y = Math.sin(i), b = Math.cos(i), x = u.data.get(a.dataId).values, w = 0; w < p; w++)
                    for (var k = w * f * h * d, N = 0; N < h; N++)
                        for (var I = N * (f * d), S = 0; S < f; S++)
                            for (var T = S * d, C = 0; C < d; C++) {
                                var E = [p, N, S, C],
                                    R = E[2],
                                    A = E[1],
                                    F = (R - v) * b - (A - g) * y,
                                    _ = (R - v) * y + (A - g) * b;
                                F = Math.round(F + v), _ = Math.round(_ + g);
                                var D = o;
                                "number" != typeof o && (D = 3 === C ? 255 : o[C]), F >= 0 && F < f && _ >= 0 && _ < h && (D = x[k + _ * (f * d) + F * d + C]), l[k + I + T + C] = D
                            }
                return {
                    dataId: u.write(l, a.shape, a.dtype),
                    shape: a.shape,
                    dtype: a.dtype
                }
            }
        },
        CB = {
            kernelName: "Round",
            backendName: "cpu",
            kernelFunc: XM("Round", function (e) {
                var t = Math.floor(e);
                return e - t < .5 ? Math.floor(e) : e - t > .5 ? Math.ceil(e) : t % 2 == 0 ? t : t + 1
            })
        };

    function EB(e, t, n, r, a, i, o, s, u, l) {
        var c = [r / a, a],
            p = e.values,
            h = t.values;
        if (0 === r) return qy(n, t.dtype);
        var f = qy(c, t.dtype);
        f.values.fill(u);
        for (var d = 0; d < i; d++) {
            for (var m = [], v = 0, g = 0; g < o; g++) {
                var y = p[d * o + g];
                m.push(y), v += y * s[g]
            }
            if (v < 0 || v >= r / a) throw new Error("Invalid indices: " + m + " does not index into " + n);
            for (var b = 0; b < a; b++) l ? f.values[v * a + b] += h[d * a + b] : f.values[v * a + b] = 0 === t.rank ? h[0] : h[d * a + b]
        }
        return f
    }
    var RB = {
            kernelName: "ScatterNd",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.indices,
                    i = t.updates,
                    o = r.shape,
                    s = Eb(0, a, o),
                    u = s.sliceRank,
                    l = s.numUpdates,
                    c = s.sliceSize,
                    p = s.strides,
                    h = s.outputSize,
                    f = EB(n.bufferSync(a), n.bufferSync(i), o, h, c, l, u, p, 0, !0);
                return n.makeTensorInfo(o, f.dtype, f.values)
            }
        },
        AB = {
            kernelName: "Select",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = t.condition,
                    a = t.t,
                    i = t.e;
                IM([r, a, i], "select");
                for (var o = r.shape.length, s = n.data.get(r.dataId).values, u = n.data.get(a.dataId).values, l = n.data.get(i.dataId).values, c = _g(a.dtype, i.dtype), p = _v(ov(a.shape), c), h = 0, f = 0 === o || o > 1 || 1 === a.shape.length ? 1 : ov(a.shape.slice(1)), d = 0; d < s.length; d++)
                    for (var m = 0; m < f; m++) 1 === s[d] ? p[h++] = u[d] : p[h++] = l[d];
                return n.makeTensorInfo(a.shape, c, p)
            }
        },
        FB = {
            kernelName: "Selu",
            backendName: "cpu",
            kernelFunc: XM("Selu", function (e) {
                return e >= 0 ? 1.0507009873554805 * e : 1.7580993408473768 * (Math.exp(e) - 1)
            })
        },
        _B = {
            kernelName: "Sigmoid",
            backendName: "cpu",
            kernelFunc: XM("Sigmoid", function (e) {
                return 1 / (1 + Math.exp(-e))
            })
        },
        DB = {
            kernelName: "Sign",
            backendName: "cpu",
            kernelFunc: XM("Sign", function (e) {
                return e < 0 ? -1 : e > 0 ? 1 : 0
            })
        },
        OB = XM(Zv, function (e) {
            return Math.sin(e)
        }),
        MB = {
            kernelName: Zv,
            backendName: "cpu",
            kernelFunc: OB
        },
        LB = {
            kernelName: "Sinh",
            backendName: "cpu",
            kernelFunc: XM("Sinh", function (e) {
                return Math.sinh(e)
            })
        },
        zB = Math.log(1.1920928955078125e-7) + 2,
        PB = {
            kernelName: "Softplus",
            backendName: "cpu",
            kernelFunc: XM("Softplus", function (e) {
                var t = e > -zB,
                    n = e < zB,
                    r = Math.exp(e);
                return n ? r : t ? e : Math.log(1 + r)
            })
        },
        BB = {
            kernelName: "SpaceToBatchND",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.blockShape,
                    o = r.paddings;
                IM([a], "spaceToBatchND");
                var s = ov(i),
                    u = [
                        [0, 0]
                    ];
                u.push.apply(u, o);
                for (var l = 1 + i.length; l < a.shape.length; ++l) u.push([0, 0]);
                var c = mB.kernelFunc({
                        inputs: {
                            x: a
                        },
                        backend: n,
                        attrs: {
                            paddings: u,
                            constantValue: 0
                        }
                    }),
                    p = FS(c.shape, i, s, !1),
                    h = _S(p.length, i.length, !1),
                    f = DS(c.shape, i, s, !1),
                    d = iz({
                        inputs: {
                            x: c
                        },
                        backend: n,
                        attrs: {
                            shape: p
                        }
                    }),
                    m = EL({
                        inputs: {
                            x: d
                        },
                        backend: n,
                        attrs: {
                            perm: h
                        }
                    }),
                    v = iz({
                        inputs: {
                            x: m
                        },
                        backend: n,
                        attrs: {
                            shape: f
                        }
                    });
                return n.disposeIntermediateTensorInfo(c), n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(m), v
            }
        },
        WB = {
            kernelName: "SparseToDense",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.sparseIndices,
                    i = t.sparseValues,
                    o = t.defaultValue,
                    s = r.outputShape,
                    u = Eb(0, a, s),
                    l = u.sliceRank,
                    c = u.numUpdates,
                    p = u.sliceSize,
                    h = u.strides,
                    f = u.outputSize,
                    d = EB(n.bufferSync(a), n.bufferSync(i), s, f, p, c, l, h, n.data.get(o.dataId).values[0], !1);
                return n.makeTensorInfo(s, d.dtype, d.values)
            }
        },
        VB = {
            kernelName: "SplitV",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.numOrSizeSplits,
                    o = fv(r.axis, a.shape)[0],
                    s = qS(a, i, o),
                    u = new Array(a.shape.length).fill(0),
                    l = a.shape.slice();
                return s.map(function (e) {
                    var t = [].concat(l);
                    t[o] = e;
                    var r = LL({
                        inputs: {
                            x: a
                        },
                        backend: n,
                        attrs: {
                            begin: u,
                            size: t
                        }
                    });
                    return u[o] += e, r
                })
            }
        },
        UB = {
            kernelName: "Sqrt",
            backendName: "cpu",
            kernelFunc: XM("Sqrt", function (e) {
                return Math.sqrt(e)
            })
        },
        GB = {
            kernelName: "Square",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = t.x,
                    a = n;
                IM(r, "square");
                for (var i = a.data.get(r.dataId).values, o = new Float32Array(i.length), s = 0; s < i.length; ++s) {
                    var u = i[s];
                    o[s] = u * u
                }
                return {
                    dataId: a.write(o, r.shape, r.dtype),
                    shape: r.shape,
                    dtype: r.dtype
                }
            }
        },
        jB = {
            kernelName: "Step",
            backendName: "cpu",
            kernelFunc: XM("Step", function (e, t) {
                var n = t;
                return isNaN(e) ? NaN : e > 0 ? 1 : n.alpha
            })
        },
        HB = {
            kernelName: "StridedSlice",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.begin,
                    o = r.end,
                    s = r.strides,
                    u = r.beginMask,
                    l = r.endMask,
                    c = r.ellipsisMask,
                    p = r.newAxisMask,
                    h = r.shrinkAxisMask;
                IM(a, "stridedSlice");
                var f, d = Hb(a.shape, i, o, s, u, l, c, p, h),
                    m = d.nonStrided,
                    v = d.$begin,
                    g = d.$strides,
                    y = d.size,
                    b = d.newShape,
                    x = d.outShape,
                    w = iz({
                        inputs: {
                            x: a
                        },
                        backend: n,
                        attrs: {
                            shape: b
                        }
                    });
                if (m) {
                    var k = LL({
                        inputs: {
                            x: w
                        },
                        backend: n,
                        attrs: {
                            begin: v,
                            size: y
                        }
                    });
                    f = iz({
                        inputs: {
                            x: k
                        },
                        backend: n,
                        attrs: {
                            shape: x
                        }
                    }), n.disposeIntermediateTensorInfo(k)
                } else if (x.some(function (e) {
                        return 0 === e
                    })) f = n.makeTensorInfo(x, a.dtype, []);
                else {
                    var N = BL(x, n.bufferSync(w), g, v);
                    f = n.makeTensorInfo(N.shape, N.dtype, N.values)
                }
                var I = iz({
                    inputs: {
                        x: f
                    },
                    backend: n,
                    attrs: {
                        shape: x
                    }
                });
                return n.disposeIntermediateTensorInfo(w), n.disposeIntermediateTensorInfo(f), I
            }
        },
        qB = XM($v, function (e) {
            return Math.tan(e)
        }),
        KB = {
            kernelName: $v,
            backendName: "cpu",
            kernelFunc: qB
        },
        XB = XM("Tanh", function (e) {
            return Math.tanh(e)
        });

    function YB(e, t, n) {
        switch (n) {
            case "reflect":
                return function (e, t) {
                    var n = e;
                    if (n < 0)
                        if (t <= 1) n = 0;
                        else {
                            var r = 2 * t;
                            n < r && (n = r * Math.trunc(-n / r) + n), n = n < -t ? n + r : -n - 1
                        }
                    else if (n > t - 1)
                        if (t <= 1) n = 0;
                        else {
                            var a = 2 * t;
                            (n -= a * Math.trunc(n / a)) >= t && (n = a - n - 1)
                        } return $m(0, n, t - 1)
                }(e, t);
            case "wrap":
                return function (e, t) {
                    var n = e;
                    if (n < 0)
                        if (t <= 1) n = 0;
                        else {
                            var r = t - 1;
                            n += t * (Math.trunc(-n / r) + 1)
                        }
                    else if (n > t - 1)
                        if (t <= 1) n = 0;
                        else {
                            var a = t - 1;
                            n -= t * Math.trunc(n / a)
                        } return $m(0, n, t - 1)
                }(e, t);
            case "nearest":
                return function (e, t) {
                    return $m(0, e, t - 1)
                }(e, t);
            case "constant":
            default:
                return function (e, t) {
                    return e
                }(e)
        }
    }

    function JB(e, t, n, r, a, i, o, s, u, l, c) {
        return 0 <= s && s < t && 0 <= u && u < n ? e[o * r + s * a + u * i + l] : c
    }

    function ZB(e, t, n, r, a, i, o, s, u, l, c) {
        return JB(e, t, n, r, a, i, o, Math.round(s), Math.round(u), l, c)
    }

    function QB(e, t, n, r, a, i, o, s, u, l, c) {
        var p = Math.floor(s),
            h = Math.floor(u),
            f = p + 1,
            d = h + 1;
        return (f - s) * ((d - u) * JB(e, t, n, r, a, i, o, p, h, l, c) + (u - h) * JB(e, t, n, r, a, i, o, p, d, l, c)) + (s - p) * ((d - u) * JB(e, t, n, r, a, i, o, f, h, l, c) + (u - h) * JB(e, t, n, r, a, i, o, f, d, l, c))
    }
    for (var $B = 0, eW = [lz, EM, cz, pz, jM, hz, fz, dz, mz, vz, gz, yz, bz, xz, wz, Sz, Tz, Cz, Ez, uz, Rz, Az, Fz, PM, ZM, _z, FM, Dz, zz, Wz, Vz, Bz, Gz, jz, Uz, qz, Kz, Xz, Yz, Jz, Zz, $z, eP, tP, nP, rP, iP, aP, dP, XL, oP, uP, cP, tL, hP, rL, gP, bP, xP, iL, wP, kP, NP, IP, SP, uL, TP, OM, CP, Mz, EP, RP, AP, JL, cL, FP, _P, dL, DP, OP, MP, LP, zP, PP, gL, VP, UP, GP, jP, HP, WP, XP, YP, bL, JP, $P, nB, NL, SL, aB, oB, uB, TL, lB, hB, dB, mB, yB, $L, FL, bB, LM, xB, tz, rz, oz, wB, kB, NB, IB, SB, TB, CB, OL, RB, AB, FB, _B, DB, MB, LB, zL, tB, PB, BB, WB, VB, UB, GB, PL, jB, HB, GL, KP, KB, {
            kernelName: "Tanh",
            backendName: "cpu",
            kernelFunc: XB
        }, {
            kernelName: "Tile",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.reps;
                IM(a, "tile");
                var o = jL(n.bufferSync(a), i);
                return n.makeTensorInfo(o.shape, o.dtype, o.values)
            }
        }, {
            kernelName: "TopK",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.k;
                r.sorted, IM(a, "topk");
                var o = HL(n.data.get(a.dataId).values, a.shape, a.dtype, i),
                    s = o[0],
                    u = o[1];
                return [n.makeTensorInfo(s.shape, s.dtype, s.values), n.makeTensorInfo(u.shape, u.dtype, u.values)]
            }
        }, RL, {
            kernelName: "Transform",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.attrs,
                    r = e.backend,
                    a = t.image,
                    i = t.transforms,
                    o = n.interpolation,
                    s = n.fillMode,
                    u = n.fillValue,
                    l = n.outputShape,
                    c = a.shape,
                    p = c[0],
                    h = c[1],
                    f = c[2],
                    d = c[3],
                    m = null != l ? l : [h, f],
                    v = m[0],
                    g = m[1],
                    y = [p, v, g, d],
                    b = Rv(a.shape),
                    x = b[0],
                    w = b[1],
                    k = b[2],
                    N = mv(a.dtype, ov(y));
                N.fill(u);
                for (var I = r.data.get(a.dataId).values, S = r.data.get(i.dataId).values, T = 0; T < p; ++T) {
                    for (var C = 1 === i.shape[0] ? S : S.subarray(8 * T, 8 * T + 8), E = 0; E < v; ++E)
                        for (var R = 0; R < g; ++R)
                            for (var A = 0; A < d; ++A) {
                                var F = void 0,
                                    _ = C[6] * R + C[7] * E + 1;
                                if (0 !== _) {
                                    var D = (C[0] * R + C[1] * E + C[2]) / _,
                                        O = (C[3] * R + C[4] * E + C[5]) / _,
                                        M = YB(D, f, s),
                                        L = YB(O, h, s);
                                    switch (o) {
                                        case "nearest":
                                            F = ZB(I, h, f, x, w, k, T, L, M, A, u);
                                            break;
                                        case "bilinear":
                                            F = QB(I, h, f, x, w, k, T, L, M, A, u);
                                            break;
                                        default:
                                            throw new Error("Error in Transform: Expect 'nearest' or 'bilinear', but got " + o)
                                    }
                                    N[T * x + E * w + R * k + A] = F
                                }
                            }
                    return r.makeTensorInfo(y, a.dtype, N)
                }
                return {
                    dataId: r.write(N, y, a.dtype),
                    shape: a.shape,
                    dtype: a.dtype
                }
            }
        }, {
            kernelName: "Unique",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.attrs,
                    r = e.backend,
                    a = n.axis,
                    i = t.x;
                IM(i, "unique");
                var o = qL(r.data.get(i.dataId).values, a, i.shape, i.dtype),
                    s = o.outputValues,
                    u = o.outputShape,
                    l = o.indices;
                return [r.makeTensorInfo(u, i.dtype, s), r.makeTensorInfo([l.length], "int32", l)]
            }
        }, {
            kernelName: "Unpack",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.value,
                    i = r.axis;
                i < 0 && (i += a.shape.length);
                for (var o = a.shape.length, s = a.shape[i], u = new Array(o - 1), l = 0, c = 0; c < o; c++) c !== i && (u[l++] = a.shape[c]);
                var p = new Array(o).fill(0),
                    h = a.shape.slice();
                h[i] = 1;
                for (var f = new Array(s), d = 0; d < f.length; d++) {
                    p[i] = d;
                    var m = LL({
                        inputs: {
                            x: a
                        },
                        backend: n,
                        attrs: {
                            begin: p,
                            size: h
                        }
                    });
                    f[d] = iz({
                        inputs: {
                            x: m
                        },
                        backend: n,
                        attrs: {
                            shape: u
                        }
                    }), n.disposeIntermediateTensorInfo(m)
                }
                return f
            }
        }, {
            kernelName: "UnsortedSegmentSum",
            backendName: "cpu",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.segmentIds,
                    o = r.numSegments;
                IM(a, "unsortedSegmentSum");
                for (var s = [], u = [], l = a.shape.length - i.shape.length, c = i, p = 0; p < l; ++p) {
                    var h = pP({
                        inputs: {
                            input: c
                        },
                        backend: n,
                        attrs: {
                            dim: p + 1
                        }
                    });
                    c = h, u.push(h)
                }
                for (var f = 0; f < o; ++f) {
                    var d = ug(f, "int32"),
                        m = n.makeTensorInfo([], "int32", d),
                        v = sP({
                            inputs: {
                                a: m,
                                b: c
                            },
                            backend: n
                        }),
                        g = zM({
                            inputs: {
                                x: v
                            },
                            backend: n,
                            attrs: {
                                dtype: "float32"
                            }
                        }),
                        y = kL({
                            inputs: {
                                a: g,
                                b: a
                            },
                            backend: n
                        }),
                        b = qP({
                            inputs: {
                                x: y
                            },
                            backend: n,
                            attrs: {
                                axis: 0,
                                keepDims: !1
                            }
                        });
                    s.push(b), u.push(m), u.push(v), u.push(g), u.push(y), u.push(b)
                }
                var x = fB({
                    inputs: s,
                    backend: n,
                    attrs: {
                        axis: 0
                    }
                });
                return u.forEach(function (e) {
                    return n.disposeIntermediateTensorInfo(e)
                }), x
            }
        }, pB]; $B < eW.length; $B++) ig(eW[$B]);
    var tW, nW, rW, aW = {},
        iW = {
            alpha: !1,
            antialias: !1,
            premultipliedAlpha: !1,
            preserveDrawingBuffer: !1,
            depth: !1,
            stencil: !1,
            failIfMajorPerformanceCaveat: !0
        };

    function oW(e) {
        if (!(e in aW)) {
            var t = function (e) {
                if (1 !== e && 2 !== e) throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
                var t = function (e) {
                    if ("undefined" != typeof OffscreenCanvas && 2 === e) return new OffscreenCanvas(300, 150);
                    if ("undefined" != typeof document) return document.createElement("canvas");
                    throw new Error("Cannot create a canvas in this context")
                }(e);
                return t.addEventListener("webglcontextlost", function (t) {
                    t.preventDefault(), delete aW[e]
                }, !1), 1 === e ? t.getContext("webgl", iW) || t.getContext("experimental-webgl", iW) : t.getContext("webgl2", iW)
            }(e);
            if (null === t) return console.log("Could not get context for WebGL version", e), null;
            aW[e] = t
        }
        var n = aW[e];
        return n.isContextLost() ? (delete aW[e], oW(e)) : (n.disable(n.DEPTH_TEST), n.disable(n.STENCIL_TEST), n.disable(n.BLEND), n.disable(n.DITHER), n.disable(n.POLYGON_OFFSET_FILL), n.disable(n.SAMPLE_COVERAGE), n.enable(n.SCISSOR_TEST), n.enable(n.CULL_FACE), n.cullFace(n.BACK), aW[e])
    }

    function sW(e, t) {
        return [t, e]
    }

    function uW(e) {
        var t = ov(e);
        return lv(Math.ceil(t / 4))
    }

    function lW(e, t) {
        return [Math.max(1, Math.ceil(t / 2)), Math.max(1, Math.ceil(e / 2))]
    }

    function cW(e, t) {
        var n, r, a, i, o, s, u, l, c, p = e;
        return 2 === Wv().getNumber("WEBGL_VERSION") ? (n = p.R32F, r = p.R16F, a = p.RGBA16F, i = p.RGBA32F, o = p.RED, s = 4, u = 1, l = p.HALF_FLOAT, c = p.FLOAT) : (n = e.RGBA, r = e.RGBA, a = e.RGBA, i = p.RGBA, o = e.RGBA, s = 4, u = 4, l = null != t ? t.HALF_FLOAT_OES : null, c = e.FLOAT), {
            internalFormatFloat: n,
            internalFormatHalfFloat: r,
            internalFormatPackedHalfFloat: a,
            internalFormatPackedFloat: i,
            textureFormatFloat: o,
            downloadTextureFormat: e.RGBA,
            downloadUnpackNumChannels: s,
            defaultNumChannels: u,
            textureTypeHalfFloat: l,
            textureTypeFloat: c
        }
    }

    function pW(e, t) {
        var n = t();
        return Wv().getBool("DEBUG") && function (e) {
            var t = e.getError();
            if (t !== e.NO_ERROR) throw new Error("WebGL Error: " + function (e, t) {
                switch (t) {
                    case e.NO_ERROR:
                        return "NO_ERROR";
                    case e.INVALID_ENUM:
                        return "INVALID_ENUM";
                    case e.INVALID_VALUE:
                        return "INVALID_VALUE";
                    case e.INVALID_OPERATION:
                        return "INVALID_OPERATION";
                    case e.INVALID_FRAMEBUFFER_OPERATION:
                        return "INVALID_FRAMEBUFFER_OPERATION";
                    case e.OUT_OF_MEMORY:
                        return "OUT_OF_MEMORY";
                    case e.CONTEXT_LOST_WEBGL:
                        return "CONTEXT_LOST_WEBGL";
                    default:
                        return "Unknown error code " + t
                }
            }(e, t))
        }(e), n
    }

    function hW(e) {
        return !!(Wv().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || 0 === e || 5.96e-8 < Math.abs(e) && Math.abs(e) < 65504)
    }

    function fW(e, t) {
        return NW(e, function () {
            return e.getExtension(t)
        }, 'Extension "' + t + '" not supported on this browser.')
    }! function (e) {
        e[e.DENSE = 0] = "DENSE", e[e.SHARED_BATCH = 1] = "SHARED_BATCH"
    }(tW || (tW = {})),
    function (e) {
        e[e.RENDER = 0] = "RENDER", e[e.UPLOAD = 1] = "UPLOAD", e[e.PIXELS = 2] = "PIXELS", e[e.DOWNLOAD = 3] = "DOWNLOAD"
    }(nW || (nW = {})),
    function (e) {
        e[e.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", e[e.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", e[e.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", e[e.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", e[e.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16"
    }(rW || (rW = {}));
    var dW, mW, vW = /ERROR: [0-9]+:([0-9]+):/g;

    function gW(e, t) {
        if (pW(e, function () {
                return e.validateProgram(t)
            }), !1 === e.getProgramParameter(t, e.VALIDATE_STATUS)) throw console.log(e.getProgramInfoLog(t)), new Error("Shader program validation failed.")
    }

    function yW(e, t, n, r, a, i, o) {
        var s = e.getAttribLocation(t, n);
        return -1 !== s && (pW(e, function () {
            return e.bindBuffer(e.ARRAY_BUFFER, r)
        }), pW(e, function () {
            return e.vertexAttribPointer(s, a, e.FLOAT, !1, i, o)
        }), pW(e, function () {
            return e.enableVertexAttribArray(s)
        }), !0)
    }

    function bW(e, t, n, r) {
        pW(e, function () {
            return function (e, t, n) {
                (function (e, t) {
                    var n = e.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1,
                        r = t + e.TEXTURE0;
                    if (r < e.TEXTURE0 || r > n) throw new Error("textureUnit must be in [gl.TEXTURE0, gl.TEXTURE" + n + "].")
                })(e, n), pW(e, function () {
                    return e.activeTexture(e.TEXTURE0 + n)
                }), pW(e, function () {
                    return e.bindTexture(e.TEXTURE_2D, t)
                })
            }(e, t, r)
        }), pW(e, function () {
            return e.uniform1i(n, r)
        })
    }

    function xW(e, t, n) {
        pW(e, function () {
            return e.bindFramebuffer(e.FRAMEBUFFER, n)
        }), pW(e, function () {
            return e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0)
        })
    }

    function wW(e, t) {
        pW(e, function () {
            return e.bindFramebuffer(e.FRAMEBUFFER, t)
        }), pW(e, function () {
            return e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, null, 0)
        })
    }

    function kW(e) {
        var t = e.checkFramebufferStatus(e.FRAMEBUFFER);
        if (t !== e.FRAMEBUFFER_COMPLETE) throw new Error("Error binding framebuffer: " + function (e, t) {
            switch (t) {
                case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                    return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
                case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                    return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
                case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                    return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
                case e.FRAMEBUFFER_UNSUPPORTED:
                    return "FRAMEBUFFER_UNSUPPORTED";
                default:
                    return "unknown error " + t
            }
        }(e, t))
    }

    function NW(e, t, n) {
        var r = pW(e, function () {
            return t()
        });
        if (null == r) throw new Error(n);
        return r
    }

    function IW(e, t) {
        return void 0 === t && (t = 2), ov(e.slice(0, e.length - t))
    }

    function SW(e) {
        if (0 === e.length) throw Error("Cannot get rows and columns of an empty shape array.");
        return [e.length > 1 ? e[e.length - 2] : 1, e[e.length - 1]]
    }

    function TW(e) {
        var t = [1, 1, 1];
        return 0 === e.length || 1 === e.length && 1 === e[0] || (t = [IW(e)].concat(SW(e))), t
    }

    function CW(e) {
        return e % 2 == 0
    }

    function EW(e, t) {
        if (sv(e = e.slice(-2), t = t.slice(-2))) return !0;
        if (!e.length || !t.length) return !0;
        if (0 === e[0] || 0 === e[1] || 0 === t[0] || 0 === t[1]) return !0;
        if (e.length !== t.length) {
            var n = e.slice(-1)[0],
                r = t.slice(-1)[0];
            if (n === r) return !0;
            if (CW(n) && CW(r) && (1 === e[0] || 1 === t[0])) return !0
        }
        return e[1] === t[1] && CW(e[0]) && CW(t[0])
    }

    function RW(e, t) {
        return null != e.getExtension(t)
    }

    function AW(e) {
        try {
            if (null != oW(e)) return !0
        } catch (e) {
            return console.log("Error when getting WebGL context: ", e), !1
        }
        return !1
    }

    function FW(e) {
        var t = cW(e),
            n = e.createTexture();
        e.bindTexture(e.TEXTURE_2D, n), e.texImage2D(e.TEXTURE_2D, 0, t.internalFormatFloat, 1, 1, 0, t.textureFormatFloat, t.textureTypeFloat, null);
        var r = e.createFramebuffer();
        e.bindFramebuffer(e.FRAMEBUFFER, r), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, n, 0);
        var a = e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE;
        return e.bindTexture(e.TEXTURE_2D, null), e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteTexture(n), e.deleteFramebuffer(r), a
    }

    function _W(e, t) {
        Array.isArray(e) || (e = [e]), e.forEach(function (e) {
            null != e && nv("complex64" !== e.dtype, function () {
                return t + " does not support complex64 tensors in the WebGL backend."
            })
        })
    }
    var DW = Wv();

    function OW() {
        var e, t, n, r, a, i, o, s, u, l;
        return 2 === Wv().getNumber("WEBGL_VERSION") ? (e = "#version 300 es", t = "in", n = "out", r = "in", a = "texture", i = "outputColor", o = "out vec4 outputColor;", s = "\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ", u = "", l = "\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ") : (e = "", t = "attribute", n = "varying", r = "varying", a = "texture2D", i = "gl_FragColor", o = "", s = "\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ", u = "\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ", l = "\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "), {
            version: e,
            attribute: t,
            varyingVs: n,
            varyingFs: r,
            texture2D: a,
            output: i,
            defineOutput: o,
            defineSpecialNaN: s,
            defineSpecialInf: u,
            defineRound: l
        }
    }

    function MW(e, t, n) {
        void 0 === n && (n = "index");
        var r = Rv(t);
        return r.map(function (t, a) {
            return "int " + e[a] + " = " + n + " / " + t + "; " + (a === r.length - 1 ? "int " + e[a + 1] + " = " + n + " - " + e[a] + " * " + t : "index -= " + e[a] + " * " + t) + ";"
        }).join("")
    }

    function LW(e) {
        var t = Rv(e).map(function (e) {
            return e.toString()
        });
        return "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * " + t[0] + " + coords.y * " + t[1] + " + coords.z;\n  }\n"
    }
    DW.registerFlag("HAS_WEBGL", function () {
        return DW.getNumber("WEBGL_VERSION") > 0
    }), DW.registerFlag("WEBGL_VERSION", function () {
        return AW(2) ? 2 : AW(1) ? 1 : 0
    }), DW.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS", function () {
        return !1
    }), DW.registerFlag("WEBGL_BUFFER_SUPPORTED", function () {
        return 2 === DW.get("WEBGL_VERSION")
    }), DW.registerFlag("WEBGL_CPU_FORWARD", function () {
        return !0
    }), DW.registerFlag("WEBGL_FORCE_F16_TEXTURES", function () {
        return !1
    }), DW.registerFlag("WEBGL_PACK", function () {
        return DW.getBool("HAS_WEBGL")
    }), DW.registerFlag("WEBGL_PACK_NORMALIZATION", function () {
        return DW.getBool("WEBGL_PACK")
    }), DW.registerFlag("WEBGL_PACK_CLIP", function () {
        return DW.getBool("WEBGL_PACK")
    }), DW.registerFlag("WEBGL_PACK_DEPTHWISECONV", function () {
        return !1
    }), DW.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", function () {
        return DW.getBool("WEBGL_PACK")
    }), DW.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", function () {
        return DW.getBool("WEBGL_PACK")
    }), DW.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", function () {
        return DW.getBool("WEBGL_PACK")
    }), DW.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", function () {
        return DW.getBool("WEBGL_PACK")
    }), DW.registerFlag("WEBGL_PACK_REDUCE", function () {
        return DW.getBool("WEBGL_PACK")
    }), DW.registerFlag("WEBGL_LAZILY_UNPACK", function () {
        return DW.getBool("WEBGL_PACK")
    }), DW.registerFlag("WEBGL_CONV_IM2COL", function () {
        return DW.getBool("WEBGL_PACK")
    }), DW.registerFlag("WEBGL_MAX_TEXTURE_SIZE", function () {
        return function (e) {
            if (null == dW) {
                var t = oW(e);
                dW = t.getParameter(t.MAX_TEXTURE_SIZE)
            }
            return dW
        }(DW.getNumber("WEBGL_VERSION"))
    }), DW.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", function () {
        return function (e) {
            if (null == mW) {
                var t = oW(e);
                mW = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)
            }
            return Math.min(16, mW)
        }(DW.getNumber("WEBGL_VERSION"))
    }), DW.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", function () {
        var e = DW.getNumber("WEBGL_VERSION");
        return 0 === e ? 0 : function (e) {
            if (0 === e) return 0;
            var t = oW(e);
            return RW(t, "EXT_disjoint_timer_query_webgl2") && 2 === e ? 2 : RW(t, "EXT_disjoint_timer_query") ? 1 : 0
        }(e)
    }), DW.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", function () {
        return DW.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && !Hg()
    }), DW.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", function () {
        return function (e) {
            if (0 === e) return !1;
            var t = oW(e);
            if (1 === e) {
                if (!RW(t, "OES_texture_float")) return !1
            } else if (!RW(t, "EXT_color_buffer_float")) return !1;
            return FW(t)
        }(DW.getNumber("WEBGL_VERSION"))
    }), DW.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", function () {
        return !DW.getBool("WEBGL_FORCE_F16_TEXTURES") && DW.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")
    }), DW.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", function () {
        return function (e) {
            if (0 === e) return !1;
            var t = oW(e);
            if (1 !== e) {
                if (RW(t, "EXT_color_buffer_float")) return FW(t);
                if (RW(t, "EXT_color_buffer_half_float")) {
                    var n = t.getExtension("EXT_color_buffer_half_float");
                    return function (e, t) {
                        var n = cW(e, t),
                            r = e.createTexture();
                        e.bindTexture(e.TEXTURE_2D, r), e.texImage2D(e.TEXTURE_2D, 0, n.internalFormatHalfFloat, 1, 1, 0, n.textureFormatFloat, n.textureTypeHalfFloat, null);
                        var a = e.createFramebuffer();
                        e.bindFramebuffer(e.FRAMEBUFFER, a), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, r, 0);
                        var i = e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE;
                        return e.bindTexture(e.TEXTURE_2D, null), e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteTexture(r), e.deleteFramebuffer(a), i
                    }(t, n)
                }
                return !1
            }
            return !!RW(t, "OES_texture_float") && !!RW(t, "WEBGL_color_buffer_float") && FW(t)
        }(DW.getNumber("WEBGL_VERSION"))
    }), DW.registerFlag("WEBGL_FENCE_API_ENABLED", function () {
        return 2 === (e = DW.getNumber("WEBGL_VERSION")) && null != oW(e).fenceSync;
        var e
    }), DW.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", function () {
        return DW.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0
    }), DW.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD", function () {
        return -1
    }, function (e) {
        if (e < 0 && -1 !== e) throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got " + e + ".")
    }), DW.registerFlag("WEBGL_FLUSH_THRESHOLD", function () {
        return Hg() && DW.getBool("IS_CHROME") ? 1 : -1
    }, function (e) {
        if (e < 0 && -1 !== e) throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got " + e + ".")
    });
    var zW = "\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",
        PW = function (e) {
            this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outPackingScheme = tW.DENSE;
            var t = uW(e),
                n = OW();
            this.outputShape = e, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " + MW(["r", "c", "d"], e) + "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(" + t[0] + ", " + t[1] + "));\n        int index = 4 * (resTexRC.x * " + t[1] + " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        " + n.output + " = result;\n      }\n    "
        },
        BW = function (e) {
            this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outPackingScheme = tW.DENSE;
            var t = uW(e),
                n = OW();
            this.outputShape = e, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " + MW(["r", "c", "d"], e) + "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(" + t[0] + ", " + t[1] + "));\n        int index = 4 * (resTexRC.x * " + t[1] + " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        " + n.output + " = result;\n      }\n    "
        },
        WW = function (e) {
            this.variableNames = ["A"], this.outTexUsage = nW.DOWNLOAD;
            var t = OW();
            this.outputShape = e, this.userCode = "\n      " + zW + "\n\n      void main() {\n        float x = getAAtOutCoords();\n        " + t.output + " = encode_float(x);\n      }\n    "
        },
        VW = function (e) {
            this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outTexUsage = nW.DOWNLOAD;
            var t = OW();
            this.outputShape = e, this.userCode = "\n      " + zW + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        " + t.output + " = encode_float(x);\n      }\n    "
        },
        UW = function (e, t, n) {
            void 0 === n && (n = !1), this.variableNames = ["A"];
            var r = OW(),
                a = t[0],
                i = t[1];
            this.outputShape = e;
            var o = "result";
            n && (o = "floor(result * 255. + 0.5)"), this.userCode = "\n      " + LW(e) + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / " + i + ";\n        int c = imod(flatIndex, " + i + ");\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(" + i + ".0, " + a + ".0);\n        vec4 values = " + r.texture2D + "(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        " + r.output + " = vec4(" + o + ", 0., 0., 0.);\n      }\n    "
        },
        GW = function (e, t, n) {
            void 0 === n && (n = !1), this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0;
            var r = OW(),
                a = t[0],
                i = t[1];
            this.outputShape = e;
            var o = "",
                s = "result";
            n && (s = "floor(result * 255. + 0.5)");
            for (var u = 0; u <= 1; u++)
                for (var l = 0; l <= 1; l++) {
                    var c = 2 * u + l;
                    o += "\n          localCoords = coords;\n          if(localCoords[2] + " + l + " < " + e[2] + ") {\n            localCoords[2] += " + l + ";\n            if(localCoords[1] + " + u + " < " + e[1] + ") {\n              localCoords[1] += " + u + ";\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / " + i + ";\n              c = imod(flatIndex, " + i + ");\n              uv = (vec2(c, r) + halfCR) / vec2(" + i + ".0, " + a + ".0);\n              values = " + r.texture2D + "(A, uv);\n\n              if(offset == 0) {\n                result[" + c + "] = values[0];\n              } else if(offset == 1) {\n                result[" + c + "] = values[1];\n              } else if(offset == 2) {\n                result[" + c + "] = values[2];\n              } else {\n                result[" + c + "] = values[3];\n              }\n            }\n          }\n        "
                }
            this.userCode = "\n      " + LW(e) + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        " + o + "\n\n        " + r.output + " = " + s + ";\n      }\n    "
        };

    function jW(e, t, n, r, a, i) {
        ! function (e, t) {
            var n = Wv().getNumber("WEBGL_MAX_TEXTURE_SIZE");
            if (e <= 0 || t <= 0) throw new Error("Requested texture size [" + e + "x" + t + "] is invalid.");
            if (e > n || t > n) throw new Error("Requested texture size [" + e + "x" + t + "] greater than WebGL maximum on this browser / GPU [" + n + "x" + n + "].")
        }(t, n);
        var o = function (e) {
                return NW(e, function () {
                    return e.createTexture()
                }, "Unable to create WebGLTexture.")
            }(e),
            s = e.TEXTURE_2D;
        return pW(e, function () {
            return e.bindTexture(s, o)
        }), pW(e, function () {
            return e.texParameteri(s, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE)
        }), pW(e, function () {
            return e.texParameteri(s, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)
        }), pW(e, function () {
            return e.texParameteri(s, e.TEXTURE_MIN_FILTER, e.NEAREST)
        }), pW(e, function () {
            return e.texParameteri(s, e.TEXTURE_MAG_FILTER, e.NEAREST)
        }), pW(e, function () {
            return e.texImage2D(s, 0, r, t, n, 0, a, i, null)
        }), pW(e, function () {
            return e.bindTexture(e.TEXTURE_2D, null)
        }), o
    }

    function HW(e) {
        return e.internalFormatFloat
    }

    function qW(e) {
        return e.internalFormatHalfFloat
    }

    function KW(e) {
        return e.downloadTextureFormat
    }

    function XW(e) {
        return e.internalFormatPackedFloat
    }

    function YW(e) {
        return e.internalFormatPackedHalfFloat
    }
    var JW = function () {
            function e(e) {
                this.outputTexture = null, this.program = null, this.disposed = !1, this.vertexAttrsAreBound = !1, this.itemsToPoll = [];
                var t = Wv().getNumber("WEBGL_VERSION");
                null != e ? (this.gl = e, function (e, t) {
                    aW[e] = t
                }(t, e)) : this.gl = oW(t);
                var n = "WEBGL_color_buffer_float";
                if (1 === Wv().getNumber("WEBGL_VERSION")) {
                    if (this.textureFloatExtension = fW(this.gl, "OES_texture_float"), RW(this.gl, "OES_texture_half_float")) this.textureHalfFloatExtension = fW(this.gl, "OES_texture_half_float");
                    else if (Wv().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
                    if (this.colorBufferFloatExtension = this.gl.getExtension(n), RW(this.gl, "EXT_color_buffer_half_float")) this.colorBufferHalfFloatExtension = fW(this.gl, "EXT_color_buffer_half_float");
                    else if (Wv().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")
                } else if (n = "EXT_color_buffer_float", RW(this.gl, n)) this.colorBufferFloatExtension = this.gl.getExtension(n);
                else {
                    if (!RW(this.gl, "EXT_color_buffer_half_float")) throw new Error("GL context does not support color renderable floats");
                    this.colorBufferHalfFloatExtension = this.gl.getExtension("EXT_color_buffer_half_float")
                }
                this.vertexBuffer = function (e) {
                    return function (e, t) {
                        var n = NW(e, function () {
                            return e.createBuffer()
                        }, "Unable to create WebGLBuffer");
                        return pW(e, function () {
                            return e.bindBuffer(e.ARRAY_BUFFER, n)
                        }), pW(e, function () {
                            return e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW)
                        }), n
                    }(e, new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]))
                }(this.gl), this.indexBuffer = function (e) {
                    return function (e, t) {
                        var n = NW(e, function () {
                            return e.createBuffer()
                        }, "Unable to create WebGLBuffer");
                        return pW(e, function () {
                            return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, n)
                        }), pW(e, function () {
                            return e.bufferData(e.ELEMENT_ARRAY_BUFFER, t, e.STATIC_DRAW)
                        }), n
                    }(e, new Uint16Array([0, 1, 2, 2, 1, 3]))
                }(this.gl), this.framebuffer = function (e) {
                    return NW(e, function () {
                        return e.createFramebuffer()
                    }, "Unable to create WebGLFramebuffer.")
                }(this.gl), this.textureConfig = cW(this.gl, this.textureHalfFloatExtension)
            }
            var t = e.prototype;
            return t.dispose = function () {
                var e = this;
                if (!this.disposed) {
                    null != this.program && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), null != this.outputTexture && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
                    var t = this.gl;
                    pW(t, function () {
                        return t.finish()
                    }), pW(t, function () {
                        return t.bindFramebuffer(t.FRAMEBUFFER, null)
                    }), pW(t, function () {
                        return t.deleteFramebuffer(e.framebuffer)
                    }), pW(t, function () {
                        return t.bindBuffer(t.ARRAY_BUFFER, null)
                    }), pW(t, function () {
                        return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, null)
                    }), pW(t, function () {
                        return t.deleteBuffer(e.indexBuffer)
                    }), this.disposed = !0
                }
            }, t.createFloat32MatrixTexture = function (e, t) {
                return this.throwIfDisposed(),
                    function (e, t, n, r) {
                        var a = sW(t, n);
                        return jW(e, a[0], a[1], HW(r), r.textureFormatFloat, e.FLOAT)
                    }(this.gl, e, t, this.textureConfig)
            }, t.createFloat16MatrixTexture = function (e, t) {
                return this.throwIfDisposed(),
                    function (e, t, n, r) {
                        var a = sW(t, n);
                        return jW(e, a[0], a[1], qW(r), r.textureFormatFloat, r.textureTypeHalfFloat)
                    }(this.gl, e, t, this.textureConfig)
            }, t.createUnsignedBytesMatrixTexture = function (e, t) {
                return this.throwIfDisposed(),
                    function (e, t, n, r) {
                        var a = sW(t, n);
                        return jW(e, a[0], a[1], KW(r), e.RGBA, e.UNSIGNED_BYTE)
                    }(this.gl, e, t, this.textureConfig)
            }, t.uploadPixelDataToTexture = function (e, t) {
                this.throwIfDisposed(),
                    function (e, t, n) {
                        pW(e, function () {
                            return e.bindTexture(e.TEXTURE_2D, t)
                        }), n.data instanceof Uint8Array ? pW(e, function () {
                            return e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, n.width, n.height, 0, e.RGBA, e.UNSIGNED_BYTE, n.data)
                        }) : pW(e, function () {
                            return e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, n)
                        }), pW(e, function () {
                            return e.bindTexture(e.TEXTURE_2D, null)
                        })
                    }(this.gl, e, t)
            }, t.uploadDenseMatrixToTexture = function (e, t, n, r) {
                this.throwIfDisposed(),
                    function (e, t, n, r, a, i) {
                        var o, s, u;
                        pW(e, function () {
                            return e.bindTexture(e.TEXTURE_2D, t)
                        }), a instanceof Uint8Array ? (o = new Uint8Array(n * r * 4), s = e.UNSIGNED_BYTE, u = e.RGBA) : (o = new Float32Array(n * r * 4), s = e.FLOAT, u = i.internalFormatPackedFloat), o.set(a), pW(e, function () {
                            return e.texImage2D(e.TEXTURE_2D, 0, u, n, r, 0, e.RGBA, s, o)
                        }), pW(e, function () {
                            return e.bindTexture(e.TEXTURE_2D, null)
                        })
                    }(this.gl, e, t, n, r, this.textureConfig)
            }, t.createFloat16PackedMatrixTexture = function (e, t) {
                return this.throwIfDisposed(),
                    function (e, t, n, r) {
                        var a = lW(t, n);
                        return jW(e, a[0], a[1], YW(r), e.RGBA, r.textureTypeHalfFloat)
                    }(this.gl, e, t, this.textureConfig)
            }, t.createPackedMatrixTexture = function (e, t) {
                return this.throwIfDisposed(),
                    function (e, t, n, r) {
                        var a = lW(t, n);
                        return jW(e, a[0], a[1], XW(r), e.RGBA, e.FLOAT)
                    }(this.gl, e, t, this.textureConfig)
            }, t.deleteMatrixTexture = function (e) {
                var t = this;
                this.throwIfDisposed(), this.outputTexture === e && (wW(this.gl, this.framebuffer), this.outputTexture = null), pW(this.gl, function () {
                    return t.gl.deleteTexture(e)
                })
            }, t.downloadByteEncodedFloatMatrixFromOutputTexture = function (e, t, n) {
                var r = this;
                return this.downloadMatrixDriver(e, function () {
                    return function (e, t, n, r) {
                        var a = sW(t, n),
                            i = a[0],
                            o = a[1],
                            s = new Uint8Array(t * n * 4);
                        return pW(e, function () {
                            return e.readPixels(0, 0, i, o, r.downloadTextureFormat, e.UNSIGNED_BYTE, s)
                        }), new Float32Array(s.buffer)
                    }(r.gl, t, n, r.textureConfig)
                })
            }, t.downloadPackedMatrixFromBuffer = function (e, t, n, r, a, i) {
                return function (e, t, n, r, a, i, o, s) {
                    var u = e,
                        l = new Float32Array(function (e, t) {
                            var n = lW(i, o);
                            return n[0] * n[1] * 4
                        }());
                    return u.bindBuffer(u.PIXEL_PACK_BUFFER, t), u.getBufferSubData(u.PIXEL_PACK_BUFFER, 0, l), u.bindBuffer(u.PIXEL_PACK_BUFFER, null), l
                }(this.gl, e, 0, 0, 0, a, i, this.textureConfig)
            }, t.downloadFloat32MatrixFromBuffer = function (e, t) {
                return function (e, t, n) {
                    var r = e,
                        a = new Float32Array(n);
                    return r.bindBuffer(r.PIXEL_PACK_BUFFER, t), r.getBufferSubData(r.PIXEL_PACK_BUFFER, 0, a), r.bindBuffer(r.PIXEL_PACK_BUFFER, null), a
                }(this.gl, e, t)
            }, t.createBufferFromTexture = function (e, t, n) {
                this.bindTextureToFrameBuffer(e);
                var r = function (e, t, n, r) {
                    var a = e.createBuffer();
                    pW(e, function () {
                        return e.bindBuffer(e.PIXEL_PACK_BUFFER, a)
                    });
                    var i = 16 * t * n;
                    return pW(e, function () {
                        return e.bufferData(e.PIXEL_PACK_BUFFER, i, e.STREAM_READ)
                    }), pW(e, function () {
                        return e.readPixels(0, 0, n, t, e.RGBA, e.FLOAT, 0)
                    }), pW(e, function () {
                        return e.bindBuffer(e.PIXEL_PACK_BUFFER, null)
                    }), a
                }(this.gl, t, n, this.textureConfig);
                return this.unbindTextureToFrameBuffer(), r
            }, t.createAndWaitForFence = function () {
                var e = this.createFence(this.gl);
                return this.pollFence(e)
            }, t.createFence = function (e) {
                var t, n, r = this;
                if (Wv().getBool("WEBGL_FENCE_API_ENABLED")) {
                    var a = e,
                        i = a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE, 0);
                    e.flush(), n = function () {
                        var e = a.clientWaitSync(i, 0, 0);
                        return e === a.ALREADY_SIGNALED || e === a.CONDITION_SATISFIED
                    }, t = i
                } else Wv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (t = this.beginQuery(), this.endQuery(), n = function () {
                    return r.isQueryAvailable(t, Wv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))
                }) : n = function () {
                    return !0
                };
                return {
                    query: t,
                    isFencePassed: n
                }
            }, t.downloadMatrixFromPackedTexture = function (e, t, n) {
                var r = this;
                return this.downloadMatrixDriver(e, function () {
                    return function (e, t, n) {
                        var r = new Float32Array(t * n * 4);
                        return pW(e, function () {
                            return e.readPixels(0, 0, n, t, e.RGBA, e.FLOAT, r)
                        }), r
                    }(r.gl, t, n)
                })
            }, t.createProgram = function (e) {
                this.throwIfDisposed();
                var t = this.gl,
                    n = function (e, t) {
                        var n = NW(e, function () {
                            return e.createShader(e.FRAGMENT_SHADER)
                        }, "Unable to create fragment WebGLShader.");
                        if (pW(e, function () {
                                return e.shaderSource(n, t)
                            }), pW(e, function () {
                                return e.compileShader(n)
                            }), !1 === e.getShaderParameter(n, e.COMPILE_STATUS)) throw function (e, t) {
                            var n = vW.exec(t);
                            if (null == n) return console.log("Couldn't parse line number in error: " + t), void console.log(e);
                            for (var r = +n[1], a = e.split("\n"), i = a.length.toString().length + 2, o = a.map(function (e, t) {
                                    return cv((t + 1).toString(), i) + e
                                }), s = 0, u = 0; u < o.length; u++) s = Math.max(o[u].length, s);
                            var l = o.slice(0, r - 1),
                                c = o.slice(r - 1, r),
                                p = o.slice(r);
                            console.log(l.join("\n")), console.log(t.split("\n")[0]), console.log("%c " + cv(c[0], s), "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(p.join("\n"))
                        }(t, e.getShaderInfoLog(n)), new Error("Failed to compile fragment shader.");
                        return n
                    }(t, e),
                    r = function (e) {
                        var t = OW();
                        return function (e, t) {
                            var n = NW(e, function () {
                                return e.createShader(e.VERTEX_SHADER)
                            }, "Unable to create vertex WebGLShader.");
                            if (pW(e, function () {
                                    return e.shaderSource(n, t)
                                }), pW(e, function () {
                                    return e.compileShader(n)
                                }), !1 === e.getShaderParameter(n, e.COMPILE_STATUS)) throw console.log(e.getShaderInfoLog(n)), new Error("Failed to compile vertex shader.");
                            return n
                        }(e, t.version + "\n    precision highp float;\n    " + t.attribute + " vec3 clipSpacePos;\n    " + t.attribute + " vec2 uv;\n    " + t.varyingVs + " vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }")
                    }(t),
                    a = function (e) {
                        return NW(e, function () {
                            return e.createProgram()
                        }, "Unable to create WebGLProgram.")
                    }(t);
                return pW(t, function () {
                        return t.attachShader(a, r)
                    }), pW(t, function () {
                        return t.attachShader(a, n)
                    }),
                    function (e, t) {
                        if (pW(e, function () {
                                return e.linkProgram(t)
                            }), !1 === e.getProgramParameter(t, e.LINK_STATUS)) throw console.log(e.getProgramInfoLog(t)), new Error("Failed to link vertex and fragment shaders.")
                    }(t, a), this.debug && gW(t, a), this.vertexAttrsAreBound || (this.setProgram(a), this.vertexAttrsAreBound = function (e, t, n) {
                        return pW(e, function () {
                            return e.bindBuffer(e.ARRAY_BUFFER, n)
                        }), yW(e, t, "clipSpacePos", n, 3, 20, 0) && yW(e, t, "uv", n, 2, 20, 12)
                    }(t, this.program, this.vertexBuffer)), a
            }, t.deleteProgram = function (e) {
                var t = this;
                this.throwIfDisposed(), e === this.program && (this.program = null), null != e && pW(this.gl, function () {
                    return t.gl.deleteProgram(e)
                })
            }, t.setProgram = function (e) {
                var t = this;
                this.throwIfDisposed(), this.program = e, null != this.program && this.debug && gW(this.gl, this.program), pW(this.gl, function () {
                    return t.gl.useProgram(e)
                })
            }, t.getUniformLocation = function (e, t, n) {
                return void 0 === n && (n = !0), this.throwIfDisposed(), n ? function (e, t, n) {
                    return NW(e, function () {
                        return e.getUniformLocation(t, n)
                    }, 'uniform "' + n + '" not present in program.')
                }(this.gl, e, t) : function (e, t, n) {
                    return e.getUniformLocation(t, n)
                }(this.gl, e, t)
            }, t.getAttributeLocation = function (e, t) {
                var n = this;
                return this.throwIfDisposed(), pW(this.gl, function () {
                    return n.gl.getAttribLocation(e, t)
                })
            }, t.getUniformLocationNoThrow = function (e, t) {
                return this.throwIfDisposed(), this.gl.getUniformLocation(e, t)
            }, t.setInputMatrixTexture = function (e, t, n) {
                this.throwIfDisposed(), this.throwIfNoProgram(), bW(this.gl, e, t, n)
            }, t.setOutputMatrixTexture = function (e, t, n) {
                this.setOutputMatrixTextureDriver(e, n, t)
            }, t.setOutputPackedMatrixTexture = function (e, t, n) {
                this.throwIfDisposed();
                var r = lW(t, n),
                    a = r[0],
                    i = r[1];
                this.setOutputMatrixTextureDriver(e, a, i)
            }, t.setOutputMatrixWriteRegion = function (e, t, n, r) {
                this.setOutputMatrixWriteRegionDriver(n, e, r, t)
            }, t.setOutputPackedMatrixWriteRegion = function (e, t, n, r) {
                throw new Error("setOutputPackedMatrixWriteRegion not implemented.")
            }, t.debugValidate = function () {
                null != this.program && gW(this.gl, this.program), kW(this.gl)
            }, t.executeProgram = function () {
                this.throwIfDisposed(), this.throwIfNoProgram();
                var e = this.gl;
                this.debug && this.debugValidate(), pW(e, function () {
                    return e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0)
                })
            }, t.blockUntilAllProgramsCompleted = function () {
                var e = this;
                this.throwIfDisposed(), pW(this.gl, function () {
                    return e.gl.finish()
                })
            }, t.getQueryTimerExtension = function () {
                return null == this.disjointQueryTimerExtension && (this.disjointQueryTimerExtension = fW(this.gl, 2 === Wv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension
            }, t.getQueryTimerExtensionWebGL2 = function () {
                return this.getQueryTimerExtension()
            }, t.getQueryTimerExtensionWebGL1 = function () {
                return this.getQueryTimerExtension()
            }, t.beginQuery = function () {
                if (2 === Wv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
                    var e = this.gl,
                        t = this.getQueryTimerExtensionWebGL2(),
                        n = e.createQuery();
                    return e.beginQuery(t.TIME_ELAPSED_EXT, n), n
                }
                var r = this.getQueryTimerExtensionWebGL1(),
                    a = r.createQueryEXT();
                return r.beginQueryEXT(r.TIME_ELAPSED_EXT, a), a
            }, t.endQuery = function () {
                if (2 !== Wv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
                    var e = this.getQueryTimerExtensionWebGL1();
                    e.endQueryEXT(e.TIME_ELAPSED_EXT)
                } else {
                    var t = this.gl,
                        n = this.getQueryTimerExtensionWebGL2();
                    t.endQuery(n.TIME_ELAPSED_EXT)
                }
            }, t.waitForQueryAndGetTime = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    var n = this;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, pv(function () {
                                    return n.disposed || n.isQueryAvailable(t, Wv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))
                                });
                            case 2:
                                return e.abrupt("return", this.getQueryTime(t, Wv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")));
                            case 3:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), t.getQueryTime = function (e, t) {
                if (0 === t) return null;
                if (2 === t) {
                    var n = this.gl;
                    return n.getQueryParameter(e, n.QUERY_RESULT) / 1e6
                }
                var r = this.getQueryTimerExtensionWebGL1();
                return r.getQueryObjectEXT(e, r.QUERY_RESULT_EXT) / 1e6
            }, t.isQueryAvailable = function (e, t) {
                if (0 === t) return !0;
                if (2 === t) {
                    var n = this.gl,
                        r = this.getQueryTimerExtensionWebGL2(),
                        a = n.getQueryParameter(e, n.QUERY_RESULT_AVAILABLE);
                    return null == this.disjoint && (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)), a && !this.disjoint
                }
                var i = this.getQueryTimerExtensionWebGL1(),
                    o = i.getQueryObjectEXT(e, i.QUERY_RESULT_AVAILABLE_EXT);
                return null == this.disjoint && (this.disjoint = this.gl.getParameter(i.GPU_DISJOINT_EXT)), o && !this.disjoint
            }, t.pollFence = function (e) {
                var t = this;
                return new Promise(function (n) {
                    t.addItemToPoll(function () {
                        return e.isFencePassed()
                    }, function () {
                        return n()
                    })
                })
            }, t.pollItems = function () {
                for (var e = function (e) {
                        for (var t = 0; t < e.length && e[t](); ++t);
                        return t - 1
                    }(this.itemsToPoll.map(function (e) {
                        return e.isDoneFn
                    })), t = 0; t <= e; ++t)(0, this.itemsToPoll[t].resolveFn)();
                this.itemsToPoll = this.itemsToPoll.slice(e + 1)
            }, t.addItemToPoll = function (e, t) {
                var n = this;
                this.itemsToPoll.push({
                    isDoneFn: e,
                    resolveFn: t
                }), this.itemsToPoll.length > 1 || pv(function () {
                    return n.pollItems(), 0 === n.itemsToPoll.length
                })
            }, t.bindTextureToFrameBuffer = function (e) {
                this.throwIfDisposed(), xW(this.gl, e, this.framebuffer), this.debug && kW(this.gl)
            }, t.unbindTextureToFrameBuffer = function () {
                null != this.outputTexture ? (xW(this.gl, this.outputTexture, this.framebuffer), this.debug && kW(this.gl)) : wW(this.gl, this.framebuffer)
            }, t.downloadMatrixDriver = function (e, t) {
                this.bindTextureToFrameBuffer(e);
                var n = t();
                return this.unbindTextureToFrameBuffer(), n
            }, t.setOutputMatrixTextureDriver = function (e, t, n) {
                this.throwIfDisposed();
                var r = this.gl;
                xW(r, e, this.framebuffer), this.debug && kW(r), this.outputTexture = e, pW(r, function () {
                    return r.viewport(0, 0, t, n)
                }), pW(r, function () {
                    return r.scissor(0, 0, t, n)
                })
            }, t.setOutputMatrixWriteRegionDriver = function (e, t, n, r) {
                var a = this;
                this.throwIfDisposed(), pW(this.gl, function () {
                    return a.gl.scissor(e, t, n, r)
                })
            }, t.throwIfDisposed = function () {
                if (this.disposed) throw new Error("Attempted to use disposed GPGPUContext.")
            }, t.throwIfNoProgram = function () {
                if (null == this.program) throw new Error("No GPU program is currently set.")
            }, Wm(e, [{
                key: "debug",
                get: function () {
                    return Wv().getBool("DEBUG")
                }
            }]), e
        }(),
        ZW = xw;

    function QW(e, t, n, r) {
        var a = [];
        e.forEach(function (e) {
            var t = ov(e.shapeInfo.logicalShape);
            e.shapeInfo.isUniform ? a.push("uniform float " + e.name + (t > 1 ? "[" + t + "]" : "") + ";") : (a.push("uniform sampler2D " + e.name + ";"), a.push("uniform int offset" + e.name + ";"))
        });
        var i, o, s = a.join("\n"),
            u = e.map(function (e) {
                return function (e, t, n) {
                    void 0 === n && (n = !1);
                    var r = "";
                    r += n ? function e(t) {
                        var n, r, a;
                        switch (t.shapeInfo.logicalShape.length) {
                            case 0:
                                return n = t.name, r = "get" + n.charAt(0).toUpperCase() + n.slice(1), a = OW(), "\n    vec4 " + r + "() {\n      return " + a.texture2D + "(" + n + ", halfCR);\n    }\n  ";
                            case 1:
                                return function (e) {
                                    var t = e.name,
                                        n = "get" + t.charAt(0).toUpperCase() + t.slice(1),
                                        r = e.shapeInfo.texShape,
                                        a = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)],
                                        i = OW();
                                    return "\n    vec4 " + n + "(int index) {\n      vec2 uv = packedUVfrom1D(\n        " + a[0] + ", " + a[1] + ", index);\n      return " + i.texture2D + "(" + t + ", uv);\n    }\n  "
                                }(t);
                            case 2:
                                return function (e) {
                                    var t = e.shapeInfo.logicalShape,
                                        n = e.name,
                                        r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
                                        a = e.shapeInfo.texShape,
                                        i = a[0],
                                        o = a[1],
                                        s = OW();
                                    if (null != a && sv(t, a)) return "\n      vec4 " + r + "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(" + o + ".0, " + i + ".0);\n\n        return " + s.texture2D + "(" + n + ", uv);\n      }\n    ";
                                    var u = [Math.ceil(a[0] / 2), Math.ceil(a[1] / 2)],
                                        l = Math.ceil(t[1] / 2);
                                    return "\n    vec4 " + r + "(int row, int col) {\n      vec2 uv = packedUVfrom2D(" + l + ", " + u[0] + ", " + u[1] + ", row, col);\n      return " + s.texture2D + "(" + n + ", uv);\n    }\n  "
                                }(t);
                            case 3:
                                return function (t) {
                                    var n = t.shapeInfo.logicalShape,
                                        r = t.name,
                                        a = "get" + r.charAt(0).toUpperCase() + r.slice(1),
                                        i = t.shapeInfo.texShape,
                                        o = [Math.ceil(i[0] / 2), Math.ceil(i[1] / 2)];
                                    if (1 === n[0]) {
                                        var s = n.slice(1),
                                            u = oV(t, s);
                                        return "\n        " + e(u) + "\n        vec4 " + a + "(int b, int row, int col) {\n          return " + a + "(" + sV(["b", "row", "col"], [1, 2]) + ");\n        }\n      "
                                    }
                                    var l = o[0],
                                        c = o[1],
                                        p = Math.ceil(n[2] / 2),
                                        h = p * Math.ceil(n[1] / 2),
                                        f = OW();
                                    return "\n    vec4 " + a + "(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        " + l + ", " + c + ", " + h + ", " + p + ", b, row, col);\n      return " + f.texture2D + "(" + r + ", uv);\n    }\n  "
                                }(t);
                            default:
                                return function (e) {
                                    for (var t = e.shapeInfo.logicalShape, n = t.length, r = e.name, a = "get" + r.charAt(0).toUpperCase() + r.slice(1), i = e.shapeInfo.texShape, o = [Math.ceil(i[0] / 2), Math.ceil(i[1] / 2)], s = o[0], u = o[1], l = Math.ceil(t[n - 1] / 2), c = l * Math.ceil(t[n - 2] / 2), p = "int b, int row, int col", h = "b * " + c + " + (row / 2) * " + l + " + (col / 2)", f = 2; f < n - 1; f++) p = "int b" + f + ", " + p, c *= t[n - f - 1], h = "b" + f + " * " + c + " + " + h;
                                    var d = OW();
                                    return "\n    vec4 " + a + "(" + p + ") {\n      int index = " + h + ";\n      int texR = index / " + u + ";\n      int texC = index - texR * " + u + ";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + u + ", " + s + ");\n      return " + d.texture2D + "(" + r + ", uv);\n    }\n  "
                                }(t)
                        }
                    }(e) : function e(t) {
                        var n = t.shapeInfo.logicalShape;
                        switch (n.length) {
                            case 0:
                                return function (e) {
                                    var t = e.name,
                                        n = "get" + t.charAt(0).toUpperCase() + t.slice(1);
                                    if (e.shapeInfo.isUniform) return "float " + n + "() {return " + t + ";}";
                                    var r = e.shapeInfo.texShape,
                                        a = r[0],
                                        i = r[1];
                                    if (1 === a && 1 === i) return "\n      float " + n + "() {\n        return sampleTexture(" + t + ", halfCR);\n      }\n    ";
                                    var o = e.shapeInfo.texShape,
                                        s = o[0],
                                        u = o[1],
                                        l = rV(t);
                                    return "\n    float " + n + "() {\n      vec2 uv = uvFromFlat(" + s + ", " + u + ", " + l + ");\n      return sampleTexture(" + t + ", uv);\n    }\n  "
                                }(t);
                            case 1:
                                return function (e) {
                                    var t = e.name,
                                        n = "get" + t.charAt(0).toUpperCase() + t.slice(1);
                                    if (e.shapeInfo.isUniform) return "\n      float " + n + "(int index) {\n        " + aV(e) + "\n      }\n    ";
                                    var r = e.shapeInfo.texShape,
                                        a = r[0],
                                        i = r[1];
                                    if (1 === i && 1 === a) return "\n      float " + n + "(int index) {\n        return sampleTexture(" + t + ", halfCR);\n      }\n    ";
                                    var o = rV(t);
                                    return 1 === i ? "\n      float " + n + "(int index) {\n        vec2 uv = vec2(0.5, (float(index + " + o + ") + 0.5) / " + a + ".0);\n        return sampleTexture(" + t + ", uv);\n      }\n    " : 1 === a ? "\n      float " + n + "(int index) {\n        vec2 uv = vec2((float(index + " + o + ") + 0.5) / " + i + ".0, 0.5);\n        return sampleTexture(" + t + ", uv);\n      }\n    " : "\n    float " + n + "(int index) {\n      vec2 uv = uvFromFlat(" + a + ", " + i + ", index + " + o + ");\n      return sampleTexture(" + t + ", uv);\n    }\n  "
                                }(t);
                            case 2:
                                return function (t) {
                                    var n = t.shapeInfo.logicalShape,
                                        r = t.name,
                                        a = "get" + r.charAt(0).toUpperCase() + r.slice(1),
                                        i = t.shapeInfo.texShape;
                                    if (null != i && sv(n, i)) {
                                        var o = i[0],
                                            s = i[1];
                                        return "\n    float " + a + "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(" + s + ".0, " + o + ".0);\n      return sampleTexture(" + r + ", uv);\n    }\n  "
                                    }
                                    var u = dv(n),
                                        l = u.newShape,
                                        c = u.keptDims,
                                        p = l;
                                    if (p.length < n.length) {
                                        var h = oV(t, p);
                                        return "\n      " + e(h) + "\n      float " + a + "(int row, int col) {\n        return " + a + "(" + sV(["row", "col"], c) + ");\n      }\n    "
                                    }
                                    if (t.shapeInfo.isUniform) return "\n      float " + a + "(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(" + n[1] + ", 1)));\n        " + aV(t) + "\n      }\n    ";
                                    var f = i[0],
                                        d = i[1],
                                        m = rV(r);
                                    return 1 === d ? "\n    float " + a + "(int row, int col) {\n      float index = dot(vec3(row, col, " + m + "), vec3(" + n[1] + ", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / " + f + ".0);\n      return sampleTexture(" + r + ", uv);\n    }\n  " : 1 === f ? "\n    float " + a + "(int row, int col) {\n      float index = dot(vec3(row, col, " + m + "), vec3(" + n[1] + ", 1, 1));\n      vec2 uv = vec2((index + 0.5) / " + d + ".0, 0.5);\n      return sampleTexture(" + r + ", uv);\n    }\n  " : "\n  float " + a + "(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * " + n[1] + " + col + " + m + ";\n    vec2 uv = uvFromFlat(" + f + ", " + d + ", index);\n    return sampleTexture(" + r + ", uv);\n  }\n"
                                }(t);
                            case 3:
                                return function (t) {
                                    var n = t.shapeInfo.logicalShape,
                                        r = t.name,
                                        a = "get" + r.charAt(0).toUpperCase() + r.slice(1),
                                        i = n[1] * n[2],
                                        o = n[2],
                                        s = dv(n),
                                        u = s.newShape,
                                        l = s.keptDims,
                                        c = u;
                                    if (c.length < n.length) {
                                        var p = oV(t, c);
                                        return "\n        " + e(p) + "\n        float " + a + "(int row, int col, int depth) {\n          return " + a + "(" + sV(["row", "col", "depth"], l) + ");\n        }\n      "
                                    }
                                    if (t.shapeInfo.isUniform) return "\n      float " + a + "(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(" + i + ", " + o + ", 1)));\n        " + aV(t) + "\n      }\n    ";
                                    var h = t.shapeInfo.texShape,
                                        f = h[0],
                                        d = h[1],
                                        m = t.shapeInfo.flatOffset;
                                    if (d === i && null == m) return "\n        float " + a + "(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(" + o + ", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(" + d + ".0, " + f + ".0);\n          return sampleTexture(" + r + ", uv);\n        }\n      ";
                                    if (d === o && null == m) return "\n    float " + a + "(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(" + n[1] + ", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + d + ".0, " + f + ".0);\n      return sampleTexture(" + r + ", uv);\n    }\n  ";
                                    var v = rV(r);
                                    return "\n      float " + a + "(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * " + i + " + col * " + o + " + depth + " + v + ";\n        vec2 uv = uvFromFlat(" + f + ", " + d + ", index);\n        return sampleTexture(" + r + ", uv);\n      }\n  "
                                }(t);
                            case 4:
                                return function (t) {
                                    var n = t.shapeInfo.logicalShape,
                                        r = t.name,
                                        a = "get" + r.charAt(0).toUpperCase() + r.slice(1),
                                        i = n[3],
                                        o = n[2] * i,
                                        s = n[1] * o,
                                        u = dv(n),
                                        l = u.newShape,
                                        c = u.keptDims;
                                    if (l.length < n.length) {
                                        var p = oV(t, l);
                                        return "\n      " + e(p) + "\n      float " + a + "(int row, int col, int depth, int depth2) {\n        return " + a + "(" + sV(["row", "col", "depth", "depth2"], c) + ");\n      }\n    "
                                    }
                                    if (t.shapeInfo.isUniform) return "\n      float " + a + "(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(" + s + ", " + o + ", " + i + ", 1)));\n        " + aV(t) + "\n      }\n    ";
                                    var h = t.shapeInfo.flatOffset,
                                        f = t.shapeInfo.texShape,
                                        d = f[0],
                                        m = f[1];
                                    if (m === s && null == h) return "\n      float " + a + "(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(" + o + ", " + i + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + m + ".0, " + d + ".0);\n        return sampleTexture(" + r + ", uv);\n      }\n    ";
                                    if (m === i && null == h) return "\n      float " + a + "(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(" + n[1] * n[2] + ", " + n[2] + ", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + m + ".0, " + d + ".0);\n        return sampleTexture(" + r + ", uv);\n      }\n    ";
                                    var v = rV(r);
                                    return "\n    float " + a + "(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + s + " + col * " + o + " +\n          depth * " + i + " + depth2;\n      vec2 uv = uvFromFlat(" + d + ", " + m + ", index + " + v + ");\n      return sampleTexture(" + r + ", uv);\n    }\n  "
                                }(t);
                            case 5:
                                return function (t) {
                                    var n = t.shapeInfo.logicalShape,
                                        r = t.name,
                                        a = "get" + r.charAt(0).toUpperCase() + r.slice(1),
                                        i = n[4],
                                        o = n[3] * i,
                                        s = n[2] * o,
                                        u = n[1] * s,
                                        l = dv(n),
                                        c = l.newShape,
                                        p = l.keptDims;
                                    if (c.length < n.length) {
                                        var h = oV(t, c);
                                        return "\n      " + e(h) + "\n      float " + a + "(int row, int col, int depth, int depth2, int depth3) {\n        return " + a + "(" + sV(["row", "col", "depth", "depth2", "depth3"], p) + ");\n      }\n    "
                                    }
                                    if (t.shapeInfo.isUniform) return "\n      float " + a + "(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + u + ", " + s + ", " + o + ", " + i + ")) +\n          depth3;\n        " + aV(t) + "\n      }\n    ";
                                    var f = t.shapeInfo.flatOffset,
                                        d = t.shapeInfo.texShape,
                                        m = d[0],
                                        v = d[1];
                                    if (v === u && null == f) return "\n      float " + a + "(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(" + s + ", " + o + ", " + i + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + v + ".0, " + m + ".0);\n        return sampleTexture(" + r + ", uv);\n      }\n    ";
                                    if (v === i && null == f) return "\n      float " + a + "(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + n[1] * n[2] * n[3] + ",\n               " + n[2] * n[3] + ", " + n[3] + ", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + v + ".0, " + m + ".0);\n        return sampleTexture(" + r + ", uv);\n      }\n    ";
                                    var g = rV(r);
                                    return "\n    float " + a + "(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + u + " + col * " + s + " + depth * " + o + " +\n          depth2 * " + i + " + depth3 + " + g + ";\n      vec2 uv = uvFromFlat(" + m + ", " + v + ", index);\n      return sampleTexture(" + r + ", uv);\n    }\n  "
                                }(t);
                            case 6:
                                return function (t) {
                                    var n = t.shapeInfo.logicalShape,
                                        r = t.name,
                                        a = "get" + r.charAt(0).toUpperCase() + r.slice(1),
                                        i = dv(n),
                                        o = i.newShape,
                                        s = i.keptDims;
                                    if (o.length < n.length) {
                                        var u = oV(t, o);
                                        return "\n      " + e(u) + "\n      float " + a + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return " + a + "(" + sV(["row", "col", "depth", "depth2", "depth3", "depth4"], s) + ");\n      }\n    "
                                    }
                                    var l = n[5],
                                        c = n[4] * l,
                                        p = n[3] * c,
                                        h = n[2] * p,
                                        f = n[1] * h;
                                    if (t.shapeInfo.isUniform) return "\n      float " + a + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + f + ", " + h + ", " + p + ", " + c + ")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(" + l + ", 1)));\n        " + aV(t) + "\n      }\n    ";
                                    var d = t.shapeInfo.flatOffset,
                                        m = t.shapeInfo.texShape,
                                        v = m[0],
                                        g = m[1];
                                    if (g === f && null == d) return "\n      float " + a + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(" + h + ", " + p + ", " + c + ", " + l + ")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + g + ".0, " + v + ".0);\n        return sampleTexture(" + r + ", uv);\n      }\n    ";
                                    if (g === l && null == d) return "\n      float " + a + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(" + n[1] * n[2] * n[3] * n[4] + ",\n               " + n[2] * n[3] * n[4] + ",\n               " + n[3] * n[4] + ",\n               " + n[4] + ")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + g + ".0, " + v + ".0);\n        return sampleTexture(" + r + ", uv);\n      }\n    ";
                                    var y = rV(r);
                                    return "\n    float " + a + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + f + " + col * " + h + " + depth * " + p + " +\n          depth2 * " + c + " + depth3 * " + l + " + depth4 + " + y + ";\n      vec2 uv = uvFromFlat(" + v + ", " + g + ", index);\n      return sampleTexture(" + r + ", uv);\n    }\n  "
                                }(t);
                            default:
                                throw new Error(n.length + "-D input sampling is not yet supported")
                        }
                    }(e);
                    var a = e.shapeInfo.logicalShape,
                        i = t.logicalShape;
                    return a.length <= i.length && (r += n ? function (e, t) {
                        var n, r = e.name,
                            a = r.charAt(0).toUpperCase() + r.slice(1),
                            i = "get" + a + "AtOutCoords",
                            o = e.shapeInfo.logicalShape.length,
                            s = t.logicalShape.length,
                            u = ZW(e.shapeInfo.logicalShape, t.logicalShape),
                            l = iV(s),
                            c = s - o,
                            p = ["x", "y", "z", "w", "u", "v"];
                        n = 0 === o ? "" : s < 2 && u.length >= 1 ? "coords = 0;" : u.map(function (e) {
                            return "coords." + p[e + c] + " = 0;"
                        }).join("\n");
                        var h;
                        h = s < 2 && o > 0 ? "coords" : e.shapeInfo.logicalShape.map(function (e, t) {
                            return "coords." + p[t + c]
                        }).join(", ");
                        var f = "return outputValue;",
                            d = 1 === ov(e.shapeInfo.logicalShape),
                            m = 1 === ov(t.logicalShape);
                        if (1 !== o || d || m) {
                            if (d && !m) f = 1 === s ? "\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      " : "\n        return vec4(outputValue.x);\n      ";
                            else if (u.length) {
                                var v = o - 2,
                                    g = o - 1;
                                u.indexOf(v) > -1 && u.indexOf(g) > -1 ? f = "return vec4(outputValue.x);" : u.indexOf(v) > -1 ? f = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : u.indexOf(g) > -1 && (f = "return vec4(outputValue.xx, outputValue.zz);")
                            }
                        } else f = "\n      return vec4(outputValue.xy, outputValue.xy);\n    ";
                        return "\n    vec4 " + i + "() {\n      " + l + " coords = getOutputCoords();\n      " + n + "\n      vec4 outputValue = get" + a + "(" + h + ");\n      " + f + "\n    }\n  "
                    }(e, t) : function (e, t) {
                        var n = e.name,
                            r = n.charAt(0).toUpperCase() + n.slice(1),
                            a = "get" + r + "AtOutCoords",
                            i = t.texShape,
                            o = e.shapeInfo.texShape,
                            s = e.shapeInfo.logicalShape.length,
                            u = t.logicalShape.length;
                        if (!e.shapeInfo.isUniform && s === u && null == e.shapeInfo.flatOffset && sv(o, i)) return "\n      float " + a + "() {\n        return sampleTexture(" + n + ", resultUV);\n      }\n    ";
                        var l = iV(u),
                            c = ZW(e.shapeInfo.logicalShape, t.logicalShape),
                            p = u - s,
                            h = ["x", "y", "z", "w", "u", "v"];
                        return "\n    float " + a + "() {\n      " + l + " coords = getOutputCoords();\n      " + (0 === s ? "" : u < 2 && c.length >= 1 ? "coords = 0;" : c.map(function (e) {
                            return "coords." + h[e + p] + " = 0;"
                        }).join("\n")) + "\n      return get" + r + "(" + (u < 2 && s > 0 ? "coords" : e.shapeInfo.logicalShape.map(function (e, t) {
                            return "coords." + h[t + p]
                        }).join(", ")) + ");\n    }\n  "
                    }(e, t)), r
                }(e, t, r)
            }).join("\n"),
            l = t.texShape,
            c = OW(),
            p = "\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return " + c.texture2D + "(textureSampler, uv).r;\n    }\n  ",
            h = function (e) {
                return e.version + "\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    " + e.varyingFs + " vec2 resultUV;\n    " + e.defineOutput + "\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    " + e.defineSpecialNaN + "\n    " + e.defineSpecialInf + "\n    " + e.defineRound + "\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    " + $W + "\n    " + eV + "\n    " + tV + "\n  "
            }(c);
        return t.isPacked ? (i = function (e, t) {
            switch (e.length) {
                case 0:
                    return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
                case 1:
                    return function (e, t) {
                        var n = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)];
                        return 1 === n[0] ? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * " + n[1] + ".0);\n      }\n    " : 1 === n[1] ? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * " + n[0] + ".0);\n      }\n    " : "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n[0] + ", " + n[1] + "));\n      return 2 * (resTexRC.x * " + n[1] + " + resTexRC.y);\n    }\n  "
                    }(0, t);
                case 2:
                    return function (e, t) {
                        var n = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)];
                        if (sv(e, t)) return "\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(" + n[0] + ", " + n[1] + "));\n      }\n    ";
                        var r = Math.ceil(e[1] / 2);
                        return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n[0] + ", " + n[1] + "));\n\n      int index = resTexRC.x * " + n[1] + " + resTexRC.y;\n      int r = 2 * (index / " + r + ");\n      int c = imod(index, " + r + ") * 2;\n\n      return ivec2(r, c);\n    }\n  "
                    }(e, t);
                case 3:
                    return n = e, r = t, a = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)], o = (i = Math.ceil(n[2] / 2)) * Math.ceil(n[1] / 2), "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + a[0] + ", " + a[1] + "));\n      int index = resTexRC.x * " + a[1] + " + resTexRC.y;\n\n      int b = index / " + o + ";\n      index -= b * " + o + ";\n\n      int r = 2 * (index / " + i + ");\n      int c = imod(index, " + i + ") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";
                default:
                    return function (e, t) {
                        for (var n = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)], r = Math.ceil(e[e.length - 1] / 2), a = r * Math.ceil(e[e.length - 2] / 2), i = a, o = "", s = "b, r, c", u = 2; u < e.length - 1; u++) o = "\n      int b" + u + " = index / " + (i *= e[e.length - u - 1]) + ";\n      index -= b" + u + " * " + i + ";\n    " + o, s = "b" + u + ", " + s;
                        return "\n    ivec" + e.length + " getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n[0] + ", " + n[1] + "));\n      int index = resTexRC.x * " + n[1] + " + resTexRC.y;\n\n      " + o + "\n\n      int b = index / " + a + ";\n      index -= b * " + a + ";\n\n      int r = 2 * (index / " + r + ");\n      int c = imod(index, " + r + ") * 2;\n\n      return ivec" + e.length + "(" + s + ");\n    }\n  "
                    }(e, t)
            }
            var n, r, a, i, o
        }(t.logicalShape, l), o = "\n    void setOutput(vec4 val) {\n      " + c.output + " = val;\n    }\n  ") : (i = function (e, t) {
            switch (e.length) {
                case 0:
                    return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
                case 1:
                    return function (e, t) {
                        return 1 === t[0] ? "\n      int getOutputCoords() {\n        return int(resultUV.x * " + t[1] + ".0);\n      }\n    " : 1 === t[1] ? "\n      int getOutputCoords() {\n        return int(resultUV.y * " + t[0] + ".0);\n      }\n    " : "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + t[0] + ", " + t[1] + "));\n      return resTexRC.x * " + t[1] + " + resTexRC.y;\n    }\n  "
                    }(0, t);
                case 2:
                    return function (e, t) {
                        return sv(e, t) ? "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(" + t[0] + ", " + t[1] + "));\n      }\n    " : 1 === e[1] ? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + t[0] + ", " + t[1] + "));\n        int index = resTexRC.x * " + t[1] + " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    " : 1 === e[0] ? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + t[0] + ", " + t[1] + "));\n        int index = resTexRC.x * " + t[1] + " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    " : "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + t[0] + ", " + t[1] + "));\n      int index = resTexRC.x * " + t[1] + " + resTexRC.y;\n      int r = index / " + e[1] + ";\n      int c = index - r * " + e[1] + ";\n      return ivec2(r, c);\n    }\n  "
                    }(e, t);
                case 3:
                    return n = t, r = MW(["r", "c", "d"], e), "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n[0] + ", " + n[1] + "));\n      int index = resTexRC.x * " + n[1] + " + resTexRC.y;\n      " + r + "\n      return ivec3(r, c, d);\n    }\n  ";
                case 4:
                    return function (e, t) {
                        var n = MW(["r", "c", "d", "d2"], e);
                        return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + t[0] + ", " + t[1] + "));\n      int index = resTexRC.x * " + t[1] + " + resTexRC.y;\n      " + n + "\n      return ivec4(r, c, d, d2);\n    }\n  "
                    }(e, t);
                case 5:
                    return function (e, t) {
                        var n = MW(["r", "c", "d", "d2", "d3"], e);
                        return "\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(" + t[0] + ",\n                             " + t[1] + "));\n\n      int index = resTexRC.x * " + t[1] + " + resTexRC.y;\n\n      " + n + "\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  "
                    }(e, t);
                case 6:
                    return function (e, t) {
                        var n = MW(["r", "c", "d", "d2", "d3", "d4"], e);
                        return "\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + t[0] + ", " + t[1] + "));\n      int index = resTexRC.x * " + t[1] + " + resTexRC.y;\n\n      " + n + "\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  "
                    }(e, t);
                default:
                    throw new Error(e.length + "-D output sampling is not yet supported")
            }
            var n, r
        }(t.logicalShape, l), o = "\n    void setOutput(float val) {\n      " + c.output + " = vec4(val, 0, 0, 0);\n    }\n  "), r && (h += nV), [h, p, o, s, i, u, n].join("\n")
    }
    var $W = "\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
        eV = "\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
        tV = "\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
        nV = "\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";

    function rV(e) {
        return "offset" + e
    }

    function aV(e) {
        var t = e.name,
            n = ov(e.shapeInfo.logicalShape);
        return n < 2 ? "return " + t + ";" : "\n    for (int i = 0; i < " + n + "; i++) {\n      if (i == index) {\n        return " + t + "[i];\n      }\n    }\n  "
    }

    function iV(e) {
        if (e <= 1) return "int";
        if (2 === e) return "ivec2";
        if (3 === e) return "ivec3";
        if (4 === e) return "ivec4";
        if (5 === e) return "ivec5";
        if (6 === e) return "ivec6";
        throw Error("GPU for rank " + e + " is not yet supported")
    }

    function oV(e, t) {
        var n = JSON.parse(JSON.stringify(e));
        return n.shapeInfo.logicalShape = t, n
    }

    function sV(e, t) {
        return t.map(function (t) {
            return e[t]
        }).join(", ")
    }

    function uV(e, t) {
        if (e.length !== t.length) throw Error("Binary was compiled with " + e.length + " inputs, but was executed with " + t.length + " inputs");
        e.forEach(function (e, n) {
            var r = e.logicalShape,
                a = t[n],
                i = a.shape;
            if (!sv(r, i)) throw Error("Binary was compiled with different shapes than the current args. Shapes " + r + " and " + i + " must match");
            if (!e.isUniform || !a.isUniform) {
                var o = e.texShape,
                    s = a.isUniform ? null : a.texData.texShape;
                if (!sv(o, s)) throw Error("Binary was compiled with different texture shapes than the current args. Shape " + o + " and " + s + " must match")
            }
        })
    }
    var lV = VM,
        cV = HM,
        pV = qM,
        hV = JM,
        fV = QM,
        dV = $M,
        mV = nL,
        vV = aL,
        gV = oL,
        yV = sL,
        bV = lL,
        xV = pL,
        wV = hL,
        kV = mL,
        NV = vL,
        IV = yL,
        SV = xL,
        TV = IL,
        CV = AL,
        EV = _L,
        RV = DL,
        AV = CM,
        FV = ML,
        _V = BL,
        DV = WL,
        OV = jL,
        MV = HL,
        LV = CL,
        zV = qL;

    function PV(e, t) {
        return ["x", "y", "z", "w", "u", "v"].slice(0, t).map(function (t) {
            return e + "." + t
        })
    }

    function BV(e, t) {
        return 1 === t ? [e] : PV(e, t)
    }
    var WV = function (e) {
            this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outputShape = e;
            var t = e.length;
            if (0 === t) this.userCode = "\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";
            else {
                var n = BV("rc", t),
                    r = iV(t),
                    a = function (e, t, n) {
                        if (1 === e) return "rc > " + t[0];
                        for (var r = "", a = e - 2; a < e; a++) r += n[a] + " >= " + t[a], a < e - 1 && (r += "||");
                        return r
                    }(t, e, n),
                    i = function (e, t, n, r) {
                        if (1 === e) return "";
                        var a = r.slice(-2);
                        return "\n    int r = " + a[0] + ";\n    int c = " + a[1] + ";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= " + t + ";\n    bool rEdge = rp1 >= " + n + ";\n  "
                    }(t, e[e.length - 1], e[e.length - 2], n),
                    o = function (e, t) {
                        var n = e.length,
                            r = function (e, t) {
                                for (var n = [], r = 0; r <= 1; r++)
                                    for (var a = 0; a <= 1; a++) {
                                        for (var i = (0 === r ? "r" : "rp1") + ", " + (0 === a ? "c" : "cp1"), o = 2; o < e; o++) i = t[t.length - 1 - o] + "," + i;
                                        n.push(i)
                                    }
                                return n
                            }(n, t);
                        return 1 === n ? "getA(rc),\n            rc + 1 >= " + e[0] + " ? 0. : getA(rc + 1),\n            0, 0" : "getA(" + r[0] + "),\n          cEdge ? 0. : getA(" + r[1] + "),\n          rEdge ? 0. : getA(" + r[2] + "),\n          rEdge || cEdge ? 0. : getA(" + r[3] + ")"
                    }(e, n);
                this.userCode = "\n        void main() {\n          " + r + " rc = getOutputCoords();\n\n          if(" + a + ") {\n            setOutput(vec4(0));\n          } else {\n            " + i + "\n\n            setOutput(vec4(" + o + "));\n          }\n        }\n      "
            }
        },
        VV = function (e, t) {
            this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e;
            for (var n = "", r = 0; r < 4; r++) {
                var a = "thisRC = rc;";
                r % 2 == 1 && (a += "thisRC.z += 1;"), r > 1 && (a += "thisRC.y += 1;"), n += "\n        " + a + "\n        " + (r > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : "") + "\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[" + r + "] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        " + (r > 0 ? "}" : "") + "\n      "
            }
            this.userCode = "\n      \n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      " + MW(["r", "c", "d"], t) + "\n      return ivec3(r, c, d);\n    }\n  \n      " + LW(e) + "\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = " + e[1] + ";\n        int cols = " + e[2] + ";\n\n        " + n + "\n\n        setOutput(result);\n      }\n    "
        },
        UV = function () {
            function e(e) {
                this.gpgpu = e, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0, this.freeTextures = {}, this.logEnabled = !1, this.usedTextures = {}
            }
            var t = e.prototype;
            return t.acquireTexture = function (e, t, n) {
                var r = jV(t, n),
                    a = HV(e, r, n);
                a in this.freeTextures || (this.freeTextures[a] = []), a in this.usedTextures || (this.usedTextures[a] = []);
                var i, o = GV(e, r, this.gpgpu.gl, this.gpgpu.textureConfig, n);
                if (this.freeTextures[a].length > 0) {
                    this.numFreeTextures--, this.numUsedTextures++, this._numBytesFree -= o, this.log();
                    var s = this.freeTextures[a].shift();
                    return this.usedTextures[a].push(s), s
                }
                return r === rW.PACKED_2X2_FLOAT32 ? i = this.gpgpu.createPackedMatrixTexture(e[0], e[1]) : r === rW.PACKED_2X2_FLOAT16 ? i = this.gpgpu.createFloat16PackedMatrixTexture(e[0], e[1]) : r === rW.UNPACKED_FLOAT32 ? i = this.gpgpu.createFloat32MatrixTexture(e[0], e[1]) : r === rW.UNPACKED_FLOAT16 ? i = this.gpgpu.createFloat16MatrixTexture(e[0], e[1]) : r === rW.PACKED_4X1_UNSIGNED_BYTE && (i = this.gpgpu.createUnsignedBytesMatrixTexture(e[0], e[1])), this.usedTextures[a].push(i), this.numUsedTextures++, this._numBytesAllocated += o, this.log(), i
            }, t.releaseTexture = function (e, t, n, r) {
                if (null != this.freeTextures) {
                    var a = jV(n, r),
                        i = HV(t, a, r);
                    i in this.freeTextures || (this.freeTextures[i] = []);
                    var o = GV(t, a, this.gpgpu.gl, this.gpgpu.textureConfig, r),
                        s = Wv().get("WEBGL_DELETE_TEXTURE_THRESHOLD"); - 1 !== s && this._numBytesAllocated > s ? (this.gpgpu.deleteMatrixTexture(e), this._numBytesAllocated -= o) : (this.freeTextures[i].push(e), this.numFreeTextures++, this._numBytesFree += o), this.numUsedTextures--;
                    var u = this.usedTextures[i],
                        l = u.indexOf(e);
                    if (l < 0) throw new Error("Cannot release a texture that was never provided by this texture manager");
                    u.splice(l, 1), this.log()
                }
            }, t.log = function () {
                if (this.logEnabled) {
                    var e = this.numFreeTextures + this.numUsedTextures;
                    console.log("Free/Used", this.numFreeTextures + " / " + this.numUsedTextures, "(" + e + ")");
                    var t = this._numBytesFree / this._numBytesAllocated;
                    console.log("Bytes allocated: " + this._numBytesAllocated), console.log("Bytes unused: " + this._numBytesFree + " (" + Math.round(100 * t) + "%)")
                }
            }, t.getNumUsedTextures = function () {
                return this.numUsedTextures
            }, t.getNumFreeTextures = function () {
                return this.numFreeTextures
            }, t.dispose = function () {
                var e = this;
                if (null != this.freeTextures) {
                    for (var t in this.freeTextures) this.freeTextures[t].forEach(function (t) {
                        e.gpgpu.deleteMatrixTexture(t)
                    });
                    for (var n in this.usedTextures) this.usedTextures[n].forEach(function (t) {
                        e.gpgpu.deleteMatrixTexture(t)
                    });
                    this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0
                }
            }, Wm(e, [{
                key: "numBytesAllocated",
                get: function () {
                    return this._numBytesAllocated
                }
            }, {
                key: "numBytesFree",
                get: function () {
                    return this._numBytesFree
                }
            }]), e
        }();

    function GV(e, t, n, r, a) {
        var i, o = function (e, t) {
            switch (e) {
                case rW.PACKED_2X2_FLOAT32:
                    return XW(t);
                case rW.PACKED_2X2_FLOAT16:
                    return YW(t);
                case rW.UNPACKED_FLOAT32:
                    return HW(t);
                case rW.UNPACKED_FLOAT16:
                    return qW(t);
                case rW.PACKED_4X1_UNSIGNED_BYTE:
                    return KW(t);
                default:
                    throw new Error("Unknown physical texture type " + e)
            }
        }(t, r);
        if (a) {
            var s = lW(e[0], e[1]);
            i = s[0] * s[1]
        } else {
            var u = sW(e[0], e[1]);
            i = u[0] * u[1]
        }
        return i * function (e, t) {
            var n = e;
            if (t === n.R32F) return 4;
            if (t === n.R16F) return 2;
            if (t === n.RGBA32F) return 16;
            if (t === e.RGBA) return 16;
            if (t === n.RGBA16F) return 8;
            throw new Error("Unknown internal format " + t)
        }(n, o)
    }

    function jV(e, t) {
        if (e === nW.UPLOAD) return rW.PACKED_2X2_FLOAT32;
        if (e === nW.RENDER || null == e) return function (e) {
            return Wv().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? e ? rW.PACKED_2X2_FLOAT32 : rW.UNPACKED_FLOAT32 : e ? rW.PACKED_2X2_FLOAT16 : rW.UNPACKED_FLOAT16
        }(t);
        if (e === nW.DOWNLOAD || e === nW.PIXELS) return rW.PACKED_4X1_UNSIGNED_BYTE;
        throw new Error("Unknown logical texture type " + e)
    }

    function HV(e, t, n) {
        return e[0] + "_" + e[1] + "_" + t + "_" + n
    }
    var qV = function (e, t) {
            this.variableNames = ["A"], this.outputShape = e, this.userCode = "\n      float unaryOperation(float x) {\n        " + t + "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "
        },
        KV = "return abs(x);",
        XV = "return x;",
        YV = function (e, t) {
            this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e, this.userCode = "\n      vec4 unaryOperation(vec4 x) {\n        " + t + "\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "
        },
        JV = function (e) {
            this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outputShape = e;
            var t = e.length,
                n = BV("rc", t),
                r = iV(t),
                a = function (e, t) {
                    if (1 === e) return "rc";
                    for (var n = "", r = 0; r < e; r++) n += t[r], r < e - 1 && (n += ",");
                    return n
                }(t, n),
                i = n.slice(-2),
                o = t <= 1 ? "rc" : "vec2(" + i.join(",") + ")";
            this.userCode = "\n      void main() {\n        " + r + " rc = getOutputCoords();\n        vec4 packedInput = getA(" + a + ");\n\n        setOutput(getChannel(packedInput, " + o + "));\n      }\n    "
        },
        ZV = eI,
        QV = {},
        $V = function (e) {
            function t(t) {
                var n, r;
                if ((n = e.call(this) || this).pendingRead = new WeakMap, n.pendingDisposal = new WeakSet, n.dataRefCount = new WeakMap, n.numBytesInGPU = 0, n.uploadWaitMs = 0, n.downloadWaitMs = 0, n.lastGlFlushTime = 0, n.warnedAboutMemory = !1, n.warnedAboutCPUBackend = !1, n.pendingDeletes = 0, n.disposed = !1, !Wv().getBool("HAS_WEBGL")) throw new Error("WebGL is not supported on this device");
                if (null == t) {
                    var a = oW(Wv().getNumber("WEBGL_VERSION"));
                    n.binaryCache = ((r = Wv().getNumber("WEBGL_VERSION")) in QV || (QV[r] = {}), QV[r]), n.gpgpu = new JW(a), n.canvas = a.canvas, n.gpgpuCreatedLocally = !0
                } else n.gpgpu = t, n.binaryCache = {}, n.gpgpuCreatedLocally = !1, n.canvas = t.gl.canvas;
                return n.textureManager = new UV(n.gpgpu), n.numMBBeforeWarning = null == Wv().global.screen ? 1024 : Wv().global.screen.height * Wv().global.screen.width * window.devicePixelRatio * 600 / 1024 / 1024, n.texData = new Ym(qm(n), tx()), n
            }
            Vm(t, e);
            var n = t.prototype;
            return n.nextDataId = function () {
                return t.nextDataId++
            }, n.numDataIds = function () {
                return this.texData.numDataIds() + (this.cpuBackend ? this.cpuBackend.numDataIds() : 0) - this.pendingDeletes
            }, n.write = function (e, t, n) {
                if ((Wv().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS") || Wv().getBool("DEBUG")) && this.checkNumericalProblems(e), "complex64" === n && null != e) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
                var r = {
                    id: this.nextDataId()
                };
                return this.texData.set(r, {
                    shape: t,
                    dtype: n,
                    values: e,
                    usage: nW.UPLOAD,
                    refCount: 1
                }), r
            }, n.refCount = function (e) {
                return this.texData.has(e) ? this.texData.get(e).refCount : 0
            }, n.incRef = function (e) {
                this.texData.get(e).refCount++
            }, n.decRef = function (e) {
                this.texData.has(e) && this.texData.get(e).refCount--
            }, n.move = function (e, t, n, r, a) {
                if (Wv().getBool("DEBUG") && this.checkNumericalProblems(t), "complex64" === r) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
                this.texData.set(e, {
                    shape: n,
                    dtype: r,
                    values: t,
                    usage: nW.UPLOAD,
                    refCount: a
                })
            }, n.disposeIntermediateTensorInfo = function (e) {
                this.disposeData(e.dataId)
            }, n.readSync = function (e) {
                var t = this.texData.get(e),
                    n = t.values,
                    r = t.dtype,
                    a = t.complexTensorInfos,
                    i = t.slice,
                    o = t.shape,
                    s = t.isPacked;
                if (null != i) {
                    var u;
                    u = s ? new YV(o, XV) : new qV(o, XV);
                    var l = this.runWebGLProgram(u, [{
                            dataId: e,
                            shape: o,
                            dtype: r
                        }], r),
                        c = this.readSync(l.dataId);
                    return this.disposeIntermediateTensorInfo(l), c
                }
                if (null != n) return this.convertAndCacheOnCPU(e);
                if ("string" === r) return n;
                var p, h, f = null != this.activeTimers;
                return f && (p = cg()), h = "complex64" === r ? PS(this.readSync(a.real.dataId), this.readSync(a.imag.dataId)) : this.getValuesFromTexture(e), f && (this.downloadWaitMs += cg() - p), this.convertAndCacheOnCPU(e, h)
            }, n.read = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    var n, r, a, i, o, s, u, l, c, p, h, f, d, m, v, g, y, b, x, w, k, N;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (!this.pendingRead.has(t)) {
                                    e.next = 3;
                                    break
                                }
                                return n = this.pendingRead.get(t), e.abrupt("return", new Promise(function (e) {
                                    return n.push(e)
                                }));
                            case 3:
                                if (r = this.texData.get(t), a = r.values, i = r.shape, o = r.slice, s = r.dtype, u = r.complexTensorInfos, l = r.isPacked, null == o) {
                                    e.next = 11;
                                    break
                                }
                                return c = l ? new YV(i, XV) : new qV(i, XV), p = this.runWebGLProgram(c, [{
                                    dataId: t,
                                    shape: i,
                                    dtype: s
                                }], s), h = this.read(p.dataId), this.disposeIntermediateTensorInfo(p), e.abrupt("return", h);
                            case 11:
                                if (null == a) {
                                    e.next = 13;
                                    break
                                }
                                return e.abrupt("return", this.convertAndCacheOnCPU(t));
                            case 13:
                                if (Wv().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") || 2 !== Wv().getNumber("WEBGL_VERSION")) {
                                    e.next = 15;
                                    break
                                }
                                throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
                            case 15:
                                if (f = null, "complex64" !== s && Wv().get("WEBGL_BUFFER_SUPPORTED") && (d = this.decode(t), v = this.texData.get(d.dataId), f = (m = this.gpgpu).createBufferFromTexture.apply(m, [v.texture].concat(uW(i)))), this.pendingRead.set(t, []), "complex64" === s) {
                                    e.next = 21;
                                    break
                                }
                                return e.next = 21, this.gpgpu.createAndWaitForFence();
                            case 21:
                                if ("complex64" !== s) {
                                    e.next = 30;
                                    break
                                }
                                return e.next = 24, Promise.all([this.read(u.real.dataId), this.read(u.imag.dataId)]);
                            case 24:
                                y = e.sent, b = y[0], x = y[1], g = PS(b, x), e.next = 31;
                                break;
                            case 30:
                                null == f ? g = this.getValuesFromTexture(t) : (w = ov(i), g = this.gpgpu.downloadFloat32MatrixFromBuffer(f, w));
                            case 31:
                                return null != d && this.disposeIntermediateTensorInfo(d), k = this.convertAndCacheOnCPU(t, g), N = this.pendingRead.get(t), this.pendingRead.delete(t), N.forEach(function (e) {
                                    return e(k)
                                }), this.pendingDisposal.has(t) && (this.pendingDisposal.delete(t), this.disposeData(t) && tx().removeDataId(t, this), this.pendingDeletes--), e.abrupt("return", k);
                            case 38:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), n.bufferSync = function (e) {
                var t = this.readSync(e.dataId),
                    n = t;
                if ("string" === e.dtype) try {
                    n = t.map(function (e) {
                        return fg(e)
                    })
                } catch (e) {
                    throw new Error("Failed to decode encoded string bytes into utf-8")
                }
                return qy(e.shape, e.dtype, n)
            }, n.checkNumericalProblems = function (e) {
                if (null != e)
                    for (var t = 0; t < e.length; t++) {
                        var n = e[t];
                        if (!hW(n)) {
                            if (Wv().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")) throw Error("The value " + n + " cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");
                            throw Error("The value " + n + " cannot be represented on this device.")
                        }
                    }
            }, n.getValuesFromTexture = function (e) {
                var t = this.texData.get(e),
                    n = t.shape,
                    r = t.dtype,
                    a = t.isPacked,
                    i = ov(n);
                if (Wv().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
                    var o, s = this.decode(e),
                        u = this.texData.get(s.dataId),
                        l = (o = this.gpgpu).downloadMatrixFromPackedTexture.apply(o, [u.texture].concat(uW(n))).subarray(0, i);
                    return this.disposeIntermediateTensorInfo(s), l
                }
                var c = Wv().getBool("WEBGL_PACK") && !0 === a,
                    p = c ? TW(n) : n,
                    h = c ? new VW(p) : new WW(p),
                    f = this.runWebGLProgram(h, [{
                        shape: p,
                        dtype: r,
                        dataId: e
                    }], "float32"),
                    d = this.texData.get(f.dataId),
                    m = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture, d.texShape[0], d.texShape[1]).subarray(0, i);
                return this.disposeIntermediateTensorInfo(f), m
            }, n.timerAvailable = function () {
                return Wv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0
            }, n.time = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    var n, r, a, i, o, s, u;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (n = this.activeTimers, r = [], a = !1, null == this.programTimersStack ? (this.programTimersStack = r, a = !0) : this.activeTimers.push(r), this.activeTimers = r, t(), i = iv(this.activeTimers.map(function (e) {
                                        return e.query
                                    })).filter(function (e) {
                                        return null != e
                                    }), o = iv(this.activeTimers.map(function (e) {
                                        return e.name
                                    })).filter(function (e) {
                                        return null != e
                                    }), this.activeTimers = n, a && (this.programTimersStack = null), s = {
                                        uploadWaitMs: this.uploadWaitMs,
                                        downloadWaitMs: this.downloadWaitMs,
                                        kernelMs: null,
                                        wallMs: null
                                    }, !(Wv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0)) {
                                    e.next = 19;
                                    break
                                }
                                return e.next = 14, Promise.all(i);
                            case 14:
                                u = e.sent, s.kernelMs = tv(u), s.getExtraProfileInfo = function () {
                                    return u.map(function (e, t) {
                                        return {
                                            name: o[t],
                                            ms: e
                                        }
                                    }).map(function (e) {
                                        return e.name + ": " + e.ms
                                    }).join(", ")
                                }, e.next = 20;
                                break;
                            case 19:
                                s.kernelMs = {
                                    error: "WebGL query timers are not supported in this environment."
                                };
                            case 20:
                                return this.uploadWaitMs = 0, this.downloadWaitMs = 0, e.abrupt("return", s);
                            case 23:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), n.memory = function () {
                return {
                    unreliable: !1,
                    numBytesInGPU: this.numBytesInGPU,
                    numBytesInGPUAllocated: this.textureManager.numBytesAllocated,
                    numBytesInGPUFree: this.textureManager.numBytesFree
                }
            }, n.startTimer = function () {
                return Wv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? this.gpgpu.beginQuery() : {
                    startMs: cg(),
                    endMs: null
                }
            }, n.endTimer = function (e) {
                return Wv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? (this.gpgpu.endQuery(), e) : (e.endMs = cg(), e)
            }, n.getQueryTime = function () {
                var e = Pm(regeneratorRuntime.mark(function e(t) {
                    var n;
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (!(Wv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0)) {
                                    e.next = 2;
                                    break
                                }
                                return e.abrupt("return", this.gpgpu.waitForQueryAndGetTime(t));
                            case 2:
                                return n = t, e.abrupt("return", n.endMs - n.startMs);
                            case 4:
                            case "end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }(), n.disposeData = function (e, t) {
                if (void 0 === t && (t = !1), this.pendingDisposal.has(e)) return !1;
                if (!this.texData.has(e)) return !0;
                if (t ? this.texData.get(e).refCount = 0 : this.texData.get(e).refCount--, !t && this.texData.get(e).refCount > 0) return !1;
                if (this.pendingRead.has(e)) return this.pendingDisposal.add(e), this.pendingDeletes++, !1;
                this.releaseGPUData(e);
                var n = this.texData.get(e).complexTensorInfos;
                return null != n && (this.disposeData(n.real.dataId, t), this.disposeData(n.imag.dataId, t)), this.texData.delete(e), !0
            }, n.releaseGPUData = function (e) {
                var t = this.texData.get(e),
                    n = t.texture,
                    r = t.dtype,
                    a = t.texShape,
                    i = t.usage,
                    o = t.isPacked,
                    s = t.slice,
                    u = s && s.origDataId || e,
                    l = this.dataRefCount.get(u);
                l > 1 ? this.dataRefCount.set(u, l - 1) : (this.dataRefCount.delete(u), null != n && (this.numBytesInGPU -= this.computeBytes(a, r), this.textureManager.releaseTexture(n, a, i, o)));
                var c = this.texData.get(e);
                c.texture = null, c.texShape = null, c.isPacked = !1, c.slice = null
            }, n.getTexture = function (e) {
                return this.uploadToGPU(e), this.texData.get(e).texture
            }, n.getDataInfo = function (e) {
                return this.texData.get(e)
            }, n.getCPUBackend = function () {
                return Wv().getBool("WEBGL_CPU_FORWARD") ? (null == this.cpuBackend && (this.cpuBackend = tx().findBackend("cpu")), this.cpuBackend) : null
            }, n.shouldExecuteOnCPU = function (e, t) {
                var n = this;
                void 0 === t && (t = 128);
                var r = this.getCPUBackend();
                return Wv().getBool("IS_TEST") || this.warnedAboutCPUBackend || null != r || (console.warn("Your application contains ops that are small enough to be executed on the CPU backend, however the CPU backend cannot be found. Consider importing the CPU backend (@tensorflow/tfjs-backend-cpu) for better performance."), this.warnedAboutCPUBackend = !0), null != r && e.every(function (e) {
                    return null == n.texData.get(e.dataId).texture && ov(e.shape) < t
                })
            }, n.getGPGPUContext = function () {
                return this.gpgpu
            }, n.where = function (e) {
                zS("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
                var t = e.dataSync();
                return ZV(e.shape, t)
            }, n.packedUnaryOp = function (e, t, n) {
                var r = new YV(e.shape, t),
                    a = this.compileAndRun(r, [e], n);
                return tx().makeTensorFromDataId(a.dataId, a.shape, a.dtype)
            }, n.abs = function (e) {
                if (this.shouldExecuteOnCPU([e]) && "complex64" !== e.dtype) {
                    var t = AV(this.texData.get(e.dataId).values);
                    return this.makeOutput(e.shape, e.dtype, t)
                }
                if (Wv().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(e, KV, e.dtype);
                var n = new qV(e.shape, KV),
                    r = this.compileAndRun(n, [e]);
                return tx().makeTensorFromDataId(r.dataId, r.shape, r.dtype)
            }, n.makeTensorInfo = function (e, t, n) {
                var r;
                if ("string" === t && null != n && n.length > 0 && Nv(n[0])) {
                    var a = n.map(function (e) {
                        return hg(e)
                    });
                    r = this.write(a, e, t)
                } else r = this.write(n, e, t);
                return this.texData.get(r).usage = null, {
                    dataId: r,
                    shape: e,
                    dtype: t
                }
            }, n.makeOutput = function (e, t, n) {
                var r = this.makeTensorInfo(e, t, n).dataId;
                return tx().makeTensorFromDataId(r, e, t, this)
            }, n.unpackTensor = function (e) {
                var t = new JV(e.shape);
                return this.runWebGLProgram(t, [e], e.dtype)
            }, n.packTensor = function (e) {
                var t = new WV(e.shape);
                return this.runWebGLProgram(t, [e], e.dtype, null, !0)
            }, n.packedReshape = function (e, t) {
                var n = [IW(e.shape)].concat(SW(e.shape)),
                    r = {
                        dtype: e.dtype,
                        shape: n,
                        dataId: e.dataId
                    },
                    a = [IW(t)].concat(SW(t)),
                    i = new VV(a, n),
                    o = this.runWebGLProgram(i, [r], e.dtype, null, !0);
                return {
                    dataId: o.dataId,
                    shape: t,
                    dtype: o.dtype
                }
            }, n.decode = function (e) {
                var t, n = this.texData.get(e),
                    r = n.isPacked,
                    a = n.shape,
                    i = n.dtype,
                    o = TW(a);
                return t = r ? new BW(o) : new PW(o), {
                    dtype: i,
                    shape: a,
                    dataId: this.runWebGLProgram(t, [{
                        shape: o,
                        dtype: i,
                        dataId: e
                    }], i, null, !0).dataId
                }
            }, n.runWebGLProgram = function (e, t, n, r, a) {
                var i = this;
                void 0 === a && (a = !1);
                var o = this.makeTensorInfo(e.outputShape, n),
                    s = this.texData.get(o.dataId);
                if (e.packedOutput && (s.isPacked = !0), e.outPackingScheme === tW.DENSE) {
                    var u = uW(e.outputShape);
                    s.texShape = u.map(function (e) {
                        return 2 * e
                    })
                }
                if (null != e.outTexUsage && (s.usage = e.outTexUsage), 0 === ov(o.shape)) return s.values = mv(o.dtype, 0), o;
                var l = [],
                    c = t.map(function (t) {
                        if ("complex64" === t.dtype) throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
                        var n = i.texData.get(t.dataId);
                        if (null == n.texture) {
                            if (!e.packedInputs && ov(t.shape) <= Wv().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) return {
                                shape: t.shape,
                                texData: null,
                                isUniform: !0,
                                uniformValues: n.values
                            };
                            e.packedInputs && (n.isPacked = !0, n.shape = t.shape)
                        } else if (!!n.isPacked != !!e.packedInputs) t = n.isPacked ? i.unpackTensor(t) : i.packTensor(t), l.push(t), n = i.texData.get(t.dataId);
                        else if (n.isPacked && !EW(n.shape, t.shape)) {
                            var r = t,
                                a = t.shape;
                            t.shape = n.shape, t = i.packedReshape(t, a), l.push(t), n = i.texData.get(t.dataId), r.shape = a
                        }
                        return i.uploadToGPU(t.dataId), {
                            shape: t.shape,
                            texData: n,
                            isUniform: !1
                        }
                    });
                this.uploadToGPU(o.dataId);
                var p, h = {
                        shape: o.shape,
                        texData: s,
                        isUniform: !1
                    },
                    f = function (e, t, n) {
                        var r = "";
                        c.concat(n).forEach(function (e) {
                            var t = null != e.texData && null != e.texData.slice && e.texData.slice.flatOffset > 0,
                                n = e.isUniform ? "uniform" : e.texData.texShape;
                            r += e.shape + "_" + n + "_" + t
                        });
                        var a = e.userCode;
                        return e.constructor.name + "_" + r + "_" + a
                    }(e, 0, h),
                    d = this.getAndSaveBinary(f, function () {
                        return function (e, t, n, r) {
                            var a = t.userCode,
                                i = n.map(function (e, n) {
                                    var r = {
                                        logicalShape: e.shape,
                                        texShape: e.isUniform ? null : e.texData.texShape,
                                        isUniform: e.isUniform,
                                        isPacked: !e.isUniform && e.texData.isPacked,
                                        flatOffset: null
                                    };
                                    return null != e.texData && null != e.texData.slice && e.texData.slice.flatOffset > 0 && (r.flatOffset = e.texData.slice.flatOffset), {
                                        name: t.variableNames[n],
                                        shapeInfo: r
                                    }
                                }),
                                o = i.map(function (e) {
                                    return e.shapeInfo
                                }),
                                s = {
                                    logicalShape: r.shape,
                                    texShape: r.texData.texShape,
                                    isUniform: !1,
                                    isPacked: r.texData.isPacked,
                                    flatOffset: null
                                },
                                u = QW(i, s, a, t.packedInputs),
                                l = e.createProgram(u),
                                c = null,
                                p = e.getUniformLocation(l, "NAN", !1);
                            1 === Wv().getNumber("WEBGL_VERSION") && (c = e.getUniformLocation(l, "INFINITY", !1));
                            for (var h = {}, f = 0; f < t.variableNames.length; f++) {
                                var d = t.variableNames[f];
                                h[d] = e.getUniformLocation(l, d, !1), h["offset" + d] = e.getUniformLocation(l, "offset" + d, !1)
                            }
                            return {
                                program: t,
                                source: u,
                                webGLProgram: l,
                                uniformLocations: h,
                                inShapeInfos: o,
                                outShapeInfo: s,
                                infLoc: c,
                                nanLoc: p
                            }
                        }(i.gpgpu, e, c, h)
                    }),
                    m = null != this.activeTimers;
                m && (p = this.startTimer()),
                    function (e, t, n, r, a) {
                        uV(t.inShapeInfos, n), uV([t.outShapeInfo], [r]);
                        var i = r.texData.texture,
                            o = r.texData.texShape;
                        r.texData.isPacked ? e.setOutputPackedMatrixTexture(i, o[0], o[1]) : e.setOutputMatrixTexture(i, o[0], o[1]), e.setProgram(t.webGLProgram), 1 === Wv().getNumber("WEBGL_VERSION") && null !== t.infLoc && e.gl.uniform1f(t.infLoc, 1 / 0), null !== t.nanLoc && e.gl.uniform1f(t.nanLoc, NaN), n.forEach(function (n, r) {
                            var a = t.program.variableNames[r],
                                i = t.uniformLocations[a],
                                o = t.uniformLocations["offset" + a];
                            if (null != i)
                                if (n.isUniform)
                                    if (ov(n.shape) < 2) e.gl.uniform1f(i, n.uniformValues[0]);
                                    else {
                                        var s = n.uniformValues;
                                        s instanceof Float32Array || (s = new Float32Array(s)), e.gl.uniform1fv(i, s)
                                    }
                            else null != n.texData.slice && null != o && e.gl.uniform1i(o, n.texData.slice.flatOffset), e.setInputMatrixTexture(n.texData.texture, i, r)
                        }), null != a && a(e, t.webGLProgram), e.executeProgram()
                    }(this.gpgpu, d, c, h, r), l.forEach(function (e) {
                        return i.disposeIntermediateTensorInfo(e)
                    }), m && (p = this.endTimer(p), this.activeTimers.push({
                        name: e.constructor.name,
                        query: this.getQueryTime(p)
                    }));
                var v = Wv().get("WEBGL_FLUSH_THRESHOLD");
                if (v > 0) {
                    var g = cg();
                    g - this.lastGlFlushTime > v && (this.gpgpu.gl.flush(), this.lastGlFlushTime = g)
                }
                if (!Wv().getBool("WEBGL_LAZILY_UNPACK") && s.isPacked && !1 === a) {
                    var y = this.unpackTensor(o);
                    return this.disposeIntermediateTensorInfo(o), y
                }
                return o
            }, n.compileAndRun = function (e, t, n, r, a) {
                return void 0 === a && (a = !1), n = n || t[0].dtype, this.runWebGLProgram(e, t, n, r, a)
            }, n.getAndSaveBinary = function (e, t) {
                return e in this.binaryCache || (this.binaryCache[e] = t()), this.binaryCache[e]
            }, n.getTextureManager = function () {
                return this.textureManager
            }, n.dispose = function () {
                var e = this;
                this.disposed || (Wv().getBool("IS_TEST") || Object.keys(this.binaryCache).forEach(function (t) {
                    e.gpgpu.deleteProgram(e.binaryCache[t].webGLProgram), delete e.binaryCache[t]
                }), this.textureManager.dispose(), null != this.canvas && "undefined" != typeof HTMLCanvasElement && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = !0)
            }, n.floatPrecision = function () {
                var e = this;
                return null == this.floatPrecisionValue && (this.floatPrecisionValue = rx(function () {
                    if (!Wv().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
                        var t = Wv().getBool("DEBUG");
                        Wv().set("DEBUG", !1);
                        var n = e.abs(wN(1e-8)).dataSync()[0];
                        if (Wv().set("DEBUG", t), n > 0) return 32
                    }
                    return 16
                })), this.floatPrecisionValue
            }, n.epsilon = function () {
                return 32 === this.floatPrecision() ? 1e-7 : 1e-4
            }, n.uploadToGPU = function (e) {
                var t = this.texData.get(e),
                    n = t.shape,
                    r = t.dtype,
                    a = t.values,
                    i = t.texture,
                    o = t.usage,
                    s = t.isPacked;
                if (null == i) {
                    var u, l = null != this.activeTimers;
                    l && (u = cg());
                    var c = t.texShape;
                    if (null == c && (c = function (e, t) {
                            void 0 === t && (t = !1);
                            var n = Wv().getNumber("WEBGL_MAX_TEXTURE_SIZE");
                            if (t && (n *= 2, 1 === (e = e.map(function (t, n) {
                                    return n >= e.length - 2 ? ev(e[n]) : e[n]
                                })).length && (e = [2, e[0]])), 2 !== e.length) {
                                var r = dv(e);
                                e = r.newShape
                            }
                            var a = ov(e);
                            if (e.length <= 1 && a <= n) return [1, a];
                            if (2 === e.length && e[0] <= n && e[1] <= n) return e;
                            if (3 === e.length && e[0] * e[1] <= n && e[2] <= n) return [e[0] * e[1], e[2]];
                            if (3 === e.length && e[0] <= n && e[1] * e[2] <= n) return [e[0], e[1] * e[2]];
                            if (4 === e.length && e[0] * e[1] * e[2] <= n && e[3] <= n) return [e[0] * e[1] * e[2], e[3]];
                            if (4 === e.length && e[0] <= n && e[1] * e[2] * e[3] <= n) return [e[0], e[1] * e[2] * e[3]];
                            if (t) {
                                var i = IW(e),
                                    o = 2,
                                    s = 2;
                                if (e.length) {
                                    var u = SW(e);
                                    o = u[0], s = u[1]
                                }
                                return lv(a = i * (o / 2) * (s / 2)).map(function (e) {
                                    return 2 * e
                                })
                            }
                            return lv(a)
                        }(n, s), t.texShape = c), null != a) {
                        var p, h = TW(n),
                            f = c[1],
                            d = c[0],
                            m = a instanceof Uint8Array;
                        if (s) {
                            var v = lW(c[0], c[1]);
                            f = v[0], d = v[1], p = new GW(h, [d, f], m)
                        } else p = new UW(h, [d, f], m);
                        var g = this.makeTensorInfo([d, f], r);
                        this.texData.get(g.dataId).usage = m ? nW.PIXELS : nW.UPLOAD, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(g.dataId), f, d, a);
                        var y = this.runWebGLProgram(p, [g], r, null, !0),
                            b = this.texData.get(y.dataId);
                        t.texture = b.texture, t.texShape = b.texShape, t.isPacked = b.isPacked, t.usage = b.usage, this.disposeIntermediateTensorInfo(g), this.texData.delete(y.dataId), t.values = null, l && (this.uploadWaitMs += cg() - u)
                    } else {
                        var x = this.acquireTexture(c, o, r, s);
                        t.texture = x
                    }
                }
            }, n.convertAndCacheOnCPU = function (e, t) {
                var n = this.texData.get(e),
                    r = n.dtype;
                return this.releaseGPUData(e), null != t && (n.values = function (e, t) {
                    if ("float32" === t || "complex64" === t) return e;
                    if ("int32" === t || "bool" === t) {
                        for (var n = "int32" === t ? new Int32Array(e.length) : new Uint8Array(e.length), r = 0; r < n.length; ++r) n[r] = Math.round(e[r]);
                        return n
                    }
                    throw new Error("Unknown dtype " + t)
                }(t, r)), n.values
            }, n.acquireTexture = function (e, t, n, r) {
                if (this.numBytesInGPU += this.computeBytes(e, n), !this.warnedAboutMemory && this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024) {
                    var a = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
                    this.warnedAboutMemory = !0, console.warn("High memory usage in GPU: " + a + " MB, most likely due to a memory leak")
                }
                return this.textureManager.acquireTexture(e, t, r)
            }, n.computeBytes = function (e, t) {
                return e[0] * e[1] * wv(t)
            }, t
        }(Jm);
    $V.nextDataId = 0, qg() && ox("webgl", function () {
        return new $V
    }, 2);
    var eU = function (e, t, n) {
            this.variableNames = ["A", "B"], this.outputShape = kw(t, n), this.userCode = "\n      float binaryOperation(float a, float b) {\n        " + e + "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    "
        },
        tU = function (e, t, n, r) {
            void 0 === r && (r = !1), this.variableNames = ["A", "B"], this.supportsBroadcasting = !0, this.packedInputs = !0, this.packedOutput = !0, this.outputShape = kw(t, n);
            var a = this.outputShape.length,
                i = "";
            if (r)
                if (0 === a || 1 === ov(this.outputShape)) i = "\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";
                else if (i = "\n          " + iV(a) + " coords = getOutputCoords();\n        ", 1 === a) i += "\n            result.y = (coords + 1) >= " + this.outputShape[0] + " ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ";
            else {
                var o = BV("coords", a);
                i += "\n            bool nextRowOutOfBounds =\n              (" + o[a - 2] + " + 1) >= " + this.outputShape[a - 2] + ";\n            bool nextColOutOfBounds =\n              (" + o[a - 1] + " + 1) >= " + this.outputShape[a - 1] + ";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "
            }
            this.userCode = "\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        " + e + "\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        " + i + "\n\n        setOutput(result);\n      }\n    "
        };

    function nU(e) {
        var t = e.inputs,
            n = e.backend,
            r = t.x;
        return n.incRef(r.dataId), {
            dataId: r.dataId,
            shape: r.shape,
            dtype: r.dtype
        }
    }
    var rU = {
        kernelName: "Identity",
        backendName: "webgl",
        kernelFunc: nU
    };

    function aU(e) {
        var t = e.inputs,
            n = e.backend,
            r = t.real,
            a = t.imag,
            i = n.makeTensorInfo(r.shape, "complex64"),
            o = n.texData.get(i.dataId),
            s = nU({
                inputs: {
                    x: r
                },
                backend: n
            }),
            u = nU({
                inputs: {
                    x: a
                },
                backend: n
            });
        return o.complexTensorInfos = {
            real: s,
            imag: u
        }, i
    }
    var iU = {
            kernelName: "Complex",
            backendName: "webgl",
            kernelFunc: aU
        },
        oU = "return (a < 0.) ? b * a : a;",
        sU = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",
        uU = {
            kernelName: "LeakyRelu",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.alpha,
                    o = n.makeTensorInfo([], "float32", ug(i, "float32")),
                    s = Wv().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new tU(sU, a.shape, o.shape) : new eU(oU, a.shape, o.shape),
                    u = n.runWebGLProgram(s, [a, o], a.dtype);
                return n.disposeIntermediateTensorInfo(o), u
            }
        },
        lU = "return (a < 0.) ? b * a : a;",
        cU = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",
        pU = {
            kernelName: "Prelu",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = t.x,
                    a = t.alpha,
                    i = Wv().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new tU(cU, r.shape, a.shape) : new eU(lU, r.shape, a.shape);
                return n.runWebGLProgram(i, [r, a], r.dtype)
            }
        };

    function hU(e) {
        var t = e.opSnippet,
            n = e.packedOpSnippet,
            r = e.cpuKernelImpl,
            a = e.dtype;
        return function (e) {
            var i, o = e.inputs,
                s = e.backend,
                u = o.x,
                l = s,
                c = a || u.dtype;
            if (l.shouldExecuteOnCPU([u]) && null != r) {
                var p = l.texData.get(u.dataId),
                    h = r(p.values, c);
                return l.makeTensorInfo(u.shape, c, h)
            }
            return i = Wv().getBool("WEBGL_PACK_UNARY_OPERATIONS") && null != n ? new YV(u.shape, n) : new qV(u.shape, t), l.runWebGLProgram(i, [u], c)
        }
    }

    function fU(e) {
        var t = e.opSnippet,
            n = e.packedOpSnippet,
            r = e.checkOutOfBounds,
            a = void 0 !== r && r,
            i = e.supportsComplex,
            o = void 0 !== i && i,
            s = e.cpuKernelImpl,
            u = e.dtype;
        return function (e) {
            var r = e.inputs,
                i = e.backend,
                l = r.a,
                c = r.b,
                p = i;
            if (o && "complex64" === l.dtype) {
                var h = p.texData.get(l.dataId),
                    f = p.texData.get(c.dataId),
                    d = [
                        [h.complexTensorInfos.real, f.complexTensorInfos.real],
                        [h.complexTensorInfos.imag, f.complexTensorInfos.imag]
                    ].map(function (e) {
                        var n = e[0],
                            r = e[1],
                            a = {
                                dataId: n.dataId,
                                dtype: n.dtype,
                                shape: l.shape
                            },
                            i = {
                                dataId: r.dataId,
                                dtype: r.dtype,
                                shape: c.shape
                            },
                            o = new eU(t, l.shape, c.shape);
                        return p.runWebGLProgram(o, [a, i], _g(n.dtype, r.dtype))
                    }),
                    m = d[0],
                    v = d[1],
                    g = aU({
                        inputs: {
                            real: m,
                            imag: v
                        },
                        backend: p
                    });
                return p.disposeIntermediateTensorInfo(m), p.disposeIntermediateTensorInfo(v), g
            }
            var y, b = u || _g(l.dtype, c.dtype);
            if (p.shouldExecuteOnCPU([l, c]) && null != s) {
                var x = p.texData.get(l.dataId),
                    w = p.texData.get(c.dataId),
                    k = s(l.shape, c.shape, x.values, w.values, b),
                    N = k[0],
                    I = k[1],
                    S = p.makeTensorInfo(I, b);
                return p.texData.get(S.dataId).values = N, S
            }
            return y = Wv().getBool("WEBGL_PACK_BINARY_OPERATIONS") && null != n ? new tU(n, l.shape, c.shape, a) : new eU(t, l.shape, c.shape), p.runWebGLProgram(y, [l, c], b)
        }
    }

    function dU(e, t) {
        if (void 0 === t && (t = !1), "linear" === e) return "return x;";
        if ("relu" === e) return t ? "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n" : "if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";
        if ("elu" === e) return t ? "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n" : "return (x >= 0.0) ? x : (exp(x) - 1.0);";
        if ("relu6" === e) return t ? "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n" : "if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";
        if ("prelu" === e) return t ? cU : lU;
        if ("leakyrelu" === e) return t ? sU : oU;
        throw new Error("Activation " + e + " has not been implemented for the WebGL backend.")
    }
    var mU = function (e, t, n, r, a, i, o, s, u) {
            void 0 === r && (r = !1), void 0 === a && (a = !1), void 0 === i && (i = !1), void 0 === o && (o = null), void 0 === s && (s = !1), void 0 === u && (u = !1), this.variableNames = ["matrixA", "matrixB"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = n;
            var l = r ? e[1] : e[2],
                c = Math.ceil(l / 2),
                p = r ? "i * 2, rc.y" : "rc.y, i * 2",
                h = a ? "rc.z, i * 2" : "i * 2, rc.z",
                f = r ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"],
                d = a ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"],
                m = "",
                v = "";
            o && (m = s ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " + o + "\n        }" : u ? "vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          " + o + "\n        }" : "vec4 activation(vec4 x) {\n          " + o + "\n        }", v = "result = activation(result);");
            var g = i ? "result += getBiasAtOutCoords();" : "";
            i && this.variableNames.push("bias"), s && this.variableNames.push("preluActivationWeights"), u && this.variableNames.push("leakyreluAlpha");
            var y = "rc.x",
                b = "rc.x";
            e[0] < t[0] ? y = "int(min(float(rc.x), " + (e[0] - 1) + ".))" : t[0] < e[0] && (b = "int(min(float(rc.x), " + (t[0] - 1) + ".))"), this.userCode = "\n      " + m + "\n\n      const float sharedDimension = " + c + ".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < " + c + "; i++) {\n          int batchA = " + y + ";\n          int batchB = " + b + ";\n          vec4 a = getMatrixA(batchA, " + p + ");\n          vec4 b = getMatrixB(batchB, " + h + ");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (" + f[0] + " * " + d[0] + ");\n          result += (" + f[1] + " * " + d[1] + ");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        " + g + "\n\n        " + v + "\n\n        setOutput(result);\n      }\n    "
        },
        vU = "return areal * breal - aimag * bimag;",
        gU = "return areal * bimag + aimag * breal;",
        yU = function (e, t, n) {
            this.variableNames = ["AReal", "AImag", "BReal", "BImag"], this.outputShape = kw(t, n), this.userCode = "\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        " + e + "\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    "
        },
        bU = "return a * b;";

    function xU(e) {
        var t, n = e.inputs,
            r = e.backend,
            a = n.a,
            i = n.b,
            o = _g(a.dtype, i.dtype);
        if ("complex64" === a.dtype) {
            var s = r.texData.get(a.dataId),
                u = r.texData.get(i.dataId),
                l = new yU(vU, a.shape, i.shape),
                c = new yU(gU, a.shape, i.shape),
                p = [{
                    dataId: s.complexTensorInfos.real.dataId,
                    dtype: s.complexTensorInfos.real.dtype,
                    shape: a.shape
                }, {
                    dataId: s.complexTensorInfos.imag.dataId,
                    dtype: s.complexTensorInfos.imag.dtype,
                    shape: a.shape
                }, {
                    dataId: u.complexTensorInfos.real.dataId,
                    dtype: u.complexTensorInfos.real.dtype,
                    shape: i.shape
                }, {
                    dataId: u.complexTensorInfos.imag.dataId,
                    dtype: u.complexTensorInfos.imag.dtype,
                    shape: i.shape
                }],
                h = r.runWebGLProgram(l, p, "float32"),
                f = r.runWebGLProgram(c, p, "float32"),
                d = aU({
                    inputs: {
                        real: h,
                        imag: f
                    },
                    backend: r
                });
            return r.disposeIntermediateTensorInfo(h), r.disposeIntermediateTensorInfo(f), d
        }
        if (r.shouldExecuteOnCPU([a, i])) {
            var m = r.texData.get(a.dataId),
                v = r.texData.get(i.dataId),
                g = SV(a.shape, i.shape, m.values, v.values, o),
                y = g[0],
                b = g[1],
                x = r.makeTensorInfo(b, o);
            return r.texData.get(x.dataId).values = y, x
        }
        return t = Wv().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new tU(bU, a.shape, i.shape) : new eU(bU, a.shape, i.shape), r.runWebGLProgram(t, [a, i], o)
    }
    var wU = {
        kernelName: "Multiply",
        backendName: "webgl",
        kernelFunc: xU
    };

    function kU(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.x,
            i = r.shape,
            o = n,
            s = ov(a.shape),
            u = hv(i, s),
            l = ov(u);
        nv(s === l, function () {
            return "The new shape (" + u + ") has " + l + " elements and the old shape (" + a.shape + ") has " + s + " elements. The new shape and old shape must have the same number of elements."
        });
        var c = o.texData.get(a.dataId);
        return !c.isPacked || EW(a.shape, u) || null !== c.texture && EW(c.shape, u) ? (o.incRef(a.dataId), {
            dataId: a.dataId,
            shape: u,
            dtype: a.dtype
        }) : function (e, t, n) {
            var r = [IW(e.shape)].concat(SW(e.shape)),
                a = {
                    dtype: e.dtype,
                    shape: r,
                    dataId: e.dataId
                },
                i = [IW(t)].concat(SW(t)),
                o = new VV(i, r),
                s = n.runWebGLProgram(o, [a], e.dtype, null, !0);
            return {
                dataId: s.dataId,
                shape: t,
                dtype: s.dtype
            }
        }(a, u, o)
    }
    var NU = {
            kernelName: "Reshape",
            backendName: "webgl",
            kernelFunc: kU
        },
        IU = function (e, t) {
            this.variableNames = ["x"];
            var n = e.windowSize,
                r = e.batchSize,
                a = e.inSize,
                i = e.outSize;
            this.outputShape = [r, i];
            var o = 4 * Math.floor(n / 4),
                s = n % 4,
                u = "sumValue += dot(values, ones);";
            if (null != t) {
                var l = 1 / t;
                u = "sumValue += dot(values * " + (uv(l) ? l.toPrecision(2) : l) + ", ones);"
            }
            var c = "";
            a % n > 0 && (c = "\n        if (inIdx < 0 || inIdx >= " + a + ") {\n          return 0.0;\n        }\n      "), this.userCode = "\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        " + c + "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + n + ";\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < " + o + "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          " + u + "\n        }\n\n        int inIdx = inOffset + " + o + ";\n        if (" + (1 === s) + ") {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          " + u + "\n        } else if (" + (2 === s) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          " + u + "\n        } else if (" + (3 === s) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          " + u + "\n        }\n        setOutput(sumValue);\n      }\n    "
        },
        SU = function (e, t) {
            this.variableNames = ["x"];
            var n = e.windowSize,
                r = e.batchSize,
                a = e.inSize,
                i = e.outSize;
            this.outputShape = [r, i];
            var o = "0.0",
                s = "";
            "prod" === t ? o = "1.0" : "min" === t ? (o = "1.0 / 1e-20", s = "min") : "max" === t && (o = "-1.0 / 1e-20", s = "max");
            var u = t + "(" + t + "(" + t + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
            "sum" === t ? u = "sumValue" : "prod" === t ? u = "prodValue" : "all" === t ? u = "allValue" : "any" === t && (u = "anyValue");
            var l = 4 * Math.floor(n / 4),
                c = n % 4,
                p = "\n      if (" + ("sum" === t) + ") {\n        sumValue += dot(values, ones);\n      } else if (" + ("prod" === t) + ") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = " + s + "(values, minMaxValue);\n      }\n    ",
                h = "vec4";
            "all" === t ? (o = "1.0", p = "\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ", h = "bvec4") : "any" === t && (o = "0.0", p = "\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ", h = "bvec4");
            var f = "";
            a % n > 0 && (f = "\n        if (inIdx < 0 || inIdx >= " + a + ") {\n          return initializationValue;\n        }\n      "), this.userCode = "\n      const float initializationValue = " + o + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        " + f + "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + n + ";\n\n        vec4 minMaxValue = vec4(" + o + ");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < " + l + "; i += 4) {\n          int inIdx = inOffset + i;\n          " + h + " values = " + h + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          " + p + "\n        }\n\n        int inIdx = inOffset + " + l + ";\n        if (" + (1 === c) + ") {\n          " + h + " values = " + h + "(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          " + p + "\n        } else if (" + (2 === c) + ") {\n          " + h + " values = " + h + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          " + p + "\n        } else if (" + (3 === c) + ") {\n          " + h + " values = " + h + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          " + p + "\n        }\n        setOutput(" + u + ");\n      }\n    "
        };

    function TU(e, t, n, r) {
        for (var a = function (e) {
                for (var t = []; 0 === t.length || 1 !== t[t.length - 1].outSize;) {
                    var n = t.length ? t[t.length - 1].outSize : e[1],
                        r = RS(n);
                    t.push({
                        inSize: n,
                        windowSize: r,
                        outSize: Math.ceil(n / r)
                    })
                }
                return t
            }(e.shape), i = e, o = 0; o < a.length; o++) {
            var s, u, l = a[o],
                c = l.inSize,
                p = l.windowSize,
                h = l.outSize;
            u = "mean" === n ? 0 === o ? new IU({
                windowSize: p,
                inSize: c,
                batchSize: e.shape[0],
                outSize: h
            }, c) : new IU({
                windowSize: p,
                inSize: c,
                batchSize: e.shape[0],
                outSize: h
            }) : new SU({
                windowSize: p,
                inSize: c,
                batchSize: e.shape[0],
                outSize: h
            }, n), s = i, i = r.runWebGLProgram(u, [i], t), s.dataId !== e.dataId && r.disposeIntermediateTensorInfo(s)
        }
        return i
    }
    var CU = function (e, t) {
            this.variableNames = ["A"];
            for (var n = new Array(e.length), r = 0; r < n.length; r++) n[r] = e[t[r]];
            this.outputShape = n, this.rank = n.length;
            var a = iV(this.rank),
                i = function (e) {
                    var t = e.length;
                    if (t > 6) throw Error("Transpose for rank " + t + " is not yet supported");
                    for (var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"], r = new Array(t), a = 0; a < e.length; a++) r[e[a]] = n[a];
                    return r.join()
                }(t);
            this.userCode = "\n    void main() {\n      " + a + " resRC = getOutputCoords();\n      setOutput(getA(" + i + "));\n    }\n    "
        },
        EU = function (e, t) {
            this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0;
            for (var n = new Array(e.length), r = 0; r < n.length; r++) n[r] = e[t[r]];
            if (this.outputShape = n, this.rank = n.length, this.rank > 6) throw Error("Packed transpose for rank " + this.rank + " is not yet supported.");
            for (var a = iV(this.rank), i = PV("rc", this.rank), o = new Array(this.rank), s = 0; s < t.length; s++) o[t[s]] = i[s];
            var u = "vec2(" + o.slice(-2).join() + ")",
                l = "++" + i[this.rank - 1] + " < " + n[this.rank - 1],
                c = "getChannel(getA(" + o.join() + "), " + u + ")";
            this.userCode = "\n    void main() {\n      " + a + " rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = " + c + ";\n      if(" + l + ") {\n        result[1] = " + c + ";\n      }\n      --" + i[this.rank - 1] + ";\n      if(++" + i[this.rank - 2] + " < " + n[this.rank - 2] + ") {\n        result[2] = " + c + ";\n        if(" + l + ") {\n          result[3] = " + c + ";\n        }\n      }\n      setOutput(result);\n    }\n    "
        };

    function RU(e, t, n) {
        var r = Wv().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new EU(e.shape, t) : new CU(e.shape, t);
        return n.runWebGLProgram(r, [e], e.dtype)
    }

    function AU(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs;
        return function (e, t, n, r) {
            var a = t,
                i = e.shape.length,
                o = fv(a, e.shape),
                s = o,
                u = hk(s, i),
                l = null != u,
                c = e;
            l && (c = RU(e, u, r), s = dk(s.length, i)), pk("sum", s, i);
            var p = lk(c.shape, s),
                h = p[0],
                f = p[1],
                d = h;
            n && (d = ck(h, o));
            var m = ov(f),
                v = kU({
                    inputs: {
                        x: c
                    },
                    attrs: {
                        shape: [ov(e.shape) / m, m]
                    },
                    backend: r
                }),
                g = TU(v, Dg(e.dtype), "sum", r),
                y = kU({
                    inputs: {
                        x: g
                    },
                    attrs: {
                        shape: d
                    },
                    backend: r
                });
            return r.disposeIntermediateTensorInfo(v), r.disposeIntermediateTensorInfo(g), l && r.disposeIntermediateTensorInfo(c), y
        }(t.x, r.axis, r.keepDims, n)
    }
    var FU = {
        kernelName: "Sum",
        backendName: "webgl",
        kernelFunc: AU
    };

    function _U(e) {
        for (var t, n = e.inputs, r = e.backend, a = e.attrs, i = n.x, o = a.perm, s = r, u = i.shape.length, l = new Array(u), c = 0; c < l.length; c++) l[c] = i.shape[o[c]];
        if (s.shouldExecuteOnCPU([i])) {
            var p = s.texData.get(i.dataId).values,
                h = LV(p, i.shape, i.dtype, o, l);
            t = s.makeTensorInfo(l, i.dtype), s.texData.get(t.dataId).values = h
        } else t = RU(i, o, s);
        return t
    }
    var DU = {
        kernelName: "Transpose",
        backendName: "webgl",
        kernelFunc: _U
    };

    function OU(e) {
        var t = e.a,
            n = e.b,
            r = e.transposeA,
            a = e.transposeB,
            i = e.backend,
            o = e.bias,
            s = void 0 === o ? null : o,
            u = e.preluActivationWeights,
            l = void 0 === u ? null : u,
            c = e.leakyreluAlpha,
            p = void 0 === c ? 0 : c,
            h = e.activation,
            f = void 0 === h ? null : h,
            d = t.shape.length,
            m = n.shape.length,
            v = r ? t.shape[d - 2] : t.shape[d - 1],
            g = a ? n.shape[m - 1] : n.shape[m - 2],
            y = r ? t.shape[d - 1] : t.shape[d - 2],
            b = a ? n.shape[m - 2] : n.shape[m - 1],
            x = t.shape.slice(0, -2),
            w = n.shape.slice(0, -2),
            k = ov(x),
            N = ov(w);
        nv(d >= 2 && m >= 2 && (k === N || 1 === k || 1 === N), function () {
            return "Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (" + x + ") and (" + w + ")."
        });
        var I = (k > N ? t.shape.slice(0, -2) : n.shape.slice(0, -2)).concat([y, b]);
        nv(v === g, function () {
            return "Error in matMul: inner shapes (" + v + ") and (" + g + ") of Tensors with shapes " + t.shape + " and " + n.shape + " and transposeA=" + r + " and transposeB=" + a + " must match."
        });
        var S, T = r ? [k, v, y] : [k, y, v],
            C = a ? [N, b, g] : [N, g, b],
            E = kU({
                inputs: {
                    x: t
                },
                backend: i,
                attrs: {
                    shape: T
                }
            }),
            R = kU({
                inputs: {
                    x: n
                },
                backend: i,
                attrs: {
                    shape: C
                }
            }),
            A = [E, R],
            F = Math.max(k, N),
            _ = r ? E.shape[1] : E.shape[2],
            D = null != s,
            O = null != l,
            M = "leakyrelu" === f,
            L = null != f ? dU(f, !0) : null;
        if ((1 === y || 1 === b) && _ > 1e3 && !1 === (D || O || M || null != L)) {
            var z = E,
                P = R;
            r && (z = _U({
                inputs: {
                    x: E
                },
                backend: i,
                attrs: {
                    perm: [0, 2, 1]
                }
            }), A.push(z)), a && (P = _U({
                inputs: {
                    x: R
                },
                backend: i,
                attrs: {
                    perm: [0, 2, 1]
                }
            }), A.push(P));
            var B = 1 === b,
                W = z;
            1 !== b && (W = kU({
                inputs: {
                    x: z
                },
                backend: i,
                attrs: {
                    shape: [F, _, 1]
                }
            }), A.push(W));
            var V = 1 === b ? 2 : 1,
                U = P;
            B && (U = kU({
                inputs: {
                    x: P
                },
                backend: i,
                attrs: {
                    shape: [F, 1, _]
                }
            }), A.push(U));
            var G = xU({
                inputs: {
                    a: W,
                    b: U
                },
                backend: i
            });
            S = AU({
                inputs: {
                    x: G
                },
                backend: i,
                attrs: {
                    axis: V,
                    keepDims: !0
                }
            }), A.push(G)
        } else {
            var j = _g(t.dtype, n.dtype),
                H = new mU(T, C, [F, y, b], r, a, D, L, O, M),
                q = [E, R];
            if (null != s && q.push(s), O && q.push(l), M) {
                var K = i.makeTensorInfo([], "float32", ug(p, "float32"));
                q.push(K), A.push(K)
            }
            S = i.runWebGLProgram(H, q, j)
        }
        var X = kU({
            inputs: {
                x: S
            },
            backend: i,
            attrs: {
                shape: I
            }
        });
        A.push(S);
        for (var Y = 0, J = A; Y < J.length; Y++) {
            var Z = J[Y];
            i.disposeIntermediateTensorInfo(Z)
        }
        return X
    }
    var MU = {
            kernelName: "_FusedMatMul",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.a,
                    i = t.b,
                    o = t.bias,
                    s = t.preluActivationWeights,
                    u = r.transposeA,
                    l = r.transposeB,
                    c = r.activation;
                return OU({
                    a: a,
                    b: i,
                    transposeA: u,
                    transposeB: l,
                    backend: n,
                    bias: o,
                    preluActivationWeights: s,
                    leakyreluAlpha: r.leakyreluAlpha,
                    activation: c
                })
            }
        },
        LU = {
            kernelName: "Abs",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t, n = e.inputs,
                    r = e.backend,
                    a = n.x;
                if (r.shouldExecuteOnCPU([a]) && "complex64" !== a.dtype) {
                    var i = r.texData.get(a.dataId),
                        o = AV(i.values);
                    return r.makeTensorInfo(a.shape, a.dtype, o)
                }
                return t = Wv().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? new YV(a.shape, "return abs(x);") : new qV(a.shape, "return abs(x);"), r.runWebGLProgram(t, [a], a.dtype)
            }
        },
        zU = {
            kernelName: "Acos",
            backendName: "webgl",
            kernelFunc: hU({
                opSnippet: "if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"
            })
        },
        PU = {
            kernelName: "Acosh",
            backendName: "webgl",
            kernelFunc: hU({
                opSnippet: "if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"
            })
        },
        BU = "return a + b;",
        WU = fU({
            opSnippet: BU,
            packedOpSnippet: BU,
            supportsComplex: !0,
            cpuKernelImpl: lV
        }),
        VU = {
            kernelName: Gv,
            backendName: "webgl",
            kernelFunc: WU
        },
        UU = function (e, t) {
            this.outputShape = [], this.outputShape = e, this.variableNames = t.map(function (e, t) {
                return "T" + t
            });
            var n = [];
            this.variableNames.forEach(function (e) {
                n.push("float v" + e + " = get" + e + "AtOutCoords();")
            });
            var r = this.variableNames.map(function (e) {
                return "v" + e
            }).join(" + ");
            this.userCode = "\n      void main() {\n        " + n.join("\n        ") + "\n\n        float result = " + r + ";\n        setOutput(result);\n      }\n    "
        },
        GU = function (e, t) {
            this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e, this.variableNames = t.map(function (e, t) {
                return "T" + t
            });
            var n = [];
            this.variableNames.forEach(function (e) {
                n.push("vec4 v" + e + " = get" + e + "AtOutCoords();")
            });
            var r = this.variableNames.map(function (e) {
                return "v" + e
            }).join(" + ");
            this.userCode = "\n      void main() {\n        " + n.join("\n        ") + "\n\n        vec4 result = " + r + ";\n        setOutput(result);\n      }\n    "
        },
        jU = {
            kernelName: "AddN",
            backendName: "webgl",
            kernelFunc: function e(t) {
                var n = t.inputs,
                    r = t.backend,
                    a = n;
                if (1 === a.length) return nU({
                    inputs: {
                        x: a[0]
                    },
                    backend: r
                });
                if (a.length > Wv().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
                    var i = Math.floor(a.length / 2),
                        o = e({
                            inputs: a.slice(0, i),
                            backend: r
                        }),
                        s = e({
                            inputs: a.slice(i),
                            backend: r
                        });
                    return e({
                        inputs: [o, s],
                        backend: r
                    })
                }
                var u = a.map(function (e) {
                        return e.dtype
                    }).reduce(function (e, t) {
                        return _g(e, t)
                    }),
                    l = a.map(function (e) {
                        return e.shape
                    }),
                    c = Wv().getBool("WEBGL_PACK") ? new GU(a[0].shape, l) : new UU(a[0].shape, l);
                return r.runWebGLProgram(c, a, u)
            }
        },
        HU = {
            kernelName: "All",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.axis,
                    o = r.keepDims,
                    s = a.shape.length,
                    u = fv(i, a.shape),
                    l = u,
                    c = hk(l, s),
                    p = a;
                null != c && (p = _U({
                    inputs: {
                        x: a
                    },
                    backend: n,
                    attrs: {
                        perm: c
                    }
                }), l = dk(l.length, s)), pk("all", l, s);
                var h, f = lk(p.shape, l),
                    d = f[0],
                    m = kU({
                        inputs: {
                            x: p
                        },
                        backend: n,
                        attrs: {
                            shape: [-1, ov(f[1])]
                        }
                    }),
                    v = TU(m, m.dtype, "all", n);
                return h = kU(o ? {
                    inputs: {
                        x: v
                    },
                    backend: n,
                    attrs: {
                        shape: ck(d, u)
                    }
                } : {
                    inputs: {
                        x: v
                    },
                    backend: n,
                    attrs: {
                        shape: d
                    }
                }), n.disposeIntermediateTensorInfo(m), n.disposeIntermediateTensorInfo(v), null != c && n.disposeIntermediateTensorInfo(p), h
            }
        },
        qU = {
            kernelName: "Any",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.axis,
                    o = r.keepDims,
                    s = a.shape.length,
                    u = fv(i, a.shape),
                    l = u,
                    c = hk(l, s),
                    p = a;
                null != c && (p = _U({
                    inputs: {
                        x: a
                    },
                    backend: n,
                    attrs: {
                        perm: c
                    }
                }), l = dk(l.length, s)), pk("any", l, s);
                var h, f = lk(p.shape, l),
                    d = f[0],
                    m = kU({
                        inputs: {
                            x: p
                        },
                        backend: n,
                        attrs: {
                            shape: [-1, ov(f[1])]
                        }
                    }),
                    v = TU(m, m.dtype, "any", n);
                return h = kU(o ? {
                    inputs: {
                        x: v
                    },
                    backend: n,
                    attrs: {
                        shape: ck(d, u)
                    }
                } : {
                    inputs: {
                        x: v
                    },
                    backend: n,
                    attrs: {
                        shape: d
                    }
                }), n.disposeIntermediateTensorInfo(m), n.disposeIntermediateTensorInfo(v), null != c && n.disposeIntermediateTensorInfo(p), h
            }
        },
        KU = function (e, t, n) {
            this.variableNames = ["A"];
            var r = e.windowSize,
                a = e.batchSize,
                i = e.outSize;
            n || this.variableNames.push("bestIndicesA"), this.outputShape = [a, i];
            var o = "max" === t ? ">" : "<",
                s = n ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
            this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + r + ";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < " + r + "; i++) {\n          int inIdx = " + s + ";\n          float candidate = getA(batch, inIdx);\n          if (candidate " + o + " bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    "
        },
        XU = function (e, t, n, r) {
            this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, nv(e.length > 2, function () {
                return "Packed arg" + (n.charAt(0).toUpperCase() + n.slice(1)) + " supports only inputs with rank above 2."
            });
            var a = e[e.length - 1],
                i = Math.ceil(a / t);
            this.outputShape = e.slice(0, -1), i > 1 && this.outputShape.push(i), r || this.variableNames.push("bestIndicesA");
            var o, s, u = this.outputShape,
                l = u.length,
                c = iV(l),
                p = BV("coords", l);
            if (1 === i) {
                var h = iV(s = l + 1);
                o = "\n        " + h + " sourceLocR = " + h + "(" + p.join() + ", 0);\n        ++" + p[l - 1] + ";\n        " + h + " sourceLocG = " + h + "(" + p.join() + ", 0);\n        ++" + p[l - 2] + ";\n        " + h + " sourceLocA = " + h + "(" + p.join() + ", 0);\n        --" + p[l - 1] + ";\n        " + h + " sourceLocB = " + h + "(" + p.join() + ", 0);\n        --" + p[l - 2] + ";"
            } else s = l, o = "\n        " + c + " sourceLocR = coords;\n        ++" + p[l - 1] + ";\n        " + c + " sourceLocG = coords;\n        ++" + p[l - 2] + ";\n        " + c + " sourceLocA = coords;\n        --" + p[l - 1] + ";\n        " + c + " sourceLocB = coords;\n        --" + p[l - 2] + ";";
            var f = ["x", "y", "z", "w", "u", "v"].slice(0, s),
                d = "." + f[s - 1],
                m = f.map(function (e) {
                    return "int " + e
                }),
                v = BV("sourceLocR", s - 1).concat("inIdx.r"),
                g = BV("sourceLocG", s - 1).concat("inIdx.g"),
                y = BV("sourceLocB", s - 1).concat("inIdx.b"),
                b = BV("sourceLocA", s - 1).concat("inIdx.a"),
                x = "max" === n ? "greaterThan" : "lessThan",
                w = r ? "" : "\n          inIdx = round(vec4(getBestIndicesAChannel(" + v.join() + "),\n                             getBestIndicesAChannel(" + g.join() + "),\n                             getBestIndicesAChannel(" + y.join() + "),\n                             getBestIndicesAChannel(" + b.join() + ")));",
                k = "vec4(\n            getAChannel(" + v.join() + "),\n            hasNextCol ? getAChannel(" + g.join() + ") : 0.,\n            hasNextRow ? getAChannel(" + y.join() + ") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(" + b.join() + ") : 0.)",
                N = r ? "" : "\n      float getBestIndicesAChannel(" + m.join() + ") {\n        return getChannel(getBestIndicesA(" + f.join() + "),\n                                          vec2(" + f.slice(-2).join() + "));\n      }";
            this.userCode = "\n      float getAChannel(" + m.join() + ") {\n        return getChannel(getA(" + f.join() + "),\n                               vec2(" + f.slice(-2).join() + "));\n      }\n      " + N + "\n      void main() {\n        " + c + " coords = getOutputCoords();\n        bool hasNextCol = " + p[l - 1] + " < " + (u[l - 1] - 1) + ";\n        bool hasNextRow = " + p[l - 2] + " < " + (u[l - 2] - 1) + ";\n        " + o + "\n        ivec4 srcIdx = ivec4(sourceLocR" + d + ", sourceLocG" + d + ",\n          sourceLocB" + d + ", sourceLocA" + d + ") * " + t + ";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = " + k + ";\n\n        for (int i = 0; i < " + t + "; i++) {\n          inIdx = srcIdx;\n          " + w + "\n          vec4 candidate = " + k + ";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(" + x + "(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    "
        };

    function YU(e, t, n, r) {
        var a = [n];
        if (pk("arg" + r.charAt(0).toUpperCase() + r.slice(1), a, t.shape.length), !Wv().getBool("WEBGL_PACK_REDUCE") || t.shape.length <= 2) {
            var i = [],
                o = lk(t.shape, a),
                s = o[0],
                u = ov(o[1]),
                l = kU({
                    inputs: {
                        x: t
                    },
                    backend: e,
                    attrs: {
                        shape: [-1, u]
                    }
                });
            i.push(l);
            var c = function e(t, n, r, a) {
                void 0 === a && (a = null);
                var i = n.shape[0],
                    o = n.shape[1];
                null != a && (i = a.shape[0], o = a.shape[1]);
                var s = RS(o),
                    u = {
                        windowSize: s,
                        inSize: o,
                        batchSize: i,
                        outSize: Math.ceil(o / s)
                    },
                    l = new KU(u, r, null == a),
                    c = [n];
                null != a && c.push(a);
                var p = t.runWebGLProgram(l, c, "int32");
                if (1 === p.shape[1]) return p;
                var h = e(t, n, r, p);
                return t.disposeIntermediateTensorInfo(p), h
            }(e, l, r);
            i.push(c);
            var p = kU({
                inputs: {
                    x: c
                },
                backend: e,
                attrs: {
                    shape: s
                }
            });
            return i.forEach(function (t) {
                return e.disposeIntermediateTensorInfo(t)
            }), p
        }
        return function e(t, n, r, a) {
            void 0 === a && (a = null);
            var i = null != a ? a.shape : n.shape,
                o = RS(i[i.length - 1]),
                s = new XU(i, o, r, null == a),
                u = null == a ? [n] : [n, a],
                l = t.runWebGLProgram(s, u, "int32");
            if (l.shape.length === n.shape.length) {
                var c = e(t, n, r, l);
                return t.disposeIntermediateTensorInfo(l), c
            }
            return l
        }(e, t, r)
    }
    var JU = {
            kernelName: "ArgMax",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = fv(r.axis, a.shape),
                    o = hk(i, a.shape.length),
                    s = a,
                    u = [];
                null != o && (s = _U({
                    inputs: {
                        x: a
                    },
                    backend: n,
                    attrs: {
                        perm: o
                    }
                }), u.push(s), i = dk(i.length, s.shape.length)), pk("argMax", [i[0]], s.shape.length);
                var l = YU(n, s, i[0], "max");
                return u.forEach(function (e) {
                    return n.disposeIntermediateTensorInfo(e)
                }), l
            }
        },
        ZU = {
            kernelName: "ArgMin",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = fv(r.axis, a.shape),
                    o = hk(i, a.shape.length),
                    s = a,
                    u = [];
                null != o && (s = _U({
                    inputs: {
                        x: a
                    },
                    backend: n,
                    attrs: {
                        perm: o
                    }
                }), u.push(s), i = dk(i.length, s.shape.length)), pk("argMin", [i[0]], s.shape.length);
                var l = YU(n, s, i[0], "min");
                return u.forEach(function (e) {
                    return n.disposeIntermediateTensorInfo(e)
                }), l
            }
        },
        QU = {
            kernelName: "Asin",
            backendName: "webgl",
            kernelFunc: hU({
                opSnippet: "if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"
            })
        },
        $U = {
            kernelName: "Asinh",
            backendName: "webgl",
            kernelFunc: hU({
                opSnippet: "if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"
            })
        },
        eG = {
            kernelName: "Atan",
            backendName: "webgl",
            kernelFunc: hU({
                opSnippet: "if (isnan(x)) return x;\n  return atan(x);\n"
            })
        },
        tG = {
            kernelName: "Atan2",
            backendName: "webgl",
            kernelFunc: fU({
                opSnippet: "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",
                packedOpSnippet: "\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"
            })
        },
        nG = {
            kernelName: "Atanh",
            backendName: "webgl",
            kernelFunc: hU({
                opSnippet: "if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"
            })
        },
        rG = function (e, t, n, r, a) {
            if (void 0 === r && (r = !1), void 0 === a && (a = !1), this.variableNames = ["x"], "avg" === t && n) throw new Error("Cannot compute positions for average pool.");
            var i = e.filterWidth,
                o = e.strideHeight,
                s = e.strideWidth,
                u = e.dilationHeight,
                l = e.dilationWidth,
                c = e.effectiveFilterHeight,
                p = e.effectiveFilterWidth,
                h = e.padInfo.top,
                f = e.padInfo.left;
            this.outputShape = e.outShape;
            var d = "avg" === t,
                m = "((batch  * " + e.inHeight + " + xR) * " + e.inWidth + " + xC) * " + e.inChannels + " + d",
                v = "(xR * " + e.inWidth + " + xC) * " + e.inChannels + " + d",
                g = "0.0";
            if (d || (g = "-1.0 / 1e-20"), n) this.userCode = "\n        const ivec2 strides = ivec2(" + o + ", " + s + ");\n        const ivec2 pads = ivec2(" + h + ", " + f + ");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < " + c + ";\n              wR += " + u + ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + e.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + p + ";\n                wC += " + l + ") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= " + e.inWidth + ") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = " + (r ? a ? m : v : "wR * " + p + " + wC") + ";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
            else {
                var y = t + "(" + t + "(" + t + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
                "avg" === t && (y = "avgValue / count");
                var b = 4 * Math.floor(i / 4),
                    x = i % 4,
                    w = "\n      if (" + d + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
                this.userCode = "\n      const ivec2 strides = ivec2(" + o + ", " + s + ");\n      const ivec2 pads = ivec2(" + h + ", " + f + ");\n      const float initializationValue = " + g + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= " + e.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + g + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < " + c + ";\n            wR += " + u + ") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + e.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + b + "; wC += 4) {\n            int xC = xCCorner + wC * " + l + ";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + l + ", d),\n              getValue(batch, xR, xC + 2 * " + l + ", d),\n              getValue(batch, xR, xC + 3 * " + l + ", d)\n            );\n\n            " + w + "\n          }\n\n          int xC = xCCorner + " + b + ";\n          if (" + (1 === x) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            " + w + "\n          } else if (" + (2 === x) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + l + ", d),\n              initializationValue,\n              initializationValue\n            );\n\n            " + w + "\n          } else if (" + (3 === x) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + l + ", d),\n              getValue(batch, xR, xC + 2 * " + l + ", d),\n              initializationValue\n            );\n\n            " + w + "\n          }\n        }\n        setOutput(" + y + ");\n      }\n    "
            }
        },
        aG = function (e, t, n, r, a) {
            if (void 0 === r && (r = !1), void 0 === a && (a = !1), this.variableNames = ["x"], "avg" === t && n) throw new Error("Cannot compute positions for average pool.");
            var i = e.filterWidth,
                o = e.strideDepth,
                s = e.strideHeight,
                u = e.strideWidth,
                l = e.dilationDepth,
                c = e.dilationHeight,
                p = e.dilationWidth,
                h = e.effectiveFilterDepth,
                f = e.effectiveFilterHeight,
                d = e.effectiveFilterWidth,
                m = e.padInfo.front,
                v = e.padInfo.top,
                g = e.padInfo.left;
            this.outputShape = e.outShape;
            var y = "avg" === t,
                b = "0.0";
            if (y || (b = "-1.0 / 1e-20"), n) this.userCode = "\n        const ivec3 strides =\n            ivec3(" + o + ", " + s + ", " + u + ");\n        const ivec3 pads = ivec3(" + m + ", " + v + ", " + g + ");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < " + h + ";\n              wD += " + l + ") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= " + e.inDepth + ") {\n              continue;\n            }\n\n            for (int wR = 0; wR < " + f + ";\n                wR += " + c + ") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= " + e.inHeight + ") {\n                continue;\n              }\n\n              for (int wC = 0; wC < " + d + ";\n                  wC += " + p + ") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= " + e.inWidth + ") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = " + (r ? a ? "(((batch * " + e.inDepth + " + xD) * " + e.inHeight + " + xR) * " + e.inWidth + " + xC) * " + e.inChannels + " + ch" : "((xD * " + e.inHeight + " + xR) * " + e.inWidth + " + xC) * " + e.inChannels + " + ch" : "wD * " + f + " * " + d + " +\n                      wR * " + d + " + wC") + ";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
            else {
                var x = t + "(" + t + "(" + t + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
                "avg" === t && (x = "avgValue / count");
                var w = 4 * Math.floor(i / 4),
                    k = i % 4,
                    N = "\n      if (" + y + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
                this.userCode = "\n      const ivec3 strides =\n        ivec3(" + o + ", " + s + ", " + u + ");\n      const ivec3 pads = ivec3(" + m + ", " + v + ", " + g + ");\n      const float initializationValue = " + b + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= " + e.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + b + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < " + h + ";\n            wD += " + l + ") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= " + e.inDepth + ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " + f + ";\n            wR += " + c + ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + e.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + w + "; wC += 4) {\n              int xC = xCCorner + wC * " + p + ";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + p + ", ch),\n                getValue(batch, xD, xR, xC + 2 * " + p + ", ch),\n                getValue(batch, xD, xR, xC + 3 * " + p + ", ch)\n              );\n\n              " + N + "\n            }\n\n            int xC = xCCorner + " + w + ";\n            if (" + (1 === k) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              " + N + "\n            } else if (" + (2 === k) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + p + ", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              " + N + "\n            } else if (" + (3 === k) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + p + ", ch),\n                getValue(batch, xD, xR, xC + 2 * " + p + ", ch),\n                initializationValue\n              );\n\n              " + N + "\n            }\n          }\n          setOutput(" + x + ");\n        }\n      }\n    "
            }
        },
        iG = {
            kernelName: "AvgPool",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x;
                _W(a, "avgPool");
                var i = r.filterSize,
                    o = r.strides,
                    s = r.pad,
                    u = r.dimRoundingMode;
                nv(Lx(o, 1), function () {
                    return "Error in avgPool: Either strides or dilations must be 1. Got strides " + o + " and dilations '1'"
                });
                var l = Tx(a.shape, i, o, 1, s, u);
                if (1 === l.filterWidth && 1 === l.filterHeight && sv(l.inShape, l.outShape)) return nU({
                    inputs: {
                        x: a
                    },
                    backend: n
                });
                var c = new rG(l, "avg", !1);
                return n.runWebGLProgram(c, [a], "float32")
            }
        },
        oG = {
            kernelName: "AvgPool3D",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.filterSize,
                    o = r.strides,
                    s = r.pad,
                    u = r.dimRoundingMode,
                    l = r.dataFormat,
                    c = Cx(a.shape, i, o, [1, 1, 1], s, u, l),
                    p = new aG(c, "avg", !1);
                return n.runWebGLProgram(p, [a], "float32")
            }
        },
        sG = function (e) {
            this.variableNames = ["dy"], this.outputShape = e.inShape;
            var t = e.filterHeight,
                n = e.filterWidth,
                r = e.strideHeight,
                a = e.strideWidth,
                i = e.dilationHeight,
                o = e.dilationWidth,
                s = e.effectiveFilterHeight,
                u = e.effectiveFilterWidth,
                l = s - 1 - e.padInfo.top,
                c = u - 1 - e.padInfo.left,
                p = 1 / (t * n);
            this.userCode = "\n      const ivec2 pads = ivec2(" + l + ", " + c + ");\n      const float avgMultiplier = float(" + p + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + s + ";\n            wR += " + i + ") {\n          float dyR = float(dyRCorner + wR) / " + r + ".0;\n\n          if (dyR < 0.0 || dyR >= " + e.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + u + ";\n            wC+= " + o + ") {\n            float dyC = float(dyCCorner + wC) / " + a + ".0;\n\n            if (dyC < 0.0 || dyC >= " + e.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
        },
        uG = function (e) {
            this.variableNames = ["dy"], this.outputShape = e.inShape;
            var t = e.filterDepth,
                n = e.filterHeight,
                r = e.filterWidth,
                a = e.strideDepth,
                i = e.strideHeight,
                o = e.strideWidth,
                s = e.dilationDepth,
                u = e.dilationHeight,
                l = e.dilationWidth,
                c = e.effectiveFilterDepth,
                p = e.effectiveFilterHeight,
                h = e.effectiveFilterWidth,
                f = c - 1 - e.padInfo.front,
                d = p - 1 - e.padInfo.top,
                m = h - 1 - e.padInfo.left,
                v = 1 / (t * n * r);
            this.userCode = "\n      const ivec3 pads = ivec3(" + f + ", " + d + ", " + m + ");\n      const float avgMultiplier = float(" + v + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " + c + ";\n            wD += " + s + ") {\n          float dyD = float(dyDCorner + wD) / " + a + ".0;\n\n          if (dyD < 0.0 || dyD >= " + e.outDepth + ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " + p + ";\n              wR += " + u + ") {\n            float dyR = float(dyRCorner + wR) / " + i + ".0;\n\n            if (dyR < 0.0 || dyR >= " + e.outHeight + ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " + h + ";\n                wC += " + l + ") {\n              float dyC = float(dyCCorner + wC) / " + o + ".0;\n\n              if (dyC < 0.0 || dyC >= " + e.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
        },
        lG = {
            kernelName: "AvgPool3DGrad",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.dy,
                    i = t.input,
                    o = r.filterSize,
                    s = r.strides,
                    u = r.pad,
                    l = r.dimRoundingMode,
                    c = Cx(i.shape, o, s, [1, 1, 1], u, l),
                    p = new uG(c);
                return n.runWebGLProgram(p, [a], i.dtype)
            }
        },
        cG = {
            kernelName: "AvgPoolGrad",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.dy,
                    i = t.input,
                    o = i;
                _W([a, i], "avgPoolGrad");
                var s = r.filterSize,
                    u = r.strides,
                    l = r.pad,
                    c = Tx(o.shape, s, u, 1, l),
                    p = new sG(c);
                return n.runWebGLProgram(p, [a], o.dtype)
            }
        },
        pG = {
            kernelName: "BatchMatMul",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs;
                return OU({
                    a: t.a,
                    b: t.b,
                    transposeA: r.transposeA,
                    transposeB: r.transposeB,
                    backend: n
                })
            }
        },
        hG = function (e, t, n, r, a, i) {
            this.outputShape = [], this.variableNames = ["x", "mean", "variance"], kw(e, t), kw(e, n);
            var o = "0.0";
            null != r && (kw(e, r), this.variableNames.push("offset"), o = "getOffsetAtOutCoords()");
            var s = "1.0";
            null != a && (kw(e, a), this.variableNames.push("scale"), s = "getScaleAtOutCoords()"), this.outputShape = e, this.userCode = "\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = " + o + ";\n        float scale = " + s + ";\n        float inv = scale * inversesqrt(variance + float(" + i + "));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    "
        },
        fG = function (e, t, n, r, a, i) {
            this.packedInputs = !0, this.packedOutput = !0, this.variableNames = ["x", "mean", "variance"], kw(e, t), kw(e, n);
            var o = "vec4(0.0)";
            null != r && (kw(e, r), this.variableNames.push("offset"), o = "getOffsetAtOutCoords()");
            var s = "vec4(1.0)";
            null != a && (kw(e, a), this.variableNames.push("scale"), s = "getScaleAtOutCoords()"), this.outputShape = e, this.userCode = "\n      void main() {\n        vec4 offset = " + o + ";\n        vec4 scale = " + s + ";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(" + i + "));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    "
        },
        dG = {
            kernelName: "FusedBatchNorm",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.mean,
                    o = t.variance,
                    s = t.offset,
                    u = t.scale;
                nv(i.shape.length === o.shape.length, function () {
                    return "Batch normalization gradient requires mean and variance to have equal ranks."
                }), nv(null == s || i.shape.length === s.shape.length, function () {
                    return "Batch normalization gradient requires mean and offset to have equal ranks."
                }), nv(null == u || i.shape.length === u.shape.length, function () {
                    return "Batch normalization gradient requires mean and scale to have equal ranks."
                });
                var l = r.varianceEpsilon;
                null == l && (l = .001);
                var c = [a, i, o],
                    p = null;
                null != s && (p = s.shape, c.push(s));
                var h = null;
                null != u && (h = u.shape, c.push(u));
                var f = Wv().getBool("WEBGL_PACK_NORMALIZATION") ? new fG(a.shape, i.shape, o.shape, p, h, l) : new hG(a.shape, i.shape, o.shape, p, h, l);
                return n.runWebGLProgram(f, c, c[0].dtype)
            }
        },
        mG = function () {
            function e(e) {
                this.variableNames = ["source"], this.outputShape = e, this.rank = e.length;
                var t, n = iV(this.rank),
                    r = "uniform int start[" + this.rank + "];",
                    a = function (e) {
                        if (1 === e) return "sourceLoc";
                        if (e <= 6) return vG.slice(0, e).map(function (e) {
                            return "sourceLoc." + e
                        }).join(",");
                        throw Error("Slicing for rank " + e + " is not yet supported")
                    }(this.rank);
                t = "\n        " + n + " sourceLoc;\n        " + n + " coords = getOutputCoords();\n        " + e.map(function (e, t) {
                    return "sourceLoc." + vG[t] + " = start[" + t + "] + coords." + vG[t] + ";"
                }).join("\n") + "\n      ", this.userCode = "\n      " + r + "\n      void main() {\n        " + t + "\n        setOutput(getSource(" + a + "));\n      }\n    "
            }
            return e.prototype.getCustomSetupFunc = function (e) {
                var t = this;
                if (e.length !== this.rank) throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + e.length + ")");
                return function (n, r) {
                    null == t.startLoc && (t.startLoc = n.getUniformLocationNoThrow(r, "start"), null == t.startLoc) || n.gl.uniform1iv(t.startLoc, e)
                }
            }, e
        }(),
        vG = ["x", "y", "z", "w", "u", "v"],
        gG = function () {
            function e(e) {
                this.variableNames = ["source"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e, this.rank = e.length;
                var t = iV(this.rank),
                    n = BV("coords", this.rank),
                    r = BV("sourceLoc", this.rank),
                    a = 1 === this.rank ? "sourceLoc" : "vec2(" + r.slice(-2).join() + ")",
                    i = "getChannel(getSource(" + r.join() + "), " + a + ")",
                    o = "\n      result.x = " + i + ";\n      if (++" + n[this.rank - 1] + " < " + e[this.rank - 1] + ") {\n        ++" + r[this.rank - 1] + ";\n        result.y = " + i + ";\n        --" + r[this.rank - 1] + ";\n      }\n    ",
                    s = 1 === this.rank ? "" : "\n      --" + n[this.rank - 1] + ";\n      if (++" + n[this.rank - 2] + " < " + e[this.rank - 2] + ") {\n        ++" + r[this.rank - 2] + ";\n        result.z = " + i + ";\n        if (++" + n[this.rank - 1] + " < " + e[this.rank - 1] + ") {\n          ++" + r[this.rank - 1] + ";\n          result.w = " + i + ";\n        }\n      }\n    ",
                    u = this.rank <= 4 ? "sourceLoc = coords +\n            " + t + "(" + e.map(function (e, t) {
                        return "start[" + t + "]"
                    }).join() + ");" : e.map(function (e, t) {
                        return r[t] + " = " + n[t] + " + start[" + t + "];"
                    }).join("\n");
                this.userCode = "\n      uniform int start[" + this.rank + "];\n      void main() {\n        " + t + " coords = getOutputCoords();\n        " + t + " sourceLoc;\n        " + u + "\n        vec4 result = vec4(0.);\n        " + o + "\n        " + s + "\n        setOutput(result);\n      }\n    "
            }
            return e.prototype.getCustomSetupFunc = function (e) {
                var t = this;
                if (e.length !== this.rank) throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + e.length + ")");
                return function (n, r) {
                    null == t.startLoc && (t.startLoc = n.getUniformLocationNoThrow(r, "start"), null == t.startLoc) || n.gl.uniform1iv(t.startLoc, e)
                }
            }, e
        }();

    function yG(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.x,
            i = jb(a, r.begin, r.size),
            o = i[0],
            s = i[1];
        if (Ab(a, o, s), 0 === ov(s)) return n.makeTensorInfo(s, a.dtype, []);
        if (n.shouldExecuteOnCPU([a]) || "string" === a.dtype) {
            var u = n.texData.get(a.dataId),
                l = FV(u.values, o, s, a.shape, a.dtype);
            return n.makeTensorInfo(s, a.dtype, l)
        }
        var c = n.texData.get(a.dataId).isPacked,
            p = Ub(a.shape, o, s);
        if (c || !p) {
            var h = Wv().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new gG(s) : new mG(s),
                f = h.getCustomSetupFunc(o);
            return n.runWebGLProgram(h, [a], a.dtype, f)
        }
        return n.uploadToGPU(a.dataId),
            function (e, t, n, r) {
                var a = r.texData.get(e.dataId),
                    i = r.makeTensorInfo(n, e.dtype),
                    o = r.texData.get(i.dataId);
                Object.assign(o, a), o.refCount = 1, o.shape = n, o.dtype = e.dtype;
                var s = Gb(t, Rv(e.shape));
                a.slice && (s += a.slice.flatOffset), o.slice = {
                    flatOffset: s,
                    origDataId: a.slice && a.slice.origDataId || e.dataId
                };
                var u = r.dataRefCount.get(o.slice.origDataId) || 1;
                return r.dataRefCount.set(o.slice.origDataId, u + 1), i
            }(a, o, s, n)
    }
    var bG = {
            kernelName: "Slice",
            backendName: "webgl",
            kernelFunc: yG
        },
        xG = {
            kernelName: "BatchToSpaceND",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.blockShape,
                    o = r.crops;
                nv(a.shape.length <= 4, function () {
                    return "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"
                });
                var s = i.reduce(function (e, t) {
                        return e * t
                    }),
                    u = FS(a.shape, i, s),
                    l = _S(u.length, i.length),
                    c = DS(a.shape, i, s),
                    p = OS(o, i.length),
                    h = MS(c, o, i.length),
                    f = [],
                    d = kU({
                        inputs: {
                            x: a
                        },
                        backend: n,
                        attrs: {
                            shape: u
                        }
                    }),
                    m = _U({
                        inputs: {
                            x: d
                        },
                        backend: n,
                        attrs: {
                            perm: l
                        }
                    }),
                    v = kU({
                        inputs: {
                            x: m
                        },
                        backend: n,
                        attrs: {
                            shape: c
                        }
                    }),
                    g = yG({
                        inputs: {
                            x: v
                        },
                        backend: n,
                        attrs: {
                            begin: p,
                            size: h
                        }
                    });
                return f.push(d), f.push(m), f.push(v), f.forEach(function (e) {
                    return n.disposeIntermediateTensorInfo(e)
                }), g
            }
        },
        wG = {
            kernelName: "Bincount",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.weights,
                    o = r.size,
                    s = n.readSync(a.dataId),
                    u = n.readSync(i.dataId),
                    l = cV(s, u, i.dtype, i.shape, o);
                return n.makeTensorInfo([o], i.dtype, l)
            }
        },
        kG = fU({
            opSnippet: "return float(a != b);",
            dtype: "bool"
        }),
        NG = {
            kernelName: "NotEqual",
            backendName: "webgl",
            kernelFunc: kG
        };

    function IG(e) {
        var t = e.inputs,
            n = e.backend,
            r = t.input;
        return nU({
            inputs: {
                x: n.texData.get(r.dataId).complexTensorInfos.real
            },
            backend: n
        })
    }
    var SG = {
            kernelName: "Real",
            backendName: "webgl",
            kernelFunc: IG
        },
        TG = {
            kernelName: "Cast",
            backendName: "webgl",
            kernelFunc: function e(t) {
                var n = t.inputs,
                    r = t.backend,
                    a = t.attrs,
                    i = n.x,
                    o = a.dtype;
                if ("complex64" === o) {
                    if ("complex64" === i.dtype) return nU({
                        inputs: {
                            x: i
                        },
                        backend: r
                    });
                    var s = Ok(i.shape),
                        u = e({
                            inputs: {
                                x: i
                            },
                            backend: r,
                            attrs: {
                                dtype: "float32"
                            }
                        }),
                        l = aU({
                            inputs: {
                                real: u,
                                imag: s
                            },
                            backend: r
                        });
                    return s.dispose(), r.disposeIntermediateTensorInfo(u), l
                }
                if ("complex64" === i.dtype) {
                    var c = IG({
                            inputs: {
                                input: i
                            },
                            backend: r
                        }),
                        p = e({
                            inputs: {
                                x: c
                            },
                            backend: r,
                            attrs: {
                                dtype: o
                            }
                        });
                    return r.disposeIntermediateTensorInfo(c), p
                }
                if (!bv(i.dtype, o)) {
                    var h = nU({
                        inputs: {
                            x: i
                        },
                        backend: r
                    });
                    return {
                        dataId: h.dataId,
                        shape: h.shape,
                        dtype: o
                    }
                }
                if ("int32" === o) return function (e, t) {
                    var n = new qV(e.shape, "return float(int(x));"),
                        r = t.runWebGLProgram(n, [e], "int32");
                    return {
                        dataId: r.dataId,
                        shape: r.shape,
                        dtype: r.dtype
                    }
                }(i, r);
                if ("bool" === o) {
                    var f = r.makeTensorInfo([], "bool", mv("bool", 1)),
                        d = kG({
                            inputs: {
                                a: i,
                                b: f
                            },
                            backend: r
                        });
                    return r.disposeIntermediateTensorInfo(f), d
                }
                throw new Error("Error in Cast: failed to cast " + i.dtype + " to " + o)
            }
        },
        CG = "return ceil(x);",
        EG = {
            kernelName: "Ceil",
            backendName: "webgl",
            kernelFunc: hU({
                opSnippet: CG,
                packedOpSnippet: CG,
                cpuKernelImpl: hV
            })
        },
        RG = function () {
            function e(e) {
                this.variableNames = ["A"], this.outputShape = e, this.userCode = "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "
            }
            return e.prototype.getCustomSetupFunc = function (e, t) {
                var n = this;
                return function (r, a) {
                    null == n.minLoc && (n.minLoc = r.getUniformLocationNoThrow(a, "minVal"), n.maxLoc = r.getUniformLocationNoThrow(a, "maxVal")), r.gl.uniform1f(n.minLoc, e), r.gl.uniform1f(n.maxLoc, t)
                }
            }, e
        }(),
        AG = function () {
            function e(e) {
                this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e, this.userCode = "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "
            }
            return e.prototype.getCustomSetupFunc = function (e, t) {
                var n = this;
                return function (r, a) {
                    null == n.minLoc && (n.minLoc = r.getUniformLocationNoThrow(a, "minVal"), n.maxLoc = r.getUniformLocationNoThrow(a, "maxVal")), r.gl.uniform1f(n.minLoc, e), r.gl.uniform1f(n.maxLoc, t)
                }
            }, e
        }(),
        FG = {
            kernelName: "ClipByValue",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t, n = e.inputs,
                    r = e.backend,
                    a = e.attrs,
                    i = n.x,
                    o = a.clipValueMin,
                    s = a.clipValueMax,
                    u = (t = Wv().getBool("WEBGL_PACK_CLIP") ? new AG(i.shape) : new RG(i.shape)).getCustomSetupFunc(o, s);
                return r.runWebGLProgram(t, [i], i.dtype, u)
            }
        },
        _G = function (e) {
            this.variableNames = ["real", "imag"], this.outputShape = e, this.userCode = "\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "
        };

    function DG(e, t) {
        return {
            dataId: t.dataId,
            dtype: t.dtype,
            shape: e.shape
        }
    }
    var OG = {
            kernelName: "ComplexAbs",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = t.x,
                    a = n.texData.get(r.dataId),
                    i = new _G(r.shape),
                    o = [DG(r, a.complexTensorInfos.real), DG(r, a.complexTensorInfos.imag)];
                return n.runWebGLProgram(i, o, o[0].dtype)
            }
        },
        MG = function (e) {
            this.outputShape = [], this.outputShape = ES(e, 1), this.variableNames = e.map(function (e, t) {
                return "T" + t
            });
            var t = new Array(e.length - 1);
            t[0] = e[0][1];
            for (var n = 1; n < t.length; n++) t[n] = t[n - 1] + e[n][1];
            for (var r = ["if (yC < " + t[0] + ") setOutput(getT0(yR, yC));"], a = 1; a < t.length; a++) {
                var i = t[a - 1];
                r.push("else if (yC < " + t[a] + ") setOutput(getT" + a + "(yR, yC-" + i + "));")
            }
            var o = t.length,
                s = t[t.length - 1];
            r.push("else setOutput(getT" + o + "(yR, yC-" + s + "));"), this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        " + r.join("\n        ") + "\n      }\n    "
        },
        LG = function (e, t) {
            this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [], this.outputShape = ES(e, t);
            var n = this.outputShape,
                r = n.length,
                a = iV(r),
                i = BV("coords", r),
                o = ["x", "y", "z", "w", "u", "v"].slice(0, r);
            this.variableNames = e.map(function (e, t) {
                return "T" + t
            });
            var s = new Array(e.length - 1);
            s[0] = e[0][t];
            for (var u = 1; u < s.length; u++) s[u] = s[u - 1] + e[u][t];
            for (var l = o[t], c = o.slice(-2), p = o.join(), h = "if (" + l + " < " + s[0] + ") {\n        return getChannel(\n            getT0(" + p + "), vec2(" + c.join() + "));\n        }", f = 1; f < s.length; f++) {
                var d = s[f - 1];
                h += "\n        if (" + l + " < " + s[f] + "  && " + l + " >= " + s[f - 1] + ") {\n          return getChannel(\n            getT" + f + "(" + zG(o, l, d) + "),\n            vec2(" + zG(c, l, d) + "));\n        }"
            }
            var m = s.length,
                v = s[s.length - 1];
            h += "\n        return getChannel(\n          getT" + m + "(" + zG(o, l, v) + "),\n          vec2(" + zG(c, l, v) + "));", this.userCode = "\n      float getValue(" + o.map(function (e) {
                return "int " + e
            }) + ") {\n        " + h + "\n      }\n\n      void main() {\n        " + a + " coords = getOutputCoords();\n        vec4 result = vec4(getValue(" + i + "), 0., 0., 0.);\n\n        " + i[r - 1] + " = " + i[r - 1] + " + 1;\n        if (" + i[r - 1] + " < " + n[r - 1] + ") {\n          result.g = getValue(" + i + ");\n        }\n\n        " + i[r - 2] + " = " + i[r - 2] + " + 1;\n        if (" + i[r - 2] + " < " + n[r - 2] + ") {\n          result.a = getValue(" + i + ");\n        }\n\n        " + i[r - 1] + " = " + i[r - 1] + " - 1;\n        if (" + i[r - 2] + " < " + n[r - 2] + " &&\n            " + i[r - 1] + " < " + n[r - 1] + ") {\n          result.b = getValue(" + i + ");\n        }\n        setOutput(result);\n      }\n    "
        };

    function zG(e, t, n) {
        var r = e.indexOf(t);
        return e.map(function (e, t) {
            return t === r ? e + " - " + n : e
        }).join()
    }

    function PG(e) {
        var t = e.inputs,
            n = e.backend,
            r = t.input;
        return nU({
            inputs: {
                x: n.texData.get(r.dataId).complexTensorInfos.imag
            },
            backend: n
        })
    }
    var BG = {
        kernelName: "Imag",
        backendName: "webgl",
        kernelFunc: PG
    };

    function WG(e, t, n) {
        var r = ES(e.map(function (e) {
            return e.shape
        }), t);
        return {
            tensors2D: e.map(function (e) {
                return kU({
                    inputs: {
                        x: e
                    },
                    attrs: {
                        shape: [-1, ov(e.shape.slice(t))]
                    },
                    backend: n
                })
            }),
            outShape: r
        }
    }

    function VG(e) {
        var t = e.inputs,
            n = e.backend,
            r = fv(e.attrs.axis, t[0].shape)[0],
            a = ES(t.map(function (e) {
                return e.shape
            }), r);
        if (0 === ov(a)) return n.makeTensorInfo(a, t[0].dtype, []);
        var i = t.filter(function (e) {
            return ov(e.shape) > 0
        });
        return 1 === i.length ? nU({
            inputs: {
                x: i[0]
            },
            backend: n
        }) : (CS(i.map(function (e) {
            return e.shape
        }), r), function e(t, n, r) {
            var a = t[0].dtype;
            if ("complex64" === a) {
                var i = t.map(function (e) {
                        return IG({
                            inputs: {
                                input: e
                            },
                            backend: r
                        })
                    }),
                    o = t.map(function (e) {
                        return PG({
                            inputs: {
                                input: e
                            },
                            backend: r
                        })
                    }),
                    s = e(i, n, r),
                    u = e(o, n, r),
                    l = aU({
                        inputs: {
                            real: s,
                            imag: u
                        },
                        backend: r
                    });
                return i.forEach(function (e) {
                    return r.disposeIntermediateTensorInfo(e)
                }), o.forEach(function (e) {
                    return r.disposeIntermediateTensorInfo(e)
                }), r.disposeIntermediateTensorInfo(s), r.disposeIntermediateTensorInfo(u), l
            }
            if ("string" === a) {
                var c = WG(t, n, r),
                    p = c.tensors2D,
                    h = c.outShape,
                    f = p.map(function (e) {
                        return {
                            vals: r.readSync(e.dataId),
                            shape: e.shape
                        }
                    }),
                    d = 1 === p[0].shape[0],
                    m = fV(f, h, a, d),
                    v = ES(t.map(function (e) {
                        return e.shape
                    }), n),
                    g = r.makeTensorInfo(v, a, m);
                return p.forEach(function (e) {
                    return r.disposeIntermediateTensorInfo(e)
                }), g
            }
            if (t.length > Wv().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
                var y = Math.floor(t.length / 2),
                    b = e(t.slice(0, y), n, r),
                    x = e(t.slice(y), n, r),
                    w = e([b, x], n, r);
                return r.disposeIntermediateTensorInfo(b), r.disposeIntermediateTensorInfo(x), w
            }
            if (Wv().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && t[0].shape.length > 1) {
                var k = new LG(t.map(function (e) {
                    return e.shape
                }), n);
                return r.runWebGLProgram(k, t, a)
            }
            var N = WG(t, n, r),
                I = N.tensors2D,
                S = N.outShape,
                T = new MG(I.map(function (e) {
                    return e.shape
                })),
                C = r.runWebGLProgram(T, I, a);
            I.forEach(function (e) {
                return r.disposeIntermediateTensorInfo(e)
            });
            var E = kU({
                inputs: {
                    x: C
                },
                attrs: {
                    shape: S
                },
                backend: r
            });
            return r.disposeIntermediateTensorInfo(C), E
        }(i, r, n))
    }
    var UG = {
            kernelName: "Concat",
            backendName: "webgl",
            kernelFunc: VG
        },
        GG = function (e, t, n, r, a) {
            void 0 === t && (t = !1), void 0 === n && (n = null), void 0 === r && (r = !1), void 0 === a && (a = !1), this.variableNames = ["x", "W"], this.outputShape = e.outShape;
            var i = e.padInfo.top,
                o = e.padInfo.left,
                s = e.strideHeight,
                u = e.strideWidth,
                l = e.dilationHeight,
                c = e.dilationWidth,
                p = e.filterHeight,
                h = e.filterWidth,
                f = 4 * Math.floor(e.inChannels / 4),
                d = e.inChannels % 4,
                m = "channelsLast" === e.dataFormat,
                v = m ? 1 : 2,
                g = m ? 2 : 3,
                y = m ? 3 : 1,
                b = "",
                x = "";
            n && (b = r ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " + n + "\n        }" : a ? "float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          " + n + "\n        }" : "\n          float activation(float x) {\n            " + n + "\n          }\n        ", x = "result = activation(result);");
            var w = t ? "result += getBiasAtOutCoords();" : "";
            t && this.variableNames.push("bias"), r && this.variableNames.push("preluActivationWeights"), a && this.variableNames.push("leakyreluAlpha"), this.userCode = "\n      " + b + "\n\n      const ivec2 strides = ivec2(" + s + ", " + u + ");\n      const ivec2 pads = ivec2(" + i + ", " + o + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[" + y + "];\n\n        ivec2 xRCCorner =\n            ivec2(coords[" + v + "], coords[" + g + "]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + p + "; wR++) {\n          int xR = xRCorner + wR * " + l + ";\n\n          if (xR < 0 || xR >= " + e.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + h + "; wC++) {\n            int xC = xCCorner + wC * " + c + ";\n\n            if (xC < 0 || xC >= " + e.inWidth + ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < " + f + "; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (" + m + ") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (" + (1 === d) + ") {\n\n              if (" + m + ") {\n                dotProd +=\n                    getX(batch, xR, xC, " + f + ") *\n                    getW(wR, wC, " + f + ", d2);\n              } else {\n                dotProd +=\n                    getX(batch, " + f + ", xR, xC) *\n                    getW(wR, wC, " + f + ", d2);\n              }\n\n            } else if (" + (2 === d) + ") {\n              vec2 wValues = vec2(\n                getW(wR, wC, " + f + ", d2),\n                getW(wR, wC, " + f + " + 1, d2)\n              );\n\n              if (" + m + ") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, " + f + "),\n                  getX(batch, xR, xC, " + f + " + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, " + f + ", xR, xC),\n                  getX(batch, " + f + " + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (" + (3 === d) + ") {\n              vec3 wValues = vec3(\n                getW(wR, wC, " + f + ", d2),\n                getW(wR, wC, " + f + " + 1, d2),\n                getW(wR, wC, " + f + " + 2, d2)\n              );\n\n              if (" + m + ") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, " + f + "),\n                  getX(batch, xR, xC, " + f + " + 1),\n                  getX(batch, xR, xC, " + f + " + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, " + f + ", xR, xC),\n                  getX(batch, " + f + " + 1, xR, xC),\n                  getX(batch, " + f + " + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        " + w + "\n        " + x + "\n        setOutput(result);\n      }\n    "
        },
        jG = function (e) {
            this.variableNames = ["x", "W"], this.outputShape = e.outShape;
            var t = e.padInfo.front,
                n = e.padInfo.top,
                r = e.padInfo.left,
                a = e.strideDepth,
                i = e.strideHeight,
                o = e.strideWidth,
                s = e.dilationDepth,
                u = e.dilationHeight,
                l = e.dilationWidth,
                c = e.filterDepth,
                p = e.filterHeight,
                h = e.filterWidth,
                f = 4 * Math.floor(e.inChannels / 4),
                d = e.inChannels % 4;
            this.userCode = "\n      const ivec3 strides = ivec3(" + a + ", " + i + ", " + o + ");\n      const ivec3 pads = ivec3(" + t + ", " + n + ", " + r + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " + c + "; wF++) {\n          int xF = xFCorner + wF * " + s + ";\n\n          if (xF < 0 || xF >= " + e.inDepth + ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " + p + "; wR++) {\n            int xR = xRCorner + wR * " + u + ";\n\n            if (xR < 0 || xR >= " + e.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + h + "; wC++) {\n              int xC = xCCorner + wC * " + l + ";\n\n              if (xC < 0 || xC >= " + e.inWidth + ") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < " + f + "; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (" + (1 === d) + ") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, " + f + ") *\n                  getW(wF, wR, wC, " + f + ", d2);\n              } else if (" + (2 === d) + ") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, " + f + "),\n                  getX(batch, xF, xR, xC, " + f + " + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, " + f + ", d2),\n                  getW(wF, wR, wC, " + f + " + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (" + (3 === d) + ") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, " + f + "),\n                  getX(batch, xF, xR, xC, " + f + " + 1),\n                  getX(batch, xF, xR, xC, " + f + " + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, " + f + ", d2),\n                  getW(wF, wR, wC, " + f + " + 1, d2),\n                  getW(wF, wR, wC, " + f + " + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
        },
        HG = function (e, t, n) {
            this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e;
            for (var r = n.filterWidth, a = n.inChannels, i = n.strideWidth, o = n.strideHeight, s = n.padInfo, u = n.outWidth, l = n.dilationWidth, c = n.dilationHeight, p = n.dataFormat, h = s.left, f = s.top, d = a * r, m = OW(), v = "channelsLast" === p, g = v ? 0 : 1, y = v ? 1 : 2, b = "", x = 0; x <= 1; x++)
                for (var w = 0; w <= 1; w++) b += "\n          blockIndex = rc.y + " + w + ";\n          pos = rc.x + " + x + ";\n\n          if(blockIndex < " + e[1] + " && pos < " + e[0] + ") {\n            offsetY = int(blockIndex / (" + u + ")) * " + o + " - " + f + ";\n            d0 = offsetY + " + c + " * (pos / " + d + ");\n\n            if(d0 < " + t[g] + " && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), " + u + ".) * " + i + ". - " + h + ".);\n              d1 = offsetX + " + l + " * (int(mod(float(pos), " + d + ".) / " + a + ".));\n\n              if(d1 < " + t[y] + " && d1 >= 0) {\n\n                ch = int(mod(float(pos), " + a + ".));\n\n                if (" + v + ") {\n                  innerDims = vec2(d1, ch);\n                  result[" + (2 * x + w) + "] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[" + (2 * x + w) + "] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ";
            this.userCode = "\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        " + b + "\n\n        " + m.output + " = result;\n      }\n    "
        };

    function qG(e) {
        var t, n = e.x,
            r = e.filter,
            a = e.convInfo,
            i = e.backend,
            o = e.bias,
            s = void 0 === o ? null : o,
            u = e.preluActivationWeights,
            l = void 0 === u ? null : u,
            c = e.leakyreluAlpha,
            p = void 0 === c ? 0 : c,
            h = e.activation,
            f = void 0 === h ? null : h,
            d = n.shape,
            m = i.texData.get(n.dataId),
            v = a.inChannels,
            g = d[0] * d[1] * d[2],
            y = a.outChannels,
            b = "channelsLast" === a.dataFormat,
            x = [],
            w = (1 === g || 1 === y) && v > 1e3,
            k = d[2] % 2 != 0 && !!m.isPacked;
        if (!w && Wv().getBool("WEBGL_LAZILY_UNPACK") && Wv().getBool("WEBGL_PACK_BINARY_OPERATIONS") && k) {
            var N = b ? d[0] * d[1] * (d[2] + 1) : d[0] * d[2] * (d[3] + 1),
                I = {
                    dataId: n.dataId,
                    shape: [1, N, a.inChannels],
                    dtype: n.dtype
                },
                S = m.shape;
            m.shape = m.shape.slice(), m.shape[m.shape.length - 2]++, nv(EW(m.shape, I.shape), function () {
                return "packed reshape " + m.shape + " to " + I.shape + " isn't free"
            });
            var T = kU({
                inputs: {
                    x: r
                },
                backend: i,
                attrs: {
                    shape: [1, a.inChannels, a.outChannels]
                }
            });
            x.push(T);
            var C = OU({
                    a: I,
                    b: T,
                    backend: i,
                    transposeA: !1,
                    transposeB: !1,
                    bias: s,
                    activation: f,
                    preluActivationWeights: l,
                    leakyreluAlpha: p
                }),
                E = i.texData.get(C.dataId);
            nv(E.isPacked, function () {
                return "batchMatMul result is expected to be packed"
            }), m.shape = S, E.shape = a.outShape, (t = nU({
                inputs: {
                    x: C
                },
                backend: i
            })).shape = a.outShape, x.push(C)
        } else {
            var R = kU({
                    inputs: {
                        x: n
                    },
                    backend: i,
                    attrs: {
                        shape: [1, b ? d[0] * d[1] * d[2] : d[0] * d[2] * d[3], a.inChannels]
                    }
                }),
                A = kU({
                    inputs: {
                        x: r
                    },
                    backend: i,
                    attrs: {
                        shape: [1, a.inChannels, a.outChannels]
                    }
                }),
                F = OU({
                    a: R,
                    b: A,
                    transposeA: !1,
                    transposeB: !1,
                    backend: i,
                    bias: s,
                    activation: f,
                    preluActivationWeights: l,
                    leakyreluAlpha: p
                });
            t = kU({
                inputs: {
                    x: F
                },
                backend: i,
                attrs: {
                    shape: a.outShape
                }
            }), x.push(R), x.push(A), x.push(F)
        }
        for (var _ = 0, D = x; _ < D.length; _++) {
            var O = D[_];
            i.disposeIntermediateTensorInfo(O)
        }
        return t
    }

    function KG(e) {
        var t = e.x,
            n = e.filter,
            r = e.convInfo,
            a = e.backend,
            i = e.bias,
            o = void 0 === i ? null : i,
            s = e.preluActivationWeights,
            u = void 0 === s ? null : s,
            l = e.leakyreluAlpha,
            c = void 0 === l ? 0 : l,
            p = e.activation,
            h = void 0 === p ? null : p,
            f = r.filterWidth,
            d = r.filterHeight,
            m = r.inChannels,
            v = r.outWidth,
            g = r.outHeight,
            y = "channelsLast" === r.dataFormat,
            b = f * d * m,
            x = g * v,
            w = [b, x],
            k = [],
            N = kU({
                inputs: {
                    x: t
                },
                backend: a,
                attrs: {
                    shape: t.shape.slice(1)
                }
            }),
            I = kU({
                inputs: {
                    x: n
                },
                backend: a,
                attrs: {
                    shape: [1, b, ov(n.shape) / b]
                }
            });
        k.push(N), k.push(I);
        var S = new HG(w, N.shape, r),
            T = a.runWebGLProgram(S, [N], "float32"),
            C = kU({
                inputs: {
                    x: T
                },
                backend: a,
                attrs: {
                    shape: [1, w[0], w[1]]
                }
            });
        k.push(T), k.push(C);
        var E = null != o,
            R = null != u,
            A = "leakyrelu" === h,
            F = h ? dU(h, !0) : null,
            _ = new mU(C.shape, I.shape, [1, x, r.outChannels], !0, !1, E, F, R, A),
            D = [C, I];
        if (o && D.push(o), R && D.push(u), A) {
            var O = a.makeTensorInfo([], "float32", ug(c, "float32"));
            D.push(O), k.push(O)
        }
        var M = a.runWebGLProgram(_, D, "float32"),
            L = kU({
                inputs: {
                    x: M
                },
                backend: a,
                attrs: {
                    shape: y ? [1, g, v, r.outChannels] : [1, r.outChannels, g, v]
                }
            });
        k.push(M);
        for (var z = 0, P = k; z < P.length; z++) {
            var B = P[z];
            a.disposeIntermediateTensorInfo(B)
        }
        return L
    }
    var XG = {
            kernelName: "Conv2D",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t, n = e.inputs,
                    r = e.backend,
                    a = e.attrs,
                    i = n.x,
                    o = n.filter,
                    s = a.strides,
                    u = a.pad,
                    l = a.dataFormat,
                    c = a.dilations,
                    p = a.dimRoundingMode,
                    h = zx(l),
                    f = Ex(i.shape, o.shape, s, c, u, p, !1, h);
                if (1 !== f.filterHeight || 1 !== f.filterWidth || 1 !== f.dilationHeight || 1 !== f.dilationWidth || 1 !== f.strideHeight || 1 !== f.strideWidth || "SAME" !== f.padInfo.type && "VALID" !== f.padInfo.type)
                    if (Wv().getBool("WEBGL_CONV_IM2COL") && 1 === i.shape[0]) t = KG({
                        x: i,
                        filter: o,
                        convInfo: f,
                        backend: r
                    });
                    else {
                        var d = new GG(f);
                        t = r.runWebGLProgram(d, [i, o], "float32")
                    }
                else t = qG({
                    x: i,
                    filter: o,
                    convInfo: f,
                    backend: r
                });
                var m = kU({
                    inputs: {
                        x: t
                    },
                    backend: r,
                    attrs: {
                        shape: f.outShape
                    }
                });
                return r.disposeIntermediateTensorInfo(t), m
            }
        },
        YG = function (e) {
            this.variableNames = ["x", "dy"], this.outputShape = e.filterShape;
            var t = e.strideHeight,
                n = e.strideWidth,
                r = e.padInfo.top,
                a = e.padInfo.left,
                i = "channelsLast" === e.dataFormat;
            this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + e.batchSize + "; b++) {\n          for (int yR = 0; yR < " + e.outHeight + "; yR++) {\n            int xR = wR + yR * " + t + " - " + r + ";\n\n            if (xR < 0 || xR >= " + e.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + e.outWidth + "; yC++) {\n              int xC = wC + yC * " + n + " - " + a + ";\n\n              if (xC < 0 || xC >= " + e.inWidth + ") {\n                continue;\n              }\n\n              if (" + i + ") {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
        },
        JG = function (e) {
            this.variableNames = ["dy", "W"], this.outputShape = e.inShape;
            var t = e.filterHeight,
                n = e.filterWidth,
                r = e.strideHeight,
                a = e.strideWidth,
                i = "channelsLast" === e.dataFormat,
                o = t - 1 - e.padInfo.top,
                s = n - 1 - e.padInfo.left,
                u = i ? 1 : 2,
                l = i ? 2 : 3,
                c = i ? 3 : 1;
            this.userCode = "\n      const ivec2 pads = ivec2(" + o + ", " + s + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[" + c + "];\n\n        ivec2 dyCorner = ivec2(coords[" + u + "], coords[" + l + "]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + t + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + r + ".0;\n\n          if (dyR < 0.0 || dyR >= " + e.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + t + " - 1 - wR;\n\n          for (int wC = 0; wC < " + n + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + a + ".0;\n\n            if (dyC < 0.0 || dyC >= " + e.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + n + " - 1 - wC;\n\n            for (int d2 = 0; d2 < " + e.outChannels + "; d2++) {\n\n              if (" + i + ") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
        },
        ZG = function (e) {
            this.variableNames = ["x", "dy"], this.outputShape = e.filterShape;
            var t = e.strideDepth,
                n = e.strideHeight,
                r = e.strideWidth,
                a = e.padInfo.front,
                i = e.padInfo.top,
                o = e.padInfo.left;
            this.userCode = "\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + e.batchSize + "; b++) {\n          for (int yF = 0; yF < " + e.outDepth + "; yF++) {\n            int xF = wF + yF * " + t + " - " + a + ";\n\n            if (xF < 0 || xF >= " + e.inDepth + ") {\n              continue;\n            }\n\n            for (int yR = 0; yR < " + e.outHeight + "; yR++) {\n              int xR = wR + yR * " + n + " - " + i + ";\n\n              if (xR < 0 || xR >= " + e.inHeight + ") {\n                continue;\n              }\n\n              for (int yC = 0; yC < " + e.outWidth + "; yC++) {\n                int xC = wC + yC * " + r + " - " + o + ";\n\n                if (xC < 0 || xC >= " + e.inWidth + ") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
        },
        QG = function (e) {
            this.variableNames = ["dy", "W"], this.outputShape = e.inShape;
            var t = e.filterDepth,
                n = e.filterHeight,
                r = e.filterWidth,
                a = e.strideDepth,
                i = e.strideHeight,
                o = e.strideWidth,
                s = t - 1 - e.padInfo.front,
                u = n - 1 - e.padInfo.top,
                l = r - 1 - e.padInfo.left;
            this.userCode = "\n      const ivec3 pads = ivec3(" + s + ", " + u + ", " + l + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " + t + "; wF++) {\n          float dyF = float(dyFCorner + wF) / " + a + ".0;\n\n          if (dyF < 0.0 || dyF >= " + e.outDepth + ".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = " + t + " - 1 - wF;\n\n          for (int wR = 0; wR < " + n + "; wR++) {\n            float dyR = float(dyRCorner + wR) / " + i + ".0;\n\n            if (dyR < 0.0 || dyR >= " + e.outHeight + ".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = " + n + " - 1 - wR;\n\n            for (int wC = 0; wC < " + r + "; wC++) {\n              float dyC = float(dyCCorner + wC) / " + o + ".0;\n\n              if (dyC < 0.0 || dyC >= " + e.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = " + r + " - 1 - wC;\n\n              for (int d2 = 0; d2 < " + e.outChannels + "; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
        },
        $G = {
            kernelName: "Conv2DBackpropFilter",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.dy,
                    o = r.strides,
                    s = r.pad,
                    u = r.dataFormat,
                    l = r.dimRoundingMode,
                    c = r.filterShape,
                    p = zx(u),
                    h = Ex(a.shape, c, o, 1, s, l, !1, p),
                    f = new YG(h);
                return n.runWebGLProgram(f, [a, i], "float32")
            }
        },
        ej = {
            kernelName: "Conv2DBackpropInput",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.dy,
                    i = t.filter,
                    o = r.inputShape,
                    s = r.strides,
                    u = r.pad,
                    l = r.dataFormat,
                    c = r.dimRoundingMode,
                    p = zx(l),
                    h = Ex(o, i.shape, s, 1, u, c, !1, p),
                    f = new JG(h);
                return n.runWebGLProgram(f, [a, i], "float32")
            }
        },
        tj = {
            kernelName: "Conv3D",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.filter,
                    o = r.strides,
                    s = r.pad,
                    u = r.dilations,
                    l = Rx(a.shape, i.shape, o, u, s),
                    c = new jG(l);
                return n.runWebGLProgram(c, [a, i], "float32")
            }
        },
        nj = {
            kernelName: "Conv3DBackpropFilterV2",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.dy,
                    o = r.strides,
                    s = r.pad,
                    u = r.filterShape,
                    l = Rx(a.shape, u, o, 1, s),
                    c = new ZG(l);
                return n.runWebGLProgram(c, [a, i], "float32")
            }
        },
        rj = {
            kernelName: "Conv3DBackpropInputV2",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.dy,
                    i = t.filter,
                    o = r.pad,
                    s = r.strides,
                    u = Rx(r.inputShape, i.shape, s, 1, o),
                    l = new QG(u);
                return n.runWebGLProgram(l, [a, i], "float32")
            }
        },
        aj = hU({
            opSnippet: "if (isnan(x)) return x;\n  return cos(x);\n"
        }),
        ij = {
            kernelName: jv,
            backendName: "webgl",
            kernelFunc: aj
        },
        oj = {
            kernelName: "Cosh",
            backendName: "webgl",
            kernelFunc: hU({
                opSnippet: "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"
            })
        },
        sj = function (e, t, n, r, a) {
            this.variableNames = ["Image", "Boxes", "BoxInd"], this.outputShape = [];
            var i = e[0],
                o = e[1],
                s = e[2],
                u = e[3],
                l = t[0],
                c = n[0],
                p = n[1];
            this.outputShape = [l, c, p, u];
            var h = "bilinear" === r ? 1 : 0,
                f = o - 1 + ".0",
                d = s - 1 + ".0",
                m = c > 1 ? ["" + (o - 1) / (c - 1), "(y2-y1) * height_ratio", "y1*" + f + " + float(y)*(height_scale)"] : ["0.0", "0.0", "0.5 * (y1+y2) * " + f],
                v = m[0],
                g = m[1],
                y = m[2],
                b = p > 1 ? ["" + (s - 1) / (p - 1), "(x2-x1) * width_ratio", "x1*" + d + " + float(x)*(width_scale)"] : ["0.0", "0.0", "0.5 * (x1+x2) * " + d],
                x = b[0],
                w = b[1],
                k = b[2];
            this.userCode = "\n      const float height_ratio = float(" + v + ");\n      const float width_ratio = float(" + x + ");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= " + i + ") {\n          return;\n        }\n\n        float height_scale = " + g + ";\n        float width_scale = " + w + ";\n\n        float in_y = " + y + ";\n        if( in_y < 0.0 || in_y > " + f + " ) {\n          setOutput(float(" + a + "));\n          return;\n        }\n        float in_x = " + k + ";\n        if( in_x < 0.0 || in_x > " + d + " ) {\n          setOutput(float(" + a + "));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(" + h + " == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    "
        },
        uj = {
            kernelName: "CropAndResize",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.image,
                    i = t.boxes,
                    o = t.boxInd,
                    s = r.cropSize,
                    u = r.method,
                    l = r.extrapolationValue,
                    c = new sj(a.shape, i.shape, s, u, l);
                return n.runWebGLProgram(c, [a, i, o], "float32")
            }
        },
        lj = function () {
            function e(e, t, n) {
                this.variableNames = ["x"], this.outputShape = e;
                var r = e.length,
                    a = t ? "0.0" : "getX(" + cj(r, "coords") + ")",
                    i = e[e.length - 1],
                    o = "",
                    s = "";
                t ? (o = n ? "end != " + (i - 1) : "end != 0", s = n ? "end + 1" : "end - 1") : (o = n ? "end + pow2 < " + i : "end >= pow2", s = n ? "end + pow2" : "end - pow2"), this.userCode = "\n      uniform float index;\n      void main() {\n        " + iV(r) + " coords = getOutputCoords();\n        int end = " + pj(r, "coords") + ";\n        float val = " + a + ";\n        int pow2 = int(pow(2.0, index));\n        if (" + o + ") {\n          int idx = " + s + ";\n          " + pj(r, "coords") + " = idx;\n          val += getX(" + cj(r, "coords") + ");\n        }\n        setOutput(val);\n      }\n    "
            }
            return e.prototype.getCustomSetupFunc = function (e) {
                var t = this;
                return function (n, r) {
                    null == t.index && (t.index = n.getUniformLocation(r, "index")), n.gl.uniform1f(t.index, e)
                }
            }, e
        }();

    function cj(e, t) {
        if (1 === e) return "" + t;
        if (2 === e) return t + ".x, " + t + ".y";
        if (3 === e) return t + ".x, " + t + ".y, " + t + ".z";
        if (4 === e) return t + ".x, " + t + ".y, " + t + ".z, " + t + ".w";
        throw Error("Cumulative sum for rank " + e + " is not yet supported")
    }

    function pj(e, t) {
        if (1 === e) return "" + t;
        if (2 === e) return t + ".y";
        if (3 === e) return t + ".z";
        if (4 === e) return t + ".w";
        throw Error("Cumulative sum for rank " + e + " is not yet supported")
    }
    var hj = {
            kernelName: "Cumsum",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.axis,
                    o = r.exclusive,
                    s = r.reverse,
                    u = a.shape.length,
                    l = hk([i], u),
                    c = a;
                null != l && (c = _U({
                    inputs: {
                        x: a
                    },
                    backend: n,
                    attrs: {
                        perm: l
                    }
                }));
                var p = dk(1, u)[0];
                if (p !== u - 1) throw new Error("WebGL cumsum shader expects an inner-most axis=" + (a.shape.length - 1) + " but got axis=" + i);
                for (var h = c.shape[p], f = nU({
                        inputs: {
                            x: c
                        },
                        backend: n
                    }), d = 0; d <= Math.ceil(Math.log2(h)) - 1; d++) {
                    var m = new lj(c.shape, !1, s),
                        v = m.getCustomSetupFunc(d),
                        g = f;
                    f = n.runWebGLProgram(m, [f], f.dtype, v), n.disposeIntermediateTensorInfo(g)
                }
                if (o) {
                    var y = new lj(c.shape, o, s),
                        b = f;
                    f = n.runWebGLProgram(y, [f], f.dtype), n.disposeIntermediateTensorInfo(b)
                }
                if (null != l) {
                    var x = _U({
                        inputs: {
                            x: f
                        },
                        backend: n,
                        attrs: {
                            perm: fk(l)
                        }
                    });
                    return n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(c), x
                }
                return f
            }
        },
        fj = {
            kernelName: "DenseBincount",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.weights,
                    o = r.size,
                    s = r.binaryOutput;
                if (1 === a.shape.length) {
                    var u = n.readSync(a.dataId),
                        l = n.readSync(i.dataId),
                        c = cV(u, l, i.dtype, i.shape, o);
                    return n.makeTensorInfo([o], i.dtype, c)
                }
                if (2 === a.shape.length) {
                    var p = n.bufferSync(a),
                        h = n.bufferSync(i),
                        f = pV(p, h, o, s);
                    return n.makeTensorInfo(f.shape, i.dtype, f.values)
                }
                throw new Error("Error in denseBincount: input must be at most rank 2, but got rank" + a.shape.length + ".")
            }
        },
        dj = function () {
            function e(e, t, n) {
                this.variableNames = ["x"], this.outputShape = [], this.outputShape = e, this.blockSize = t, this.dataFormat = n, this.userCode = "\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = " + this.getHeightCoordString() + ";\n      int w = " + this.getWidthCoordString() + ";\n      int d = " + this.getDepthCoordString() + ";\n\n      int in_h = h / " + t + ";\n      int offset_h = imod(h, " + t + ");\n      int in_w = w / " + t + ";\n      int offset_w = imod(w, " + t + ");\n      int offset_d = (offset_h * " + t + " + offset_w) *\n        " + this.getOutputDepthSize() + ";\n      int in_d = d + offset_d;\n\n      float result = " + this.getInputSamplingString() + ";\n      setOutput(result);\n    }\n  "
            }
            var t = e.prototype;
            return t.getHeightCoordString = function () {
                return "NHWC" === this.dataFormat ? "coords[1]" : "coords[2]"
            }, t.getWidthCoordString = function () {
                return "NHWC" === this.dataFormat ? "coords[2]" : "coords[3]"
            }, t.getDepthCoordString = function () {
                return "NHWC" === this.dataFormat ? "coords[3]" : "coords[1]"
            }, t.getOutputDepthSize = function () {
                return "NHWC" === this.dataFormat ? this.outputShape[3] : this.outputShape[1]
            }, t.getInputSamplingString = function () {
                return "NHWC" === this.dataFormat ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)"
            }, e
        }(),
        mj = {
            kernelName: "DepthToSpace",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.blockSize,
                    o = r.dataFormat;
                nv(i > 1, function () {
                    return "blockSize should be > 1 for depthToSpace, but was: " + i
                });
                var s = a.shape[0],
                    u = "NHWC" === o ? a.shape[1] : a.shape[2],
                    l = "NHWC" === o ? a.shape[2] : a.shape[3],
                    c = "NHWC" === o ? a.shape[3] : a.shape[1],
                    p = u * i,
                    h = l * i,
                    f = c / (i * i),
                    d = new dj("NHWC" === o ? [s, p, h, f] : [s, f, p, h], i, o);
                return n.runWebGLProgram(d, [a], a.dtype)
            }
        },
        vj = function (e, t, n, r, a) {
            void 0 === t && (t = !1), void 0 === n && (n = null), void 0 === r && (r = !1), void 0 === a && (a = !1), this.variableNames = ["x", "W"], this.outputShape = e.outShape;
            var i = e.inHeight,
                o = e.inWidth,
                s = e.padInfo.top,
                u = e.padInfo.left,
                l = e.strideHeight,
                c = e.strideWidth,
                p = e.dilationHeight,
                h = e.dilationWidth,
                f = e.filterHeight,
                d = e.filterWidth,
                m = e.outChannels / e.inChannels,
                v = "",
                g = "";
            n && (v = r ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " + n + "\n        }" : a ? "float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          " + n + "\n        }" : "\n          float activation(float x) {\n            " + n + "\n          }\n        ", g = "result = activation(result);");
            var y = t ? "result += getBiasAtOutCoords();" : "";
            t && this.variableNames.push("bias"), r && this.variableNames.push("preluActivationWeights"), a && this.variableNames.push("leakyreluAlpha"), this.userCode = "\n      " + v + "\n\n      const ivec2 strides = ivec2(" + l + ", " + c + ");\n      const ivec2 pads = ivec2(" + s + ", " + u + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / " + m + ";\n        int q = d2 - d1 * " + m + ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < " + f + "; wR++) {\n          int xR = xRCorner + wR * " + p + ";\n\n          if (xR < 0 || xR >= " + i + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + d + "; wC++) {\n            int xC = xCCorner + wC * " + h + ";\n\n            if (xC < 0 || xC >= " + o + ") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        " + y + "\n        " + g + "\n        setOutput(result);\n      }\n    "
        },
        gj = function (e, t, n, r, a) {
            void 0 === t && (t = !1), void 0 === n && (n = null), void 0 === r && (r = !1), void 0 === a && (a = !1), this.variableNames = ["x", "W"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e.outShape;
            for (var i = e.inHeight, o = e.inWidth, s = e.padInfo.top, u = e.padInfo.left, l = e.strideHeight, c = e.strideWidth, p = e.dilationHeight, h = e.dilationWidth, f = e.filterHeight, d = e.filterWidth, m = d, v = "int xR; int xC; int xCOffset;", g = 0; g < f; g++)
                for (var y = 0; y < d; y++) v += "\n          vec4 xTexelR" + g + "C" + 2 * y + " = vec4(0.);\n          vec4 wR" + g + "C" + y + " = vec4(0.);\n          vec4 xR" + g + "C" + y + " = vec4(0.);";
            for (var b = 0; b < f; b++)
                for (var x = 0; x < m; x++) {
                    var w = 2 * x;
                    if (v += "\n          xR = xRCorner + " + b * p + ";\n          xC = xCCorner + " + w * h + ";\n        ", 1 === c) {
                        if (w < d && (v += u % 2 == 1 ? "\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < " + i + " && xCOffset >= 0 && xCOffset < " + o + ") {\n                  xTexelR" + b + "C" + w + " = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= " + o + ") {\n                    xTexelR" + b + "C" + w + ".zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR" + b + "C" + w + " = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < " + i + " && xCOffset >= 0 && xCOffset < " + o + ") {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= " + o + ") {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR" + b + "C" + w + " = vec4(previous.zw, xTexelR" + b + "C" + w + ".xy);\n                } else {\n                  xR" + b + "C" + w + " = vec4(0, 0, xTexelR" + b + "C" + w + ".xy);\n                }\n              " : "\n                if(xR >= 0 && xR < " + i + " && xC >= 0 && xC < " + o + ") {\n                  xTexelR" + b + "C" + w + " = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR" + b + "C" + w + " = vec4(0.);\n                }\n\n                xR" + b + "C" + w + " = xTexelR" + b + "C" + w + ";\n              ", w + 1 < d)) {
                            var k = u % 2 == 0 ? ev(h) : h;
                            h % 2 == 0 && u % 2 == 1 || h % 2 != 0 && u % 2 != 1 ? (v += "\n                  xCOffset = xC + " + u % 2 + " + " + k + ";\n\n                  if(xR >= 0 && xR < " + i + " &&\n                    xCOffset >= 0 && xCOffset < " + o + ") {\n                    xTexelR" + b + "C" + (w + 2) + " = getX(batch, xR, xCOffset, d1);\n                  }\n                ", h > 1 && (v += "\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < " + i + " &&\n                      xCOffset >= 0 && xCOffset < " + o + ") {\n                      xTexelR" + b + "C" + w + " = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR" + b + "C" + w + " = vec4(0.);\n                    }\n                  "), v += "\n                  xR" + b + "C" + (w + 1) + " = vec4(\n                    xTexelR" + b + "C" + w + ".zw, xTexelR" + b + "C" + (w + 2) + ".xy);\n                ") : v += "\n                  xCOffset = xC + " + k + ";\n\n                  if(xR >= 0 && xR < " + i + " &&\n                    xCOffset >= 0 && xCOffset < " + o + ") {\n                    xTexelR" + b + "C" + (w + 2) + " = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR" + b + "C" + (w + 1) + " = xTexelR" + b + "C" + (w + 2) + ";\n                "
                        }
                    } else w < d && (v += "\n              if(xR >= 0 && xR < " + i + ") {\n            ", u % 2 == 1 ? (v += "\n                xCOffset = xC + 1 - " + c + ";\n                if(xCOffset >= 0 && xCOffset < " + o + ") {\n                  xTexelR" + b + "C" + w + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + b + "C" + w + " = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < " + o + ") {\n                  xTexelR" + b + "C" + (w + 2) + " = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR" + b + "C" + (w + 2) + " = vec4(0.);\n                }\n\n                xR" + b + "C" + w + " = vec4(\n                  xTexelR" + b + "C" + w + ".zw, xTexelR" + b + "C" + (w + 2) + ".zw);\n              ", w + 1 < d && (v += "\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + " + c + ";\n                  if(xCOffset >= 0 && xCOffset < " + o + ") {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR" + b + "C" + (w + 1) + " = vec4(xTexelR" + b + "C" + (w + 2) + ".xy, final.xy);\n                ")) : (v += "\n                if(xC >= 0 && xC < " + o + ") {\n                  xTexelR" + b + "C" + w + " = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR" + b + "C" + w + " = vec4(0.);\n                }\n\n                xCOffset = xC + " + c + ";\n                if(xCOffset >= 0 && xCOffset < " + o + ") {\n                  xTexelR" + b + "C" + (w + 2) + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + b + "C" + (w + 2) + " = vec4(0.);\n                }\n\n                xR" + b + "C" + w + " = vec4(\n                  xTexelR" + b + "C" + w + ".xy, xTexelR" + b + "C" + (w + 2) + ".xy);\n              ", w + 1 < d && (v += "\n                  xR" + b + "C" + (w + 1) + " = vec4(\n                    xTexelR" + b + "C" + w + ".zw, xTexelR" + b + "C" + (w + 2) + ".zw);\n                ")), v += "}");
                    w < d && (v += "\n            vec4 wTexelR" + b + "C" + w + " = getW(" + b + ", " + w + ", d1, q);\n            wR" + b + "C" + w + " = vec4(wTexelR" + b + "C" + w + ".xz, wTexelR" + b + "C" + w + ".xz);\n          ", w + 1 < d && (v += "\n              vec4 wTexelR" + b + "C" + (w + 1) + " = getW(" + b + ", " + (w + 1) + ", d1, q);\n              wR" + b + "C" + (w + 1) + " =\n                vec4(wTexelR" + b + "C" + (w + 1) + ".xz, wTexelR" + b + "C" + (w + 1) + ".xz);"))
                }
            for (var N = 0; N < f; N++)
                for (var I = 0; I < d; I++) v += "dotProd += xR" + N + "C" + I + " * wR" + N + "C" + I + ";";
            var S = "",
                T = "";
            n && (S = r ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " + n + "\n        }" : a ? "vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          " + n + "\n        }" : "vec4 activation(vec4 x) {\n          " + n + "\n        }", T = "result = activation(result);");
            var C = t ? "result += getBiasAtOutCoords();" : "";
            t && this.variableNames.push("bias"), r && this.variableNames.push("preluActivationWeights"), a && this.variableNames.push("leakyreluAlpha"), this.userCode = "\n      " + S + "\n\n      const ivec2 strides = ivec2(" + l + ", " + c + ");\n      const ivec2 pads = ivec2(" + s + ", " + u + ");\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        " + v + "\n\n        vec4 result = dotProd;\n        " + C + "\n        " + T + "\n        setOutput(result);\n      }\n    "
        },
        yj = {
            kernelName: "DepthwiseConv2dNative",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.filter,
                    o = r.strides,
                    s = r.pad,
                    u = r.dilations,
                    l = r.dimRoundingMode,
                    c = u;
                null == c && (c = [1, 1]), nv(Lx(o, c), function () {
                    return "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides " + o + " and dilations '" + c + "'"
                });
                var p, h = Ex(a.shape, i.shape, o, c, s, l, !0);
                return p = Wv().getBool("WEBGL_PACK_DEPTHWISECONV") && h.strideWidth <= 2 && h.outChannels / h.inChannels == 1 ? new gj(h) : new vj(h), n.runWebGLProgram(p, [a, i], "float32")
            }
        },
        bj = function (e) {
            this.variableNames = ["x", "dy"], this.outputShape = e.filterShape;
            var t = e.strideHeight,
                n = e.strideWidth,
                r = e.padInfo.top,
                a = e.padInfo.left,
                i = e.outChannels / e.inChannels;
            this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * " + i + " + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < " + e.batchSize + "; b++) {\n          for (int yR = 0; yR < " + e.outHeight + "; yR++) {\n            int xR = wR + yR * " + t + " - " + r + ";\n\n            if (xR < 0 || xR >= " + e.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + e.outWidth + "; yC++) {\n              int xC = wC + yC * " + n + " - " + a + ";\n\n              if (xC < 0 || xC >= " + e.inWidth + ") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
        },
        xj = function (e) {
            this.variableNames = ["dy", "W"], this.outputShape = e.inShape;
            var t = e.filterHeight,
                n = e.filterWidth,
                r = e.strideHeight,
                a = e.strideWidth,
                i = t - 1 - e.padInfo.top,
                o = n - 1 - e.padInfo.left,
                s = e.outChannels / e.inChannels;
            this.userCode = "\n      const ivec2 pads = ivec2(" + i + ", " + o + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < " + t + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + r + ".0;\n\n          if (dyR < 0.0 || dyR >= " + e.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + t + " - 1 - wR;\n\n          for (int wC = 0; wC < " + n + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + a + ".0;\n\n            if (dyC < 0.0 || dyC >= " + e.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + n + " - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < " + s + "; dm++) {\n              int d2 = d1 * " + s + " + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
        },
        wj = {
            kernelName: "DepthwiseConv2dNativeBackpropFilter",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.dy,
                    o = r.strides,
                    s = r.dilations,
                    u = r.pad,
                    l = r.dimRoundingMode,
                    c = r.filterShape,
                    p = Ex(a.shape, c, o, s, u, l, !0),
                    h = new bj(p);
                return n.runWebGLProgram(h, [a, i], "float32")
            }
        },
        kj = {
            kernelName: "DepthwiseConv2dNativeBackpropInput",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.dy,
                    i = t.filter,
                    o = r.strides,
                    s = r.dilations,
                    u = r.pad,
                    l = r.dimRoundingMode,
                    c = Ex(r.inputShape, i.shape, o, s, u, l, !0),
                    p = new xj(c);
                return n.runWebGLProgram(p, [a, i], "float32")
            }
        },
        Nj = function (e) {
            this.variableNames = ["X"], this.outputShape = [e, e], this.userCode = "\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "
        },
        Ij = {
            kernelName: "Diag",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = t.x,
                    a = [].concat(r.shape, r.shape),
                    i = ov(r.shape),
                    o = kU({
                        inputs: {
                            x: r
                        },
                        backend: n,
                        attrs: {
                            shape: [i]
                        }
                    }),
                    s = new Nj(i),
                    u = n.runWebGLProgram(s, [o], o.dtype),
                    l = kU({
                        inputs: {
                            x: u
                        },
                        backend: n,
                        attrs: {
                            shape: a
                        }
                    });
                return n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(u), l
            }
        },
        Sj = function (e) {
            this.variableNames = ["x", "W"], this.outputShape = e.outShape;
            var t = e.inHeight,
                n = e.inWidth,
                r = e.padInfo,
                a = e.strideHeight,
                i = e.strideWidth,
                o = e.filterHeight,
                s = e.filterWidth,
                u = e.dilationHeight,
                l = e.dilationWidth,
                c = r.top,
                p = r.left;
            this.userCode = "\n      const ivec2 strides = ivec2(" + a + ", " + i + ");\n      const ivec2 pads = ivec2(" + c + ", " + p + ");\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < " + o + "; h++) {\n          int hIn = hBeg + h * " + u + ";\n\n          if (hIn >= 0 && hIn < " + t + ") {\n            for (int w = 0; w < " + s + "; w++) {\n              int wIn = wBeg + w * " + l + ";\n\n              if (wIn >= 0 && wIn < " + n + ") {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    "
        },
        Tj = {
            kernelName: "Dilation2D",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t, n = e.inputs,
                    r = e.backend,
                    a = e.attrs,
                    i = n.x,
                    o = n.filter,
                    s = a.strides,
                    u = a.pad,
                    l = a.dilations,
                    c = Sx(i.shape, o.shape, s, u, "NHWC", l),
                    p = new Sj(c),
                    h = kU({
                        inputs: {
                            x: t = r.runWebGLProgram(p, [i, o], "float32")
                        },
                        backend: r,
                        attrs: {
                            shape: c.outShape
                        }
                    });
                return r.disposeIntermediateTensorInfo(t), h
            }
        },
        Cj = hU({
            opSnippet: "return (x >= 0.0) ? x : (exp(x) - 1.0);",
            packedOpSnippet: "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"
        }),
        Ej = {
            kernelName: Hv,
            backendName: "webgl",
            kernelFunc: Cj
        },
        Rj = {
            kernelName: "EluGrad",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = t.dy,
                    a = t.y,
                    i = Wv().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new tU("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n", r.shape, a.shape) : new eU("return (b >= 1.0) ? a : a * (b + 1.0);", r.shape, a.shape);
                return n.runWebGLProgram(i, [r, a], r.dtype)
            }
        },
        Aj = {
            kernelName: "Equal",
            backendName: "webgl",
            kernelFunc: fU({
                opSnippet: "return float(a == b);",
                packedOpSnippet: "\n  return vec4(equal(a, b));\n",
                dtype: "bool"
            })
        },
        Fj = hU({
            opSnippet: '\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = 0.254829592;\n  float a2 = -0.284496736;\n  float a3 = 1.421413741;\n  float a4 = -1.453152027;\n  float a5 = 1.061405429;\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n'
        }),
        _j = {
            kernelName: qv,
            backendName: "webgl",
            kernelFunc: Fj
        },
        Dj = "return exp(x);",
        Oj = hU({
            opSnippet: Dj,
            packedOpSnippet: Dj,
            cpuKernelImpl: dV
        }),
        Mj = {
            kernelName: Kv,
            backendName: "webgl",
            kernelFunc: Oj
        };

    function Lj(e) {
        var t = e.inputs,
            n = e.attrs,
            r = e.backend,
            a = n.dim,
            i = t.input,
            o = i.shape.length,
            s = i.shape.slice(),
            u = a;
        return a < 0 && (nv(-(o + 1) <= a, function () {
            return "Axis must be in the interval [" + -(o + 1) + ", " + o + "]"
        }), u = o + a + 1), s.splice(u, 0, 1), kU({
            inputs: {
                x: i
            },
            backend: r,
            attrs: {
                shape: s
            }
        })
    }
    var zj = {
            kernelName: "ExpandDims",
            backendName: "webgl",
            kernelFunc: Lj
        },
        Pj = "return exp(x) - 1.0;",
        Bj = {
            kernelName: "Expm1",
            backendName: "webgl",
            kernelFunc: hU({
                opSnippet: Pj,
                packedOpSnippet: Pj,
                cpuKernelImpl: mV
            })
        },
        Wj = function (e, t, n) {
            this.variableNames = ["real", "imag"];
            var r = t[1];
            this.outputShape = t;
            var a, i = n ? "2.0 * " + Math.PI : "-2.0 * " + Math.PI,
                o = n ? r + ".0" : "1.0";
            if ("real" === e) a = "return real * expR - imag * expI;";
            else {
                if ("imag" !== e) throw new Error('FFT component must be either "real" or "imag", got ' + e + ".");
                a = "return real * expI + imag * expR;"
            }
            this.userCode = "\n      const float exponentMultiplier = " + i + ";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        " + a + "\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(" + r + ");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < " + r + "; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / " + o + ";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    "
        };

    function Vj(e, t, n) {
        var r = n.texData.get(e.dataId),
            a = ov(e.shape),
            i = e.shape[e.shape.length - 1],
            o = kU({
                inputs: {
                    x: e
                },
                backend: n,
                attrs: {
                    shape: [a / i, i]
                }
            }),
            s = o.shape,
            u = new Wj("real", s, t),
            l = new Wj("imag", s, t),
            c = [{
                dataId: r.complexTensorInfos.real.dataId,
                dtype: r.complexTensorInfos.real.dtype,
                shape: s
            }, {
                dataId: r.complexTensorInfos.imag.dataId,
                dtype: r.complexTensorInfos.imag.dtype,
                shape: s
            }],
            p = n.runWebGLProgram(u, c, "float32"),
            h = n.runWebGLProgram(l, c, "float32"),
            f = aU({
                inputs: {
                    real: p,
                    imag: h
                },
                backend: n
            });
        n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(h);
        var d = kU({
            inputs: {
                x: f
            },
            backend: n,
            attrs: {
                shape: e.shape
            }
        });
        return n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(f), d
    }
    var Uj = {
            kernelName: "FFT",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend;
                return Vj(t.input, !1, n)
            }
        },
        Gj = function () {
            function e(e, t) {
                this.outputShape = [], this.variableNames = ["x"], this.outputShape = e, this.userCode = "\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "
            }
            return e.prototype.getCustomSetupFunc = function (e) {
                var t = this;
                return function (n, r) {
                    null == t.valueLoc && (t.valueLoc = n.getUniformLocationNoThrow(r, "value")), n.gl.uniform1f(t.valueLoc, e)
                }
            }, e
        }();

    function jj(e) {
        var t = e.backend,
            n = e.attrs,
            r = n.shape,
            a = n.value,
            i = n.dtype;
        if ("string" === (i = i || Tv(a))) {
            var o = vv(i, ov(r));
            return o.fill(a), t.makeTensorInfo(r, i, o)
        }
        var s = new Gj(r, a),
            u = s.getCustomSetupFunc(a);
        return t.runWebGLProgram(s, [], i, u)
    }
    var Hj, qj = {
            kernelName: "Fill",
            backendName: "webgl",
            kernelFunc: jj
        },
        Kj = function (e) {
            this.variableNames = ["Image"], this.outputShape = [];
            var t = e[2];
            this.outputShape = e, this.userCode = "\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = " + t + " - x;\n          float outputValue;\n          if(coordX >= 0 && coordX < " + t + ") {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    "
        },
        Xj = {
            kernelName: "FlipLeftRight",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = t.image,
                    a = n,
                    i = new Kj(r.shape);
                return a.runWebGLProgram(i, [r], r.dtype)
            }
        },
        Yj = "return floor(x);",
        Jj = {
            kernelName: "Floor",
            backendName: "webgl",
            kernelFunc: hU({
                opSnippet: Yj,
                packedOpSnippet: Yj,
                cpuKernelImpl: vV
            })
        },
        Zj = {
            kernelName: "FloorDiv",
            backendName: "webgl",
            kernelFunc: fU({
                opSnippet: "\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",
                packedOpSnippet: "\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",
                dtype: "int32"
            })
        },
        Qj = function (e) {
            this.variableNames = ["A"];
            var t = OW(),
                n = e[0],
                r = e[1];
            this.outputShape = e, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + r + ".0, " + n + ".0);\n\n        vec4 values = " + t.texture2D + "(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    "
        },
        $j = function (e) {
            this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0;
            var t = OW(),
                n = e[0],
                r = e[1];
            this.outputShape = e, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(" + r + ".0, " + n + ".0);\n            vec4 values = " + t.texture2D + "(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        " + t.output + " = result;\n      }\n    "
        },
        eH = {
            kernelName: "FromPixels",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.pixels,
                    i = r.numChannels,
                    o = "undefined" != typeof HTMLVideoElement && a instanceof HTMLVideoElement,
                    s = "undefined" != typeof HTMLImageElement && a instanceof HTMLImageElement,
                    u = o ? [a.videoWidth, a.videoHeight] : [a.width, a.height],
                    l = u[0],
                    c = u[1],
                    p = [c, l],
                    h = [c, l, i];
                (s || o) && (null == Hj && (Hj = document.createElement("canvas").getContext("2d")), Hj.canvas.width = l, Hj.canvas.height = c, Hj.drawImage(a, 0, 0, l, c), a = Hj.canvas);
                var f = n.makeTensorInfo(p, "int32");
                n.texData.get(f.dataId).usage = nW.PIXELS, n.gpgpu.uploadPixelDataToTexture(n.getTexture(f.dataId), a);
                var d = Wv().getBool("WEBGL_PACK") ? new $j(h) : new Qj(h),
                    m = n.runWebGLProgram(d, [f], "int32");
                return n.disposeData(f.dataId), m
            }
        },
        tH = {
            kernelName: "FusedConv2D",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t, n = e.inputs,
                    r = e.backend,
                    a = e.attrs,
                    i = n.x,
                    o = n.filter,
                    s = n.bias,
                    u = n.preluActivationWeights,
                    l = a.strides,
                    c = a.pad,
                    p = a.dataFormat,
                    h = a.dilations,
                    f = a.dimRoundingMode,
                    d = a.activation,
                    m = a.leakyreluAlpha,
                    v = zx(p),
                    g = Ex(i.shape, o.shape, l, h, c, f, !1, v),
                    y = [];
                if (1 !== g.filterHeight || 1 !== g.filterWidth || 1 !== g.dilationHeight || 1 !== g.dilationWidth || 1 !== g.strideHeight || 1 !== g.strideWidth || "SAME" !== g.padInfo.type && "VALID" !== g.padInfo.type)
                    if (Wv().getBool("WEBGL_CONV_IM2COL") && 1 === i.shape[0]) t = KG({
                        x: i,
                        filter: o,
                        convInfo: g,
                        backend: r,
                        bias: s,
                        activation: d,
                        preluActivationWeights: u,
                        leakyreluAlpha: m
                    });
                    else {
                        var b = null != s,
                            x = null != u,
                            w = "leakyrelu" === d,
                            k = d ? dU(d, !1) : null,
                            N = new GG(g, b, k, x, w),
                            I = [i, o];
                        if (s && I.push(s), u && I.push(u), w) {
                            var S = r.makeTensorInfo([], "float32", ug(m, "float32"));
                            I.push(S), y.push(S)
                        }
                        t = r.runWebGLProgram(N, I, "float32")
                    }
                else t = qG({
                    x: i,
                    filter: o,
                    convInfo: g,
                    backend: r,
                    bias: s,
                    activation: d,
                    preluActivationWeights: u,
                    leakyreluAlpha: m
                });
                var T = kU({
                    inputs: {
                        x: t
                    },
                    backend: r,
                    attrs: {
                        shape: g.outShape
                    }
                });
                return y.push(t), y.forEach(function (e) {
                    return r.disposeIntermediateTensorInfo(e)
                }), T
            }
        },
        nH = {
            kernelName: "FusedDepthwiseConv2D",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.filter,
                    o = t.bias,
                    s = t.preluActivationWeights,
                    u = r.strides,
                    l = r.pad,
                    c = r.dilations,
                    p = r.dimRoundingMode,
                    h = r.activation,
                    f = r.leakyreluAlpha,
                    d = [],
                    m = c;
                null == m && (m = [1, 1]), nv(Lx(u, m), function () {
                    return "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides " + u + " and dilations '" + m + "'"
                });
                var v, g = Ex(a.shape, i.shape, u, m, l, p, !0),
                    y = Wv().getBool("WEBGL_PACK_DEPTHWISECONV") && g.strideWidth <= 2 && g.outChannels / g.inChannels == 1,
                    b = h ? dU(h, y) : null,
                    x = [a, i],
                    w = null != o,
                    k = null != s,
                    N = "leakyrelu" === h;
                if (w && x.push(o), k && x.push(s), N) {
                    var I = n.makeTensorInfo([], "float32", ug(f, "float32"));
                    x.push(I), d.push(I)
                }
                v = y ? new gj(g, w, b, k, N) : new vj(g, w, b, k, N);
                var S = n.runWebGLProgram(v, x, "float32");
                return d.forEach(function (e) {
                    return n.disposeIntermediateTensorInfo(e)
                }), S
            }
        },
        rH = function (e, t, n) {
            this.sliceDim = e, this.strides = t, this.variableNames = ["x", "indices"], this.outputShape = n;
            var r = iV(t.length),
                a = iV(n.length),
                i = this.sliceDim > 1 ? "strides[j]" : "strides";
            this.userCode = "\n        " + r + " strides = " + r + "(" + this.strides + ");\n         void main() {\n          " + a + " coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < " + this.sliceDim + "; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * " + i + ";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      "
        },
        aH = {
            kernelName: "GatherNd",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = t.params,
                    a = t.indices,
                    i = a.shape,
                    o = i[i.length - 1],
                    s = Ib(r, a),
                    u = s[0],
                    l = s[1],
                    c = s[2],
                    p = s[3],
                    h = kU({
                        inputs: {
                            x: a
                        },
                        backend: n,
                        attrs: {
                            shape: [l, o]
                        }
                    }),
                    f = kU({
                        inputs: {
                            x: r
                        },
                        backend: n,
                        attrs: {
                            shape: [ov(r.shape) / c, c]
                        }
                    }),
                    d = new rH(o, p, [l, c]),
                    m = n.runWebGLProgram(d, [f, h], f.dtype),
                    v = kU({
                        inputs: {
                            x: m
                        },
                        backend: n,
                        attrs: {
                            shape: u
                        }
                    });
                return n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(m), v
            }
        },
        iH = function (e, t) {
            this.variableNames = ["A", "indices"], this.outputShape = t, this.rank = t.length;
            var n = iV(this.rank),
                r = function (e, t) {
                    for (var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], r = [], a = 0; a < e.length; a++) 2 === a ? r.push("int(getIndices(resRC.x, resRC.z))") : r.push("" + n[a]);
                    return r.join()
                }(e);
            this.userCode = "\n      void main() {\n        " + n + " resRC = getOutputCoords();\n        setOutput(getA(" + r + "));\n      }\n    "
        },
        oH = {
            kernelName: "GatherV2",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.indices,
                    o = r.axis,
                    s = r.batchDims,
                    u = YS(a, i, fv(o, a.shape)[0], s),
                    l = ov(i.shape),
                    c = [],
                    p = kU({
                        inputs: {
                            x: a
                        },
                        backend: n,
                        attrs: {
                            shape: [u.batchSize, u.outerSize, u.dimSize, u.sliceSize]
                        }
                    }),
                    h = kU({
                        inputs: {
                            x: i
                        },
                        backend: n,
                        attrs: {
                            shape: [u.batchSize, l / u.batchSize]
                        }
                    });
                c.push(p), c.push(h);
                var f = [u.batchSize, u.outerSize, l / u.batchSize, u.sliceSize];
                if (n.shouldExecuteOnCPU([a, i]) || "string" === a.dtype) {
                    var d = n.bufferSync(h),
                        m = n.bufferSync(p),
                        v = gV(m, d, f);
                    return c.forEach(function (e) {
                        return n.disposeIntermediateTensorInfo(e)
                    }), n.makeTensorInfo(u.outputShape, v.dtype, v.values)
                }
                var g = new iH(p.shape, f),
                    y = n.runWebGLProgram(g, [p, h], p.dtype);
                c.push(y);
                var b = kU({
                    inputs: {
                        x: y
                    },
                    backend: n,
                    attrs: {
                        shape: u.outputShape
                    }
                });
                return c.forEach(function (e) {
                    return n.disposeIntermediateTensorInfo(e)
                }), b
            }
        },
        sH = {
            kernelName: "Greater",
            backendName: "webgl",
            kernelFunc: fU({
                opSnippet: "return float(a > b);",
                packedOpSnippet: "\n  return vec4(greaterThan(a, b));\n",
                cpuKernelImpl: yV,
                dtype: "bool"
            })
        },
        uH = {
            kernelName: "GreaterEqual",
            backendName: "webgl",
            kernelFunc: fU({
                opSnippet: "return float(a >= b);",
                packedOpSnippet: "\n  return vec4(greaterThanEqual(a, b));\n",
                dtype: "bool"
            })
        },
        lH = {
            kernelName: "IFFT",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend;
                return Vj(t.input, !0, n)
            }
        },
        cH = {
            kernelName: "IsFinite",
            backendName: "webgl",
            kernelFunc: hU({
                opSnippet: "return float(!isnan(x) && !isinf(x));",
                dtype: "bool"
            })
        },
        pH = {
            kernelName: "IsInf",
            backendName: "webgl",
            kernelFunc: hU({
                opSnippet: "return float(isinf(x));",
                dtype: "bool"
            })
        },
        hH = {
            kernelName: "IsNan",
            backendName: "webgl",
            kernelFunc: hU({
                opSnippet: "return float(isnan(x));",
                dtype: "bool"
            })
        },
        fH = {
            kernelName: "Less",
            backendName: "webgl",
            kernelFunc: fU({
                opSnippet: "return float(a < b);",
                packedOpSnippet: "\n  return vec4(lessThan(a, b));\n",
                cpuKernelImpl: bV,
                dtype: "bool"
            })
        },
        dH = {
            kernelName: "LessEqual",
            backendName: "webgl",
            kernelFunc: fU({
                opSnippet: "return float(a <= b);",
                packedOpSnippet: "\n  return vec4(lessThanEqual(a, b));\n",
                dtype: "bool"
            })
        },
        mH = {
            kernelName: "LinSpace",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.backend,
                    n = e.attrs,
                    r = n.start,
                    a = n.stop,
                    i = n.num,
                    o = xV(r, a, i);
                return t.makeTensorInfo([o.length], "float32", o)
            }
        },
        vH = hU({
            opSnippet: "if (x < 0.0) return NAN;\n  return log(x);",
            packedOpSnippet: "\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",
            cpuKernelImpl: wV
        }),
        gH = {
            kernelName: Xv,
            backendName: "webgl",
            kernelFunc: vH
        },
        yH = {
            kernelName: "Log1p",
            backendName: "webgl",
            kernelFunc: hU({
                opSnippet: "return log(1.0 + x);"
            })
        },
        bH = {
            kernelName: "LogicalAnd",
            backendName: "webgl",
            kernelFunc: fU({
                opSnippet: "return float(a >= 1.0 && b >= 1.0);",
                packedOpSnippet: "\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",
                dtype: "bool"
            })
        },
        xH = {
            kernelName: "LogicalNot",
            backendName: "webgl",
            kernelFunc: hU({
                opSnippet: "return float(!(x >= 1.0));"
            })
        },
        wH = {
            kernelName: "LogicalOr",
            backendName: "webgl",
            kernelFunc: fU({
                opSnippet: "return float(a >= 1.0 || b >= 1.0);",
                packedOpSnippet: "\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",
                dtype: "bool"
            })
        },
        kH = function (e, t, n, r, a) {
            this.variableNames = ["x"], this.outputShape = [];
            var i, o = t,
                s = e[3] - 1;
            this.outputShape = e;
            var u = "float(" + n + ") + float(" + r + ") * sum";
            i = .5 === a ? "inversesqrt(" + u + ")" : 1 === a ? "1.0/(" + u + ")" : "exp(log(" + u + ") * float(-" + a + "));", this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -" + o + "; j <= " + o + "; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  " + s + ") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * " + i + ";\n        setOutput(val);\n      }\n    "
        },
        NH = function (e, t, n, r, a) {
            this.variableNames = ["x"], this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0;
            var i, o = t,
                s = e[3] - 1;
            this.outputShape = e;
            var u = "float(" + n + ") + float(" + r + ") * sum";
            i = .5 === a ? "inversesqrt(" + u + ")" : 1 === a ? "1.0/(" + u + ")" : "exp(log(" + u + ") * float(-" + a + "));", this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < " + this.outputShape[3] + ";\n        bool hasNextRow = c < " + this.outputShape[2] + ";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - " + o + ";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - " + o + "; j <= " + o + "; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(" + s + "));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * " + i + ";\n        setOutput(result);\n      }\n    "
        },
        IH = {
            kernelName: "LRN",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.depthRadius,
                    o = r.bias,
                    s = r.alpha,
                    u = r.beta,
                    l = Wv().getBool("WEBGL_PACK_NORMALIZATION") ? new NH(a.shape, i, o, s, u) : new kH(a.shape, i, o, s, u);
                return n.runWebGLProgram(l, [a], a.dtype)
            }
        },
        SH = function (e, t, n, r, a) {
            this.variableNames = ["inputImage", "outputImage", "dy"], this.outputShape = [], this.outputShape = e, this.depth = e[3], this.depthRadius = t, this.bias = n, this.alpha = r, this.beta = a, this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < " + this.depth + "; ++d) {\n          int depthBegin = int(max(0.0, float(d - " + t + ")));\n          int depthEnd = int(min(float(" + this.depth + "),\n              float(d + " + t + " + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = " + this.depth + ";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(" + r + ") * norm + float(" + n + ");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(" + r + ")\n                * float(" + a + ")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * " + a + ");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    "
        },
        TH = {
            kernelName: "LRNGrad",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.y,
                    o = t.dy,
                    s = r.depthRadius,
                    u = r.bias,
                    l = r.alpha,
                    c = r.beta,
                    p = new SH(a.shape, s, u, l, c);
                return n.runWebGLProgram(p, [a, i, o], a.dtype)
            }
        };

    function CH(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.x,
            i = r.reductionIndices,
            o = r.keepDims,
            s = a.shape.length,
            u = fv(i, a.shape),
            l = u,
            c = hk(l, s),
            p = null != c,
            h = n.shouldExecuteOnCPU([a]),
            f = a;
        if (p) {
            if (h) {
                for (var d = n.texData.get(f.dataId).values, m = new Array(s), v = 0; v < m.length; v++) m[v] = a.shape[c[v]];
                var g = LV(d, a.shape, a.dtype, c, m);
                f = n.makeTensorInfo(m, a.dtype), n.texData.get(f.dataId).values = g
            } else f = RU(a, c, n);
            l = dk(l.length, s)
        }
        pk("max", l, s);
        var y, b = lk(f.shape, l),
            x = b[0],
            w = b[1],
            k = x;
        if (o && (k = ck(x, u)), h) {
            var N = n.texData.get(f.dataId).values,
                I = kV(N, ov(w), k, a.dtype);
            y = n.makeTensorInfo(k, a.dtype), n.texData.get(y.dataId).values = I
        } else y = function (e, t, n, r) {
            var a = ov(w),
                i = kU({
                    inputs: {
                        x: e
                    },
                    attrs: {
                        shape: [ov(e.shape) / a, a]
                    },
                    backend: r
                }),
                o = TU(i, e.dtype, "max", r),
                s = kU({
                    inputs: {
                        x: o
                    },
                    attrs: {
                        shape: n
                    },
                    backend: r
                });
            return r.disposeIntermediateTensorInfo(i), r.disposeIntermediateTensorInfo(o), s
        }(f, 0, k, n);
        return p && n.disposeIntermediateTensorInfo(f), y
    }
    var EH = {
            kernelName: "Max",
            backendName: "webgl",
            kernelFunc: CH
        },
        RH = {
            kernelName: "Maximum",
            backendName: "webgl",
            kernelFunc: fU({
                opSnippet: "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",
                packedOpSnippet: "\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",
                cpuKernelImpl: NV
            })
        },
        AH = {
            kernelName: "MaxPool",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x;
                _W(a, "maxPool");
                var i = r.filterSize,
                    o = r.strides,
                    s = r.pad,
                    u = r.dimRoundingMode;
                nv(Lx(o, 1), function () {
                    return "Error in maxPool: Either strides or dilations must be 1. Got strides " + o + " and dilations '1'"
                });
                var l = Tx(a.shape, i, o, 1, s, u);
                if (1 === l.filterWidth && 1 === l.filterHeight && sv(l.inShape, l.outShape)) return nU({
                    inputs: {
                        x: a
                    },
                    backend: n
                });
                var c = new rG(l, "max", !1);
                return n.runWebGLProgram(c, [a], a.dtype)
            }
        },
        FH = {
            kernelName: "MaxPool3D",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.filterSize,
                    o = r.strides,
                    s = r.pad,
                    u = r.dataFormat,
                    l = r.dimRoundingMode,
                    c = Cx(a.shape, i, o, [1, 1, 1], s, l, u),
                    p = new aG(c, "max", !1);
                return n.runWebGLProgram(p, [a], a.dtype)
            }
        },
        _H = function (e) {
            this.variableNames = ["dy", "maxPos"], this.outputShape = e.inShape;
            var t = e.strideHeight,
                n = e.strideWidth,
                r = e.dilationHeight,
                a = e.effectiveFilterHeight,
                i = e.effectiveFilterWidth,
                o = a - 1 - e.padInfo.top,
                s = i - 1 - e.padInfo.left,
                u = a * i - 1;
            this.userCode = "\n      const ivec2 pads = ivec2(" + o + ", " + s + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + a + ";\n          wR += " + r + ") {\n          float dyR = float(dyRCorner + wR) / " + t + ".0;\n\n          if (dyR < 0.0 || dyR >= " + e.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + i + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + n + ".0;\n\n            if (dyC < 0.0 || dyC >= " + e.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = " + u + " - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * " + i + " + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
        },
        DH = function (e) {
            this.variableNames = ["dy", "maxPos"], this.outputShape = e.inShape;
            var t = e.strideDepth,
                n = e.strideHeight,
                r = e.strideWidth,
                a = e.dilationDepth,
                i = e.dilationHeight,
                o = e.dilationWidth,
                s = e.effectiveFilterDepth,
                u = e.effectiveFilterHeight,
                l = e.effectiveFilterWidth,
                c = s - 1 - e.padInfo.front,
                p = u - 1 - e.padInfo.top,
                h = l - 1 - e.padInfo.left,
                f = s * u * l - 1;
            this.userCode = "\n      const ivec3 pads = ivec3(" + c + ", " + p + ", " + h + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " + s + ";\n           wD += " + a + ") {\n          float dyD = float(dyDCorner + wD) / " + t + ".0;\n\n          if (dyD < 0.0 || dyD >= " + e.outDepth + ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " + u + ";\n              wR += " + i + ") {\n            float dyR = float(dyRCorner + wR) / " + n + ".0;\n\n            if (dyR < 0.0 || dyR >= " + e.outHeight + ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " + l + ";\n                wC += " + o + ") {\n              float dyC = float(dyCCorner + wC) / " + r + ".0;\n\n              if (dyC < 0.0 || dyC >= " + e.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = " + f + " -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * " + u + " * " + l + " +\n                  wR * " + l + " + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
        },
        OH = {
            kernelName: "MaxPool3DGrad",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.dy,
                    i = t.input,
                    o = r.filterSize,
                    s = r.strides,
                    u = r.pad,
                    l = r.dimRoundingMode,
                    c = Cx(i.shape, o, s, [1, 1, 1], u, l),
                    p = new aG(c, "max", !0),
                    h = n.runWebGLProgram(p, [i], i.dtype),
                    f = new DH(c),
                    d = n.runWebGLProgram(f, [a, h], i.dtype);
                return n.disposeIntermediateTensorInfo(h), d
            }
        },
        MH = {
            kernelName: "MaxPoolGrad",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.dy,
                    i = t.input,
                    o = i;
                _W([i, t.output], "maxPoolGrad");
                var s = r.filterSize,
                    u = r.strides,
                    l = r.pad,
                    c = r.dimRoundingMode,
                    p = Tx(o.shape, s, u, 1, l, c),
                    h = new rG(p, "max", !0),
                    f = n.runWebGLProgram(h, [o], o.dtype),
                    d = new _H(p),
                    m = n.runWebGLProgram(d, [a, f], o.dtype);
                return n.disposeIntermediateTensorInfo(f), m
            }
        },
        LH = {
            kernelName: "MaxPoolWithArgmax",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.attrs,
                    r = e.backend,
                    a = t.x,
                    i = n.filterSize,
                    o = n.strides,
                    s = n.pad,
                    u = n.includeBatchInIndex,
                    l = r;
                nv(4 === a.shape.length, function () {
                    return "Error in maxPool: input must be rank 4 but got rank " + a.shape.length + "."
                });
                var c = [1, 1];
                nv(Lx(o, c), function () {
                    return "Error in maxPool: Either strides or dilations must be 1. Got strides " + o + " and dilations '" + c + "'"
                });
                var p = Tx(a.shape, i, o, c, s),
                    h = function (e, t, n, r) {
                        var a = new rG(n, "max", !1),
                            i = r.runWebGLProgram(a, [e], "float32");
                        return a = new rG(n, "max", !0, !0, t), [i, r.runWebGLProgram(a, [e], "float32")]
                    }(a, u, p, l);
                return [h[0], h[1]]
            }
        },
        zH = {
            kernelName: "Mean",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.attrs,
                    r = e.backend,
                    a = t.x,
                    i = n.keepDims,
                    o = n.axis,
                    s = r,
                    u = a.shape.length,
                    l = fv(o, a.shape),
                    c = l,
                    p = hk(c, u),
                    h = null != p,
                    f = s.shouldExecuteOnCPU([a]),
                    d = [],
                    m = a;
                if (h) {
                    if (f) {
                        for (var v = s.texData.get(m.dataId).values, g = new Array(u), y = 0; y < g.length; y++) g[y] = a.shape[p[y]];
                        var b = LV(v, a.shape, a.dtype, p, g);
                        m = s.makeTensorInfo(g, a.dtype), s.texData.get(m.dataId).values = b
                    } else m = RU(a, p, s);
                    d.push(m), c = dk(c.length, u)
                }
                pk("sum", c, u);
                var x = lk(m.shape, c),
                    w = x[0],
                    k = x[1],
                    N = w;
                i && (N = ck(w, l));
                for (var I = function (e, t, n, r) {
                        var a = ov(k),
                            i = kU({
                                inputs: {
                                    x: e
                                },
                                attrs: {
                                    shape: [ov(e.shape) / a, a]
                                },
                                backend: r
                            }),
                            o = TU(i, "float32", "mean", r),
                            s = kU({
                                inputs: {
                                    x: o
                                },
                                attrs: {
                                    shape: n
                                },
                                backend: r
                            });
                        return r.disposeIntermediateTensorInfo(i), r.disposeIntermediateTensorInfo(o), s
                    }(m, 0, N, s), S = 0, T = d; S < T.length; S++) {
                    var C = T[S];
                    s.disposeIntermediateTensorInfo(C)
                }
                return I
            }
        },
        PH = {
            kernelName: "Min",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.axis,
                    o = r.keepDims,
                    s = a.shape.length,
                    u = fv(i, a.shape),
                    l = u,
                    c = hk(l, s),
                    p = a;
                null != c && (p = _U({
                    inputs: {
                        x: a
                    },
                    backend: n,
                    attrs: {
                        perm: c
                    }
                }), l = dk(l.length, a.shape.length)), pk("min", l, s);
                var h, f = lk(p.shape, l),
                    d = f[0],
                    m = kU({
                        inputs: {
                            x: p
                        },
                        backend: n,
                        attrs: {
                            shape: [-1, ov(f[1])]
                        }
                    }),
                    v = TU(m, m.dtype, "min", n);
                return h = kU(o ? {
                    inputs: {
                        x: v
                    },
                    backend: n,
                    attrs: {
                        shape: ck(d, u)
                    }
                } : {
                    inputs: {
                        x: v
                    },
                    backend: n,
                    attrs: {
                        shape: d
                    }
                }), n.disposeIntermediateTensorInfo(m), n.disposeIntermediateTensorInfo(v), null != c && n.disposeIntermediateTensorInfo(p), h
            }
        },
        BH = {
            kernelName: "Minimum",
            backendName: "webgl",
            kernelFunc: fU({
                opSnippet: "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",
                packedOpSnippet: "\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",
                cpuKernelImpl: IV
            })
        },
        WH = function (e, t, n) {
            this.variableNames = ["x"], this.outputShape = t.map(function (t, n) {
                return t[0] + e[n] + t[1]
            });
            var r = e.length,
                a = iV(r),
                i = t.map(function (e) {
                    return e[0]
                }).join(","),
                o = t.map(function (t, n) {
                    return t[0] + e[n]
                }).join(","),
                s = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, r),
                u = "reflect" === n ? 0 : 1;
            this.userCode = 1 !== r ? "\n      " + a + " start = " + a + "(" + i + ");\n      " + a + " end = " + a + "(" + o + ");\n\n      void main() {\n        " + a + " outC = getOutputCoords();\n        for (int i = 0; i < " + r + "; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - " + u + ";\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + " + u + ";\n          }\n        }\n        " + a + " coords = outC - start;\n        setOutput(getX(" + s + "));\n      }\n    " : "\n        int start = " + i + ";\n        int end = " + o + ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - " + u + ";\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + " + u + ";\n          }\n          setOutput(getX(outC - start));\n        }\n      "
        },
        VH = function (e, t, n) {
            this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t.map(function (t, n) {
                return t[0] + e[n] + t[1]
            });
            var r = e.length,
                a = iV(r),
                i = t.map(function (e) {
                    return e[0]
                }).join(","),
                o = t.map(function (t, n) {
                    return t[0] + e[n]
                }).join(","),
                s = BV("rc", r),
                u = BV("source", r),
                l = s[r - 1] + " < " + this.outputShape[r - 1],
                c = 1 === r ? "source" : "vec2(" + u.slice(-2).join() + ")",
                p = "reflect" === n ? 0 : 1,
                h = "";
            if (1 === r) {
                var f = "\n        " + a + " source = rc;\n        if (source < start) {\n          source = start * 2 - source - " + p + ";\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + " + p + ";\n        }\n        source -= start;\n      ";
                h = "\n        " + a + " rc = outputLoc;\n        " + f + "\n        result[0] = getChannel(getX(" + u.join() + "), " + c + ");\n        " + s[r - 1] + " += 1;\n        if(" + l + ") {\n          " + f + "\n          result[1] = getChannel(getX(" + u.join() + "), " + c + ");\n        }\n      "
            } else {
                var d = "\n        " + a + " source = rc;\n        " + a + " lt = " + a + "(lessThan(source, start));\n        " + a + " gte = " + a + "(greaterThanEqual(source, end));\n        " + a + " orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - " + p + ") +\n                gte * ((end - 1) * 2 - source + " + p + ");\n        source -= start;\n      ";
                h = "\n        " + a + " rc = outputLoc;\n        " + d + "\n        result[0] = getChannel(getX(" + u.join() + "), " + c + ");\n        " + s[r - 1] + " += 1;\n        if(" + l + ") {\n          " + d + "\n          result[1] = getChannel(getX(" + u.join() + "), " + c + ");\n        }\n        rc = outputLoc;\n        " + s[r - 2] + " += 1;\n        if(" + s[r - 2] + " < " + this.outputShape[r - 2] + ") {\n          " + d + "\n          result[2] = getChannel(getX(" + u.join() + "), " + c + ");\n          " + s[r - 1] + " += 1;\n          if(" + l + ") {\n            " + d + "\n            result[3] = getChannel(getX(" + u.join() + "), " + c + ");\n          }\n        }\n      "
            }
            this.userCode = "\n      const " + a + " start = " + a + "(" + i + ");\n      const " + a + " end = " + a + "(" + o + ");\n\n      void main() {\n        " + a + " outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        " + h + "\n        setOutput(result);\n      }\n    "
        },
        UH = {
            kernelName: "MirrorPad",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.paddings,
                    o = r.mode,
                    s = Wv().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new VH(a.shape, i, o) : new WH(a.shape, i, o);
                return n.runWebGLProgram(s, [a], a.dtype)
            }
        },
        GH = fU({
            opSnippet: "if (b == 0.0) return NAN;\n  return mod(a, b);",
            packedOpSnippet: "\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"
        }),
        jH = {
            kernelName: Yv,
            backendName: "webgl",
            kernelFunc: GH
        },
        HH = function () {
            function e(e, t, n) {
                this.variableNames = ["probs"], this.outputShape = [e, n], this.userCode = "\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < " + (t - 1) + "; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(" + (t - 1) + "));\n      }\n    "
            }
            return e.prototype.getCustomSetupFunc = function (e) {
                var t = this;
                return function (n, r) {
                    null == t.seedLoc && (t.seedLoc = n.getUniformLocation(r, "seed")), n.gl.uniform1f(t.seedLoc, e)
                }
            }, e
        }(),
        qH = fU({
            opSnippet: "\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",
            packedOpSnippet: "\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",
            checkOutOfBounds: !0
        }),
        KH = {
            kernelName: "RealDiv",
            backendName: "webgl",
            kernelFunc: qH
        },
        XH = "return a - b;",
        YH = fU({
            opSnippet: XH,
            packedOpSnippet: XH,
            supportsComplex: !0,
            cpuKernelImpl: DV
        }),
        JH = {
            kernelName: Qv,
            backendName: "webgl",
            kernelFunc: YH
        };

    function ZH(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.logits,
            i = fv([r.dim], a.shape),
            o = CH({
                inputs: {
                    x: a
                },
                backend: n,
                attrs: {
                    reductionIndices: i,
                    keepDims: !1
                }
            }),
            s = ck(o.shape, i),
            u = kU({
                inputs: {
                    x: o
                },
                backend: n,
                attrs: {
                    shape: s
                }
            }),
            l = YH({
                inputs: {
                    a: a,
                    b: u
                },
                backend: n
            }),
            c = Oj({
                inputs: {
                    x: l
                },
                backend: n
            }),
            p = AU({
                inputs: {
                    x: c
                },
                backend: n,
                attrs: {
                    axis: i,
                    keepDims: !1
                }
            }),
            h = kU({
                inputs: {
                    x: p
                },
                backend: n,
                attrs: {
                    shape: s
                }
            }),
            f = qH({
                inputs: {
                    a: c,
                    b: h
                },
                backend: n
            });
        return n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(u), n.disposeIntermediateTensorInfo(l), n.disposeIntermediateTensorInfo(c), n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(h), f
    }
    var QH = {
            kernelName: "Softmax",
            backendName: "webgl",
            kernelFunc: ZH
        },
        $H = {
            kernelName: "Multinomial",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.logits,
                    i = r.numSamples,
                    o = r.seed,
                    s = r.normalized,
                    u = s ? a : ZH({
                        inputs: {
                            logits: a
                        },
                        backend: n,
                        attrs: {
                            dim: a.shape.length - 1
                        }
                    }),
                    l = u.shape[0],
                    c = u.shape[1],
                    p = new HH(l, c, i),
                    h = p.getCustomSetupFunc(o),
                    f = n.runWebGLProgram(p, [u], "int32", h);
                return s || n.disposeIntermediateTensorInfo(u), f
            }
        },
        eq = "return -x;",
        tq = {
            kernelName: "Neg",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t, n = e.inputs,
                    r = e.backend,
                    a = n.x;
                if (r.shouldExecuteOnCPU([a])) {
                    var i = r.texData.get(a.dataId),
                        o = TV(i.values, a.shape, a.dtype),
                        s = o[0],
                        u = o[1];
                    return r.makeTensorInfo(u, a.dtype, s)
                }
                return t = Wv().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? new YV(a.shape, eq) : new qV(a.shape, eq), r.runWebGLProgram(t, [a], a.dtype)
            }
        },
        nq = MI,
        rq = {
            kernelName: "NonMaxSuppressionV3",
            backendName: "webgl",
            kernelFunc: function (e) {
                zS("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.boxes,
                    i = t.scores,
                    o = r.maxOutputSize,
                    s = r.iouThreshold,
                    u = r.scoreThreshold,
                    l = n.readSync(a.dataId),
                    c = n.readSync(i.dataId),
                    p = nq(l, c, o, s, u).selectedIndices;
                return n.makeTensorInfo([p.length], "int32", new Int32Array(p))
            }
        },
        aq = LI,
        iq = {
            kernelName: "NonMaxSuppressionV4",
            backendName: "webgl",
            kernelFunc: function (e) {
                zS("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.boxes,
                    i = t.scores,
                    o = r.maxOutputSize,
                    s = r.iouThreshold,
                    u = r.scoreThreshold,
                    l = r.padToMaxOutputSize,
                    c = n.readSync(a.dataId),
                    p = n.readSync(i.dataId),
                    h = aq(c, p, o, s, u, l),
                    f = h.selectedIndices,
                    d = h.validOutputs;
                return [n.makeTensorInfo([f.length], "int32", new Int32Array(f)), n.makeTensorInfo([], "int32", new Int32Array([d]))]
            }
        },
        oq = zI,
        sq = {
            kernelName: "NonMaxSuppressionV5",
            backendName: "webgl",
            kernelFunc: function (e) {
                zS("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.boxes,
                    i = t.scores,
                    o = r.maxOutputSize,
                    s = r.iouThreshold,
                    u = r.scoreThreshold,
                    l = r.softNmsSigma,
                    c = n.readSync(a.dataId),
                    p = n.readSync(i.dataId),
                    h = oq(c, p, o, s, u, l),
                    f = h.selectedIndices,
                    d = h.selectedScores;
                return [n.makeTensorInfo([f.length], "int32", new Int32Array(f)), n.makeTensorInfo([d.length], "float32", new Float32Array(d))]
            }
        },
        uq = function (e, t, n, r) {
            this.variableNames = ["indices"], this.outputShape = [e, t], this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(" + r + "), float(" + n + "),\n                      float(index == coords.y)));\n      }\n    "
        },
        lq = {
            kernelName: "OneHot",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.indices,
                    i = r.depth,
                    o = r.onValue,
                    s = r.offValue,
                    u = ov(a.shape),
                    l = new uq(u, i, o, s),
                    c = kU({
                        inputs: {
                            x: a
                        },
                        backend: n,
                        attrs: {
                            shape: [u]
                        }
                    }),
                    p = n.runWebGLProgram(l, [c], a.dtype);
                n.disposeIntermediateTensorInfo(c);
                var h = kU({
                    inputs: {
                        x: p
                    },
                    backend: n,
                    attrs: {
                        shape: [].concat(a.shape, [i])
                    }
                });
                return n.disposeIntermediateTensorInfo(p), h
            }
        };

    function cq(e) {
        var t = e.inputs,
            n = e.backend,
            r = t.x;
        if ("complex64" === r.dtype) {
            var a = IG({
                    inputs: {
                        input: r
                    },
                    backend: n
                }),
                i = cq({
                    inputs: {
                        x: a
                    },
                    backend: n
                }),
                o = PG({
                    inputs: {
                        input: r
                    },
                    backend: n
                }),
                s = cq({
                    inputs: {
                        x: o
                    },
                    backend: n
                }),
                u = aU({
                    inputs: {
                        real: i,
                        imag: s
                    },
                    backend: n
                });
            return n.disposeIntermediateTensorInfo(a), n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(s), u
        }
        return jj({
            attrs: {
                shape: r.shape,
                dtype: r.dtype,
                value: "string" === r.dtype ? "" : 0
            },
            backend: n
        })
    }
    var pq = {
            kernelName: "ZerosLike",
            backendName: "webgl",
            kernelFunc: cq
        },
        hq = {
            kernelName: "OnesLike",
            backendName: "webgl",
            kernelFunc: function e(t) {
                var n = t.inputs,
                    r = t.backend,
                    a = n.x;
                if ("string" === a.dtype) throw new Error("onesLike is not supported under string dtype");
                if ("complex64" === a.dtype) {
                    var i = IG({
                            inputs: {
                                input: a
                            },
                            backend: r
                        }),
                        o = e({
                            inputs: {
                                x: i
                            },
                            backend: r
                        }),
                        s = PG({
                            inputs: {
                                input: a
                            },
                            backend: r
                        }),
                        u = cq({
                            inputs: {
                                x: s
                            },
                            backend: r
                        }),
                        l = aU({
                            inputs: {
                                real: o,
                                imag: u
                            },
                            backend: r
                        });
                    return r.disposeIntermediateTensorInfo(i), r.disposeIntermediateTensorInfo(o), r.disposeIntermediateTensorInfo(s), r.disposeIntermediateTensorInfo(u), l
                }
                return jj({
                    attrs: {
                        shape: a.shape,
                        dtype: a.dtype,
                        value: 1
                    },
                    backend: r
                })
            }
        },
        fq = {
            kernelName: "Pack",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs.axis;
                if (1 === t.length) return Lj({
                    inputs: {
                        input: t[0]
                    },
                    backend: n,
                    attrs: {
                        dim: r
                    }
                });
                var a = t[0].shape,
                    i = t[0].dtype;
                t.forEach(function (e) {
                    rv(a, e.shape, "All tensors passed to stack must have matching shapes"), nv(i === e.dtype, function () {
                        return "All tensors passed to stack must have matching dtypes"
                    })
                });
                var o = [],
                    s = VG({
                        inputs: t.map(function (e) {
                            var t = Lj({
                                inputs: {
                                    input: e
                                },
                                backend: n,
                                attrs: {
                                    dim: r
                                }
                            });
                            return o.push(t), t
                        }),
                        backend: n,
                        attrs: {
                            axis: r
                        }
                    });
                return o.forEach(function (e) {
                    return n.disposeIntermediateTensorInfo(e)
                }), s
            }
        },
        dq = function () {
            function e(e, t, n) {
                this.variableNames = ["x"], this.outputShape = t.map(function (t, n) {
                    return t[0] + e[n] + t[1]
                });
                var r = e.length,
                    a = iV(r),
                    i = t.map(function (e) {
                        return e[0]
                    }).join(","),
                    o = t.map(function (t, n) {
                        return t[0] + e[n]
                    }).join(","),
                    s = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, r);
                this.userCode = 1 !== r ? "\n      " + a + " start = " + a + "(" + i + ");\n      " + a + " end = " + a + "(" + o + ");\n      uniform float value;\n\n      void main() {\n        " + a + " outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          " + a + " coords = outC - start;\n          setOutput(getX(" + s + "));\n        }\n      }\n    " : "\n        int start = " + i + ";\n        int end = " + o + ";\n        uniform float value;\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      "
            }
            return e.prototype.getCustomSetupFunc = function (e) {
                var t = this;
                return function (n, r) {
                    null == t.valueLoc && (t.valueLoc = n.getUniformLocationNoThrow(r, "value")), n.gl.uniform1f(t.valueLoc, e)
                }
            }, e
        }(),
        mq = function () {
            function e(e, t, n) {
                this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t.map(function (t, n) {
                    return t[0] + e[n] + t[1]
                });
                for (var r = e.length, a = iV(r), i = t.map(function (e) {
                        return e[0]
                    }).join(","), o = t.map(function (t, n) {
                        return t[0] + e[n]
                    }).join(","), s = BV("rc", r), u = BV("source", r), l = s[r - 1] + " < " + this.outputShape[r - 1], c = 1 === r ? "source" : "vec2(" + u.slice(-2).join() + ")", p = [a + " rc = outputLoc;", s[r - 1] + " += 1;\n       if(" + l + ") {\n      ", 1 === r ? "" : "}\n       rc = outputLoc;\n       " + s[r - 2] + " += 1;\n       if(" + s[r - 2] + " < " + this.outputShape[r - 2] + ") {", 1 === r ? "" : "  " + s[r - 1] + " += 1;\n         if(" + l + ") {"], h = 1 === r ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))", f = "", d = 0, m = 1 === r ? 2 : 4; d < m; d++) f += "\n        " + p[d] + "\n        if (" + h + ") {\n          result[" + d + "] = float(value);\n        } else {\n          " + a + " source = rc - start;\n          result[" + d + "] = getChannel(getX(" + u.join() + "), " + c + ");\n        }\n      ";
                f += 1 === r ? "} " : "}}", this.userCode = "\n      const " + a + " start = " + a + "(" + i + ");\n      const " + a + " end = " + a + "(" + o + ");\n      uniform float value;\n\n      void main() {\n        " + a + " outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        " + f + "\n        setOutput(result);\n      }\n    "
            }
            return e.prototype.getCustomSetupFunc = function (e) {
                var t = this;
                return function (n, r) {
                    null == t.valueLoc && (t.valueLoc = n.getUniformLocationNoThrow(r, "value")), n.gl.uniform1f(t.valueLoc, e)
                }
            }, e
        }(),
        vq = function (e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = r.paddings,
                o = r.constantValue,
                s = Wv().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new mq(a.shape, i, o) : new dq(a.shape, i, o),
                u = s.getCustomSetupFunc(o);
            return n.runWebGLProgram(s, [a], a.dtype, u)
        },
        gq = {
            kernelName: "PadV2",
            backendName: "webgl",
            kernelFunc: vq
        },
        yq = fU({
            opSnippet: "\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",
            packedOpSnippet: "\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"
        }),
        bq = {
            kernelName: Jv,
            backendName: "webgl",
            kernelFunc: yq
        },
        xq = {
            kernelName: "Prod",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t, n = e.inputs,
                    r = e.backend,
                    a = e.attrs,
                    i = n.x,
                    o = a.axis,
                    s = a.keepDims,
                    u = i.shape.length,
                    l = [],
                    c = fv(o, i.shape),
                    p = c,
                    h = hk(p, u),
                    f = i;
                if (null != h && (f = _U({
                        inputs: {
                            x: i
                        },
                        backend: r,
                        attrs: {
                            perm: h
                        }
                    }), p = dk(p.length, u), l.push(f)), pk("prod", p, u), r.shouldExecuteOnCPU([f])) {
                    var d = r.texData.get(f.dataId).values,
                        m = CV(f.shape, f.dtype, d, p),
                        v = m.outVals,
                        g = m.outShape,
                        y = m.outDtype;
                    t = r.makeTensorInfo(g, y, v)
                } else {
                    var b = lk(f.shape, p),
                        x = b[0],
                        w = ov(b[1]),
                        k = kU({
                            inputs: {
                                x: f
                            },
                            backend: r,
                            attrs: {
                                shape: [-1, w]
                            }
                        }),
                        N = TU(k, Dg(i.dtype), "prod", r);
                    t = kU({
                        inputs: {
                            x: N
                        },
                        backend: r,
                        attrs: {
                            shape: x
                        }
                    }), l.push(k), l.push(N)
                }
                if (s) {
                    l.push(t);
                    var I = ck(t.shape, c);
                    t = kU({
                        inputs: {
                            x: t
                        },
                        backend: r,
                        attrs: {
                            shape: I
                        }
                    })
                }
                return l.forEach(function (e) {
                    return r.disposeIntermediateTensorInfo(e)
                }), t
            }
        },
        wq = function (e) {
            var t = e.backend,
                n = e.attrs,
                r = n.start,
                a = n.stop,
                i = n.step,
                o = n.dtype,
                s = EV(r, a, i, o);
            return t.makeTensorInfo([s.length], o, s)
        },
        kq = {
            kernelName: "Range",
            backendName: "webgl",
            kernelFunc: wq
        },
        Nq = {
            kernelName: "Reciprocal",
            backendName: "webgl",
            kernelFunc: hU({
                opSnippet: "return 1.0 / x;"
            })
        },
        Iq = {
            kernelName: "Relu",
            backendName: "webgl",
            kernelFunc: hU({
                opSnippet: "if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",
                packedOpSnippet: "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"
            })
        },
        Sq = {
            kernelName: "Relu6",
            backendName: "webgl",
            kernelFunc: hU({
                opSnippet: "if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",
                packedOpSnippet: "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"
            })
        },
        Tq = function (e, t, n, r, a) {
            this.variableNames = ["A"], this.outputShape = [];
            var i = e[0],
                o = e[1],
                s = e[2],
                u = e[3];
            this.outputShape = [i, t, n, u];
            var l, c = [r && t > 1 ? o - 1 : o, r && n > 1 ? s - 1 : s],
                p = [r && t > 1 ? t - 1 : t, r && n > 1 ? n - 1 : n];
            l = a ? "(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)" : "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + c[0] / p[0] + ",\n          " + c[1] / p[1] + ");\n      const vec2 inputShapeRC = vec2(" + o + ".0, " + s + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = " + l + ";\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    "
        },
        Cq = function (e, t, n, r, a) {
            this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [];
            var i = e[0],
                o = e[1],
                s = e[2],
                u = e[3];
            this.outputShape = [i, t, n, u];
            var l, c = [r && t > 1 ? o - 1 : o, r && n > 1 ? s - 1 : s],
                p = [r && t > 1 ? t - 1 : t, r && n > 1 ? n - 1 : n];
            l = a ? "(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)" : "vec3(yRC) * effectiveInputOverOutputRatioRC", this.userCode = "\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          " + c[0] / p[0] + ",\n          " + c[1] / p[1] + ",\n          " + c[1] / p[1] + ");\n      const vec3 inputShapeRC = vec3(" + o + ".0, " + s + ".0,\n                                     " + s + ".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = " + l + ";\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < " + (u - 1) + ";\n        bool hasNextRow = coords.z < " + (n - 1) + ";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    "
        },
        Eq = {
            kernelName: "ResizeBilinear",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.images,
                    i = r.alignCorners,
                    o = r.halfPixelCenters,
                    s = r.size,
                    u = s[0],
                    l = s[1],
                    c = Wv().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new Cq(a.shape, u, l, i, o) : new Tq(a.shape, u, l, i, o);
                return n.runWebGLProgram(c, [a], "float32")
            }
        },
        Rq = function (e, t, n) {
            this.variableNames = ["dy"], this.outputShape = [], this.outputShape = t;
            var r = t[1],
                a = t[2],
                i = e[1],
                o = e[2],
                s = [n && i > 1 ? r - 1 : r, n && o > 1 ? a - 1 : a],
                u = [n && i > 1 ? i - 1 : i, n && o > 1 ? o - 1 : o],
                l = s[0] / u[0],
                c = s[1] / u[1],
                p = 1 / l,
                h = 1 / c,
                f = 2 * Math.ceil(p) + 2,
                d = 2 * Math.ceil(h) + 2;
            this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + l + ");\n        const float widthScale = float(" + c + ");\n\n        const float invHeightScale = float(" + p + ");\n        const float invWidthScale = float(" + h + ");\n\n        const int winHeight = int(" + f + ");\n        const int winWidth = int(" + d + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + i + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + o + ") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), " + (r - 1) + ".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), " + (a - 1) + ".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "
        },
        Aq = {
            kernelName: "ResizeBilinearGrad",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.images,
                    i = t.dy,
                    o = r.alignCorners,
                    s = new Rq(i.shape, a.shape, o);
                return n.runWebGLProgram(s, [i], i.dtype)
            }
        },
        Fq = function (e, t, n, r, a) {
            this.variableNames = ["A"], this.outputShape = [];
            var i = e[0],
                o = e[1],
                s = e[2],
                u = e[3];
            this.outputShape = [i, t, n, u];
            var l, c = [r && t > 1 ? o - 1 : o, r && n > 1 ? s - 1 : s],
                p = [r && t > 1 ? t - 1 : t, r && n > 1 ? n - 1 : n],
                h = r ? "0.5" : "0.0";
            l = a ? "max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))" : "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + c[0] / p[0] + ",\n          " + c[1] / p[1] + ");\n      const vec2 inputShapeRC = vec2(" + o + ".0, " + s + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = " + l + ";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + " + h + ")));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    "
        },
        _q = {
            kernelName: "ResizeNearestNeighbor",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.images,
                    i = r.alignCorners,
                    o = r.halfPixelCenters,
                    s = r.size,
                    u = s[0],
                    l = s[1],
                    c = new Fq(a.shape, u, l, i, o);
                return n.runWebGLProgram(c, [a], a.dtype)
            }
        },
        Dq = function (e, t, n) {
            this.variableNames = ["dy"], this.outputShape = [], this.outputShape = t;
            var r = t[1],
                a = t[2],
                i = e[1],
                o = e[2],
                s = [n && i > 1 ? r - 1 : r, n && o > 1 ? a - 1 : a],
                u = [n && i > 1 ? i - 1 : i, n && o > 1 ? o - 1 : o],
                l = s[0] / u[0],
                c = s[1] / u[1],
                p = 1 / l,
                h = 1 / c,
                f = 2 * Math.ceil(p) + 2,
                d = 2 * Math.ceil(h) + 2;
            this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + l + ");\n        const float widthScale = float(" + c + ");\n\n        const float invHeightScale = float(" + p + ");\n        const float invWidthScale = float(" + h + ");\n\n        const int winHeight = int(" + f + ");\n        const int winWidth = int(" + d + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + i + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + o + ") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(" + s[0] + ") *\n                (float(dyR) / float(" + u[0] + "));\n\n            float sourceFracCol =\n                float(" + s[1] + ") *\n                  (float(dyC) / float(" + u[1] + "));\n\n            int sourceNearestRow = int(min(\n                float(int(" + r + ") - 1),\n                " + n + " ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(" + a + ") - 1),\n                " + n + " ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "
        },
        Oq = {
            kernelName: "ResizeNearestNeighborGrad",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.images,
                    i = t.dy,
                    o = r.alignCorners,
                    s = new Dq(i.shape, a.shape, o);
                return n.runWebGLProgram(s, [i], i.dtype)
            }
        },
        Mq = function (e, t) {
            this.variableNames = ["x"];
            var n = e.length;
            if (n > 4) throw new Error("WebGL backend: Reverse of rank-" + n + " tensor is not yet supported");
            if (this.outputShape = e, 1 !== n) {
                var r = e.map(function (n, r) {
                        return function (n) {
                            return -1 !== t.indexOf(n) && 1 !== e[n] ? e[n] + " - coords[" + n + "] - 1" : "coords[" + n + "]"
                        }(r)
                    }).join(","),
                    a = iV(n);
                this.userCode = "\n      void main() {\n        " + a + " coords = getOutputCoords();\n        setOutput(getX(" + r + "));\n      }\n    "
            } else this.userCode = "\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(" + e[0] + " - coord - 1));\n        }\n      "
        },
        Lq = function (e, t) {
            this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0;
            var n = e.length;
            if (n > 4) throw new Error("WebGL backend: Reverse of rank-" + n + " tensor is not yet supported");
            this.outputShape = e;
            var r = BV("rc", n),
                a = r[n - 1] + " + 1 < " + this.outputShape[n - 1],
                i = r[n - 2] + " + 1 < " + this.outputShape[n - 2],
                o = iV(n);

            function s(n) {
                var r = e.map(function (r, a) {
                    return function (n, r) {
                        return -1 !== t.indexOf(n) && 1 !== e[n] ? e[n] + " - " + r[n] + " - 1" : "" + r[n]
                    }(a, n)
                });
                return "getChannel(getX(" + r.join(",") + "), vec2(" + r.slice(-2).join(",") + "))"
            }
            this.userCode = 1 === n ? "\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(" + e[0] + " - rc - 1),\n            " + e[0] + " - rc - 1);\n          if(" + a + "){\n              result.g = getChannel(getX(" + e[0] + " - (rc  + 1) - 1),\n                " + e[0] + " - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      " : "\n        void main() {\n          " + o + " rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = " + s(r.slice()) + ";\n          if(" + a + "){\n            result.g = " + function (e) {
                return e[n - 1] = "(" + e[n - 1] + " + 1)", s(e)
            }(r.slice()) + ";\n          }\n          if(" + i + ") {\n            result.b = " + function (e) {
                return e[n - 2] = "(" + e[n - 2] + " + 1)", s(e)
            }(r.slice()) + ";\n            if(" + a + ") {\n              result.a = " + function (e) {
                return e[n - 1] = "(" + e[n - 1] + " + 1)", e[n - 2] = "(" + e[n - 2] + " + 1)", s(e)
            }(r.slice()) + ";\n            }\n          }\n          setOutput(result);\n        }\n    "
        },
        zq = {
            kernelName: "Reverse",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.dims,
                    o = a.shape.length,
                    s = fv(i, a.shape);
                if (0 === o) return nU({
                    inputs: {
                        x: a
                    },
                    backend: n
                });
                var u = Wv().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Lq(a.shape, s) : new Mq(a.shape, s);
                return n.runWebGLProgram(u, [a], a.dtype)
            }
        },
        Pq = function () {
            function e(e, t) {
                this.variableNames = ["Image"], this.outputShape = [];
                var n = e[1],
                    r = e[2];
                this.outputShape = e;
                var a;
                a = "number" == typeof t ? "float outputValue = " + t.toFixed(2) + ";" : "\n        vec3 fill = vec3(" + t.join(",") + ");\n        float outputValue = fill[coords[3]];", this.userCode = "\n        uniform vec4 params;\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          " + a + "\n          if(coordX >= 0 && coordX < " + r + " && coordY >= 0 && coordY < " + n + ") {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    "
            }
            return e.prototype.getCustomSetupFunc = function (e, t, n, r) {
                var a = this;
                return function (i, o) {
                    null == a.paramsLoc && (a.paramsLoc = i.getUniformLocationNoThrow(o, "params")), i.gl.uniform4f(a.paramsLoc, e, t, n, r)
                }
            }, e
        }(),
        Bq = {
            kernelName: "RotateWithOffset",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.attrs,
                    r = e.backend,
                    a = t.image,
                    i = n.radians,
                    o = n.fillValue,
                    s = n.center,
                    u = r,
                    l = new Pq(a.shape, o),
                    c = AS(s, a.shape[1], a.shape[2]),
                    p = c[0],
                    h = c[1],
                    f = l.getCustomSetupFunc(p, h, Math.sin(i), Math.cos(i));
                return u.runWebGLProgram(l, [a], a.dtype, f)
            }
        },
        Wq = {
            kernelName: "Round",
            backendName: "webgl",
            kernelFunc: hU({
                opSnippet: "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"
            })
        },
        Vq = {
            kernelName: "Rsqrt",
            backendName: "webgl",
            kernelFunc: hU({
                opSnippet: "return inversesqrt(x);",
                cpuKernelImpl: RV
            })
        },
        Uq = function (e, t, n, r, a, i, o) {
            void 0 === o && (o = !0), this.variableNames = ["updates", "indices", "defaultValue"], this.outputShape = i;
            var s = iV(a.length),
                u = iV(i.length),
                l = "";
            1 === n ? l = "i" : 2 === n && (l = "i, j");
            var c = "getIndices(" + l + ")",
                p = "";
            1 === r ? p = "i" : 2 === r && (p = "i, coords[1]");
            var h = "getUpdates(" + p + ")",
                f = t > 1 ? "strides[j]" : "strides";
            this.userCode = "\n        " + s + " strides = " + s + "(" + a + ");\n\n        void main() {\n          " + u + " coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < " + e + "; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < " + t + "; j++) {\n              int index = round(" + c + ");\n              flattenedIndex += index * " + f + ";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += " + h + ";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      "
        },
        Gq = {
            kernelName: "ScatterNd",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.indices,
                    i = t.updates,
                    o = r.shape,
                    s = Eb(0, a, o),
                    u = s.sliceRank,
                    l = s.numUpdates,
                    c = s.sliceSize,
                    p = s.strides,
                    h = s.outputSize,
                    f = [h / c, c];
                if (0 === h) return n.makeTensorInfo(o, a.dtype);
                var d = kU({
                        inputs: {
                            x: a
                        },
                        backend: n,
                        attrs: {
                            shape: [l, u]
                        }
                    }),
                    m = kU({
                        inputs: {
                            x: i
                        },
                        backend: n,
                        attrs: {
                            shape: [l, c]
                        }
                    }),
                    v = n.makeTensorInfo([], "float32", new Float32Array([0])),
                    g = new Uq(l, u, d.shape.length, m.shape.length, p, f),
                    y = n.runWebGLProgram(g, [m, d, v], m.dtype),
                    b = kU({
                        inputs: {
                            x: y
                        },
                        backend: n,
                        attrs: {
                            shape: o
                        }
                    });
                return n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(m), n.disposeIntermediateTensorInfo(y), n.disposeIntermediateTensorInfo(v), b
            }
        },
        jq = function (e, t, n) {
            var r, a;
            if (this.variableNames = ["c", "a", "b"], this.outputShape = t, n > 4) throw Error("Where for rank " + n + " is not yet supported");
            if (1 === n) a = "resRC", r = "resRC";
            else {
                for (var i = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], o = [], s = [], u = 0; u < t.length; u++) s.push("" + i[u]), u < e && o.push("" + i[u]);
                r = o.join(), a = s.join()
            }
            var l = iV(n);
            this.userCode = "\n      void main() {\n        " + l + " resRC = getOutputCoords();\n        float cVal = getC(" + r + ");\n        if (cVal >= 1.0) {\n          setOutput(getA(" + a + "));\n        } else {\n          setOutput(getB(" + a + "));\n        }\n      }\n    "
        },
        Hq = {
            kernelName: "Select",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = t.condition,
                    a = t.t,
                    i = t.e,
                    o = new jq(r.shape.length, a.shape, a.shape.length);
                return n.runWebGLProgram(o, [r, a, i], _g(a.dtype, i.dtype))
            }
        },
        qq = {
            kernelName: "Selu",
            backendName: "webgl",
            kernelFunc: hU({
                opSnippet: "\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = 1.7580993408473768;\n  float scale = 1.0507009873554805;\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n"
            })
        },
        Kq = {
            kernelName: "Sigmoid",
            backendName: "webgl",
            kernelFunc: hU({
                opSnippet: "return 1.0 / (1.0 + exp(-1.0 * x));"
            })
        },
        Xq = {
            kernelName: "Sign",
            backendName: "webgl",
            kernelFunc: hU({
                opSnippet: "\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"
            })
        },
        Yq = hU({
            opSnippet: "if (isnan(x)) return x;\n  return sin(x);\n"
        }),
        Jq = {
            kernelName: Zv,
            backendName: "webgl",
            kernelFunc: Yq
        },
        Zq = {
            kernelName: "Sinh",
            backendName: "webgl",
            kernelFunc: hU({
                opSnippet: "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"
            })
        },
        Qq = {
            kernelName: "Softplus",
            backendName: "webgl",
            kernelFunc: hU({
                opSnippet: "\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"
            })
        },
        $q = {
            kernelName: "SpaceToBatchND",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.blockShape,
                    o = r.paddings;
                nv(a.shape.length <= 4, function () {
                    return "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"
                });
                var s = i.reduce(function (e, t) {
                        return e * t
                    }),
                    u = [
                        [0, 0]
                    ];
                u.push.apply(u, o);
                for (var l = 1 + i.length; l < a.shape.length; ++l) u.push([0, 0]);
                var c = [],
                    p = vq({
                        inputs: {
                            x: a
                        },
                        backend: n,
                        attrs: {
                            paddings: u,
                            constantValue: 0
                        }
                    }),
                    h = FS(p.shape, i, s, !1),
                    f = _S(h.length, i.length, !1),
                    d = DS(p.shape, i, s, !1),
                    m = kU({
                        inputs: {
                            x: p
                        },
                        backend: n,
                        attrs: {
                            shape: h
                        }
                    }),
                    v = _U({
                        inputs: {
                            x: m
                        },
                        backend: n,
                        attrs: {
                            perm: f
                        }
                    }),
                    g = kU({
                        inputs: {
                            x: v
                        },
                        backend: n,
                        attrs: {
                            shape: d
                        }
                    });
                return c.push(p), c.push(m), c.push(v), c.forEach(function (e) {
                    return n.disposeIntermediateTensorInfo(e)
                }), g
            }
        },
        eK = {
            kernelName: "SparseToDense",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.sparseIndices,
                    i = t.sparseValues,
                    o = t.defaultValue,
                    s = r.outputShape,
                    u = Eb(0, a, s),
                    l = u.sliceRank,
                    c = u.numUpdates,
                    p = u.strides,
                    h = u.outputSize,
                    f = new Uq(c, l, a.shape.length, i.shape.length, p, [h, 1], !1),
                    d = n.runWebGLProgram(f, [i, a, o], i.dtype),
                    m = kU({
                        inputs: {
                            x: d
                        },
                        backend: n,
                        attrs: {
                            shape: s
                        }
                    });
                return n.disposeIntermediateTensorInfo(d), m
            }
        },
        tK = {
            kernelName: "SplitV",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.numOrSizeSplits,
                    o = fv(r.axis, a.shape)[0],
                    s = qS(a, i, o),
                    u = a.shape.length,
                    l = new Array(u).fill(0),
                    c = a.shape.slice();
                return s.map(function (e) {
                    var t = [].concat(c);
                    t[o] = e;
                    var r = yG({
                        inputs: {
                            x: a
                        },
                        backend: n,
                        attrs: {
                            begin: l,
                            size: t
                        }
                    });
                    return l[o] += e, r
                })
            }
        },
        nK = {
            kernelName: "Sqrt",
            backendName: "webgl",
            kernelFunc: hU({
                opSnippet: "return sqrt(x);"
            })
        },
        rK = {
            kernelName: "Square",
            backendName: "webgl",
            kernelFunc: hU({
                opSnippet: "return x * x;"
            })
        },
        aK = {
            kernelName: "SquaredDifference",
            backendName: "webgl",
            kernelFunc: fU({
                opSnippet: "return (a - b) * (a - b);",
                packedOpSnippet: "return (a - b) * (a - b);"
            })
        },
        iK = {
            kernelName: "Step",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.attrs,
                    r = e.backend,
                    a = t.x,
                    i = "if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(" + n.alpha + ");\n  ",
                    o = new qV(a.shape, i);
                return r.runWebGLProgram(o, [a], a.dtype)
            }
        },
        oK = function (e, t, n) {
            this.variableNames = ["x"], this.outputShape = n;
            var r = n.length,
                a = iV(n.length),
                i = iV(n.length),
                o = "";
            if (1 === r) o = "coords * strides + begin";
            else {
                var s = 0;
                o = n.map(function (e, t) {
                    return s++, 1 === n.length ? "coords * strides[" + t + "] + begin[" + t + "]" : "coords[" + (s - 1) + "] * strides[" + t + "] + begin[" + t + "]"
                }).join(",")
            }
            this.userCode = "\n      " + a + " begin = " + a + "(" + e + ");\n      " + a + " strides = " + a + "(" + t + ");\n\n      void main() {\n        " + i + " coords = getOutputCoords();\n        setOutput(getX(" + o + "));\n      }\n    "
        },
        sK = {
            kernelName: "StridedSlice",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t, n = e.inputs,
                    r = e.backend,
                    a = e.attrs,
                    i = n.x,
                    o = a.begin,
                    s = a.end,
                    u = a.strides,
                    l = a.beginMask,
                    c = a.endMask,
                    p = a.ellipsisMask,
                    h = a.newAxisMask,
                    f = a.shrinkAxisMask,
                    d = Hb(i.shape, o, s, u, l, c, p, h, f),
                    m = d.nonStrided,
                    v = d.$begin,
                    g = d.$strides,
                    y = d.size,
                    b = d.newShape,
                    x = d.outShape,
                    w = kU({
                        inputs: {
                            x: i
                        },
                        backend: r,
                        attrs: {
                            shape: b
                        }
                    });
                if (m) {
                    var k = yG({
                        inputs: {
                            x: w
                        },
                        backend: r,
                        attrs: {
                            begin: v,
                            size: y
                        }
                    });
                    t = kU({
                        inputs: {
                            x: k
                        },
                        backend: r,
                        attrs: {
                            shape: x
                        }
                    }), r.disposeIntermediateTensorInfo(k)
                } else if (x.some(function (e) {
                        return 0 === e
                    })) t = r.makeTensorInfo(x, i.dtype, []);
                else if (r.shouldExecuteOnCPU([w])) {
                    var N = r.texData.get(w.dataId).values,
                        I = qy(w.shape, w.dtype, N),
                        S = _V(x, I, g, v);
                    t = r.makeTensorInfo(x, w.dtype, S.values)
                } else {
                    var T = new oK(v, g, x);
                    t = r.runWebGLProgram(T, [w], w.dtype)
                }
                var C = kU({
                    inputs: {
                        x: t
                    },
                    backend: r,
                    attrs: {
                        shape: x
                    }
                });
                return r.disposeIntermediateTensorInfo(w), r.disposeIntermediateTensorInfo(t), C
            }
        },
        uK = hU({
            opSnippet: "return tan(x);"
        }),
        lK = {
            kernelName: $v,
            backendName: "webgl",
            kernelFunc: uK
        },
        cK = hU({
            opSnippet: "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"
        }),
        pK = function (e, t) {
            this.variableNames = ["A"];
            for (var n = new Array(e.length), r = 0; r < n.length; r++) n[r] = e[r] * t[r];
            this.outputShape = n, this.rank = n.length;
            var a = iV(this.rank),
                i = function (e) {
                    var t = e.length;
                    if (t > 5) throw Error("Tile for rank " + t + " is not yet supported");
                    if (1 === t) return "imod(resRC, " + e[0] + ")";
                    for (var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"], r = [], a = 0; a < e.length; a++) r.push("imod(" + n[a] + ", " + e[a] + ")");
                    return r.join()
                }(e);
            this.userCode = "\n      void main() {\n        " + a + " resRC = getOutputCoords();\n        setOutput(getA(" + i + "));\n      }\n    "
        };

    function hK(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.x,
            i = r.reps;
        if ("string" === a.dtype) {
            var o = n.readSync(a.dataId).map(function (e) {
                    return fg(e)
                }),
                s = qy(a.shape, a.dtype, o),
                u = OV(s, i);
            return n.makeTensorInfo(u.shape, u.dtype, u.values)
        }
        var l = new pK(a.shape, i);
        return n.runWebGLProgram(l, [a], a.dtype)
    }
    for (var fK = function (e, t, n, r, a, i) {
            this.variableNames = ["Image", "Transforms"], this.outputShape = i;
            var o, s = "nearest" === n ? 1 : 2;
            switch (r) {
                case "constant":
                    o = 1;
                    break;
                case "reflect":
                    o = 2;
                    break;
                case "wrap":
                    o = 3;
                    break;
                case "nearest":
                    o = 4;
                    break;
                default:
                    o = 1
            }
            this.userCode = "\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(" + o + " == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (" + o + " == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (" + o + " == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < " + e + " && 0 <= coordX && coordX < " + t + ") {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(" + a + ");\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(" + a + ");\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(" + t + "));\n                float mapY = mapCoord(inY, float(" + e + "));\n\n                if (" + s + " == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        "
        }, dK = function (e, t) {
            this.variableNames = ["x", "segmentIds"];
            var n = e.windowSize,
                r = e.batchSize,
                a = e.inSize,
                i = e.numSegments,
                o = i * Math.ceil(a / n);
            this.outputShape = [r, o];
            var s = 4 * Math.floor(n / 4),
                u = n % 4,
                l = "\n        sumValue += dot(values, segFilter);\n    ",
                c = "";
            a % n > 0 && (c = "\n        if (inIdx < 0 || inIdx >= " + a + ") {\n          return initializationValue;\n        }\n      ");
            var p = "";
            a % n > 0 && (p = "\n        if (inIdx < 0 || inIdx >= " + a + ") {\n          return -1.0;\n        }\n      "), this.userCode = "\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        " + c + "\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        " + p + "\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          " + i + ")) * float(" + n + "));\n        int currentSeg = int(mod(float(outIdx), float(" + i + ")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < " + s + "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          " + l + "\n        }\n\n        int inIdx = inOffset + " + s + ";\n        if (" + (1 === u) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          " + l + "\n        } else if (" + (2 === u) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          " + l + "\n        } else if (" + (3 === u) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          " + l + "\n        }\n        setOutput(sumValue);\n      }\n    "
        }, mK = 0, vK = [IH, TH, MU, LU, zU, PU, VU, jU, HU, qU, JU, ZU, QU, $U, tG, eG, nG, oG, iG, lG, cG, pG, dG, xG, wG, TG, EG, FG, OG, iU, UG, $G, ej, XG, nj, rj, tj, ij, oj, uj, hj, fj, mj, wj, kj, yj, Ij, Tj, Ej, Rj, Aj, _j, Mj, zj, Bj, Uj, qj, Xj, Jj, Zj, eH, tH, nH, aH, oH, sH, uH, rU, lH, BG, cH, pH, hH, uU, fH, dH, mH, yH, gH, bH, xH, wH, EH, FH, AH, OH, MH, LH, RH, zH, PH, BH, UH, jH, $H, wU, tq, rq, iq, sq, NG, lq, hq, fq, gq, bq, pU, xq, kq, SG, KH, Nq, Sq, Iq, NU, Eq, Aq, _q, Oq, zq, Bq, Wq, Vq, Gq, Hq, qq, Kq, Xq, Jq, Zq, bG, QH, Qq, $q, eK, tK, nK, rK, aK, iK, sK, JH, FU, lK, {
            kernelName: "Tanh",
            backendName: "webgl",
            kernelFunc: cK
        }, {
            kernelName: "Tile",
            backendName: "webgl",
            kernelFunc: hK
        }, {
            kernelName: "TopK",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.k,
                    o = r.sorted,
                    s = n.readSync(a.dataId),
                    u = MV(s, a.shape, a.dtype, i, o),
                    l = u[0],
                    c = u[1];
                return [n.makeTensorInfo(l.shape, l.dtype, l.values), n.makeTensorInfo(c.shape, c.dtype, c.values)]
            }
        }, {
            kernelName: "Transform",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.image,
                    i = t.transforms,
                    o = r.interpolation,
                    s = r.fillMode,
                    u = r.fillValue,
                    l = r.outputShape,
                    c = a.shape,
                    p = c[0],
                    h = c[1],
                    f = c[2],
                    d = c[3],
                    m = null != l ? l : [h, f],
                    v = m[0],
                    g = m[1],
                    y = new fK(h, f, o, s, u, [p, v, g, d]);
                return n.runWebGLProgram(y, [a, i], "float32")
            }
        }, DU, {
            kernelName: "Unique",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.attrs,
                    r = e.backend,
                    a = n.axis,
                    i = t.x;
                _W(i, "unique"), console.warn("WARNING: ", "UI might be locked temporarily as data is being downloaded");
                var o = r.readSync(i.dataId),
                    s = zV(o, a, i.shape, i.dtype),
                    u = s.outputValues,
                    l = s.outputShape,
                    c = s.indices;
                return [r.makeTensorInfo(l, i.dtype, u), r.makeTensorInfo([c.length], "int32", c)]
            }
        }, {
            kernelName: "Unpack",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.value,
                    i = r.axis;
                i < 0 && (i += a.shape.length);
                for (var o = a, s = o.shape.length, u = a.shape[i], l = new Array(s - 1), c = 0, p = 0; p < s; p++) p !== i && (l[c++] = o.shape[p]);
                var h = [],
                    f = new Array(s).fill(0),
                    d = o.shape.slice();
                d[i] = 1;
                for (var m = new Array(u), v = 0; v < m.length; v++) {
                    f[i] = v;
                    var g = yG({
                            inputs: {
                                x: o
                            },
                            backend: n,
                            attrs: {
                                begin: f,
                                size: d
                            }
                        }),
                        y = kU({
                            inputs: {
                                x: g
                            },
                            backend: n,
                            attrs: {
                                shape: l
                            }
                        });
                    m[v] = y, h.push(g)
                }
                return h.forEach(function (e) {
                    return n.disposeIntermediateTensorInfo(e)
                }), m
            }
        }, {
            kernelName: "UnsortedSegmentSum",
            backendName: "webgl",
            kernelFunc: function (e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.segmentIds,
                    o = r.numSegments,
                    s = a.shape.length,
                    u = [],
                    l = 0,
                    c = hk([l], s),
                    p = a;
                null != c && (p = _U({
                    inputs: {
                        x: a
                    },
                    backend: n,
                    attrs: {
                        perm: c
                    }
                }), u.push(p), l = dk(1, s)[0]);
                var h = XS(p.shape, l, o),
                    f = ov([p.shape[l]]),
                    d = kU({
                        inputs: {
                            x: p
                        },
                        backend: n,
                        attrs: {
                            shape: [-1, f]
                        }
                    });
                u.push(d);
                var m = kU({
                        inputs: {
                            x: function e(t, r, a, i, o) {
                                var s = t.shape[0],
                                    l = t.shape[1],
                                    c = KS(l, o),
                                    p = new dK({
                                        windowSize: c,
                                        inSize: l,
                                        batchSize: s,
                                        numSegments: o
                                    }, r),
                                    h = n.compileAndRun(p, [t, a], i);
                                if (u.push(h), h.shape[1] === o) return h;
                                var f = wq({
                                        backend: n,
                                        attrs: {
                                            start: 0,
                                            stop: o,
                                            step: 1,
                                            dtype: "float32"
                                        }
                                    }),
                                    d = hK({
                                        inputs: {
                                            x: f
                                        },
                                        backend: n,
                                        attrs: {
                                            reps: [l / c]
                                        }
                                    });
                                return u.push(f), u.push(d), e(h, r, d, i, o)
                            }(d, "unsortedSegmentSum", i, Dg(a.dtype), o)
                        },
                        backend: n,
                        attrs: {
                            shape: h
                        }
                    }),
                    v = m;
                if (null != c) {
                    u.push(m);
                    var g = fk(c);
                    v = _U({
                        inputs: {
                            x: v
                        },
                        backend: n,
                        attrs: {
                            perm: g
                        }
                    })
                }
                return u.forEach(function (e) {
                    return n.disposeIntermediateTensorInfo(e)
                }), v
            }
        }, pq]; mK < vK.length; mK++) ig(vK[mK]);
    e.Abs = "Abs", e.Acos = "Acos", e.Acosh = "Acosh", e.AdadeltaOptimizer = vS, e.AdagradOptimizer = gS, e.AdamOptimizer = yS, e.AdamaxOptimizer = bS, e.Add = Gv, e.AddN = "AddN", e.All = "All", e.Any = "Any", e.ArgMax = "ArgMax", e.ArgMin = "ArgMin", e.Asin = "Asin", e.Asinh = "Asinh", e.Atan = "Atan", e.Atan2 = "Atan2", e.Atanh = "Atanh", e.AvgPool = "AvgPool", e.AvgPool3D = "AvgPool3D", e.AvgPool3DGrad = "AvgPool3DGrad", e.AvgPoolGrad = "AvgPoolGrad", e.BatchMatMul = "BatchMatMul", e.BatchToSpaceND = "BatchToSpaceND", e.Bincount = "Bincount", e.BroadcastTo = "BroadcastTo", e.Callback = J_, e.CallbackList = xR, e.Cast = "Cast", e.Ceil = "Ceil", e.ClipByValue = "ClipByValue", e.Complex = "Complex", e.ComplexAbs = "ComplexAbs", e.Concat = "Concat", e.Conv2D = "Conv2D", e.Conv2DBackpropFilter = "Conv2DBackpropFilter", e.Conv2DBackpropInput = "Conv2DBackpropInput", e.Conv3D = "Conv3D", e.Conv3DBackpropFilterV2 = "Conv3DBackpropFilterV2", e.Conv3DBackpropInputV2 = "Conv3DBackpropInputV2", e.Cos = jv, e.Cosh = "Cosh", e.CropAndResize = "CropAndResize", e.Cumsum = "Cumsum", e.CustomCallback = NR, e.DataStorage = Ym, e.DenseBincount = "DenseBincount", e.DepthToSpace = "DepthToSpace", e.DepthwiseConv2dNative = "DepthwiseConv2dNative", e.DepthwiseConv2dNativeBackpropFilter = "DepthwiseConv2dNativeBackpropFilter", e.DepthwiseConv2dNativeBackpropInput = "DepthwiseConv2dNativeBackpropInput", e.Diag = "Diag", e.Dilation2D = "Dilation2D", e.Dilation2DBackpropFilter = "Dilation2DBackpropFilter", e.Dilation2DBackpropInput = "Dilation2DBackpropInput", e.EarlyStopping = tD, e.Elu = Hv, e.EluGrad = "EluGrad", e.Environment = Bv, e.Equal = "Equal", e.Erf = qv, e.Exp = Kv, e.ExpandDims = "ExpandDims", e.Expm1 = "Expm1", e.FFT = "FFT", e.Fill = "Fill", e.FlipLeftRight = "FlipLeftRight", e.Floor = "Floor", e.FloorDiv = "FloorDiv", e.FromPixels = "FromPixels", e.FusedBatchNorm = "FusedBatchNorm", e.FusedConv2D = "FusedConv2D", e.FusedDepthwiseConv2D = "FusedDepthwiseConv2D", e.GatherNd = "GatherNd", e.GatherV2 = "GatherV2", e.GraphModel = yO, e.Greater = "Greater", e.GreaterEqual = "GreaterEqual", e.History = kR, e.IFFT = "IFFT", e.Identity = "Identity", e.Imag = "Imag", e.InputSpec = lR, e.IsFinite = "IsFinite", e.IsInf = "IsInf", e.IsNan = "IsNan", e.KernelBackend = Jm, e.LRN = "LRN", e.LRNGrad = "LRNGrad", e.LayerVariable = iR, e.LayersModel = FA, e.LeakyRelu = "LeakyRelu", e.Less = "Less", e.LessEqual = "LessEqual", e.LinSpace = "LinSpace", e.Log = Xv, e.Log1p = "Log1p", e.LogSoftmax = "LogSoftmax", e.LogicalAnd = "LogicalAnd", e.LogicalNot = "LogicalNot", e.LogicalOr = "LogicalOr", e.Max = "Max", e.MaxPool = "MaxPool", e.MaxPool3D = "MaxPool3D", e.MaxPool3DGrad = "MaxPool3DGrad", e.MaxPoolGrad = "MaxPoolGrad", e.MaxPoolWithArgmax = "MaxPoolWithArgmax", e.Maximum = "Maximum", e.Mean = "Mean", e.Min = "Min", e.Minimum = "Minimum", e.MirrorPad = "MirrorPad", e.Mod = Yv, e.MomentumOptimizer = wS, e.Multinomial = "Multinomial", e.Multiply = "Multiply", e.Neg = "Neg", e.NonMaxSuppressionV3 = "NonMaxSuppressionV3", e.NonMaxSuppressionV4 = "NonMaxSuppressionV4", e.NonMaxSuppressionV5 = "NonMaxSuppressionV5", e.NotEqual = "NotEqual", e.OP_SCOPE_SUFFIX = "__op", e.OneHot = "OneHot", e.OnesLike = "OnesLike", e.Optimizer = mS, e.Pack = "Pack", e.PadV2 = "PadV2", e.Pool = "Pool", e.Pow = Jv, e.Prelu = "Prelu", e.Prod = "Prod", e.RMSPropOptimizer = kS, e.RNN = OF, e.Range = "Range", e.Real = "Real", e.RealDiv = "RealDiv", e.Reciprocal = "Reciprocal", e.Relu = "Relu", e.Relu6 = "Relu6", e.Reshape = "Reshape", e.ResizeBilinear = "ResizeBilinear", e.ResizeBilinearGrad = "ResizeBilinearGrad", e.ResizeNearestNeighbor = "ResizeNearestNeighbor", e.ResizeNearestNeighborGrad = "ResizeNearestNeighborGrad", e.Reverse = "Reverse", e.RotateWithOffset = "RotateWithOffset", e.Round = "Round", e.Rsqrt = "Rsqrt", e.SGDOptimizer = xS, e.ScatterNd = "ScatterNd", e.Select = "Select", e.Selu = "Selu", e.Sequential = zA, e.Sigmoid = "Sigmoid", e.Sign = "Sign", e.Sin = Zv, e.Sinh = "Sinh", e.Slice = "Slice", e.Softmax = "Softmax", e.Softplus = "Softplus", e.SpaceToBatchND = "SpaceToBatchND", e.SparseToDense = "SparseToDense", e.SplitV = "SplitV", e.Sqrt = "Sqrt", e.Square = "Square", e.SquaredDifference = "SquaredDifference", e.Step = "Step", e.StridedSlice = "StridedSlice", e.Sub = Qv, e.Sum = "Sum", e.SymbolicTensor = cR, e.Tan = $v, e.Tanh = "Tanh", e.Tensor = Ng, e.TensorBuffer = xg, e.Tile = "Tile", e.TopK = "TopK", e.Transform = "Transform", e.Transpose = "Transpose", e.Unique = "Unique", e.Unpack = "Unpack", e.UnsortedSegmentSum = "UnsortedSegmentSum", e.Variable = Ag, e.ZerosLike = "ZerosLike", e._FusedMatMul = "_FusedMatMul", e.abs = hx, e.acos = fx, e.acosh = dx, e.add = ux, e.addN = mx, e.all = vx, e.any = gx, e.argMax = yx, e.argMin = bx, e.asin = xx, e.asinh = wx, e.atan = kx, e.atan2 = Nx, e.atanh = Ix, e.avgPool = Bx, e.avgPool3d = Wx, e.backend = sx, e.backend_util = QS, e.basicLSTMCell = Hx, e.batchNorm = Kx, e.batchNorm2d = Xx, e.batchNorm3d = Yx, e.batchNorm4d = Jx, e.batchToSpaceND = qx, e.bincount = Zx, e.booleanMaskAsync = function (e, t, n) {
        return rI.apply(this, arguments)
    }, e.broadcastTo = Qx, e.browser = Nb, e.buffer = qy, e.callbacks = nD, e.cast = Ky, e.ceil = $x, e.clipByValue = ew, e.clone = Xy, e.complex = ey, e.concat = Vx, e.concat1d = tw, e.concat2d = nw, e.concat3d = rw, e.concat4d = aw, e.constraints = jC, e.conv1d = ow, e.conv2d = iw, e.conv2dTranspose = uw, e.conv3d = lw, e.conv3dTranspose = pw, e.copyRegisteredKernels = function (e, t) {
        ag(e).forEach(function (e) {
            ig(Object.assign({}, e, {
                backendName: t
            }))
        })
    }, e.cos = hw, e.cosh = fw, e.cosineWindow = pI, e.cumsum = dw, e.customGrad = Qw, e.data = NM, e.denseBincount = mw, e.deprecationWarn = function (e) {
        Wv().getBool("DEPRECATION_WARNINGS_ENABLED") && console.warn(e + " You can disable deprecation warnings with tf.disableDeprecationWarnings().")
    }, e.depthToSpace = vw, e.depthwiseConv2d = gw, e.deregisterOp = function (e) {
        delete rD[e]
    }, e.device_util = Kg, e.diag = yw, e.dilation2d = bw, e.disableDeprecationWarnings = function () {
        Wv().set("DEPRECATION_WARNINGS_ENABLED", !1), console.warn("TensorFlow.js deprecation warnings have been disabled.")
    }, e.dispose = ax, e.disposeVariables = function () {
        Gg.disposeVariables()
    }, e.div = cx, e.divNoNan = Tw, e.dot = Cw, e.dropout = lI, e.elu = Ew, e.enableDebugMode = function () {
        Wv().set("DEBUG", !0)
    }, e.enableProdMode = function () {
        Wv().set("PROD", !0)
    }, e.enclosingPowerOfTwo = cI, e.engine = tx, e.env = Wv, e.equal = Nw, e.erf = Rw, e.exp = Aw, e.expandDims = Fw, e.expm1 = _w, e.eye = Ow, e.fft = ON, e.fill = Mw, e.findBackend = function (e) {
        return Gg.findBackend(e)
    }, e.findBackendFactory = function (e) {
        return Gg.findBackendFactory(e)
    }, e.floor = Lw, e.floorDiv = lx, e.fused = NI, e.gather = zw, e.gatherND = uI, e.gather_util = Sb, e.getBackend = function () {
        return Gg.backendName
    }, e.getGradient = rg, e.getKernel = ng, e.getKernelsForBackend = ag, e.grad = function (e) {
        return nv(Cv(e), function () {
                return "The f passed in grad(f) must be a function"
            }),
            function (t, n) {
                var r = Zg(t, "x", "tf.grad", "string_or_numeric"),
                    a = null != n ? Zg(n, "dy", "tf.grad") : null;
                return Gg.tidy(function () {
                    var t = Gg.gradients(function () {
                            return e(r)
                        }, [r], a),
                        n = t.value,
                        i = t.grads;
                    return null != a && rv(n.shape, a.shape, "The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"), $w(i), i[0]
                })
            }
    }, e.grads = function (e) {
        return nv(Cv(e), function () {
                return "The f passed in grads(f) must be a function"
            }),
            function (t, n) {
                nv(Array.isArray(t), function () {
                    return "The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"
                });
                var r = Qg(t, "args", "tf.grads", "string_or_numeric"),
                    a = null != n ? Zg(n, "dy", "tf.grads") : null;
                return Gg.tidy(function () {
                    var t = Gg.gradients(function () {
                            return e.apply(void 0, r)
                        }, r, a),
                        n = t.value,
                        i = t.grads;
                    return null != a && rv(n.shape, a.shape, "The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), $w(i), i
                })
            }
    }, e.greater = Pw, e.greaterEqual = Bw, e.ifft = MN, e.imag = Ww, e.image = hS, e.inTopKAsync = function (e, t, n) {
        return hI.apply(this, arguments)
    }, e.initializers = YE, e.input = PA, e.io = hb, e.irfft = LN, e.isFinite = Vw, e.isInf = Uw, e.isNaN = Gw, e.keep = ix, e.kernel_impls = $S, e.layers = q_, e.leakyRelu = jw, e.less = Hw, e.lessEqual = qw, e.linalg = fS, e.linspace = Kw, e.loadGraphModel = function (e, t) {
        return bO.apply(this, arguments)
    }, e.loadLayersModel = function (e, t) {
        return null == t && (t = {}),
            function (e, t) {
                return OA.apply(this, arguments)
            }(e, t)
    }, e.localResponseNormalization = Xw, e.log = Yw, e.log1p = Jw, e.logSigmoid = nk, e.logSoftmax = ok, e.logSumExp = mk, e.logicalAnd = vk, e.logicalNot = gk, e.logicalOr = yk, e.logicalXor = bk, e.losses = dS, e.matMul = fb, e.math = vb, e.max = rk, e.maxPool = xk, e.maxPool3d = wk, e.maxPoolWithArgmax = kk, e.maximum = Nk, e.mean = Ik, e.memory = nx, e.metrics = K_, e.min = Sk, e.minimum = Tk, e.mirrorPad = Ck, e.mod = Ek, e.model = function (e) {
        return new FA(e)
    }, e.models = X_, e.moments = Ak, e.movingAverage = iI, e.mul = px, e.multiRNNCell = Fk, e.multinomial = _k, e.neg = ek, e.nextFrame = TS, e.norm = aI, e.notEqual = Dk, e.oneHot = db, e.ones = Mk, e.onesLike = Lk, e.op = $g, e.outerProduct = zk, e.pad = Pk, e.pad1d = Bk, e.pad2d = Wk, e.pad3d = Vk, e.pad4d = Uk, e.pool = jk, e.pow = Hk, e.prelu = qk, e.print = Yy, e.prod = Kk, e.profile = function (e) {
        return Gg.profile(e)
    }, e.rand = Xk, e.randomGamma = oN, e.randomNormal = sN, e.randomUniform = uN, e.range = lN, e.ready = function () {
        return Gg.ready()
    }, e.real = cN, e.reciprocal = pN, e.registerBackend = ox, e.registerCallbackConstructor = function (e, t) {
        SR.registerCallbackConstructor(e, t)
    }, e.registerGradient = og, e.registerKernel = ig, e.registerOp = function (e, t) {
        var n = {
            tfOpName: e,
            category: "custom",
            inputs: [],
            attrs: [],
            customExecutor: t
        };
        rD[e] = n
    }, e.regularizers = Y_, e.relu = hN, e.relu6 = fN, e.removeBackend = function (e) {
        Gg.removeBackend(e)
    }, e.reshape = Px, e.reverse = dN, e.reverse1d = mN, e.reverse2d = vN, e.reverse3d = gN, e.reverse4d = yN, e.rfft = PN, e.round = bN, e.rsqrt = xN, e.scalar = wN, e.scatterND = oI, e.scatter_util = Rb, e.selu = kN, e.separableConv2d = NN, e.sequential = function (e) {
        return new zA(e)
    }, e.serialization = Jb, e.setBackend = function (e) {
        return Gg.setBackend(e)
    }, e.setPlatform = function (e, t) {
        Wv().setPlatform(e, t)
    }, e.setdiff1dAsync = SN, e.sigmoid = Ux, e.sign = TN, e.signal = pS, e.sin = CN, e.sinh = EN, e.slice = Gx, e.slice1d = RN, e.slice2d = AN, e.slice3d = FN, e.slice4d = _N, e.slice_util = qb, e.softmax = DN, e.softplus = tk, e.spaceToBatchND = Gk, e.sparseToDense = sI, e.spectral = cS, e.split = zN, e.sqrt = BN, e.square = Rk, e.squaredDifference = WN, e.squeeze = VN, e.stack = UN, e.step = GN, e.stridedSlice = jN, e.sub = ak, e.sum = ik, e.sumOutType = Dg, e.tan = HN, e.tanh = jx, e.tensor = ny, e.tensor1d = qN, e.tensor2d = KN, e.tensor3d = gb, e.tensor4d = function (e, t, n) {
        if (av(e), null != t && 4 !== t.length) throw new Error("tensor4d() requires shape to have four numbers");
        var r = Yg(e, n);
        if (4 !== r.length && 1 !== r.length) throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
        if (1 === r.length && null == t) throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
        return ty(e, t, r, n)
    }, e.tensor5d = function (e, t, n) {
        if (av(e), null != t && 5 !== t.length) throw new Error("tensor5d() requires shape to have five numbers");
        var r = Yg(e, n);
        if (5 !== r.length && 1 !== r.length) throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
        if (1 === r.length && null == t) throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
        return ty(e, t, r, n)
    }, e.tensor6d = function (e, t, n) {
        if (av(e), null != t && 6 !== t.length) throw new Error("tensor6d() requires shape to have six numbers");
        var r = Yg(e, n);
        if (6 !== r.length && 1 !== r.length) throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
        if (1 === r.length && null == t) throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
        return ty(e, t = t || r, r, n)
    }, e.tensor_util = Pg, e.test_util = ex, e.tidy = rx, e.tile = Dw, e.time = function (e) {
        return Gg.time(e)
    }, e.topk = XN, e.train = IS, e.transpose = mb, e.truncatedNormal = YN, e.unique = JN, e.unregisterGradient = function (e) {
        if (!tg.has(e)) throw new Error("The gradient '" + e + "' for backend is not registered");
        tg.delete(e)
    }, e.unregisterKernel = function (e, t) {
        var n = sg(e, t);
        if (!eg.has(n)) throw new Error("The kernel '" + e + "' for backend '" + t + "' is not registered");
        eg.delete(n)
    }, e.unsortedSegmentSum = ZN, e.unstack = QN, e.upcastType = _g, e.util = dg, e.valueAndGrad = function (e) {
        return nv(Cv(e), function () {
                return "The f passed in valueAndGrad(f) must be a function"
            }),
            function (t, n) {
                nv(t instanceof Ng, function () {
                    return "The x passed in valueAndGrad(f)(x) must be a tensor"
                }), nv(null == n || n instanceof Ng, function () {
                    return "The dy passed in valueAndGrad(f)(x, dy) must be a tensor"
                });
                var r = Gg.gradients(function () {
                        return e(t)
                    }, [t], n),
                    a = r.grads,
                    i = r.value;
                return $w(a), {
                    grad: a[0],
                    value: i
                }
            }
    }, e.valueAndGrads = function (e) {
        return nv(Cv(e), function () {
                return "The f passed in valueAndGrads(f) must be a function"
            }),
            function (t, n) {
                nv(Array.isArray(t) && t.every(function (e) {
                    return e instanceof Ng
                }), function () {
                    return "The args passed in valueAndGrads(f)(args) must be array of tensors"
                }), nv(null == n || n instanceof Ng, function () {
                    return "The dy passed in valueAndGrads(f)(args, dy) must be a tensor"
                });
                var r = Gg.gradients(function () {
                    return e.apply(void 0, t)
                }, t, n);
                return null != n && rv(r.value.shape, n.shape, "The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), $w(r.grads), r
            }
    }, e.variable = $N, e.variableGrads = Zw, e.version = {
        "tfjs-core": "3.3.0",
        "tfjs-backend-cpu": "3.3.0",
        "tfjs-backend-webgl": "3.3.0",
        "tfjs-data": "3.3.0",
        "tfjs-layers": "3.3.0",
        "tfjs-converter": "3.3.0",
        tfjs: "3.3.0"
    }, e.version_converter = "3.3.0", e.version_core = "3.3.0", e.version_layers = "3.3.0", e.where = Iw, e.whereAsync = nI, e.zeros = Ok, e.zerosLike = Sw, Object.defineProperty(e, "__esModule", {
        value: !0
    })
});